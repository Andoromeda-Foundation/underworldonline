//@cannot search
if (typeof top.kdsrpg != "undefined") {
	top.frameRef(1);
}
/***********************************/
/*http://www.the3box.com  2017/12/12*/
/***********************************/
var Laya = window.Laya = (function (window, document) {
	var Laya = {
		__internals: [],
		__packages: {},
		__classmap: { 'Object': Object, 'Function': Function, 'Array': Array, 'String': String },
		__sysClass: { 'object': 'Object', 'array': 'Array', 'string': 'String', 'dictionary': 'Dictionary' },
		__propun: { writable: true, enumerable: false, configurable: true },
		__presubstr: String.prototype.substr,
		__substr: function (ofs, sz) { return arguments.length == 1 ? Laya.__presubstr.call(this, ofs) : Laya.__presubstr.call(this, ofs, sz > 0 ? sz : (this.length + sz)); },
		__init: function (_classs) { _classs.forEach(function (o) { o.__init$ && o.__init$(); }); },
		__isClass: function (o) { return o && (o.__isclass || o == Object || o == String || o == Array); },
		__newvec: function (sz, value) {
			var d = [];
			d.length = sz;
			for (var i = 0; i < sz; i++) d[i] = value;
			return d;
		},
		__extend: function (d, b) {
			for (var p in b) {
				if (!b.hasOwnProperty(p)) continue;
				var gs = Object.getOwnPropertyDescriptor(b, p);
				var g = gs.get, s = gs.set;
				if (g || s) {
					if (g && s)
						Object.defineProperty(d, p, gs);
					else {
						g && Object.defineProperty(d, p, g);
						s && Object.defineProperty(d, p, s);
					}
				}
				else d[p] = b[p];
			}
			function __() { Laya.un(this, 'constructor', d); } __.prototype = b.prototype; d.prototype = new __(); Laya.un(d.prototype, '__imps', Laya.__copy({}, b.prototype.__imps));
		},
		__copy: function (dec, src) {
			if (!src) return null;
			dec = dec || {};
			for (var i in src) dec[i] = src[i];
			return dec;
		},
		__package: function (name, o) {
			if (Laya.__packages[name]) return;
			Laya.__packages[name] = true;
			var p = window, strs = name.split('.');
			if (strs.length > 1) {
				for (var i = 0, sz = strs.length - 1; i < sz; i++) {
					var c = p[strs[i]];
					p = c ? c : (p[strs[i]] = {});
				}
			}
			p[strs[strs.length - 1]] || (p[strs[strs.length - 1]] = o || {});
		},
		__hasOwnProperty: function (name, o) {
			o = o || this;
			function classHas(name, o) {
				if (Object.hasOwnProperty.call(o.prototype, name)) return true;
				var s = o.prototype.__super;
				return s == null ? null : classHas(name, s);
			}
			return (Object.hasOwnProperty.call(o, name)) || classHas(name, o.__class);
		},
		__typeof: function (o, value) {
			if (!o || !value) return false;
			if (value === String) return (typeof o === 'string');
			if (value === Number) return (typeof o === 'number');
			if (value.__interface__) value = value.__interface__;
			else if (typeof value != 'string') return (o instanceof value);
			return (o.__imps && o.__imps[value]) || (o.__class == value);
		},
		__as: function (value, type) {
			return (this.__typeof(value, type)) ? value : null;
		},
		__int: function (value) {
			return value ? parseInt(value) : 0;
		},
		interface: function (name, _super) {
			Laya.__package(name, {});
			var ins = Laya.__internals;
			var a = ins[name] = ins[name] || { self: name };
			if (_super) {
				var supers = _super.split(',');
				a.extend = [];
				for (var i = 0; i < supers.length; i++) {
					var nm = supers[i];
					ins[nm] = ins[nm] || { self: nm };
					a.extend.push(ins[nm]);
				}
			}
			var o = window, words = name.split('.');
			for (var i = 0; i < words.length - 1; i++) o = o[words[i]];
			o[words[words.length - 1]] = { __interface__: name };
		},
		class: function (o, fullName, _super, miniName) {
			_super && Laya.__extend(o, _super);
			if (fullName) {
				Laya.__package(fullName, o);
				Laya.__classmap[fullName] = o;
				if (fullName.indexOf('.') > 0) {
					if (fullName.indexOf('laya.') == 0) {
						var paths = fullName.split('.');
						miniName = miniName || paths[paths.length - 1];
						if (Laya[miniName]) console.log("Warning!,this class[" + miniName + "] already exist:", Laya[miniName]);
						Laya[miniName] = o;
					}
				}
				else {
					if (fullName == "Main")
						window.Main = o;
					else {
						if (Laya[fullName]) {
							console.log("Error!,this class[" + fullName + "] already exist:", Laya[fullName]);
						}
						Laya[fullName] = o;
					}
				}
			}
			var un = Laya.un, p = o.prototype;
			un(p, 'hasOwnProperty', Laya.__hasOwnProperty);
			un(p, '__class', o);
			un(p, '__super', _super);
			un(p, '__className', fullName);
			un(o, '__super', _super);
			un(o, '__className', fullName);
			un(o, '__isclass', true);
			un(o, 'super', function (o) { this.__super.call(o); });
		},
		imps: function (dec, src) {
			if (!src) return null;
			var d = dec.__imps || Laya.un(dec, '__imps', {});
			function __(name) {
				var c, exs;
				if (!(c = Laya.__internals[name])) return;
				d[name] = true;
				if (!(exs = c.extend)) return;
				for (var i = 0; i < exs.length; i++) {
					__(exs[i].self);
				}
			}
			for (var i in src) __(i);
		},
		superSet: function (clas, o, prop, value) {
			var fun = clas.prototype["_$set_" + prop];
			fun && fun.call(o, value);
		},
		superGet: function (clas, o, prop) {
			var fun = clas.prototype["_$get_" + prop];
			return fun ? fun.call(o) : null;
		},
		getset: function (isStatic, o, name, getfn, setfn) {
			if (!isStatic) {
				getfn && Laya.un(o, '_$get_' + name, getfn);
				setfn && Laya.un(o, '_$set_' + name, setfn);
			}
			else {
				getfn && (o['_$GET_' + name] = getfn);
				setfn && (o['_$SET_' + name] = setfn);
			}
			if (getfn && setfn)
				Object.defineProperty(o, name, { get: getfn, set: setfn, enumerable: false, configurable: true });
			else {
				getfn && Object.defineProperty(o, name, { get: getfn, enumerable: false, configurable: true });
				setfn && Object.defineProperty(o, name, { set: setfn, enumerable: false, configurable: true });
			}
		},
		static: function (_class, def) {
			for (var i = 0, sz = def.length; i < sz; i += 2) {
				if (def[i] == 'length')
					_class.length = def[i + 1].call(_class);
				else {
					function tmp() {
						var name = def[i];
						var getfn = def[i + 1];
						Object.defineProperty(_class, name, {
							get: function () { delete this[name]; return this[name] = getfn.call(this); },
							set: function (v) { delete this[name]; this[name] = v; }, enumerable: true, configurable: true
						});
					}
					tmp();
				}
			}
		},
		un: function (obj, name, value) {
			value || (value = obj[name]);
			Laya.__propun.value = value;
			Object.defineProperty(obj, name, Laya.__propun);
			return value;
		},
		uns: function (obj, names) {
			names.forEach(function (o) { Laya.un(obj, o) });
		}
	};

	window.console = window.console || ({ log: function () { } });
	window.trace = window.console.log;
	Error.prototype.throwError = function () { throw arguments; };
	//String.prototype.substr=Laya.__substr;
	Object.defineProperty(Array.prototype, 'fixed', { enumerable: false });

	return Laya;
})(window, document);

(function (window, document, Laya) {
	var __un = Laya.un, __uns = Laya.uns, __static = Laya.static, __class = Laya.class, __getset = Laya.getset, __newvec = Laya.__newvec;

})(window, document, Laya);


(function (window, document, Laya) {
	var __un = Laya.un, __uns = Laya.uns, __static = Laya.static, __class = Laya.class, __getset = Laya.getset, __newvec = Laya.__newvec;
	Laya.interface('laya.runtime.IMarket');
	Laya.interface('laya.filters.IFilter');
	Laya.interface('laya.display.ILayout');
	Laya.interface('laya.resource.IDispose');
	Laya.interface('laya.runtime.IPlatform');
	Laya.interface('laya.resource.IDestroy');
	Laya.interface('laya.runtime.IConchNode');
	Laya.interface('laya.filters.IFilterAction');
	Laya.interface('laya.runtime.ICPlatformClass');
	Laya.interface('laya.resource.ICreateResource');
	Laya.interface('laya.runtime.IConchRenderObject');
	Laya.interface('laya.runtime.IPlatformClass', 'laya.runtime.IPlatform');
	/**
	*@private
	*/
	//class laya.utils.RunDriver
	var RunDriver = (function () {
		function RunDriver() { }
		__class(RunDriver, 'laya.utils.RunDriver');
		RunDriver.FILTER_ACTIONS = [];
		RunDriver.pixelRatio = -1;
		RunDriver._charSizeTestDiv = null;
		RunDriver.now = function () {
			return /*__JS__ */Date.now();
		}

		RunDriver.getWindow = function () {
			return /*__JS__ */window;
		}

		RunDriver.getPixelRatio = function () {
			if (RunDriver.pixelRatio < 0) {
				var ctx = Browser.context;
				var backingStore = ctx.backingStorePixelRatio || ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1;
				RunDriver.pixelRatio = (Browser.window.devicePixelRatio || 1) / backingStore;
				if (RunDriver.pixelRatio < 1) RunDriver.pixelRatio = 1;
			}
			return RunDriver.pixelRatio;
		}

		RunDriver.getIncludeStr = function (name) {
			return null;
		}

		RunDriver.createShaderCondition = function (conditionScript) {
			var fn = "(function() {return " + conditionScript + ";})";
			return Browser.window.eval(fn);
		}

		RunDriver.fontMap = [];
		RunDriver.measureText = function (txt, font) {
			var isChinese = RunDriver.hanzi.test(txt);
			if (isChinese && RunDriver.fontMap[font]) {
				return RunDriver.fontMap[font];
			};
			var ctx = Browser.context;
			ctx.font = font;
			var r = ctx.measureText(txt);
			if (isChinese) RunDriver.fontMap[font] = r;
			return r;
		}

		RunDriver.getWebGLContext = function (canvas) {
		};

		RunDriver.beginFlush = function () {
		};

		RunDriver.endFinish = function () {
		};

		RunDriver.addToAtlas = null;
		RunDriver.flashFlushImage = function (atlasWebGLCanvas) {
		};

		RunDriver.drawToCanvas = function (sprite, _renderType, canvasWidth, canvasHeight, offsetX, offsetY) {
			var canvas = HTMLCanvas.create("2D");
			var context = new RenderContext(canvasWidth, canvasHeight, canvas);
			RenderSprite.renders[_renderType]._fun(sprite, context, offsetX, offsetY);
			return canvas;
		}

		RunDriver.createParticleTemplate2D = null;
		RunDriver.createGLTextur = null;
		RunDriver.createWebGLContext2D = null;
		RunDriver.changeWebGLSize = function (w, h) {
		};

		RunDriver.createRenderSprite = function (type, next) {
			return new RenderSprite(type, next);
		}

		RunDriver.createFilterAction = function (type) {
			return new ColorFilterAction();
		}

		RunDriver.createGraphics = function () {
			return new Graphics();
		}

		RunDriver.clear = function (value) {
			Render._context.ctx.clear();
		}

		RunDriver.cancelLoadByUrl = function (url) {
		};

		RunDriver.clearAtlas = function (value) {
		};

		RunDriver.isAtlas = function (bitmap) {
			return false;
		}

		RunDriver.addTextureToAtlas = function (value) {
		};

		RunDriver.getTexturePixels = function (value, x, y, width, height) {
			return null;
		}

		RunDriver.skinAniSprite = function () {
			return null;
		}

		RunDriver.update3DLoop = function () {
		};

		__static(RunDriver,
			['hanzi', function () { return this.hanzi = new RegExp("^[\u4E00-\u9FA5]$"); }
			]);
		return RunDriver;
	})()


	/**
	*<code>Laya</code> 是全局对象的引用入口集。
	*Laya类引用了一些常用的全局对象，比如Laya.stage：舞台，Laya.timer：时间管理器，Laya.loader：加载管理器，使用时注意大小写。
	*/
	//class Laya
	var ___The3 = (function () {
		//function Laya(){}
		/**
		*表示是否捕获全局错误并弹出提示。默认为false。
		*适用于移动设备等不方便调试的时候，设置为true后，如有未知错误，可以弹窗抛出详细错误堆栈。
		*/
		__getset(1, Laya, 'alertGlobalError', null, function (value) {
			var erralert = 0;
			if (value) {
				Browser.window.onerror = function (msg, url, line, column, detail) {
					if (erralert++ < 5 && detail)
						alert("出错啦，请把此信息截图给研发商\n" + msg + "\n" + detail.stack || detail);
				}
			} else {
				Browser.window.onerror = null;
			}
		});

		Laya.init = function (width, height, __plugins) {
			var plugins = []; for (var i = 2, sz = arguments.length; i < sz; i++)plugins.push(arguments[i]);
			if (Laya._isinit) return;
			ArrayBuffer.prototype.slice || (ArrayBuffer.prototype.slice = Laya._arrayBufferSlice);
			Laya._isinit = true;
			Browser.__init__();
			Context.__init__();
			Graphics.__init__();
			Laya.timer = new Timer();
			Laya.scaleTimer = new Timer();
			Laya.loader = new LoaderManager();
			WeakObject.__init__();
			for (var i = 0, n = plugins.length; i < n; i++) {
				if (plugins[i].enable) plugins[i].enable();
			}
			Font.__init__();
			Style.__init__();
			ResourceManager.__init__();
			CacheManager.beginCheck();
			Laya._currentStage = Laya.stage = new Stage();
			Laya.stage.conchModel && Laya.stage.conchModel.setRootNode();
			Laya.getUrlPath();
			Laya.render = new Render(0, 0);
			Laya.stage.size(width, height);
			RenderSprite.__init__();
			KeyBoardManager.__init__();
			MouseManager.instance.__init__(Laya.stage, Render.canvas);
			Input.__init__();
			SoundManager.autoStopMusic = true;
			LocalStorage.__init__();
			return Render.canvas;
		}

		Laya.getUrlPath = function () {
			var location = Browser.window.location;
			var pathName = location.pathname;
			pathName = pathName.charAt(2) == ':' ? pathName.substring(1) : pathName;
			URL.rootPath = URL.basePath = URL.getPath(location.protocol == "file:" ? pathName : location.protocol + "//" + location.host + location.pathname);
		}

		Laya._arrayBufferSlice = function (start, end) {
			var arr =/*__JS__ */this;
			var arrU8List = new Uint8Array(arr, start, end - start);
			var newU8List = new Uint8Array(arrU8List.length);
			newU8List.set(arrU8List);
			return newU8List.buffer;
		}

		Laya.stage = null;
		Laya.timer = null;
		Laya.scaleTimer = null;
		Laya.loader = null;
		Laya.version = "1.7.17beta";
		Laya.render = null;
		Laya._currentStage = null;
		Laya._isinit = false;
		Laya.MiniAdpter =/*__JS__ */{ init: function () { if (window.navigator && window.navigator.userAgent && window.navigator.userAgent.indexOf("MiniGame") > -1) console.error("请先引用小游戏适配库laya.wxmini.js,详细教程：https://ldc.the3box.com/doc/?nav=zh-ts-5-0-0") } };
		__static(Laya,
			['conchMarket', function () { return this.conchMarket =/*__JS__ */window.conch ? conchMarket : null; }, 'PlatformClass', function () { return this.PlatformClass =/*__JS__ */window.PlatformClass; }
			]);
		return Laya;
	})()


	/**
	*Config 用于配置一些全局参数。如需更改，请在初始化引擎之前设置。
	*/
	//class Config
	var Config = (function () {
		function Config() { }
		__class(Config, 'Config');
		Config.WebGLTextCacheCount = 500;
		Config.atlasEnable = false;
		Config.showCanvasMark = false;
		Config.animationInterval = 50;
		Config.isAntialias = false;
		Config.isAlpha = false;
		Config.premultipliedAlpha = true;
		Config.isStencil = true;
		Config.preserveDrawingBuffer = false;
		return Config;
	})()


	/**
	*<code>EventDispatcher</code> 类是可调度事件的所有类的基类。
	*/
	//class laya.events.EventDispatcher
	var EventDispatcher = (function () {
		var EventHandler;
		function EventDispatcher() {
			/**@private */
			this._events = null;
		}

		__class(EventDispatcher, 'laya.events.EventDispatcher');
		var __proto = EventDispatcher.prototype;
		/**
		*检查 EventDispatcher 对象是否为特定事件类型注册了任何侦听器。
		*@param type 事件的类型。
		*@return 如果指定类型的侦听器已注册，则值为 true；否则，值为 false。
		*/
		__proto.hasListener = function (type) {
			var listener = this._events && this._events[type];
			var allnone = true;
			for (var i in listener) {
				if (listener[i]) { allnone = false; break; }
			}
			if (allnone) return false;
			return !!listener;
		}

		/**
		*派发事件。
		*@param type 事件类型。
		*@param data （可选）回调数据。<b>注意：</b>如果是需要传递多个参数 p1,p2,p3,...可以使用数组结构如：[p1,p2,p3,...] ；如果需要回调单个参数 p ，且 p 是一个数组，则需要使用结构如：[p]，其他的单个参数 p ，可以直接传入参数 p。
		*@return 此事件类型是否有侦听者，如果有侦听者则值为 true，否则值为 false。
		*/
		__proto.event = function (type, data) {
			if (!this._events || !this._events[type]) return false;
			var listeners = this._events[type];
			if (listeners.run) {
				if (listeners.once) delete this._events[type];
				data != null ? listeners.runWith(data) : listeners.run();
			} else {
				for (var i = 0, n = listeners.length; i < n; i++) {
					var listener = listeners[i];
					if (listener) {
						(data != null) ? listener.runWith(data) : listener.run();
					}
					if (!listener || listener.once) {
						listeners.splice(i, 1);
						i--;
						n--;
					}
				}
				if (listeners.length === 0 && this._events) delete this._events[type];
			}
			return true;
		}

		/**
		*使用 EventDispatcher 对象注册指定类型的事件侦听器对象，以使侦听器能够接收事件通知。
		*@param type 事件的类型。
		*@param caller 事件侦听函数的执行域。
		*@param listener 事件侦听函数。
		*@param args （可选）事件侦听函数的回调参数。
		*@return 此 EventDispatcher 对象。
		*/
		__proto.on = function (type, caller, listener, args) {
			return this._createListener(type, caller, listener, args, false);
		}

		/**
		*使用 EventDispatcher 对象注册指定类型的事件侦听器对象，以使侦听器能够接收事件通知，此侦听事件响应一次后自动移除。
		*@param type 事件的类型。
		*@param caller 事件侦听函数的执行域。
		*@param listener 事件侦听函数。
		*@param args （可选）事件侦听函数的回调参数。
		*@return 此 EventDispatcher 对象。
		*/
		__proto.once = function (type, caller, listener, args) {
			return this._createListener(type, caller, listener, args, true);
		}

		/**@private */
		__proto._createListener = function (type, caller, listener, args, once, offBefore) {
			(offBefore === void 0) && (offBefore = true);
			offBefore && this.off(type, caller, listener, once);
			var handler = EventHandler.create(caller || this, listener, args, once);
			this._events || (this._events = {});
			var events = this._events;
			if (!events[type]) events[type] = handler;
			else {
				if (!events[type].run) events[type].push(handler);
				else events[type] = [events[type], handler];
			}
			return this;
		}

		/**
		*从 EventDispatcher 对象中删除侦听器。
		*@param type 事件的类型。
		*@param caller 事件侦听函数的执行域。
		*@param listener 事件侦听函数。
		*@param onceOnly （可选）如果值为 true ,则只移除通过 once 方法添加的侦听器。
		*@return 此 EventDispatcher 对象。
		*/
		__proto.off = function (type, caller, listener, onceOnly) {
			(onceOnly === void 0) && (onceOnly = false);
			if (!this._events || !this._events[type]) return this;
			var listeners = this._events[type];
			if (listener != null) {
				if (listeners.run) {
					if ((!caller || listeners.caller === caller) && listeners.method === listener && (!onceOnly || listeners.once)) {
						delete this._events[type];
						listeners.recover();
					}
				} else {
					var count = 0;
					for (var i = 0, n = listeners.length; i < n; i++) {
						var item = listeners[i];
						if (item && (!caller || item.caller === caller) && item.method === listener && (!onceOnly || item.once)) {
							count++;
							listeners[i] = null;
							item.recover();
						}
					}
					if (count === n) delete this._events[type];
				}
			}
			return this;
		}

		/**
		*从 EventDispatcher 对象中删除指定事件类型的所有侦听器。
		*@param type （可选）事件类型，如果值为 null，则移除本对象所有类型的侦听器。
		*@return 此 EventDispatcher 对象。
		*/
		__proto.offAll = function (type) {
			var events = this._events;
			if (!events) return this;
			if (type) {
				this._recoverHandlers(events[type]);
				delete events[type];
			} else {
				for (var name in events) {
					this._recoverHandlers(events[name]);
				}
				this._events = null;
			}
			return this;
		}

		__proto._recoverHandlers = function (arr) {
			if (!arr) return;
			if (arr.run) {
				arr.recover();
			} else {
				for (var i = arr.length - 1; i > -1; i--) {
					if (arr[i]) {
						arr[i].recover();
						arr[i] = null;
					}
				}
			}
		}

		/**
		*检测指定事件类型是否是鼠标事件。
		*@param type 事件的类型。
		*@return 如果是鼠标事件，则值为 true;否则，值为 false。
		*/
		__proto.isMouseEvent = function (type) {
			return EventDispatcher.MOUSE_EVENTS[type];
		}

		EventDispatcher.MOUSE_EVENTS = { "rightmousedown": true, "rightmouseup": true, "rightclick": true, "mousedown": true, "mouseup": true, "mousemove": true, "mouseover": true, "mouseout": true, "click": true, "doubleclick": true };
		EventDispatcher.__init$ = function () {
			Object.defineProperty(laya.events.EventDispatcher.prototype, "_events", { enumerable: false, writable: true });
			/**@private */
			//class EventHandler extends laya.utils.Handler
			EventHandler = (function (_super) {
				function EventHandler(caller, method, args, once) {
					EventHandler.__super.call(this, caller, method, args, once);
				}
				__class(EventHandler, '', _super);
				var __proto = EventHandler.prototype;
				__proto.recover = function () {
					if (this._id > 0) {
						this._id = 0;
						EventHandler._pool.push(this.clear());
					}
				}
				EventHandler.create = function (caller, method, args, once) {
					(once === void 0) && (once = true);
					if (EventHandler._pool.length) return EventHandler._pool.pop().setTo(caller, method, args, once);
					return new EventHandler(caller, method, args, once);
				}
				EventHandler._pool = [];
				return EventHandler;
			})(Handler)
		}

		return EventDispatcher;
	})()


	/**
	*<p><code>Handler</code> 是事件处理器类。</p>
	*<p>推荐使用 Handler.create()方法从对象池创建，减少对象创建消耗。创建的 Handler 对象不再使用后，可以使用 Handler.recover()将其回收到对象池，回收后不要再使用此对象，否则会导致不可预料的错误。</p>
	*<p><b>注意：</b>由于鼠标事件也用本对象池，不正确的回收及调用，可能会影响鼠标事件的执行。</p>
	*/
	//class laya.utils.Handler
	var Handler = (function () {
		function Handler(caller, method, args, once) {
			/**执行域(this)。*/
			//this.caller=null;
			/**处理方法。*/
			//this.method=null;
			/**参数。*/
			//this.args=null;
			/**表示是否只执行一次。如果为true，回调后执行recover()进行回收，回收后会被再利用，默认为false 。*/
			this.once = false;
			/**@private */
			this._id = 0;
			(once === void 0) && (once = false);
			this.setTo(caller, method, args, once);
		}

		__class(Handler, 'laya.utils.Handler');
		var __proto = Handler.prototype;
		/**
		*设置此对象的指定属性值。
		*@param caller 执行域(this)。
		*@param method 回调方法。
		*@param args 携带的参数。
		*@param once 是否只执行一次，如果为true，执行后执行recover()进行回收。
		*@return 返回 handler 本身。
		*/
		__proto.setTo = function (caller, method, args, once) {
			this._id = Handler._gid++;
			this.caller = caller;
			this.method = method;
			this.args = args;
			this.once = once;
			return this;
		}

		/**
		*执行处理器。
		*/
		__proto.run = function () {
			if (this.method == null) return null;
			var id = this._id;
			var result = this.method.apply(this.caller, this.args);
			this._id === id && this.once && this.recover();
			return result;
		}

		/**
		*执行处理器，携带额外数据。
		*@param data 附加的回调数据，可以是单数据或者Array(作为多参)。
		*/
		__proto.runWith = function (data) {
			if (this.method == null) return null;
			var id = this._id;
			if (data == null)
				var result = this.method.apply(this.caller, this.args);
			else if (!this.args && !data.unshift) result = this.method.call(this.caller, data);
			else if (this.args) result = this.method.apply(this.caller, this.args.concat(data));
			else result = this.method.apply(this.caller, data);
			this._id === id && this.once && this.recover();
			return result;
		}

		/**
		*清理对象引用。
		*/
		__proto.clear = function () {
			this.caller = null;
			this.method = null;
			this.args = null;
			return this;
		}

		/**
		*清理并回收到 Handler 对象池内。
		*/
		__proto.recover = function () {
			if (this._id > 0) {
				this._id = 0;
				Handler._pool.push(this.clear());
			}
		}

		Handler.create = function (caller, method, args, once) {
			(once === void 0) && (once = true);
			if (Handler._pool.length) return Handler._pool.pop().setTo(caller, method, args, once);
			return new Handler(caller, method, args, once);
		}

		Handler._pool = [];
		Handler._gid = 1;
		return Handler;
	})()


	/**
	*<code>BitmapFont</code> 是位图字体类，用于定义位图字体信息。
	*/
	//class laya.display.BitmapFont
	var BitmapFont = (function () {
		function BitmapFont() {
			this._texture = null;
			this._fontCharDic = {};
			this._fontWidthMap = {};
			this._complete = null;
			this._path = null;
			this._maxWidth = 0;
			this._spaceWidth = 10;
			this._padding = null;
			/**当前位图字体字号。*/
			this.fontSize = 12;
			/**表示是否根据实际使用的字体大小缩放位图字体大小。*/
			this.autoScaleSize = false;
			/**字符间距（以像素为单位）。*/
			this.letterSpacing = 0;
		}

		__class(BitmapFont, 'laya.display.BitmapFont');
		var __proto = BitmapFont.prototype;
		/**
		*通过指定位图字体文件路径，加载位图字体文件，加载完成后会自动解析。
		*@param path 位图字体文件的路径。
		*@param complete 加载并解析完成的回调。如果成功返回this,如果失败返回null
		*/
		__proto.loadFont = function (path, complete) {
			this._path = path;
			this._complete = complete;
			Laya.loader.load([{ url: this._path, type:/*laya.net.Loader.XML*/"xml" }, { url: this._path.replace(".fnt", ".png"), type:/*laya.net.Loader.IMAGE*/"image" }], Handler.create(this, this.onLoaded));
		}

		/**
		*@private
		*/
		__proto.onLoaded = function () {
			this.parseFont(Loader.getRes(this._path), Loader.getRes(this._path.replace(".fnt", ".png")));
			this._complete && this._complete.runWith(this._texture ? this : null);
		}

		/**
		*解析字体文件。
		*@param xml 字体文件XML。
		*@param texture 字体的纹理。
		*/
		__proto.parseFont = function (xml, texture) {
			if (xml == null || texture == null) return;
			this._texture = texture;
			var tX = 0;
			var tScale = 1;
			var tInfo = xml.getElementsByTagName("info");
			if (!tInfo[0].getAttributeNode) {
				return this.parseFont2(xml, texture);
			}
			this.fontSize = parseInt(tInfo[0].getAttributeNode("size").nodeValue);
			var tPadding = tInfo[0].getAttributeNode("padding").nodeValue;
			var tPaddingArray = tPadding.split(",");
			this._padding = [parseInt(tPaddingArray[0]), parseInt(tPaddingArray[1]), parseInt(tPaddingArray[2]), parseInt(tPaddingArray[3])];
			var chars;
			chars = xml.getElementsByTagName("char");
			var i = 0;
			for (i = 0; i < chars.length; i++) {
				var tAttribute = chars[i];
				var tId = parseInt(tAttribute.getAttributeNode("id").nodeValue);
				var xOffset = parseInt(tAttribute.getAttributeNode("xoffset").nodeValue) / tScale;
				var yOffset = parseInt(tAttribute.getAttributeNode("yoffset").nodeValue) / tScale;
				var xAdvance = parseInt(tAttribute.getAttributeNode("xadvance").nodeValue) / tScale;
				var region = new Rectangle();
				region.x = parseInt(tAttribute.getAttributeNode("x").nodeValue);
				region.y = parseInt(tAttribute.getAttributeNode("y").nodeValue);
				region.width = parseInt(tAttribute.getAttributeNode("width").nodeValue);
				region.height = parseInt(tAttribute.getAttributeNode("height").nodeValue);
				var tTexture = Texture.create(texture, region.x, region.y, region.width, region.height, xOffset, yOffset);
				this._maxWidth = Math.max(this._maxWidth, xAdvance + this.letterSpacing);
				this._fontCharDic[tId] = tTexture;
				this._fontWidthMap[tId] = xAdvance;
			}
		}

		/**
		*@private
		*解析字体文件。
		*@param xml 字体文件XML。
		*@param texture 字体的纹理。
		*/
		__proto.parseFont2 = function (xml, texture) {
			if (xml == null || texture == null) return;
			this._texture = texture;
			var tX = 0;
			var tScale = 1;
			var tInfo = xml.getElementsByTagName("info");
			this.fontSize = parseInt(tInfo[0].attributes["size"].nodeValue);
			var tPadding = tInfo[0].attributes["padding"].nodeValue;
			var tPaddingArray = tPadding.split(",");
			this._padding = [parseInt(tPaddingArray[0]), parseInt(tPaddingArray[1]), parseInt(tPaddingArray[2]), parseInt(tPaddingArray[3])];
			var chars = xml.getElementsByTagName("char");
			var i = 0;
			for (i = 0; i < chars.length; i++) {
				var tAttribute = chars[i].attributes;
				var tId = parseInt(tAttribute["id"].nodeValue);
				var xOffset = parseInt(tAttribute["xoffset"].nodeValue) / tScale;
				var yOffset = parseInt(tAttribute["yoffset"].nodeValue) / tScale;
				var xAdvance = parseInt(tAttribute["xadvance"].nodeValue) / tScale;
				var region = new Rectangle();
				region.x = parseInt(tAttribute["x"].nodeValue);
				region.y = parseInt(tAttribute["y"].nodeValue);
				region.width = parseInt(tAttribute["width"].nodeValue);
				region.height = parseInt(tAttribute["height"].nodeValue);
				var tTexture = Texture.create(texture, region.x, region.y, region.width, region.height, xOffset, yOffset);
				this._maxWidth = Math.max(this._maxWidth, xAdvance + this.letterSpacing);
				this._fontCharDic[tId] = tTexture;
				this._fontWidthMap[tId] = xAdvance;
			}
		}

		/**
		*获取指定字符的字体纹理对象。
		*@param char 字符。
		*@return 指定的字体纹理对象。
		*/
		__proto.getCharTexture = function (char) {
			return this._fontCharDic[char.charCodeAt(0)];
		}

		/**
		*销毁位图字体，调用Text.unregisterBitmapFont 时，默认会销毁。
		*/
		__proto.destroy = function () {
			if (this._texture) {
				for (var p in this._fontCharDic) {
					var tTexture = this._fontCharDic[p];
					if (tTexture) tTexture.destroy();
				}
				this._texture.destroy();
				this._fontCharDic = null;
				this._fontWidthMap = null;
				this._texture = null;
			}
		}

		/**
		*设置空格的宽（如果字体库有空格，这里就可以不用设置了）。
		*@param spaceWidth 宽度，单位为像素。
		*/
		__proto.setSpaceWidth = function (spaceWidth) {
			this._spaceWidth = spaceWidth;
		}

		/**
		*获取指定字符的宽度。
		*@param char 字符。
		*@return 宽度。
		*/
		__proto.getCharWidth = function (char) {
			var code = char.charCodeAt(0);
			if (this._fontWidthMap[code]) return this._fontWidthMap[code] + this.letterSpacing;
			if (char == " ") return this._spaceWidth + this.letterSpacing;
			return 0;
		}

		/**
		*获取指定文本内容的宽度。
		*@param text 文本内容。
		*@return 宽度。
		*/
		__proto.getTextWidth = function (text) {
			var tWidth = 0;
			for (var i = 0, n = text.length; i < n; i++) {
				tWidth += this.getCharWidth(text.charAt(i));
			}
			return tWidth;
		}

		/**
		*获取最大字符宽度。
		*/
		__proto.getMaxWidth = function () {
			return this._maxWidth;
		}

		/**
		*获取最大字符高度。
		*/
		__proto.getMaxHeight = function () {
			return this.fontSize;
		}

		/**
		*@private
		*将指定的文本绘制到指定的显示对象上。
		*/
		__proto.drawText = function (text, sprite, drawX, drawY, align, width) {
			var tWidth = this.getTextWidth(text);
			var tTexture;
			var dx = 0;
			align === "center" && (dx = (width - tWidth) / 2);
			align === "right" && (dx = (width - tWidth));
			var tX = 0;
			for (var i = 0, n = text.length; i < n; i++) {
				tTexture = this.getCharTexture(text.charAt(i));
				if (tTexture) {
					sprite.graphics.drawTexture(tTexture, drawX + tX + dx, drawY);
					tX += this.getCharWidth(text.charAt(i));
				}
			}
		}

		return BitmapFont;
	})()


	/**
	*@private
	*<code>Style</code> 类是元素样式定义类。
	*/
	//class laya.display.css.Style
	var Style = (function () {
		function Style() {
			/**透明度。*/
			this.alpha = 1;
			/**表示是否显示。*/
			this.visible = true;
			/**表示滚动区域。*/
			this.scrollRect = null;
			/**混合模式。*/
			this.blendMode = null;
			/**@private */
			this._type = 0;
			this._tf = Style._TF_EMPTY;
		}

		__class(Style, 'laya.display.css.Style');
		var __proto = Style.prototype;
		__proto.getTransform = function () {
			return this._tf;
		}

		__proto.setTransform = function (value) {
			this._tf = value === 'none' || !value ? Style._TF_EMPTY : value;
		}

		__proto.setTranslateX = function (value) {
			this._tf === Style._TF_EMPTY && (this._tf = new TransformInfo());
			this._tf.translateX = value;
		}

		__proto.setTranslateY = function (value) {
			this._tf === Style._TF_EMPTY && (this._tf = new TransformInfo());
			this._tf.translateY = value;
		}

		__proto.setScaleX = function (value) {
			this._tf === Style._TF_EMPTY && (this._tf = new TransformInfo());
			this._tf.scaleX = value;
		}

		__proto.setScale = function (x, y) {
			this._tf === Style._TF_EMPTY && (this._tf = new TransformInfo());
			this._tf.scaleX = x;
			this._tf.scaleY = y;
		}

		__proto.setScaleY = function (value) {
			this._tf === Style._TF_EMPTY && (this._tf = new TransformInfo());
			this._tf.scaleY = value;
		}

		__proto.setRotate = function (value) {
			this._tf === Style._TF_EMPTY && (this._tf = new TransformInfo());
			this._tf.rotate = value;
		}

		__proto.setSkewX = function (value) {
			this._tf === Style._TF_EMPTY && (this._tf = new TransformInfo());
			this._tf.skewX = value;
		}

		__proto.setSkewY = function (value) {
			this._tf === Style._TF_EMPTY && (this._tf = new TransformInfo());
			this._tf.skewY = value;
		}

		/**销毁此对象。*/
		__proto.destroy = function () {
			this.scrollRect = null;
		}

		/**@private */
		__proto.render = function (sprite, context, x, y) { }
		/**@private */
		__proto.getCSSStyle = function () {
			return CSSStyle.EMPTY;
		}

		/**@private */
		__proto._enableLayout = function () {
			return false;
		}

		/**X 轴缩放值。*/
		__getset(0, __proto, 'scaleX', function () {
			return this._tf.scaleX;
		}, function (value) {
			this.setScaleX(value);
		});

		/**元素应用的 2D 或 3D 转换的值。该属性允许我们对元素进行旋转、缩放、移动或倾斜。*/
		__getset(0, __proto, 'transform', function () {
			return this.getTransform();
		}, function (value) {
			this.setTransform(value);
		});

		/**定义转换，只是用 X 轴的值。*/
		__getset(0, __proto, 'translateX', function () {
			return this._tf.translateX;
		}, function (value) {
			this.setTranslateX(value);
		});

		/**定义转换，只是用 Y 轴的值。*/
		__getset(0, __proto, 'translateY', function () {
			return this._tf.translateY;
		}, function (value) {
			this.setTranslateY(value);
		});

		/**Y 轴缩放值。*/
		__getset(0, __proto, 'scaleY', function () {
			return this._tf.scaleY;
		}, function (value) {
			this.setScaleY(value);
		});

		/**表示元素是否显示为块级元素。*/
		__getset(0, __proto, 'block', function () {
			return (this._type & 0x1) != 0;
		});

		/**定义沿着 Y 轴的 2D 倾斜转换。*/
		__getset(0, __proto, 'skewY', function () {
			return this._tf.skewY;
		}, function (value) {
			this.setSkewY(value);
		});

		/**定义旋转角度。*/
		__getset(0, __proto, 'rotate', function () {
			return this._tf.rotate;
		}, function (value) {
			this.setRotate(value);
		});

		/**定义沿着 X 轴的 2D 倾斜转换。*/
		__getset(0, __proto, 'skewX', function () {
			return this._tf.skewX;
		}, function (value) {
			this.setSkewX(value);
		});

		/**表示元素的左内边距。*/
		__getset(0, __proto, 'paddingLeft', function () {
			return 0;
		});

		/**表示元素的上内边距。*/
		__getset(0, __proto, 'paddingTop', function () {
			return 0;
		});

		/**是否为绝对定位。*/
		__getset(0, __proto, 'absolute', function () {
			return true;
		});

		Style.__init__ = function () {
			Style._TF_EMPTY = new TransformInfo();
			Style.EMPTY = new Style();
		}

		Style.EMPTY = null;
		Style._TF_EMPTY = null;
		return Style;
	})()


	/**
	*@private
	*<code>Font</code> 类是字体显示定义类。
	*/
	//class laya.display.css.Font
	var Font = (function () {
		function Font(src) {
			this._type = 0;
			this._weight = 0;
			this._decoration = null;
			this._text = null;
			/**
			*首行缩进 （以像素为单位）。
			*/
			this.indent = 0;
			this._color = Color.create(Font.defaultColor);
			this.family = Font.defaultFamily;
			this.stroke = Font._STROKE;
			this.size = Font.defaultSize;
			src && src !== Font.EMPTY && src.copyTo(this);
		}

		__class(Font, 'laya.display.css.Font');
		var __proto = Font.prototype;
		/**
		*字体样式字符串。
		*/
		__proto.set = function (value) {
			this._text = null;
			var strs = value.split(' ');
			for (var i = 0, n = strs.length; i < n; i++) {
				var str = strs[i];
				switch (str) {
					case 'italic':
						this.italic = true;
						continue;
					case 'bold':
						this.bold = true;
						continue;
				}
				if (str.indexOf('px') > 0) {
					this.size = parseInt(str);
					this.family = strs[i + 1];
					i++;
					continue;
				}
			}
		}

		/**
		*返回字体样式字符串。
		*@return 字体样式字符串。
		*/
		__proto.toString = function () {
			this._text = ""
			this.italic && (this._text += "italic ");
			this.bold && (this._text += "bold ");
			return this._text += this.size + "px " + this.family;
		}

		/**
		*将当前的属性值复制到传入的 <code>Font</code> 对象。
		*@param dec 一个 Font 对象。
		*/
		__proto.copyTo = function (dec) {
			dec._type = this._type;
			dec._text = this._text;
			dec._weight = this._weight;
			dec._color = this._color;
			dec.family = this.family;
			dec.stroke = this.stroke != Font._STROKE ? this.stroke.slice() : Font._STROKE;
			dec.indent = this.indent;
			dec.size = this.size;
		}

		/**
		*表示是否为密码格式。
		*/
		__getset(0, __proto, 'password', function () {
			return (this._type & 0x400) !== 0;
		}, function (value) {
			value ? (this._type |= 0x400) : (this._type &= ~0x400);
		});

		/**
		*表示颜色字符串。
		*/
		__getset(0, __proto, 'color', function () {
			return this._color.strColor;
		}, function (value) {
			this._color = Color.create(value);
		});

		/**
		*表示是否为斜体。
		*/
		__getset(0, __proto, 'italic', function () {
			return (this._type & 0x200) !== 0;
		}, function (value) {
			value ? (this._type |= 0x200) : (this._type &= ~0x200);
		});

		/**
		*表示是否为粗体。
		*/
		__getset(0, __proto, 'bold', function () {
			return (this._type & 0x800) !== 0;
		}, function (value) {
			value ? (this._type |= 0x800) : (this._type &= ~0x800);
		});

		/**
		*文本的粗细。
		*/
		__getset(0, __proto, 'weight', function () {
			return "" + this._weight;
		}, function (value) {
			var weight = 0;
			switch (value) {
				case 'normal':
					break;
				case 'bold':
					this.bold = true;
					weight = 700;
					break;
				case 'bolder':
					weight = 800;
					break;
				case 'lighter':
					weight = 100;
					break;
				default:
					weight = parseInt(value);
			}
			this._weight = weight;
			this._text = null;
		});

		/**
		*规定添加到文本的修饰。
		*/
		__getset(0, __proto, 'decoration', function () {
			return this._decoration ? this._decoration.value : "none";
		}, function (value) {
			var strs = value.split(' ');
			this._decoration || (this._decoration = {});
			switch (strs[0]) {
				case '_':
					this._decoration.type = 'underline'
					break;
				case '-':
					this._decoration.type = 'line-through'
					break;
				case 'overline':
					this._decoration.type = 'overline'
					break;
				default:
					this._decoration.type = strs[0];
			}
			strs[1] && (this._decoration.color = Color.create(strs));
			this._decoration.value = value;
		});

		Font.__init__ = function () {
			Font.EMPTY = new Font(null);
		}

		Font.EMPTY = null;
		Font.defaultColor = "#000000";
		Font.defaultSize = 12;
		Font.defaultFamily = "Arial";
		Font.defaultFont = "12px Arial";
		Font._STROKE = [0, "#000000"];
		Font._ITALIC = 0x200;
		Font._PASSWORD = 0x400;
		Font._BOLD = 0x800;
		return Font;
	})()


	/**
	*@private
	*/
	//class laya.display.css.TransformInfo
	var TransformInfo = (function () {
		function TransformInfo() {
			this.translateX = 0;
			this.translateY = 0;
			this.scaleX = 1;
			this.scaleY = 1;
			this.rotate = 0;
			this.skewX = 0;
			this.skewY = 0;
		}

		__class(TransformInfo, 'laya.display.css.TransformInfo');
		return TransformInfo;
	})()


	/**
	*<code>Graphics</code> 类用于创建绘图显示对象。Graphics可以同时绘制多个位图或者矢量图，还可以结合save，restore，transform，scale，rotate，translate，alpha等指令对绘图效果进行变化。
	*Graphics以命令流方式存储，可以通过cmds属性访问所有命令流。Graphics是比Sprite更轻量级的对象，合理使用能提高应用性能(比如把大量的节点绘图改为一个节点的Graphics命令集合，能减少大量节点创建消耗)。
	*@see laya.display.Sprite#graphics
	*/
	//class laya.display.Graphics
	var Graphics = (function () {
		function Graphics() {
			/**@private */
			//this._sp=null;
			/**@private */
			this._one = null;
			/**@private */
			this._cmds = null;
			/**@private */
			//this._vectorgraphArray=null;
			/**@private */
			//this._graphicBounds=null;
			this._render = this._renderEmpty;
			if (Render.isConchNode) {
				var _this_ = this;
				_this_._nativeObj = new (window)._conchGraphics();
				_this_.id = _this_._nativeObj.conchID;
			}
		}

		__class(Graphics, 'laya.display.Graphics');
		var __proto = Graphics.prototype;
		/**
		*<p>销毁此对象。</p>
		*/
		__proto.destroy = function () {
			this.clear();
			if (this._graphicBounds) this._graphicBounds.destroy();
			this._graphicBounds = null;
			this._vectorgraphArray = null;
			this._sp && (this._sp._renderType = 0);
			this._sp = null;
		}

		/**
		*<p>清空绘制命令。</p>
		*@param recoverCmds 是否回收绘图指令
		*/
		__proto.clear = function (recoverCmds) {
			(recoverCmds === void 0) && (recoverCmds = false);
			var i = 0, len = 0;
			if (recoverCmds) {
				var tCmd = this._one;
				if (this._cmds) {
					len = this._cmds.length;
					for (i = 0; i < len; i++) {
						tCmd = this._cmds[i];
						if (tCmd && (tCmd.callee === Render._context._drawTexture || tCmd.callee === Render._context._drawTextureWithTransform)) {
							tCmd[0] = null;
							Graphics._cache.push(tCmd);
						}
					}
					this._cmds.length = 0;
				} else if (tCmd) {
					if (tCmd && (tCmd.callee === Render._context._drawTexture || tCmd.callee === Render._context._drawTextureWithTransform)) {
						tCmd[0] = null;
						Graphics._cache.push(tCmd);
					}
				}
			} else {
				this._cmds = null;
			}
			this._one = null;
			this._render = this._renderEmpty;
			this._sp && (this._sp._renderType &= ~ /*laya.renders.RenderSprite.IMAGE*/0x01 & ~ /*laya.renders.RenderSprite.GRAPHICS*/0x200);
			this._repaint();
			if (this._vectorgraphArray) {
				for (i = 0, len = this._vectorgraphArray.length; i < len; i++) {
					VectorGraphManager.getInstance().deleteShape(this._vectorgraphArray[i]);
				}
				this._vectorgraphArray.length = 0;
			}
		}

		/**@private */
		__proto._clearBoundsCache = function () {
			if (this._graphicBounds) this._graphicBounds.reset();
		}

		/**@private */
		__proto._initGraphicBounds = function () {
			if (!this._graphicBounds) {
				this._graphicBounds = new GraphicsBounds();
				this._graphicBounds._graphics = this;
			}
		}

		/**
		*@private
		*重绘此对象。
		*/
		__proto._repaint = function () {
			this._clearBoundsCache();
			this._sp && this._sp.repaint();
		}

		/**@private */
		__proto._isOnlyOne = function () {
			return !this._cmds || this._cmds.length === 0;
		}

		/**
		*获取位置及宽高信息矩阵(比较耗CPU，频繁使用会造成卡顿，尽量少用)。
		*@param realSize （可选）使用图片的真实大小，默认为false
		*@return 位置与宽高组成的 一个 Rectangle 对象。
		*/
		__proto.getBounds = function (realSize) {
			(realSize === void 0) && (realSize = false);
			this._initGraphicBounds();
			return this._graphicBounds.getBounds(realSize);
		}

		/**
		*@private
		*@param realSize （可选）使用图片的真实大小，默认为false
		*获取端点列表。
		*/
		__proto.getBoundPoints = function (realSize) {
			(realSize === void 0) && (realSize = false);
			this._initGraphicBounds();
			return this._graphicBounds.getBoundPoints(realSize);
		}

		__proto._addCmd = function (a) {
			this._cmds = this._cmds || [];
			a.callee = a.shift();
			this._cmds.push(a);
		}

		__proto.setFilters = function (fs) {
			this._saveToCmd(Render._context._setFilters, fs);
		}

		/**
		*绘制纹理。
		*@param tex 纹理。
		*@param x （可选）X轴偏移量。
		*@param y （可选）Y轴偏移量。
		*@param width （可选）宽度。
		*@param height （可选）高度。
		*@param m （可选）矩阵信息。
		*@param alpha （可选）透明度。
		*/
		__proto.drawTexture = function (tex, x, y, width, height, m, alpha) {
			(x === void 0) && (x = 0);
			(y === void 0) && (y = 0);
			(width === void 0) && (width = 0);
			(height === void 0) && (height = 0);
			(alpha === void 0) && (alpha = 1);
			if (!tex || alpha < 0.01) return null;
			if (!width) width = tex.sourceWidth;
			if (!height) height = tex.sourceHeight;
			alpha = alpha < 0 ? 0 : (alpha > 1 ? 1 : alpha);
			var offset = (!Render.isWebGL && (Browser.onFirefox || Browser.onEdge || Browser.onIE)) ? 0.5 : 0;
			var wRate = width / tex.sourceWidth;
			var hRate = height / tex.sourceHeight;
			width = tex.width * wRate;
			height = tex.height * hRate;
			if (tex.loaded && (width <= 0 || height <= 0)) return null;
			x += tex.offsetX * wRate;
			y += tex.offsetY * hRate;
			this._sp && (this._sp._renderType |=/*laya.renders.RenderSprite.GRAPHICS*/0x200);
			var args;
			x -= offset;
			y -= offset;
			width += 2 * offset;
			height += 2 * offset;
			if (Graphics._cache.length) {
				args = Graphics._cache.pop();
				args[0] = tex;
				args[1] = x;
				args[2] = y;
				args[3] = width;
				args[4] = height;
				args[5] = m;
				args[6] = alpha;
			} else {
				args = [tex, x, y, width, height, m, alpha];
			}
			args.callee = (m || alpha != 1) ? Render._context._drawTextureWithTransform : Render._context._drawTexture;
			if (this._one == null && !m && alpha == 1) {
				this._one = args;
				this._render = this._renderOneImg;
			} else {
				this._saveToCmd(args.callee, args);
			}
			if (!tex.loaded) {
				tex.once(/*laya.events.Event.LOADED*/"loaded", this, this._textureLoaded, [tex, args]);
			}
			this._repaint();
			return args;
		}

		/**
		*@private 清理贴图并替换为最新的
		*@param tex
		*/
		__proto.cleanByTexture = function (tex, x, y, width, height) {
			(width === void 0) && (width = 0);
			(height === void 0) && (height = 0);
			if (!tex) return this.clear();
			if (this._one && this._render === this._renderOneImg) {
				if (!width) width = tex.sourceWidth;
				if (!height) height = tex.sourceHeight;
				var wRate = width / tex.sourceWidth;
				var hRate = height / tex.sourceHeight;
				width = tex.width * wRate;
				height = tex.height * hRate;
				x += tex.offsetX * wRate;
				y += tex.offsetY * hRate;
				this._one[0] = tex;
				this._one[1] = x;
				this._one[2] = y;
				this._one[3] = width;
				this._one[4] = height;
			} else {
				this.clear();
				tex && this.drawTexture(tex, x, y, width, height);
			}
		}

		/**
		*批量绘制同样纹理。
		*@param tex 纹理。
		*@param pos 绘制坐标。
		*/
		__proto.drawTextures = function (tex, pos) {
			if (!tex) return;
			this._saveToCmd(Render._context._drawTextures, [tex, pos]);
		}

		/**
		*用texture填充。
		*@param tex 纹理。
		*@param x X轴偏移量。
		*@param y Y轴偏移量。
		*@param width （可选）宽度。
		*@param height （可选）高度。
		*@param type （可选）填充类型 repeat|repeat-x|repeat-y|no-repeat
		*@param offset （可选）贴图纹理偏移
		*/
		__proto.fillTexture = function (tex, x, y, width, height, type, offset) {
			(width === void 0) && (width = 0);
			(height === void 0) && (height = 0);
			(type === void 0) && (type = "repeat");
			if (!tex) return;
			var args = [tex, x, y, width, height, type, offset || Point.EMPTY, {}];
			if (!tex.loaded) {
				tex.once(/*laya.events.Event.LOADED*/"loaded", this, this._textureLoaded, [tex, args]);
			}
			this._saveToCmd(Render._context._fillTexture, args);
		}

		__proto._textureLoaded = function (tex, param) {
			param[3] = param[3] || tex.width;
			param[4] = param[4] || tex.height;
			this._repaint();
		}

		/**
		*填充一个圆形。这是一个临时函数，以后会删除，建议用户自己实现。
		*@param x
		*@param y
		*@param tex
		*@param cx 圆心位置。
		*@param cy
		*@param radius
		*@param segNum 分段数，越大越平滑。
		*/
		__proto.fillCircle = function (x, y, tex, cx, cy, radius, segNum) {
			tex.bitmap.enableMerageInAtlas = false;
			var verts = new Float32Array((segNum + 1) * 2);
			var uvs = new Float32Array((segNum + 1) * 2);
			var indices = new Uint16Array(segNum * 3);
			var dang = 2 * Math.PI / segNum;
			var cang = 0;
			verts[0] = cx;
			verts[1] = cy;
			uvs[0] = cx / tex.width;
			uvs[1] = cy / tex.height;
			var idx = 2;
			for (var i = 0; i < segNum; i++) {
				var px = radius * Math.cos(cang) + cx;
				var py = radius * Math.sin(cang) + cy;
				verts[idx] = px;
				verts[idx + 1] = py;
				uvs[idx] = px / tex.width;
				uvs[idx + 1] = py / tex.height;
				cang += dang;
				idx += 2;
			}
			idx = 0;
			for (i = 0; i < segNum; i++) {
				indices[idx++] = 0;
				indices[idx++] = i + 1;
				indices[idx++] = (i + 2 >= segNum + 1) ? 1 : (i + 2);
			}
			this.drawTriangles(tex, x, y, verts, uvs, indices);
		}

		/**
		*绘制一组三角形
		*@param texture 纹理。
		*@param x X轴偏移量。
		*@param y Y轴偏移量。
		*@param vertices 顶点数组。
		*@param indices 顶点索引。
		*@param uvData UV数据。
		*@param matrix 缩放矩阵。
		*@param alpha alpha
		*@param color 颜色变换
		*@param blendMode blend模式
		*/
		__proto.drawTriangles = function (texture, x, y, vertices, uvs, indices, matrix, alpha, color, blendMode) {
			(alpha === void 0) && (alpha = 1);
			this._saveToCmd(Render._context.drawTriangles, [texture, x, y, vertices, uvs, indices, matrix, alpha, color, blendMode]);
		}

		/**
		*@private
		*保存到命令流。
		*/
		__proto._saveToCmd = function (fun, args) {
			this._sp && (this._sp._renderType |=/*laya.renders.RenderSprite.GRAPHICS*/0x200);
			if (this._one == null) {
				this._one = args;
				this._render = this._renderOne;
			} else {
				this._sp && (this._sp._renderType &= ~ /*laya.renders.RenderSprite.IMAGE*/0x01);
				this._render = this._renderAll;
				(this._cmds || (this._cmds = [])).length === 0 && this._cmds.push(this._one);
				this._cmds.push(args);
			}
			args.callee = fun;
			this._repaint();
			return args;
		}

		/**
		*设置剪裁区域，超出剪裁区域的坐标不显示。
		*@param x X 轴偏移量。
		*@param y Y 轴偏移量。
		*@param width 宽度。
		*@param height 高度。
		*/
		__proto.clipRect = function (x, y, width, height) {
			this._saveToCmd(Render._context._clipRect, [x, y, width, height]);
		}

		/**
		*在画布上绘制文本。
		*@param text 在画布上输出的文本。
		*@param x 开始绘制文本的 x 坐标位置（相对于画布）。
		*@param y 开始绘制文本的 y 坐标位置（相对于画布）。
		*@param font 定义字号和字体，比如"20px Arial"。
		*@param color 定义文本颜色，比如"#ff0000"。
		*@param textAlign 文本对齐方式，可选值："left"，"center"，"right"。
		*/
		__proto.fillText = function (text, x, y, font, color, textAlign, underLine) {
			(underLine === void 0) && (underLine = 0);
			this._saveToCmd(Render._context._fillText, [text, x, y, font || Font.defaultFont, color, textAlign]);
		}

		/**
		*在画布上绘制“被填充且镶边的”文本。
		*@param text 在画布上输出的文本。
		*@param x 开始绘制文本的 x 坐标位置（相对于画布）。
		*@param y 开始绘制文本的 y 坐标位置（相对于画布）。
		*@param font 定义字体和字号，比如"20px Arial"。
		*@param fillColor 定义文本颜色，比如"#ff0000"。
		*@param borderColor 定义镶边文本颜色。
		*@param lineWidth 镶边线条宽度。
		*@param textAlign 文本对齐方式，可选值："left"，"center"，"right"。
		*/
		__proto.fillBorderText = function (text, x, y, font, fillColor, borderColor, lineWidth, textAlign) {
			this._saveToCmd(Render._context._fillBorderText, [text, x, y, font || Font.defaultFont, fillColor, borderColor, lineWidth, textAlign]);
		}

		/**
		*在画布上绘制文本（没有填色）。文本的默认颜色是黑色。
		*@param text 在画布上输出的文本。
		*@param x 开始绘制文本的 x 坐标位置（相对于画布）。
		*@param y 开始绘制文本的 y 坐标位置（相对于画布）。
		*@param font 定义字体和字号，比如"20px Arial"。
		*@param color 定义文本颜色，比如"#ff0000"。
		*@param lineWidth 线条宽度。
		*@param textAlign 文本对齐方式，可选值："left"，"center"，"right"。
		*/
		__proto.strokeText = function (text, x, y, font, color, lineWidth, textAlign) {
			this._saveToCmd(Render._context._strokeText, [text, x, y, font || Font.defaultFont, color, lineWidth, textAlign]);
		}

		/**
		*设置透明度。
		*@param value 透明度。
		*/
		__proto.alpha = function (value) {
			value = value < 0 ? 0 : (value > 1 ? 1 : value);
			this._saveToCmd(Render._context._alpha, [value]);
		}

		/**
		*设置当前透明度。
		*@param value 透明度。
		*/
		__proto.setAlpha = function (value) {
			value = value < 0 ? 0 : (value > 1 ? 1 : value);
			this._saveToCmd(Render._context._setAlpha, [value]);
		}

		/**
		*替换绘图的当前转换矩阵。
		*@param mat 矩阵。
		*@param pivotX （可选）水平方向轴心点坐标。
		*@param pivotY （可选）垂直方向轴心点坐标。
		*/
		__proto.transform = function (matrix, pivotX, pivotY) {
			(pivotX === void 0) && (pivotX = 0);
			(pivotY === void 0) && (pivotY = 0);
			this._saveToCmd(Render._context._transform, [matrix, pivotX, pivotY]);
		}

		/**
		*旋转当前绘图。(推荐使用transform，性能更高)
		*@param angle 旋转角度，以弧度计。
		*@param pivotX （可选）水平方向轴心点坐标。
		*@param pivotY （可选）垂直方向轴心点坐标。
		*/
		__proto.rotate = function (angle, pivotX, pivotY) {
			(pivotX === void 0) && (pivotX = 0);
			(pivotY === void 0) && (pivotY = 0);
			this._saveToCmd(Render._context._rotate, [angle, pivotX, pivotY]);
		}

		/**
		*缩放当前绘图至更大或更小。(推荐使用transform，性能更高)
		*@param scaleX 水平方向缩放值。
		*@param scaleY 垂直方向缩放值。
		*@param pivotX （可选）水平方向轴心点坐标。
		*@param pivotY （可选）垂直方向轴心点坐标。
		*/
		__proto.scale = function (scaleX, scaleY, pivotX, pivotY) {
			(pivotX === void 0) && (pivotX = 0);
			(pivotY === void 0) && (pivotY = 0);
			this._saveToCmd(Render._context._scale, [scaleX, scaleY, pivotX, pivotY]);
		}

		/**
		*重新映射画布上的 (0,0)位置。
		*@param x 添加到水平坐标（x）上的值。
		*@param y 添加到垂直坐标（y）上的值。
		*/
		__proto.translate = function (x, y) {
			this._saveToCmd(Render._context._translate, [x, y]);
		}

		/**
		*保存当前环境的状态。
		*/
		__proto.save = function () {
			this._saveToCmd(Render._context._save, []);
		}

		/**
		*返回之前保存过的路径状态和属性。
		*/
		__proto.restore = function () {
			this._saveToCmd(Render._context._restore, []);
		}

		/**
		*@private
		*替换文本内容。
		*@param text 文本内容。
		*@return 替换成功则值为true，否则值为flase。
		*/
		__proto.replaceText = function (text) {
			this._repaint();
			var cmds = this._cmds;
			if (!cmds) {
				if (this._one && this._isTextCmd(this._one.callee)) {
					if (this._one[0].toUpperCase) this._one[0] = text;
					else this._one[0].setText(text);
					return true;
				}
			} else {
				for (var i = cmds.length - 1; i > -1; i--) {
					if (this._isTextCmd(cmds[i].callee)) {
						if (cmds[i][0].toUpperCase) cmds[i][0] = text;
						else cmds[i][0].setText(text);
						return true;
					}
				}
			}
			return false;
		}

		/**@private */
		__proto._isTextCmd = function (fun) {
			return fun === Render._context._fillText || fun === Render._context._fillBorderText || fun === Render._context._strokeText;
		}

		/**
		*@private
		*替换文本颜色。
		*@param color 颜色。
		*/
		__proto.replaceTextColor = function (color) {
			this._repaint();
			var cmds = this._cmds;
			if (!cmds) {
				if (this._one && this._isTextCmd(this._one.callee)) {
					this._one[4] = color;
					if (!this._one[0].toUpperCase) this._one[0].changed = true;
				}
			} else {
				for (var i = cmds.length - 1; i > -1; i--) {
					if (this._isTextCmd(cmds[i].callee)) {
						cmds[i][4] = color;
						if (!cmds[i][0].toUpperCase) cmds[i][0].changed = true;
					}
				}
			}
		}

		/**
		*加载并显示一个图片。
		*@param url 图片地址。
		*@param x （可选）显示图片的x位置。
		*@param y （可选）显示图片的y位置。
		*@param width （可选）显示图片的宽度，设置为0表示使用图片默认宽度。
		*@param height （可选）显示图片的高度，设置为0表示使用图片默认高度。
		*@param complete （可选）加载完成回调。
		*/
		__proto.loadImage = function (url, x, y, width, height, complete) {
			var _$this = this;
			(x === void 0) && (x = 0);
			(y === void 0) && (y = 0);
			(width === void 0) && (width = 0);
			(height === void 0) && (height = 0);
			var tex = Loader.getRes(url);
			if (tex) onloaded(tex);
			else Laya.loader.load(url, Handler.create(null, onloaded), null,/*laya.net.Loader.IMAGE*/"image");
			function onloaded(tex) {
				if (tex) {
					_$this.drawTexture(tex, x, y, width, height);
					if (complete != null) complete.call(_$this._sp, tex);
				}
			}
		}

		/**
		*@private
		*/
		__proto._renderEmpty = function (sprite, context, x, y) { }
		/**
		*@private
		*/
		__proto._renderAll = function (sprite, context, x, y) {
			var cmds = this._cmds, cmd;
			for (var i = 0, n = cmds.length; i < n; i++) {
				(cmd = cmds[i]).callee.call(context, x, y, cmd);
			}
		}

		/**
		*@private
		*/
		__proto._renderOne = function (sprite, context, x, y) {
			this._one.callee.call(context, x, y, this._one);
		}

		/**
		*@private
		*/
		__proto._renderOneImg = function (sprite, context, x, y) {
			this._one.callee.call(context, x, y, this._one);
			if (sprite._renderType !== 2305) {
				sprite._renderType |=/*laya.renders.RenderSprite.IMAGE*/0x01;
			}
		}

		/**
		*绘制一条线。
		*@param fromX X轴开始位置。
		*@param fromY Y轴开始位置。
		*@param toX X轴结束位置。
		*@param toY Y轴结束位置。
		*@param lineColor 颜色。
		*@param lineWidth （可选）线条宽度。
		*/
		__proto.drawLine = function (fromX, fromY, toX, toY, lineColor, lineWidth) {
			(lineWidth === void 0) && (lineWidth = 1);
			var tId = 0;
			if (Render.isWebGL) {
				tId = VectorGraphManager.getInstance().getId();
				if (this._vectorgraphArray == null) this._vectorgraphArray = [];
				this._vectorgraphArray.push(tId);
			};
			var offset = lineWidth % 2 === 0 ? 0 : 0.5;
			var arr = [fromX + offset, fromY + offset, toX + offset, toY + offset, lineColor, lineWidth, tId];
			this._saveToCmd(Render._context._drawLine, arr);
		}

		/**
		*绘制一系列线段。
		*@param x 开始绘制的X轴位置。
		*@param y 开始绘制的Y轴位置。
		*@param points 线段的点集合。格式:[x1,y1,x2,y2,x3,y3...]。
		*@param lineColor 线段颜色，或者填充绘图的渐变对象。
		*@param lineWidth （可选）线段宽度。
		*/
		__proto.drawLines = function (x, y, points, lineColor, lineWidth) {
			(lineWidth === void 0) && (lineWidth = 1);
			var tId = 0;
			if (!points || points.length < 4) return;
			if (Render.isWebGL) {
				tId = VectorGraphManager.getInstance().getId();
				if (this._vectorgraphArray == null) this._vectorgraphArray = [];
				this._vectorgraphArray.push(tId);
			};
			var offset = lineWidth % 2 === 0 ? 0 : 0.5;
			var arr = [x + offset, y + offset, points, lineColor, lineWidth, tId];
			this._saveToCmd(Render._context._drawLines, arr);
		}

		/**
		*绘制一系列曲线。
		*@param x 开始绘制的 X 轴位置。
		*@param y 开始绘制的 Y 轴位置。
		*@param points 线段的点集合，格式[startx,starty,ctrx,ctry,startx,starty...]。
		*@param lineColor 线段颜色，或者填充绘图的渐变对象。
		*@param lineWidth （可选）线段宽度。
		*/
		__proto.drawCurves = function (x, y, points, lineColor, lineWidth) {
			(lineWidth === void 0) && (lineWidth = 1);
			var arr = [x, y, points, lineColor, lineWidth];
			this._saveToCmd(Render._context._drawCurves, arr);
		}

		/**
		*绘制矩形。
		*@param x 开始绘制的 X 轴位置。
		*@param y 开始绘制的 Y 轴位置。
		*@param width 矩形宽度。
		*@param height 矩形高度。
		*@param fillColor 填充颜色，或者填充绘图的渐变对象。
		*@param lineColor （可选）边框颜色，或者填充绘图的渐变对象。
		*@param lineWidth （可选）边框宽度。
		*/
		__proto.drawRect = function (x, y, width, height, fillColor, lineColor, lineWidth) {
			(lineWidth === void 0) && (lineWidth = 1);
			var offset = lineColor ? lineWidth / 2 : 0;
			var lineOffset = lineColor ? lineWidth : 0;
			var arr = [x + offset, y + offset, width - lineOffset, height - lineOffset, fillColor, lineColor, lineWidth];
			this._saveToCmd(Render._context._drawRect, arr);
		}

		/**
		*绘制圆形。
		*@param x 圆点X 轴位置。
		*@param y 圆点Y 轴位置。
		*@param radius 半径。
		*@param fillColor 填充颜色，或者填充绘图的渐变对象。
		*@param lineColor （可选）边框颜色，或者填充绘图的渐变对象。
		*@param lineWidth （可选）边框宽度。
		*/
		__proto.drawCircle = function (x, y, radius, fillColor, lineColor, lineWidth) {
			(lineWidth === void 0) && (lineWidth = 1);
			var offset = lineColor ? lineWidth / 2 : 0;
			var tId = 0;
			if (Render.isWebGL) {
				tId = VectorGraphManager.getInstance().getId();
				if (this._vectorgraphArray == null) this._vectorgraphArray = [];
				this._vectorgraphArray.push(tId);
			};
			var arr = [x, y, radius - offset, fillColor, lineColor, lineWidth, tId];
			this._saveToCmd(Render._context._drawCircle, arr);
		}

		/**
		*绘制扇形。
		*@param x 开始绘制的 X 轴位置。
		*@param y 开始绘制的 Y 轴位置。
		*@param radius 扇形半径。
		*@param startAngle 开始角度。
		*@param endAngle 结束角度。
		*@param fillColor 填充颜色，或者填充绘图的渐变对象。
		*@param lineColor （可选）边框颜色，或者填充绘图的渐变对象。
		*@param lineWidth （可选）边框宽度。
		*/
		__proto.drawPie = function (x, y, radius, startAngle, endAngle, fillColor, lineColor, lineWidth) {
			(lineWidth === void 0) && (lineWidth = 1);
			var offset = lineColor ? lineWidth / 2 : 0;
			var lineOffset = lineColor ? lineWidth : 0;
			var tId = 0;
			if (Render.isWebGL) {
				tId = VectorGraphManager.getInstance().getId();
				if (this._vectorgraphArray == null) this._vectorgraphArray = [];
				this._vectorgraphArray.push(tId);
			};
			var arr = [x + offset, y + offset, radius - lineOffset, startAngle, endAngle, fillColor, lineColor, lineWidth, tId];
			arr[3] = Utils.toRadian(startAngle);
			arr[4] = Utils.toRadian(endAngle);
			this._saveToCmd(Render._context._drawPie, arr);
		}

		/**
		*绘制多边形。
		*@param x 开始绘制的 X 轴位置。
		*@param y 开始绘制的 Y 轴位置。
		*@param points 多边形的点集合。
		*@param fillColor 填充颜色，或者填充绘图的渐变对象。
		*@param lineColor （可选）边框颜色，或者填充绘图的渐变对象。
		*@param lineWidth （可选）边框宽度。
		*/
		__proto.drawPoly = function (x, y, points, fillColor, lineColor, lineWidth) {
			(lineWidth === void 0) && (lineWidth = 1);
			var tId = 0;
			var tIsConvexPolygon = false;
			if (Render.isWebGL) {
				tId = VectorGraphManager.getInstance().getId();
				if (this._vectorgraphArray == null) this._vectorgraphArray = [];
				this._vectorgraphArray.push(tId);
				if (points.length > 6) {
					tIsConvexPolygon = false;
				} else {
					tIsConvexPolygon = true;
				}
			};
			var offset = lineColor ? (lineWidth % 2 === 0 ? 0 : 0.5) : 0;
			var arr = [x + offset, y + offset, points, fillColor, lineColor, lineWidth, tId, tIsConvexPolygon];
			this._saveToCmd(Render._context._drawPoly, arr);
		}

		/**
		*绘制路径。
		*@param x 开始绘制的 X 轴位置。
		*@param y 开始绘制的 Y 轴位置。
		*@param paths 路径集合，路径支持以下格式：[["moveTo",x,y],["lineTo",x,y,x,y,x,y],["arcTo",x1,y1,x2,y2,r],["closePath"]]。
		*@param brush （可选）刷子定义，支持以下设置{fillStyle}。
		*@param pen （可选）画笔定义，支持以下设置{strokeStyle,lineWidth,lineJoin,lineCap,miterLimit}。
		*/
		__proto.drawPath = function (x, y, paths, brush, pen) {
			var arr = [x, y, paths, brush, pen];
			this._saveToCmd(Render._context._drawPath, arr);
		}

		/**
		*@private
		*命令流。存储了所有绘制命令。
		*/
		__getset(0, __proto, 'cmds', function () {
			return this._cmds;
		}, function (value) {
			this._sp && (this._sp._renderType |=/*laya.renders.RenderSprite.GRAPHICS*/0x200);
			this._cmds = value;
			this._render = this._renderAll;
			this._repaint();
		});

		Graphics.__init__ = function () {
			if (Render.isConchNode) {
				var from = laya.display.Graphics.prototype;
				var to = Browser.window.ConchGraphics.prototype;
				var list = ["clear", "destroy", "alpha", "rotate", "transform", "scale", "translate", "save", "restore", "clipRect", "blendMode", "fillText", "fillBorderText", "_fands", "drawRect", "drawCircle", "drawPie", "drawPoly", "drawPath", "drawImageM", "drawLine", "drawLines", "_drawPs", "drawCurves", "replaceText", "replaceTextColor", "_fillImage", "fillTexture", "setSkinMesh", "drawParticle", "drawImageS"];
				for (var i = 0, len = list.length; i <= len; i++) {
					var temp = list[i];
					from[temp] = to[temp];
				}
				from._saveToCmd = null;
				if (to.drawImageS) {
					from.drawTextures = function (tex, pos) {
						if (!tex) return;
						if (!(tex.loaded && tex.bitmap && tex.source)) {
							return;
						};
						var uv = tex.uv, w = tex.bitmap.width, h = tex.bitmap.height;
						this.drawImageS(tex.bitmap.source, uv[0] * w, uv[1] * h, (uv[2] - uv[0]) * w, (uv[5] - uv[3]) * h, tex.offsetX, tex.offsetY, tex.width, tex.height, pos);
					}
				}
				from.drawTexture = function (tex, x, y, width, height, m, alpha) {
					(x === void 0) && (x = 0);
					(y === void 0) && (y = 0);
					(width === void 0) && (width = 0);
					(height === void 0) && (height = 0);
					(alpha === void 0) && (alpha = 1);
					if (!tex) return;
					if (!tex.loaded) {
						tex.once(/*laya.events.Event.LOADED*/"loaded", this, function () {
							this.drawTexture(tex, x, y, width, height, m);
						});
						return;
					}
					if (!(tex.loaded && tex.bitmap && tex.source)) {
						return;
					}
					if (!width) width = tex.sourceWidth;
					if (!height) height = tex.sourceHeight;
					alpha = alpha < 0 ? 0 : (alpha > 1 ? 1 : alpha);
					width = width - tex.sourceWidth + tex.width;
					height = height - tex.sourceHeight + tex.height;
					if (width <= 0 || height <= 0) return;
					x += tex.offsetX;
					y += tex.offsetY;
					var uv = tex.uv, w = tex.bitmap.width, h = tex.bitmap.height;
					this.drawImageM(tex.bitmap.source, uv[0] * w, uv[1] * h, (uv[2] - uv[0]) * w, (uv[5] - uv[3]) * h, x, y, width, height, m, alpha);
					this._repaint();
				}
				from.fillTexture = function (tex, x, y, width, height, type, offset) {
					(width === void 0) && (width = 0);
					(height === void 0) && (height = 0);
					(type === void 0) && (type = "repeat");
					if (!tex) return;
					if (tex.loaded) {
						var ctxi = Render._context.ctx;
						var w = tex.bitmap.width, h = tex.bitmap.height, uv = tex.uv;
						var pat;
						if (tex.uv != Texture.DEF_UV) {
							pat = ctxi.createPattern(tex.bitmap.source, type, uv[0] * w, uv[1] * h, (uv[2] - uv[0]) * w, (uv[5] - uv[3]) * h);
						} else {
							pat = ctxi.createPattern(tex.bitmap.source, type);
						};
						var sX = 0, sY = 0;
						if (offset) {
							x += offset.x % tex.width;
							y += offset.y % tex.height;
							sX -= offset.x % tex.width;
							sY -= offset.y % tex.height;
						}
						this._fillImage(pat, x, y, sX, sY, width, height);
					}
				}
			}
		}

		Graphics._cache = [];
		return Graphics;
	})()


	/**
	*@private
	*Graphic bounds数据类
	*/
	//class laya.display.GraphicsBounds
	var GraphicsBounds = (function () {
		function GraphicsBounds() {
			/**@private */
			//this._temp=null;
			/**@private */
			//this._bounds=null;
			/**@private */
			//this._rstBoundPoints=null;
			/**@private */
			this._cacheBoundsType = false;
			/**@private */
			//this._graphics=null;
		}

		__class(GraphicsBounds, 'laya.display.GraphicsBounds');
		var __proto = GraphicsBounds.prototype;
		/**
		*销毁
		*/
		__proto.destroy = function () {
			this._graphics = null;
			this._temp = null;
			this._rstBoundPoints = null;
			this._bounds = null;
		}

		/**
		*重置数据
		*/
		__proto.reset = function () {
			this._temp && (this._temp.length = 0);
		}

		/**
		*获取位置及宽高信息矩阵(比较耗CPU，频繁使用会造成卡顿，尽量少用)。
		*@param realSize （可选）使用图片的真实大小，默认为false
		*@return 位置与宽高组成的 一个 Rectangle 对象。
		*/
		__proto.getBounds = function (realSize) {
			(realSize === void 0) && (realSize = false);
			if (!this._bounds || !this._temp || this._temp.length < 1 || realSize != this._cacheBoundsType) {
				this._bounds = Rectangle._getWrapRec(this.getBoundPoints(realSize), this._bounds)
			}
			this._cacheBoundsType = realSize;
			return this._bounds;
		}

		/**
		*@private
		*@param realSize （可选）使用图片的真实大小，默认为false
		*获取端点列表。
		*/
		__proto.getBoundPoints = function (realSize) {
			(realSize === void 0) && (realSize = false);
			if (!this._temp || this._temp.length < 1 || realSize != this._cacheBoundsType)
				this._temp = this._getCmdPoints(realSize);
			this._cacheBoundsType = realSize;
			return this._rstBoundPoints = Utils.copyArray(this._rstBoundPoints, this._temp);
		}

		__proto._getCmdPoints = function (realSize) {
			(realSize === void 0) && (realSize = false);
			var context = Render._context;
			var cmds = this._graphics.cmds;
			var rst;
			rst = this._temp || (this._temp = []);
			rst.length = 0;
			if (!cmds && this._graphics._one != null) {
				GraphicsBounds._tempCmds.length = 0;
				GraphicsBounds._tempCmds.push(this._graphics._one);
				cmds = GraphicsBounds._tempCmds;
			}
			if (!cmds)
				return rst;
			var matrixs;
			matrixs = GraphicsBounds._tempMatrixArrays;
			matrixs.length = 0;
			var tMatrix = GraphicsBounds._initMatrix;
			tMatrix.identity();
			var tempMatrix = GraphicsBounds._tempMatrix;
			var cmd;
			var tex;
			var wRate = NaN;
			var hRate = NaN;
			var oWidth = NaN;
			var oHeight = NaN;
			var offX = NaN;
			var offY = NaN;
			for (var i = 0, n = cmds.length; i < n; i++) {
				cmd = cmds[i];
				if (!cmd.callee) continue;
				switch (cmd.callee) {
					case context._save:
					case 7:
						matrixs.push(tMatrix);
						tMatrix = tMatrix.clone();
						break;
					case context._restore:
					case 8:
						tMatrix = matrixs.pop();
						break;
					case context._scale:
					case 5:
						tempMatrix.identity();
						tempMatrix.translate(-cmd[2], -cmd[3]);
						tempMatrix.scale(cmd[0], cmd[1]);
						tempMatrix.translate(cmd[2], cmd[3]);
						this._switchMatrix(tMatrix, tempMatrix);
						break;
					case context._rotate:
					case 3:
						tempMatrix.identity();
						tempMatrix.translate(-cmd[1], -cmd[2]);
						tempMatrix.rotate(cmd[0]);
						tempMatrix.translate(cmd[1], cmd[2]);
						this._switchMatrix(tMatrix, tempMatrix);
						break;
					case context._translate:
					case 6:
						tempMatrix.identity();
						tempMatrix.translate(cmd[0], cmd[1]);
						this._switchMatrix(tMatrix, tempMatrix);
						break;
					case context._transform:
					case 4:
						tempMatrix.identity();
						tempMatrix.translate(-cmd[1], -cmd[2]);
						tempMatrix.concat(cmd[0]);
						tempMatrix.translate(cmd[1], cmd[2]);
						this._switchMatrix(tMatrix, tempMatrix);
						break;
					case 16:
					case 24:
						GraphicsBounds._addPointArrToRst(rst, Rectangle._getBoundPointS(cmd[0], cmd[1], cmd[2], cmd[3]), tMatrix);
						break;
					case 17:
						tMatrix.copyTo(tempMatrix);
						tempMatrix.concat(cmd[4]);
						GraphicsBounds._addPointArrToRst(rst, Rectangle._getBoundPointS(cmd[0], cmd[1], cmd[2], cmd[3]), tempMatrix);
						break;
					case context._drawTexture:
						tex = cmd[0];
						if (realSize) {
							if (cmd[3] && cmd[4]) {
								GraphicsBounds._addPointArrToRst(rst, Rectangle._getBoundPointS(cmd[1], cmd[2], cmd[3], cmd[4]), tMatrix);
							} else {
								tex = cmd[0];
								GraphicsBounds._addPointArrToRst(rst, Rectangle._getBoundPointS(cmd[1], cmd[2], tex.width, tex.height), tMatrix);
							}
						} else {
							wRate = (cmd[3] || tex.sourceWidth) / tex.width;
							hRate = (cmd[4] || tex.sourceHeight) / tex.height;
							oWidth = wRate * tex.sourceWidth;
							oHeight = hRate * tex.sourceHeight;
							offX = tex.offsetX > 0 ? tex.offsetX : 0;
							offY = tex.offsetY > 0 ? tex.offsetY : 0;
							offX *= wRate;
							offY *= hRate;
							GraphicsBounds._addPointArrToRst(rst, Rectangle._getBoundPointS(cmd[1] - offX, cmd[2] - offY, oWidth, oHeight), tMatrix);
						}
						break;
					case context._fillTexture:
						if (cmd[3] && cmd[4]) {
							GraphicsBounds._addPointArrToRst(rst, Rectangle._getBoundPointS(cmd[1], cmd[2], cmd[3], cmd[4]), tMatrix);
						} else {
							tex = cmd[0];
							GraphicsBounds._addPointArrToRst(rst, Rectangle._getBoundPointS(cmd[1], cmd[2], tex.width, tex.height), tMatrix);
						}
						break;
					case context._drawTextureWithTransform: ;
						var drawMatrix;
						if (cmd[5]) {
							tMatrix.copyTo(tempMatrix);
							tempMatrix.concat(cmd[5]);
							drawMatrix = tempMatrix;
						} else {
							drawMatrix = tMatrix;
						}
						if (realSize) {
							if (cmd[3] && cmd[4]) {
								GraphicsBounds._addPointArrToRst(rst, Rectangle._getBoundPointS(cmd[1], cmd[2], cmd[3], cmd[4]), drawMatrix);
							} else {
								tex = cmd[0];
								GraphicsBounds._addPointArrToRst(rst, Rectangle._getBoundPointS(cmd[1], cmd[2], tex.width, tex.height), drawMatrix);
							}
						} else {
							tex = cmd[0];
							wRate = (cmd[3] || tex.sourceWidth) / tex.width;
							hRate = (cmd[4] || tex.sourceHeight) / tex.height;
							oWidth = wRate * tex.sourceWidth;
							oHeight = hRate * tex.sourceHeight;
							offX = tex.offsetX > 0 ? tex.offsetX : 0;
							offY = tex.offsetY > 0 ? tex.offsetY : 0;
							offX *= wRate;
							offY *= hRate;
							GraphicsBounds._addPointArrToRst(rst, Rectangle._getBoundPointS(cmd[1] - offX, cmd[2] - offY, oWidth, oHeight), drawMatrix);
						}
						break;
					case context._drawRect:
					case 13:
						GraphicsBounds._addPointArrToRst(rst, Rectangle._getBoundPointS(cmd[0], cmd[1], cmd[2], cmd[3]), tMatrix);
						break;
					case context._drawCircle:
					case context._fillCircle:
					case 14:
						GraphicsBounds._addPointArrToRst(rst, Rectangle._getBoundPointS(cmd[0] - cmd[2], cmd[1] - cmd[2], cmd[2] + cmd[2], cmd[2] + cmd[2]), tMatrix);
						break;
					case context._drawLine:
					case 20:
						GraphicsBounds._tempPoints.length = 0;
						var lineWidth = NaN;
						lineWidth = cmd[5] * 0.5;
						if (cmd[0] == cmd[2]) {
							GraphicsBounds._tempPoints.push(cmd[0] + lineWidth, cmd[1], cmd[2] + lineWidth, cmd[3], cmd[0] - lineWidth, cmd[1], cmd[2] - lineWidth, cmd[3]);
						} else if (cmd[1] == cmd[3]) {
							GraphicsBounds._tempPoints.push(cmd[0], cmd[1] + lineWidth, cmd[2], cmd[3] + lineWidth, cmd[0], cmd[1] - lineWidth, cmd[2], cmd[3] - lineWidth);
						} else {
							GraphicsBounds._tempPoints.push(cmd[0], cmd[1], cmd[2], cmd[3]);
						}
						GraphicsBounds._addPointArrToRst(rst, GraphicsBounds._tempPoints, tMatrix);
						break;
					case context._drawCurves:
					case 22:
						GraphicsBounds._addPointArrToRst(rst, Bezier.I.getBezierPoints(cmd[2]), tMatrix, cmd[0], cmd[1]);
						break;
					case context._drawPoly:
					case context._drawLines:
					case 18:
						GraphicsBounds._addPointArrToRst(rst, cmd[2], tMatrix, cmd[0], cmd[1]);
						break;
					case context._drawPath:
					case 19:
						GraphicsBounds._addPointArrToRst(rst, this._getPathPoints(cmd[2]), tMatrix, cmd[0], cmd[1]);
						break;
					case context._drawPie:
					case 15:
						GraphicsBounds._addPointArrToRst(rst, this._getPiePoints(cmd[0], cmd[1], cmd[2], cmd[3], cmd[4]), tMatrix);
						break;
				}
			}
			if (rst.length > 200) {
				rst = Utils.copyArray(rst, Rectangle._getWrapRec(rst)._getBoundPoints());
			} else if (rst.length > 8)
				rst = GrahamScan.scanPList(rst);
			return rst;
		}

		__proto._switchMatrix = function (tMatix, tempMatrix) {
			tempMatrix.concat(tMatix);
			tempMatrix.copyTo(tMatix);
		}

		__proto._getPiePoints = function (x, y, radius, startAngle, endAngle) {
			var rst = GraphicsBounds._tempPoints;
			GraphicsBounds._tempPoints.length = 0;
			rst.push(x, y);
			var delta = (endAngle - startAngle) % (2 * Math.PI);
			var segnum = 10;
			var step = delta / segnum;
			var i = NaN;
			var angle = startAngle;
			for (i = 0; i <= segnum; i++) {
				rst.push(x + radius * Math.cos(angle), y + radius * Math.sin(angle));
				angle += step;
			}
			return rst;
		}

		__proto._getPathPoints = function (paths) {
			var i = 0, len = 0;
			var rst = GraphicsBounds._tempPoints;
			rst.length = 0;
			len = paths.length;
			var tCMD;
			for (i = 0; i < len; i++) {
				tCMD = paths[i];
				if (tCMD.length > 1) {
					rst.push(tCMD[1], tCMD[2]);
					if (tCMD.length > 3) {
						rst.push(tCMD[3], tCMD[4]);
					}
				}
			}
			return rst;
		}

		GraphicsBounds._addPointArrToRst = function (rst, points, matrix, dx, dy) {
			(dx === void 0) && (dx = 0);
			(dy === void 0) && (dy = 0);
			var i = 0, len = 0;
			len = points.length;
			for (i = 0; i < len; i += 2) {
				GraphicsBounds._addPointToRst(rst, points[i] + dx, points[i + 1] + dy, matrix);
			}
		}

		GraphicsBounds._addPointToRst = function (rst, x, y, matrix) {
			var _tempPoint = Point.TEMP;
			_tempPoint.setTo(x ? x : 0, y ? y : 0);
			matrix.transformPoint(_tempPoint);
			rst.push(_tempPoint.x, _tempPoint.y);
		}

		GraphicsBounds._tempPoints = [];
		GraphicsBounds._tempMatrixArrays = [];
		GraphicsBounds._tempCmds = [];
		__static(GraphicsBounds,
			['_tempMatrix', function () { return this._tempMatrix = new Matrix(); }, '_initMatrix', function () { return this._initMatrix = new Matrix(); }
			]);
		return GraphicsBounds;
	})()


	/**
	*<code>Event</code> 是事件类型的集合。一般当发生事件时，<code>Event</code> 对象将作为参数传递给事件侦听器。
	*/
	//class laya.events.Event
	var Event = (function () {
		function Event() {
			/**事件类型。*/
			//this.type=null;
			/**原生浏览器事件。*/
			//this.nativeEvent=null;
			/**事件目标触发对象。*/
			//this.target=null;
			/**事件当前冒泡对象。*/
			//this.currentTarget=null;
			/**@private */
			//this._stoped=false;
			/**分配给触摸点的唯一标识号（作为 int）。*/
			//this.touchId=0;
			/**键盘值*/
			//this.keyCode=0;
			/**滚轮滑动增量*/
			//this.delta=0;
		}

		__class(Event, 'laya.events.Event');
		var __proto = Event.prototype;
		/**
		*设置事件数据。
		*@param type 事件类型。
		*@param currentTarget 事件目标触发对象。
		*@param target 事件当前冒泡对象。
		*@return 返回当前 Event 对象。
		*/
		__proto.setTo = function (type, currentTarget, target) {
			this.type = type;
			this.currentTarget = currentTarget;
			this.target = target;
			return this;
		}

		/**
		*阻止对事件流中当前节点的后续节点中的所有事件侦听器进行处理。此方法不会影响当前节点 (currentTarget)中的任何事件侦听器。
		*/
		__proto.stopPropagation = function () {
			this._stoped = true;
		}

		/**鼠标在 Stage 上的 Y 轴坐标*/
		__getset(0, __proto, 'stageY', function () {
			return Laya.stage.mouseY;
		});

		/**
		*包含按下或释放的键的字符代码值。字符代码值为英文键盘值。
		*/
		__getset(0, __proto, 'charCode', function () {
			return this.nativeEvent.charCode;
		});

		/**
		*触摸点列表。
		*/
		__getset(0, __proto, 'touches', function () {
			var arr = this.nativeEvent.touches;
			if (arr) {
				var stage = Laya.stage;
				for (var i = 0, n = arr.length; i < n; i++) {
					var e = arr[i];
					var point = Point.TEMP;
					point.setTo(e.clientX, e.clientY);
					stage._canvasTransform.invertTransformPoint(point);
					stage.transform.invertTransformPoint(point);
					e.stageX = point.x;
					e.stageY = point.y;
				}
			}
			return arr;
		});

		/**
		*表示键在键盘上的位置。这对于区分在键盘上多次出现的键非常有用。<br>
		*例如，您可以根据此属性的值来区分左 Shift 键和右 Shift 键：左 Shift 键的值为 KeyLocation.LEFT，右 Shift 键的值为 KeyLocation.RIGHT。另一个示例是区分标准键盘 (KeyLocation.STANDARD)与数字键盘 (KeyLocation.NUM_PAD)上按下的数字键。
		*/
		__getset(0, __proto, 'keyLocation', function () {
			return this.nativeEvent.keyLocation;
		});

		/**
		*表示 Ctrl 键是处于活动状态 (true)还是非活动状态 (false)。
		*/
		__getset(0, __proto, 'ctrlKey', function () {
			return this.nativeEvent.ctrlKey;
		});

		/**
		*表示 Alt 键是处于活动状态 (true)还是非活动状态 (false)。
		*/
		__getset(0, __proto, 'altKey', function () {
			return this.nativeEvent.altKey;
		});

		/**
		*表示 Shift 键是处于活动状态 (true)还是非活动状态 (false)。
		*/
		__getset(0, __proto, 'shiftKey', function () {
			return this.nativeEvent.shiftKey;
		});

		/**鼠标在 Stage 上的 X 轴坐标*/
		__getset(0, __proto, 'stageX', function () {
			return Laya.stage.mouseX;
		});

		Event.EMPTY = new Event();
		Event.MOUSE_DOWN = "mousedown";
		Event.MOUSE_UP = "mouseup";
		Event.CLICK = "click";
		Event.RIGHT_MOUSE_DOWN = "rightmousedown";
		Event.RIGHT_MOUSE_UP = "rightmouseup";
		Event.RIGHT_CLICK = "rightclick";
		Event.MOUSE_MOVE = "mousemove";
		Event.MOUSE_OVER = "mouseover";
		Event.MOUSE_OUT = "mouseout";
		Event.MOUSE_WHEEL = "mousewheel";
		Event.ROLL_OVER = "mouseover";
		Event.ROLL_OUT = "mouseout";
		Event.DOUBLE_CLICK = "doubleclick";
		Event.CHANGE = "change";
		Event.CHANGED = "changed";
		Event.RESIZE = "resize";
		Event.ADDED = "added";
		Event.REMOVED = "removed";
		Event.DISPLAY = "display";
		Event.UNDISPLAY = "undisplay";
		Event.ERROR = "error";
		Event.COMPLETE = "complete";
		Event.LOADED = "loaded";
		Event.PROGRESS = "progress";
		Event.INPUT = "input";
		Event.RENDER = "render";
		Event.OPEN = "open";
		Event.MESSAGE = "message";
		Event.CLOSE = "close";
		Event.KEY_DOWN = "keydown";
		Event.KEY_PRESS = "keypress";
		Event.KEY_UP = "keyup";
		Event.FRAME = "enterframe";
		Event.DRAG_START = "dragstart";
		Event.DRAG_MOVE = "dragmove";
		Event.DRAG_END = "dragend";
		Event.ENTER = "enter";
		Event.SELECT = "select";
		Event.BLUR = "blur";
		Event.FOCUS = "focus";
		Event.VISIBILITY_CHANGE = "visibilitychange";
		Event.FOCUS_CHANGE = "focuschange";
		Event.PLAYED = "played";
		Event.PAUSED = "paused";
		Event.STOPPED = "stopped";
		Event.START = "start";
		Event.END = "end";
		Event.ENABLE_CHANGED = "enablechanged";
		Event.ACTIVE_IN_HIERARCHY_CHANGED = "activeinhierarchychanged";
		Event.COMPONENT_ADDED = "componentadded";
		Event.COMPONENT_REMOVED = "componentremoved";
		Event.LAYER_CHANGED = "layerchanged";
		Event.HIERARCHY_LOADED = "hierarchyloaded";
		Event.RECOVERED = "recovered";
		Event.RELEASED = "released";
		Event.LINK = "link";
		Event.LABEL = "label";
		Event.FULL_SCREEN_CHANGE = "fullscreenchange";
		Event.DEVICE_LOST = "devicelost";
		Event.MESH_CHANGED = "meshchanged";
		Event.MATERIAL_CHANGED = "materialchanged";
		Event.WORLDMATRIX_NEEDCHANGE = "worldmatrixneedchanged";
		Event.ANIMATION_CHANGED = "animationchanged";
		Event.TRIGGER_ENTER = "triggerenter";
		Event.TRIGGER_STAY = "triggerstay";
		Event.TRIGGER_EXIT = "triggerexit";
		Event.TRAIL_FILTER_CHANGE = "trailfilterchange";
		Event.DOMINO_FILTER_CHANGE = "dominofilterchange";
		return Event;
	})()


	/**
	*<code>Keyboard</code> 类的属性是一些常数，这些常数表示控制游戏时最常用的键。
	*/
	//class laya.events.Keyboard
	var Keyboard = (function () {
		function Keyboard() { }
		__class(Keyboard, 'laya.events.Keyboard');
		Keyboard.NUMBER_0 = 48;
		Keyboard.NUMBER_1 = 49;
		Keyboard.NUMBER_2 = 50;
		Keyboard.NUMBER_3 = 51;
		Keyboard.NUMBER_4 = 52;
		Keyboard.NUMBER_5 = 53;
		Keyboard.NUMBER_6 = 54;
		Keyboard.NUMBER_7 = 55;
		Keyboard.NUMBER_8 = 56;
		Keyboard.NUMBER_9 = 57;
		Keyboard.A = 65;
		Keyboard.B = 66;
		Keyboard.C = 67;
		Keyboard.D = 68;
		Keyboard.E = 69;
		Keyboard.F = 70;
		Keyboard.G = 71;
		Keyboard.H = 72;
		Keyboard.I = 73;
		Keyboard.J = 74;
		Keyboard.K = 75;
		Keyboard.L = 76;
		Keyboard.M = 77;
		Keyboard.N = 78;
		Keyboard.O = 79;
		Keyboard.P = 80;
		Keyboard.Q = 81;
		Keyboard.R = 82;
		Keyboard.S = 83;
		Keyboard.T = 84;
		Keyboard.U = 85;
		Keyboard.V = 86;
		Keyboard.W = 87;
		Keyboard.X = 88;
		Keyboard.Y = 89;
		Keyboard.Z = 90;
		Keyboard.F1 = 112;
		Keyboard.F2 = 113;
		Keyboard.F3 = 114;
		Keyboard.F4 = 115;
		Keyboard.F5 = 116;
		Keyboard.F6 = 117;
		Keyboard.F7 = 118;
		Keyboard.F8 = 119;
		Keyboard.F9 = 120;
		Keyboard.F10 = 121;
		Keyboard.F11 = 122;
		Keyboard.F12 = 123;
		Keyboard.F13 = 124;
		Keyboard.F14 = 125;
		Keyboard.F15 = 126;
		Keyboard.NUMPAD = 21;
		Keyboard.NUMPAD_0 = 96;
		Keyboard.NUMPAD_1 = 97;
		Keyboard.NUMPAD_2 = 98;
		Keyboard.NUMPAD_3 = 99;
		Keyboard.NUMPAD_4 = 100;
		Keyboard.NUMPAD_5 = 101;
		Keyboard.NUMPAD_6 = 102;
		Keyboard.NUMPAD_7 = 103;
		Keyboard.NUMPAD_8 = 104;
		Keyboard.NUMPAD_9 = 105;
		Keyboard.NUMPAD_ADD = 107;
		Keyboard.NUMPAD_DECIMAL = 110;
		Keyboard.NUMPAD_DIVIDE = 111;
		Keyboard.NUMPAD_ENTER = 108;
		Keyboard.NUMPAD_MULTIPLY = 106;
		Keyboard.NUMPAD_SUBTRACT = 109;
		Keyboard.SEMICOLON = 186;
		Keyboard.EQUAL = 187;
		Keyboard.COMMA = 188;
		Keyboard.MINUS = 189;
		Keyboard.PERIOD = 190;
		Keyboard.SLASH = 191;
		Keyboard.BACKQUOTE = 192;
		Keyboard.LEFTBRACKET = 219;
		Keyboard.BACKSLASH = 220;
		Keyboard.RIGHTBRACKET = 221;
		Keyboard.QUOTE = 222;
		Keyboard.ALTERNATE = 18;
		Keyboard.BACKSPACE = 8;
		Keyboard.CAPS_LOCK = 20;
		Keyboard.COMMAND = 15;
		Keyboard.CONTROL = 17;
		Keyboard.DELETE = 46;
		Keyboard.ENTER = 13;
		Keyboard.ESCAPE = 27;
		Keyboard.PAGE_UP = 33;
		Keyboard.PAGE_DOWN = 34;
		Keyboard.END = 35;
		Keyboard.HOME = 36;
		Keyboard.LEFT = 37;
		Keyboard.UP = 38;
		Keyboard.RIGHT = 39;
		Keyboard.DOWN = 40;
		Keyboard.SHIFT = 16;
		Keyboard.SPACE = 32;
		Keyboard.TAB = 9;
		Keyboard.INSERT = 45;
		return Keyboard;
	})()


	/**
	*<p><code>KeyBoardManager</code> 是键盘事件管理类。该类从浏览器中接收键盘事件，并派发该事件。</p>
	*<p>派发事件时若 Stage.focus 为空则只从 Stage 上派发该事件，否则将从 Stage.focus 对象开始一直冒泡派发该事件。所以在 Laya.stage 上监听键盘事件一定能够收到，如果在其他地方监听，则必须处在Stage.focus的冒泡链上才能收到该事件。</p>
	*<p>用户可以通过代码 Laya.stage.focus=someNode 的方式来设置focus对象。</p>
	*<p>用户可统一的根据事件对象中 e.keyCode 来判断按键类型，该属性兼容了不同浏览器的实现。</p>
	*/
	//class laya.events.KeyBoardManager
	var KeyBoardManager = (function () {
		function KeyBoardManager() { }
		__class(KeyBoardManager, 'laya.events.KeyBoardManager');
		KeyBoardManager.__init__ = function () {
			KeyBoardManager._addEvent("keydown");
			KeyBoardManager._addEvent("keypress");
			KeyBoardManager._addEvent("keyup");
		}

		KeyBoardManager._addEvent = function (type) {
			Browser.document.addEventListener(type, function (e) {
				laya.events.KeyBoardManager._dispatch(e, type);
			}, true);
		}

		KeyBoardManager._dispatch = function (e, type) {
			if (!KeyBoardManager.enabled) return;
			KeyBoardManager._event._stoped = false;
			KeyBoardManager._event.nativeEvent = e;
			KeyBoardManager._event.keyCode = e.keyCode || e.which || e.charCode;
			if (type === "keydown") KeyBoardManager._pressKeys[KeyBoardManager._event.keyCode] = true;
			else if (type === "keyup") KeyBoardManager._pressKeys[KeyBoardManager._event.keyCode] = null;
			var target = (Laya.stage.focus && (Laya.stage.focus.event != null) && Laya.stage.focus.displayedInStage) ? Laya.stage.focus : Laya.stage;
			var ct = target;
			while (ct) {
				ct.event(type, KeyBoardManager._event.setTo(type, ct, target));
				ct = ct.parent;
			}
		}

		KeyBoardManager.hasKeyDown = function (key) {
			return KeyBoardManager._pressKeys[key];
		}

		KeyBoardManager._pressKeys = {};
		KeyBoardManager.enabled = true;
		__static(KeyBoardManager,
			['_event', function () { return this._event = new Event(); }
			]);
		return KeyBoardManager;
	})()


	/**
	*<p><code>KeyLocation</code> 类包含表示在键盘或类似键盘的输入设备上按键位置的常量。</p>
	*<p><code>KeyLocation</code> 常数用在键盘事件对象的 <code>keyLocation </code>属性中。</p>
	*/
	//class laya.events.KeyLocation
	var KeyLocation = (function () {
		function KeyLocation() { }
		__class(KeyLocation, 'laya.events.KeyLocation');
		KeyLocation.STANDARD = 0;
		KeyLocation.LEFT = 1;
		KeyLocation.RIGHT = 2;
		KeyLocation.NUM_PAD = 3;
		return KeyLocation;
	})()


	/**
	*<p><code>MouseManager</code> 是鼠标、触摸交互管理器。</p>
	*<p>鼠标事件流包括捕获阶段、目标阶段、冒泡阶段。<br/>
	*捕获阶段：此阶段引擎会从stage开始递归检测stage及其子对象，直到找到命中的目标对象或者未命中任何对象；<br/>
	*目标阶段：找到命中的目标对象；<br/>
	*冒泡阶段：事件离开目标对象，按节点层级向上逐层通知，直到到达舞台的过程。</p>
	*/
	//class laya.events.MouseManager
	var MouseManager = (function () {
		function MouseManager() {
			/**canvas 上的鼠标X坐标。*/
			this.mouseX = 0;
			/**canvas 上的鼠标Y坐标。*/
			this.mouseY = 0;
			/**是否禁用除 stage 以外的鼠标事件检测。*/
			this.disableMouseEvent = false;
			/**鼠标按下的时间。单位为毫秒。*/
			this.mouseDownTime = 0;
			/**鼠标移动精度。*/
			this.mouseMoveAccuracy = 2;
			this._stage = null;
			this._target = null;
			this._lastMoveTimer = 0;
			this._isLeftMouse = false;
			this._eventList = [];
			this._touchIDs = {};
			this._id = 1;
			this._tTouchID = 0;
			this._event = new Event();
			this._matrix = new Matrix();
			this._point = new Point();
			this._rect = new Rectangle();
			this._prePoint = new Point();
			this._curTouchID = NaN;
		}

		__class(MouseManager, 'laya.events.MouseManager');
		var __proto = MouseManager.prototype;
		/**
		*@private
		*初始化。
		*/
		__proto.__init__ = function (stage, canvas) {
			var _$this = this;
			this._stage = stage;
			var _this = this;
			var list = this._eventList;
			canvas.oncontextmenu = function (e) {
				if (MouseManager.enabled) return false;
			}
			canvas.addEventListener('mousedown', function (e) {
				if (MouseManager.enabled) {
					if (!Browser.onIE) e.preventDefault();
					list.push(e);
					_this.mouseDownTime = Browser.now();
				}
			});
			canvas.addEventListener('mouseup', function (e) {
				if (MouseManager.enabled) {
					e.preventDefault();
					list.push(e);
					_this.mouseDownTime = -Browser.now();
				}
			}, true);
			canvas.addEventListener('mousemove', function (e) {
				if (MouseManager.enabled) {
					e.preventDefault();
					var now = Browser.now();
					if (now - _this._lastMoveTimer < 10) return;
					_this._lastMoveTimer = now;
					list.push(e);
				}
			}, true);
			canvas.addEventListener("mouseout", function (e) {
				if (MouseManager.enabled) list.push(e);
			})
			canvas.addEventListener("mouseover", function (e) {
				if (MouseManager.enabled) list.push(e);
			})
			canvas.addEventListener("touchstart", function (e) {
				if (MouseManager.enabled) {
					list.push(e);
					if (!MouseManager._isFirstTouch && !Input.isInputting) e.preventDefault();
					_this.mouseDownTime = Browser.now();
				}
			});
			canvas.addEventListener("touchend", function (e) {
				if (MouseManager.enabled) {
					if (!MouseManager._isFirstTouch && !Input.isInputting) e.preventDefault();
					MouseManager._isFirstTouch = false;
					list.push(e);
					_this.mouseDownTime = -Browser.now();
				} else {
					_$this._curTouchID = NaN;
				}
			}, true);
			canvas.addEventListener("touchmove", function (e) {
				if (MouseManager.enabled) {
					e.preventDefault();
					list.push(e);
				}
			}, true);
			canvas.addEventListener("touchcancel", function (e) {
				if (MouseManager.enabled) {
					e.preventDefault();
					list.push(e);
				} else {
					_$this._curTouchID = NaN;
				}
			}, true);
			canvas.addEventListener('mousewheel', function (e) {
				if (MouseManager.enabled) list.push(e);
			});
			canvas.addEventListener('DOMMouseScroll', function (e) {
				if (MouseManager.enabled) list.push(e);
			});
		}

		__proto.initEvent = function (e, nativeEvent) {
			var _this = this;
			_this._event._stoped = false;
			_this._event.nativeEvent = nativeEvent || e;
			_this._target = null;
			this._point.setTo(e.pageX || e.clientX, e.pageY || e.clientY);
			this._stage._canvasTransform.invertTransformPoint(this._point);
			_this.mouseX = this._point.x;
			_this.mouseY = this._point.y;
			_this._event.touchId = e.identifier || 0;
			this._tTouchID = _this._event.touchId;
			var evt;
			evt = TouchManager.I._event;
			evt._stoped = false;
			evt.nativeEvent = _this._event.nativeEvent;
			evt.touchId = _this._event.touchId;
		}

		__proto.checkMouseWheel = function (e) {

			this._event.delta = e.wheelDelta ? e.wheelDelta * 0.025 : -e.detail;
			var _lastOvers = TouchManager.I.getLastOvers();
			for (var i = 0, n = _lastOvers.length; i < n; i++) {
				var ele = _lastOvers[i];
				ele.event(/*laya.events.Event.MOUSE_WHEEL*/"mousewheel", this._event.setTo(/*laya.events.Event.MOUSE_WHEEL*/"mousewheel", ele, this._target));
			}
		}

		// _stage.event(Event.MOUSE_WHEEL,_event.setTo(Event.MOUSE_WHEEL,_stage,_target));
		__proto.onMouseMove = function (ele) {
			TouchManager.I.onMouseMove(ele, this._tTouchID);
		}

		__proto.onMouseDown = function (ele) {
			if (Input.isInputting && Laya.stage.focus && Laya.stage.focus["focus"] && !Laya.stage.focus.contains(this._target)) {
				var pre_input = Laya.stage.focus['_tf'] || Laya.stage.focus;
				var new_input = ele['_tf'] || ele;
				if ((new_input instanceof laya.display.Input) && new_input.multiline == pre_input.multiline)
					pre_input['_focusOut']();
				else
					pre_input.focus = false;
			}
			TouchManager.I.onMouseDown(ele, this._tTouchID, this._isLeftMouse);
		}

		__proto.onMouseUp = function (ele) {
			TouchManager.I.onMouseUp(ele, this._tTouchID, this._isLeftMouse);
		}

		__proto.check = function (sp, mouseX, mouseY, callBack) {
			this._point.setTo(mouseX, mouseY);
			sp.fromParentPoint(this._point);
			mouseX = this._point.x;
			mouseY = this._point.y;
			var scrollRect = sp.scrollRect;
			if (scrollRect) {
				this._rect.setTo(scrollRect.x, scrollRect.y, scrollRect.width, scrollRect.height);
				if (!this._rect.contains(mouseX, mouseY)) return false;
			}
			if (!this.disableMouseEvent) {
				if (sp.hitTestPrior && !sp.mouseThrough && !this.hitTest(sp, mouseX, mouseY)) {
					return false;
				}
				for (var i = sp._childs.length - 1; i > -1; i--) {
					var child = sp._childs[i];
					if (!child.destroyed && child.mouseEnabled && child.visible) {
						if (this.check(child, mouseX, mouseY, callBack)) return true;
					}
				}
			};
			var isHit = (sp.hitTestPrior && !sp.mouseThrough && !this.disableMouseEvent) ? true : this.hitTest(sp, mouseX, mouseY);
			if (isHit) {
				this._target = sp;
				callBack.call(this, sp);
			} else if (callBack === this.onMouseUp && sp === this._stage) {
				this._target = this._stage;
				callBack.call(this, this._target);
			}
			return isHit;
		}

		__proto.hitTest = function (sp, mouseX, mouseY) {
			var isHit = false;
			if (sp.scrollRect) {
				mouseX -= sp.scrollRect.x;
				mouseY -= sp.scrollRect.y;
			}
			if ((sp.hitArea instanceof laya.utils.HitArea)) {
				return sp.hitArea.isHit(mouseX, mouseY);
			}
			if (sp.width > 0 && sp.height > 0 || sp.mouseThrough || sp.hitArea) {
				if (!sp.mouseThrough) {
					var hitRect = this._rect;
					if (sp.hitArea) hitRect = sp.hitArea;
					else hitRect.setTo(0, 0, sp.width, sp.height);
					isHit = hitRect.contains(mouseX, mouseY);
				} else {
					isHit = sp.getGraphicBounds().contains(mouseX, mouseY);
				}
			}
			return isHit;
		}

		/**
		*执行事件处理。
		*/
		__proto.runEvent = function () {
			var len = this._eventList.length;
			if (!len) return;
			var _this = this;
			var i = 0, j = 0, n = 0, touch;
			while (i < len) {
				var evt = this._eventList[i];
				if (evt.type !== 'mousemove') this._prePoint.x = this._prePoint.y = -1000000;
				switch (evt.type) {
					case 'mousedown':
						this._touchIDs[0] = this._id++;
						if (!MouseManager._isTouchRespond) {
							_this._isLeftMouse = evt.button === 0;
							_this.initEvent(evt);
							_this.check(_this._stage, _this.mouseX, _this.mouseY, _this.onMouseDown);
						} else
							MouseManager._isTouchRespond = false;
						break;
					case 'mouseup':
						_this._isLeftMouse = evt.button === 0;
						_this.initEvent(evt);
						_this.check(_this._stage, _this.mouseX, _this.mouseY, _this.onMouseUp);
						break;
					case 'mousemove':
						if ((Math.abs(this._prePoint.x - evt.clientX) + Math.abs(this._prePoint.y - evt.clientY)) >= this.mouseMoveAccuracy) {
							this._prePoint.x = evt.clientX;
							this._prePoint.y = evt.clientY;
							_this.initEvent(evt);
							_this.check(_this._stage, _this.mouseX, _this.mouseY, _this.onMouseMove);
						}
						break;
					case "touchstart":
						MouseManager._isTouchRespond = true;
						_this._isLeftMouse = true;
						var touches = evt.changedTouches;
						for (j = 0, n = touches.length; j < n; j++) {
							touch = touches[j];
							if (MouseManager.multiTouchEnabled || isNaN(this._curTouchID)) {
								this._curTouchID = touch.identifier;
								if (this._id % 200 === 0) this._touchIDs = {};
								this._touchIDs[touch.identifier] = this._id++;
								_this.initEvent(touch, evt);
								_this.check(_this._stage, _this.mouseX, _this.mouseY, _this.onMouseDown);
							}
						}
						break;
					case "touchend":
					case "touchcancel":
						MouseManager._isTouchRespond = true;
						_this._isLeftMouse = true;
						var touchends = evt.changedTouches;
						for (j = 0, n = touchends.length; j < n; j++) {
							touch = touchends[j];
							if (MouseManager.multiTouchEnabled || touch.identifier == this._curTouchID) {
								this._curTouchID = NaN;
								_this.initEvent(touch, evt);
								var isChecked = false;
								isChecked = _this.check(_this._stage, _this.mouseX, _this.mouseY, _this.onMouseUp);
								if (!isChecked) {
									_this.onMouseUp(null);
								}
							}
						}
						break;
					case "touchmove": ;
						var touchemoves = evt.changedTouches;
						for (j = 0, n = touchemoves.length; j < n; j++) {
							touch = touchemoves[j];
							if (MouseManager.multiTouchEnabled || touch.identifier == this._curTouchID) {
								_this.initEvent(touch, evt);
								_this.check(_this._stage, _this.mouseX, _this.mouseY, _this.onMouseMove);
							}
						}
						break;
					case "wheel":

					case "mousewheel":

					case "DOMMouseScroll":
						_this.checkMouseWheel(evt);
						break;
					case "mouseout":
						TouchManager.I.stageMouseOut();
						break;
					case "mouseover":
						_this._stage.event(/*laya.events.Event.MOUSE_OVER*/"mouseover", _this._event.setTo(/*laya.events.Event.MOUSE_OVER*/"mouseover", _this._stage, _this._stage));
						break;
				}
				i++;
			}
			this._eventList.length = 0;
		}

		MouseManager.enabled = true;
		MouseManager.multiTouchEnabled = true;
		MouseManager._isTouchRespond = false;
		MouseManager._isFirstTouch = true;
		__static(MouseManager,
			['instance', function () { return this.instance = new MouseManager(); }
			]);
		return MouseManager;
	})()


	/**
	*@private
	*Touch事件管理类，处理多点触控下的鼠标事件
	*/
	//class laya.events.TouchManager
	var TouchManager = (function () {
		function TouchManager() {
			/**
			*当前over的touch表
			*/
			this.preOvers = [];
			/**
			*当前down的touch表
			*/
			this.preDowns = [];
			this.preRightDowns = [];
			/**
			*是否启用
			*/
			this.enable = true;
			this._lastClickTime = 0;
			this._event = new Event();
		}

		__class(TouchManager, 'laya.events.TouchManager');
		var __proto = TouchManager.prototype;
		__proto._clearTempArrs = function () {
			TouchManager._oldArr.length = 0;
			TouchManager._newArr.length = 0;
			TouchManager._tEleArr.length = 0;
		}

		/**
		*从touch表里查找对应touchID的数据
		*@param touchID touch ID
		*@param arr touch表
		*@return
		*
		*/
		__proto.getTouchFromArr = function (touchID, arr) {
			var i = 0, len = 0;
			len = arr.length;
			var tTouchO;
			for (i = 0; i < len; i++) {
				tTouchO = arr[i];
				if (tTouchO.id == touchID) {
					return tTouchO;
				}
			}
			return null;
		}

		/**
		*从touch表里移除一个元素
		*@param touchID touch ID
		*@param arr touch表
		*
		*/
		__proto.removeTouchFromArr = function (touchID, arr) {
			var i = 0;
			for (i = arr.length - 1; i >= 0; i--) {
				if (arr[i].id == touchID) {
					arr.splice(i, 1);
				}
			}
		}

		/**
		*创建一个touch数据
		*@param ele 当前的根节点
		*@param touchID touchID
		*@return
		*
		*/
		__proto.createTouchO = function (ele, touchID) {
			var rst;
			rst = Pool.getItem("TouchData") || {};
			rst.id = touchID;
			rst.tar = ele;
			return rst;
		}

		/**
		*处理touchStart
		*@param ele 根节点
		*@param touchID touchID
		*@param isLeft （可选）是否为左键
		*/
		__proto.onMouseDown = function (ele, touchID, isLeft) {
			(isLeft === void 0) && (isLeft = false);
			if (!this.enable)
				return;
			var preO;
			var tO;
			var arrs;
			preO = this.getTouchFromArr(touchID, this.preOvers);
			arrs = this.getEles(ele, null, TouchManager._tEleArr);
			if (!preO) {
				tO = this.createTouchO(ele, touchID);
				this.preOvers.push(tO);
			} else {
				preO.tar = ele;
			}
			if (Browser.onMobile)
				this.sendEvents(arrs,/*laya.events.Event.MOUSE_OVER*/"mouseover", touchID);
			var preDowns;
			preDowns = isLeft ? this.preDowns : this.preRightDowns;
			preO = this.getTouchFromArr(touchID, preDowns);
			if (!preO) {
				tO = this.createTouchO(ele, touchID);
				preDowns.push(tO);
			} else {
				preO.tar = ele;
			}
			this.sendEvents(arrs, isLeft ? /*laya.events.Event.MOUSE_DOWN*/"mousedown" :/*laya.events.Event.RIGHT_MOUSE_DOWN*/"rightmousedown", touchID);
			this._clearTempArrs();
		}

		/**
		*派发事件。
		*@param eles 对象列表。
		*@param type 事件类型。
		*@param touchID （可选）touchID，默认为0。
		*/
		__proto.sendEvents = function (eles, type, touchID) {
			(touchID === void 0) && (touchID = 0);
			var i = 0, len = 0;
			len = eles.length;
			this._event._stoped = false;
			var _target;
			_target = eles[0];
			var tE;
			for (i = 0; i < len; i++) {
				tE = eles[i];
				if (tE.destroyed) return;
				tE.event(type, this._event.setTo(type, tE, _target));
				if (this._event._stoped)
					break;
			}
		}

		/**
		*获取对象列表。
		*@param start 起始节点。
		*@param end 结束节点。
		*@param rst 返回值。如果此值不为空，则将其赋值为计算结果，从而避免创建新数组；如果此值为空，则创建新数组返回。
		*@return Array 返回节点列表。
		*/
		__proto.getEles = function (start, end, rst) {
			if (!rst) {
				rst = [];
			} else {
				rst.length = 0;
			}
			while (start && start != end) {
				rst.push(start);
				start = start.parent;
			}
			return rst;
		}

		/**
		*touchMove时处理out事件和over时间。
		*@param eleNew 新的根节点。
		*@param elePre 旧的根节点。
		*@param touchID （可选）touchID，默认为0。
		*/
		__proto.checkMouseOutAndOverOfMove = function (eleNew, elePre, touchID) {
			(touchID === void 0) && (touchID = 0);
			if (elePre == eleNew)
				return;
			var tar;
			var arrs;
			var i = 0, len = 0;
			if (elePre.contains(eleNew)) {
				arrs = this.getEles(eleNew, elePre, TouchManager._tEleArr);
				this.sendEvents(arrs,/*laya.events.Event.MOUSE_OVER*/"mouseover", touchID);
			} else if (eleNew.contains(elePre)) {
				arrs = this.getEles(elePre, eleNew, TouchManager._tEleArr);
				this.sendEvents(arrs,/*laya.events.Event.MOUSE_OUT*/"mouseout", touchID);
			} else {
				arrs = TouchManager._tEleArr;
				arrs.length = 0;
				var oldArr;
				oldArr = this.getEles(elePre, null, TouchManager._oldArr);
				var newArr;
				newArr = this.getEles(eleNew, null, TouchManager._newArr);
				len = oldArr.length;
				var tIndex = 0;
				for (i = 0; i < len; i++) {
					tar = oldArr[i];
					tIndex = newArr.indexOf(tar);
					if (tIndex >= 0) {
						newArr.splice(tIndex, newArr.length - tIndex);
						break;
					} else {
						arrs.push(tar);
					}
				}
				if (arrs.length > 0) {
					this.sendEvents(arrs,/*laya.events.Event.MOUSE_OUT*/"mouseout", touchID);
				}
				if (newArr.length > 0) {
					this.sendEvents(newArr,/*laya.events.Event.MOUSE_OVER*/"mouseover", touchID);
				}
			}
		}

		/**
		*处理TouchMove事件
		*@param ele 根节点
		*@param touchID touchID
		*
		*/
		__proto.onMouseMove = function (ele, touchID) {
			if (!this.enable)
				return;
			var preO;
			preO = this.getTouchFromArr(touchID, this.preOvers);
			var arrs;
			var tO;
			if (!preO) {
				arrs = this.getEles(ele, null, TouchManager._tEleArr);
				this.sendEvents(arrs,/*laya.events.Event.MOUSE_OVER*/"mouseover", touchID);
				this.preOvers.push(this.createTouchO(ele, touchID));
			} else {
				this.checkMouseOutAndOverOfMove(ele, preO.tar);
				preO.tar = ele;
				arrs = this.getEles(ele, null, TouchManager._tEleArr);
			}
			this.sendEvents(arrs,/*laya.events.Event.MOUSE_MOVE*/"mousemove", touchID);
			this._clearTempArrs();
		}

		__proto.getLastOvers = function () {
			TouchManager._tEleArr.length = 0;
			if (this.preOvers.length > 0 && this.preOvers[0].tar) {
				return this.getEles(this.preOvers[0].tar, null, TouchManager._tEleArr);
			}
			TouchManager._tEleArr.push(Laya.stage);
			return TouchManager._tEleArr;
		}

		__proto.stageMouseOut = function () {
			var lastOvers;
			lastOvers = this.getLastOvers();
			this.preOvers.length = 0;
			this.sendEvents(lastOvers,/*laya.events.Event.MOUSE_OUT*/"mouseout", 0);
		}

		/**
		*处理TouchEnd事件
		*@param ele 根节点
		*@param touchID touchID
		*@param isLeft 是否为左键
		*/
		__proto.onMouseUp = function (ele, touchID, isLeft) {
			(isLeft === void 0) && (isLeft = false);
			if (!this.enable)
				return;
			var preO;
			var tO;
			var arrs;
			var oldArr;
			var i = 0, len = 0;
			var tar;
			var sendArr;
			var onMobile = Browser.onMobile;
			arrs = this.getEles(ele, null, TouchManager._tEleArr);
			this.sendEvents(arrs, isLeft ? /*laya.events.Event.MOUSE_UP*/"mouseup" :/*laya.events.Event.RIGHT_MOUSE_UP*/"rightmouseup", touchID);
			var preDowns;
			preDowns = isLeft ? this.preDowns : this.preRightDowns;
			preO = this.getTouchFromArr(touchID, preDowns);
			if (!preO) {
			} else {
				var isDouble = false;
				var now = Browser.now();
				isDouble = now - this._lastClickTime < 300;
				this._lastClickTime = now;
				if (ele == preO.tar) {
					sendArr = arrs;
				} else {
					oldArr = this.getEles(preO.tar, null, TouchManager._oldArr);
					sendArr = TouchManager._newArr;
					sendArr.length = 0;
					len = oldArr.length;
					for (i = 0; i < len; i++) {
						tar = oldArr[i];
						if (arrs.indexOf(tar) >= 0) {
							sendArr.push(tar);
						}
					}
				}
				if (sendArr.length > 0) {
					this.sendEvents(sendArr, isLeft ? /*laya.events.Event.CLICK*/"click" :/*laya.events.Event.RIGHT_CLICK*/"rightclick", touchID);
				}
				if (isLeft && isDouble) {
					this.sendEvents(sendArr,/*laya.events.Event.DOUBLE_CLICK*/"doubleclick", touchID);
				}
				this.removeTouchFromArr(touchID, preDowns);
				preO.tar = null;
				Pool.recover("TouchData", preO);
			}
			preO = this.getTouchFromArr(touchID, this.preOvers);
			if (!preO) {
			} else {
				if (onMobile) {
					sendArr = this.getEles(preO.tar, null, sendArr);
					if (sendArr && sendArr.length > 0) {
						this.sendEvents(sendArr,/*laya.events.Event.MOUSE_OUT*/"mouseout", touchID);
					}
					this.removeTouchFromArr(touchID, this.preOvers);
					preO.tar = null;
					Pool.recover("TouchData", preO);
				}
			}
			this._clearTempArrs();
		}

		TouchManager._oldArr = [];
		TouchManager._newArr = [];
		TouchManager._tEleArr = [];
		__static(TouchManager,
			['I', function () { return this.I = new TouchManager(); }
			]);
		return TouchManager;
	})()


	/**
	*<code>Filter</code> 是滤镜基类。
	*/
	//class laya.filters.Filter
	var Filter = (function () {
		function Filter() {
			/**@private */
			this._action = null;
		}

		__class(Filter, 'laya.filters.Filter');
		var __proto = Filter.prototype;
		Laya.imps(__proto, { "laya.filters.IFilter": true })
		/**@private */
		__proto.callNative = function (sp) { }
		/**@private 滤镜类型。*/
		__getset(0, __proto, 'type', function () { return -1 });
		/**@private 滤镜动作。*/
		__getset(0, __proto, 'action', function () { return this._action });
		Filter.BLUR = 0x10;
		Filter.COLOR = 0x20;
		Filter.GLOW = 0x08;
		Filter._filterStart = null;
		Filter._filterEnd = null;
		Filter._EndTarget = null;
		Filter._recycleScope = null;
		Filter._filter = null;
		Filter._useSrc = null;
		Filter._endSrc = null;
		Filter._useOut = null;
		Filter._endOut = null;
		return Filter;
	})()


	/**
	*@private
	*<code>ColorFilterAction</code> 是一个颜色滤镜应用类。
	*/
	//class laya.filters.ColorFilterAction
	var ColorFilterAction = (function () {
		function ColorFilterAction() {
			this.data = null;
		}

		__class(ColorFilterAction, 'laya.filters.ColorFilterAction');
		var __proto = ColorFilterAction.prototype;
		Laya.imps(__proto, { "laya.filters.IFilterAction": true })
		/**
		*给指定的对象应用颜色滤镜。
		*@param srcCanvas 需要应用画布对象。
		*@return 应用了滤镜后的画布对象。
		*/
		__proto.apply = function (srcCanvas) {
			var ctx = srcCanvas.ctx.ctx;
			var canvas = srcCanvas.ctx.ctx.canvas;
			if (canvas.width == 0 || canvas.height == 0) return canvas;
			var imgdata = ctx.getImageData(0, 0, canvas.width, canvas.height);
			var data = imgdata.data;
			var nData;
			for (var i = 0, n = data.length; i < n; i += 4) {
				nData = this.getColor(data[i], data[i + 1], data[i + 2], data[i + 3]);
				if (data[i + 3] == 0) continue;
				data[i] = nData[0];
				data[i + 1] = nData[1];
				data[i + 2] = nData[2];
				data[i + 3] = nData[3];
			}
			ctx.putImageData(imgdata, 0, 0);
			return srcCanvas;
		}

		__proto.getColor = function (red, green, blue, alpha) {
			var rst = [];
			if (this.data._mat && this.data._alpha) {
				var mat = this.data._mat;
				var tempAlpha = this.data._alpha;
				rst[0] = mat[0] * red + mat[1] * green + mat[2] * blue + mat[3] * alpha + tempAlpha[0];
				rst[1] = mat[4] * red + mat[5] * green + mat[6] * blue + mat[7] * alpha + tempAlpha[1];
				rst[2] = mat[8] * red + mat[9] * green + mat[10] * blue + mat[11] * alpha + tempAlpha[2];
				rst[3] = mat[12] * red + mat[13] * green + mat[14] * blue + mat[15] * alpha + tempAlpha[3];
			}
			return rst;
		}

		return ColorFilterAction;
	})()


	/**
	*@private
	*/
	//class laya.maths.Arith
	var Arith = (function () {
		function Arith() { }
		__class(Arith, 'laya.maths.Arith');
		Arith.formatR = function (r) {
			if (r > Math.PI) r -= Math.PI * 2;
			if (r < -Math.PI) r += Math.PI * 2;
			return r;
		}

		Arith.isPOT = function (w, h) {
			return (w > 0 && (w & (w - 1)) === 0 && h > 0 && (h & (h - 1)) === 0);
		}

		Arith.setMatToArray = function (mat, array) {
			mat.a, mat.b, 0, 0, mat.c, mat.d, 0, 0, 0, 0, 1, 0, mat.tx + 20, mat.ty + 20, 0, 1
			array[0] = mat.a;
			array[1] = mat.b;
			array[4] = mat.c;
			array[5] = mat.d;
			array[12] = mat.tx;
			array[13] = mat.ty;
		}

		return Arith;
	})()


	/**
	*@private
	*计算贝塞尔曲线的工具类。
	*/
	//class laya.maths.Bezier
	var Bezier = (function () {
		function Bezier() {
			/**@private */
			this._controlPoints = [new Point(), new Point(), new Point()];
			this._calFun = this.getPoint2;
		}

		__class(Bezier, 'laya.maths.Bezier');
		var __proto = Bezier.prototype;
		/**@private */
		__proto._switchPoint = function (x, y) {
			var tPoint = this._controlPoints.shift();
			tPoint.setTo(x, y);
			this._controlPoints.push(tPoint);
		}

		/**
		*计算二次贝塞尔点。
		*@param t
		*@param rst
		*
		*/
		__proto.getPoint2 = function (t, rst) {
			var p1 = this._controlPoints[0];
			var p2 = this._controlPoints[1];
			var p3 = this._controlPoints[2];
			var lineX = Math.pow((1 - t), 2) * p1.x + 2 * t * (1 - t) * p2.x + Math.pow(t, 2) * p3.x;
			var lineY = Math.pow((1 - t), 2) * p1.y + 2 * t * (1 - t) * p2.y + Math.pow(t, 2) * p3.y;
			rst.push(lineX, lineY);
		}

		/**
		*计算三次贝塞尔点
		*@param t
		*@param rst
		*
		*/
		__proto.getPoint3 = function (t, rst) {
			var p1 = this._controlPoints[0];
			var p2 = this._controlPoints[1];
			var p3 = this._controlPoints[2];
			var p4 = this._controlPoints[3];
			var lineX = Math.pow((1 - t), 3) * p1.x + 3 * p2.x * t * (1 - t) * (1 - t) + 3 * p3.x * t * t * (1 - t) + p4.x * Math.pow(t, 3);
			var lineY = Math.pow((1 - t), 3) * p1.y + 3 * p2.y * t * (1 - t) * (1 - t) + 3 * p3.y * t * t * (1 - t) + p4.y * Math.pow(t, 3);
			rst.push(lineX, lineY);
		}

		/**
		*计算贝塞尔点序列
		*@param count
		*@param rst
		*
		*/
		__proto.insertPoints = function (count, rst) {
			var i = NaN;
			count = count > 0 ? count : 5;
			var dLen = NaN;
			dLen = 1 / count;
			for (i = 0; i <= 1; i += dLen) {
				this._calFun(i, rst);
			}
		}

		/**
		*获取贝塞尔曲线上的点。
		*@param pList 控制点[x0,y0,x1,y1...]
		*@param inSertCount 每次曲线的插值数量
		*@return
		*
		*/
		__proto.getBezierPoints = function (pList, inSertCount, count) {
			(inSertCount === void 0) && (inSertCount = 5);
			(count === void 0) && (count = 2);
			var i = 0, len = 0;
			len = pList.length;
			if (len < (count + 1) * 2) return [];
			var rst;
			rst = [];
			switch (count) {
				case 2:
					this._calFun = this.getPoint2;
					break;
				case 3:
					this._calFun = this.getPoint3;
					break;
				default:
					return [];
			}
			while (this._controlPoints.length <= count) {
				this._controlPoints.push(new Point());
			}
			for (i = 0; i < count * 2; i += 2) {
				this._switchPoint(pList[i], pList[i + 1]);
			}
			for (i = count * 2; i < len; i += 2) {
				this._switchPoint(pList[i], pList[i + 1]);
				if ((i / 2) % count == 0)
					this.insertPoints(inSertCount, rst);
			}
			return rst;
		}

		__static(Bezier,
			['I', function () { return this.I = new Bezier(); }
			]);
		return Bezier;
	})()


	/**
	*@private
	*凸包算法。
	*/
	//class laya.maths.GrahamScan
	var GrahamScan = (function () {
		function GrahamScan() { }
		__class(GrahamScan, 'laya.maths.GrahamScan');
		GrahamScan.multiply = function (p1, p2, p0) {
			return ((p1.x - p0.x) * (p2.y - p0.y) - (p2.x - p0.x) * (p1.y - p0.y));
		}

		GrahamScan.dis = function (p1, p2) {
			return (p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y);
		}

		GrahamScan._getPoints = function (count, tempUse, rst) {
			(tempUse === void 0) && (tempUse = false);
			if (!GrahamScan._mPointList) GrahamScan._mPointList = [];
			while (GrahamScan._mPointList.length < count) GrahamScan._mPointList.push(new Point());
			if (!rst) rst = [];
			rst.length = 0;
			if (tempUse) {
				GrahamScan.getFrom(rst, GrahamScan._mPointList, count);
			} else {
				GrahamScan.getFromR(rst, GrahamScan._mPointList, count);
			}
			return rst;
		}

		GrahamScan.getFrom = function (rst, src, count) {
			var i = 0;
			for (i = 0; i < count; i++) {
				rst.push(src[i]);
			}
			return rst;
		}

		GrahamScan.getFromR = function (rst, src, count) {
			var i = 0;
			for (i = 0; i < count; i++) {
				rst.push(src.pop());
			}
			return rst;
		}

		GrahamScan.pListToPointList = function (pList, tempUse) {
			(tempUse === void 0) && (tempUse = false);
			var i = 0, len = pList.length / 2, rst = GrahamScan._getPoints(len, tempUse, GrahamScan._tempPointList);
			for (i = 0; i < len; i++) {
				rst[i].setTo(pList[i + i], pList[i + i + 1]);
			}
			return rst;
		}

		GrahamScan.pointListToPlist = function (pointList) {
			var i = 0, len = pointList.length, rst = GrahamScan._temPList, tPoint;
			rst.length = 0;
			for (i = 0; i < len; i++) {
				tPoint = pointList[i];
				rst.push(tPoint.x, tPoint.y);
			}
			return rst;
		}

		GrahamScan.scanPList = function (pList) {
			return Utils.copyArray(pList, GrahamScan.pointListToPlist(GrahamScan.scan(GrahamScan.pListToPointList(pList, true))));
		}

		GrahamScan.scan = function (PointSet) {
			var i = 0, j = 0, k = 0, top = 2, tmp, n = PointSet.length, ch;
			var _tmpDic = {};
			var key;
			ch = GrahamScan._temArr;
			ch.length = 0;
			n = PointSet.length;
			for (i = n - 1; i >= 0; i--) {
				tmp = PointSet[i];
				key = tmp.x + "_" + tmp.y;
				if (!_tmpDic.hasOwnProperty(key)) {
					_tmpDic[key] = true;
					ch.push(tmp);
				}
			}
			n = ch.length;
			Utils.copyArray(PointSet, ch);
			for (i = 1; i < n; i++)
				if ((PointSet[i].y < PointSet[k].y) || ((PointSet[i].y == PointSet[k].y) && (PointSet[i].x < PointSet[k].x)))
					k = i;
			tmp = PointSet[0];
			PointSet[0] = PointSet[k];
			PointSet[k] = tmp;
			for (i = 1; i < n - 1; i++) {
				k = i;
				for (j = i + 1; j < n; j++)
					if ((GrahamScan.multiply(PointSet[j], PointSet[k], PointSet[0]) > 0) || ((GrahamScan.multiply(PointSet[j], PointSet[k], PointSet[0]) == 0) && (GrahamScan.dis(PointSet[0], PointSet[j]) < GrahamScan.dis(PointSet[0], PointSet[k]))))
						k = j;
				tmp = PointSet[i];
				PointSet[i] = PointSet[k];
				PointSet[k] = tmp;
			}
			ch = GrahamScan._temArr;
			ch.length = 0;
			if (PointSet.length < 3) {
				return Utils.copyArray(ch, PointSet);
			}
			ch.push(PointSet[0], PointSet[1], PointSet[2]);
			for (i = 3; i < n; i++) {
				while (ch.length >= 2 && GrahamScan.multiply(PointSet[i], ch[ch.length - 1], ch[ch.length - 2]) >= 0) ch.pop();
				PointSet[i] && ch.push(PointSet[i]);
			}
			return ch;
		}

		GrahamScan._mPointList = null;
		GrahamScan._tempPointList = [];
		GrahamScan._temPList = [];
		GrahamScan._temArr = [];
		return GrahamScan;
	})()


	/**
	*@private
	*<code>MathUtil</code> 是一个数据处理工具类。
	*/
	//class laya.maths.MathUtil
	var MathUtil = (function () {
		function MathUtil() { }
		__class(MathUtil, 'laya.maths.MathUtil');
		MathUtil.subtractVector3 = function (l, r, o) {
			o[0] = l[0] - r[0];
			o[1] = l[1] - r[1];
			o[2] = l[2] - r[2];
		}

		MathUtil.lerp = function (left, right, amount) {
			return left * (1 - amount) + right * amount;
		}

		MathUtil.scaleVector3 = function (f, b, e) {
			e[0] = f[0] * b;
			e[1] = f[1] * b;
			e[2] = f[2] * b;
		}

		MathUtil.lerpVector3 = function (l, r, t, o) {
			var ax = l[0], ay = l[1], az = l[2];
			o[0] = ax + t * (r[0] - ax);
			o[1] = ay + t * (r[1] - ay);
			o[2] = az + t * (r[2] - az);
		}

		MathUtil.lerpVector4 = function (l, r, t, o) {
			var ax = l[0], ay = l[1], az = l[2], aw = l[3];
			o[0] = ax + t * (r[0] - ax);
			o[1] = ay + t * (r[1] - ay);
			o[2] = az + t * (r[2] - az);
			o[3] = aw + t * (r[3] - aw);
		}

		MathUtil.slerpQuaternionArray = function (a, Offset1, b, Offset2, t, out, Offset3) {
			var ax = a[Offset1 + 0], ay = a[Offset1 + 1], az = a[Offset1 + 2], aw = a[Offset1 + 3], bx = b[Offset2 + 0], by = b[Offset2 + 1], bz = b[Offset2 + 2], bw = b[Offset2 + 3];
			var omega, cosom, sinom, scale0, scale1;
			cosom = ax * bx + ay * by + az * bz + aw * bw;
			if (cosom < 0.0) {
				cosom = -cosom;
				bx = -bx;
				by = -by;
				bz = -bz;
				bw = -bw;
			}
			if ((1.0 - cosom) > 0.000001) {
				omega = Math.acos(cosom);
				sinom = Math.sin(omega);
				scale0 = Math.sin((1.0 - t) * omega) / sinom;
				scale1 = Math.sin(t * omega) / sinom;
			} else {
				scale0 = 1.0 - t;
				scale1 = t;
			}
			out[Offset3 + 0] = scale0 * ax + scale1 * bx;
			out[Offset3 + 1] = scale0 * ay + scale1 * by;
			out[Offset3 + 2] = scale0 * az + scale1 * bz;
			out[Offset3 + 3] = scale0 * aw + scale1 * bw;
			return out;
		}

		MathUtil.getRotation = function (x0, y0, x1, y1) {
			return Math.atan2(y1 - y0, x1 - x0) / Math.PI * 180;
		}

		MathUtil.sortBigFirst = function (a, b) {
			if (a == b)
				return 0;
			return b > a ? 1 : -1;
		}

		MathUtil.sortSmallFirst = function (a, b) {
			if (a == b)
				return 0;
			return b > a ? -1 : 1;
		}

		MathUtil.sortNumBigFirst = function (a, b) {
			return parseFloat(b) - parseFloat(a);
		}

		MathUtil.sortNumSmallFirst = function (a, b) {
			return parseFloat(a) - parseFloat(b);
		}

		MathUtil.sortByKey = function (key, bigFirst, forceNum) {
			(bigFirst === void 0) && (bigFirst = false);
			(forceNum === void 0) && (forceNum = true);
			var _sortFun;
			if (bigFirst) {
				_sortFun = forceNum ? MathUtil.sortNumBigFirst : MathUtil.sortBigFirst;
			} else {
				_sortFun = forceNum ? MathUtil.sortNumSmallFirst : MathUtil.sortSmallFirst;
			}
			return function (a, b) {
				return _sortFun(a[key], b[key]);
			}
		}

		return MathUtil;
	})()


	/**
	*<p> <code>Matrix</code> 类表示一个转换矩阵，它确定如何将点从一个坐标空间映射到另一个坐标空间。</p>
	*<p>您可以对一个显示对象执行不同的图形转换，方法是设置 Matrix 对象的属性，将该 Matrix 对象应用于 Transform 对象的 matrix 属性，然后应用该 Transform 对象作为显示对象的 transform 属性。这些转换函数包括平移（x 和 y 重新定位）、旋转、缩放和倾斜。</p>
	*/
	//class laya.maths.Matrix
	var Matrix = (function () {
		function Matrix(a, b, c, d, tx, ty) {
			/**缩放或旋转图像时影响像素沿 x 轴定位的值。*/
			//this.a=NaN;
			/**旋转或倾斜图像时影响像素沿 y 轴定位的值。*/
			//this.b=NaN;
			/**旋转或倾斜图像时影响像素沿 x 轴定位的值。*/
			//this.c=NaN;
			/**缩放或旋转图像时影响像素沿 y 轴定位的值。*/
			//this.d=NaN;
			/**沿 x 轴平移每个点的距离。*/
			//this.tx=NaN;
			/**沿 y 轴平移每个点的距离。*/
			//this.ty=NaN;
			/**@private 表示此对象是否在对象池中。*/
			this.inPool = false;
			/**@private 是否有改变矩阵的值。*/
			this.bTransform = false;
			(a === void 0) && (a = 1);
			(b === void 0) && (b = 0);
			(c === void 0) && (c = 0);
			(d === void 0) && (d = 1);
			(tx === void 0) && (tx = 0);
			(ty === void 0) && (ty = 0);
			this.a = a;
			this.b = b;
			this.c = c;
			this.d = d;
			this.tx = tx;
			this.ty = ty;
			this._checkTransform();
		}

		__class(Matrix, 'laya.maths.Matrix');
		var __proto = Matrix.prototype;
		/**
		*将本矩阵设置为单位矩阵。
		*@return 返回当前矩形。
		*/
		__proto.identity = function () {
			this.a = this.d = 1;
			this.b = this.tx = this.ty = this.c = 0;
			this.bTransform = false;
			return this;
		}

		/**@private */
		__proto._checkTransform = function () {
			return this.bTransform = (this.a !== 1 || this.b !== 0 || this.c !== 0 || this.d !== 1);
		}

		/**
		*设置沿 x 、y 轴平移每个点的距离。
		*@param x 沿 x 轴平移每个点的距离。
		*@param y 沿 y 轴平移每个点的距离。
		*@return 返回对象本身
		*/
		__proto.setTranslate = function (x, y) {
			this.tx = x;
			this.ty = y;
			return this;
		}

		/**
		*沿 x 和 y 轴平移矩阵，平移的变化量由 x 和 y 参数指定。
		*@param x 沿 x 轴向右移动的量（以像素为单位）。
		*@param y 沿 y 轴向下移动的量（以像素为单位）。
		*@return 返回此矩形对象。
		*/
		__proto.translate = function (x, y) {
			this.tx += x;
			this.ty += y;
			return this;
		}

		/**
		*对矩阵应用缩放转换。
		*@param x 用于沿 x 轴缩放对象的乘数。
		*@param y 用于沿 y 轴缩放对象的乘数。
		*/
		__proto.scale = function (x, y) {
			this.a *= x;
			this.d *= y;
			this.c *= x;
			this.b *= y;
			this.tx *= x;
			this.ty *= y;
			this.bTransform = true;
		}

		/**
		*对 Matrix 对象应用旋转转换。
		*@param angle 以弧度为单位的旋转角度。
		*/
		__proto.rotate = function (angle) {
			var cos = Math.cos(angle);
			var sin = Math.sin(angle);
			var a1 = this.a;
			var c1 = this.c;
			var tx1 = this.tx;
			this.a = a1 * cos - this.b * sin;
			this.b = a1 * sin + this.b * cos;
			this.c = c1 * cos - this.d * sin;
			this.d = c1 * sin + this.d * cos;
			this.tx = tx1 * cos - this.ty * sin;
			this.ty = tx1 * sin + this.ty * cos;
			this.bTransform = true;
		}

		/**
		*对 Matrix 对象应用倾斜转换。
		*@param x 沿着 X 轴的 2D 倾斜弧度。
		*@param y 沿着 Y 轴的 2D 倾斜弧度。
		*@return 当前 Matrix 对象。
		*/
		__proto.skew = function (x, y) {
			var tanX = Math.tan(x);
			var tanY = Math.tan(y);
			var a1 = this.a;
			var b1 = this.b;
			this.a += tanY * this.c;
			this.b += tanY * this.d;
			this.c += tanX * a1;
			this.d += tanX * b1;
			return this;
		}

		/**
		*对指定的点应用当前矩阵的逆转化并返回此点。
		*@param out 待转化的点 Point 对象。
		*@return 返回out
		*/
		__proto.invertTransformPoint = function (out) {
			var a1 = this.a;
			var b1 = this.b;
			var c1 = this.c;
			var d1 = this.d;
			var tx1 = this.tx;
			var n = a1 * d1 - b1 * c1;
			var a2 = d1 / n;
			var b2 = -b1 / n;
			var c2 = -c1 / n;
			var d2 = a1 / n;
			var tx2 = (c1 * this.ty - d1 * tx1) / n;
			var ty2 = -(a1 * this.ty - b1 * tx1) / n;
			return out.setTo(a2 * out.x + c2 * out.y + tx2, b2 * out.x + d2 * out.y + ty2);
		}

		/**
		*将 Matrix 对象表示的几何转换应用于指定点。
		*@param out 用来设定输出结果的点。
		*@return 返回out
		*/
		__proto.transformPoint = function (out) {
			return out.setTo(this.a * out.x + this.c * out.y + this.tx, this.b * out.x + this.d * out.y + this.ty);
		}

		/**
		*将 Matrix 对象表示的几何转换应用于指定点，忽略tx、ty。
		*@param out 用来设定输出结果的点。
		*@return 返回out
		*/
		__proto.transformPointN = function (out) {
			return out.setTo(this.a * out.x + this.c * out.y, this.b * out.x + this.d * out.y);
		}

		/**
		*@private
		*将 Matrix 对象表示的几何转换应用于指定点。
		*@param data 点集合。
		*@param out 存储应用转化的点的列表。
		*@return 返回out数组
		*/
		__proto.transformPointArray = function (data, out) {
			var len = data.length;
			for (var i = 0; i < len; i += 2) {
				var x = data[i], y = data[i + 1];
				out[i] = this.a * x + this.c * y + this.tx;
				out[i + 1] = this.b * x + this.d * y + this.ty;
			}
			return out;
		}

		/**
		*@private
		*将 Matrix 对象表示的几何缩放转换应用于指定点。
		*@param data 点集合。
		*@param out 存储应用转化的点的列表。
		*@return 返回out数组
		*/
		__proto.transformPointArrayScale = function (data, out) {
			var len = data.length;
			for (var i = 0; i < len; i += 2) {
				var x = data[i], y = data[i + 1];
				out[i] = this.a * x + this.c * y;
				out[i + 1] = this.b * x + this.d * y;
			}
			return out;
		}

		/**
		*获取 X 轴缩放值。
		*@return X 轴缩放值。
		*/
		__proto.getScaleX = function () {
			return this.b === 0 ? this.a : Math.sqrt(this.a * this.a + this.b * this.b);
		}

		/**
		*获取 Y 轴缩放值。
		*@return Y 轴缩放值。
		*/
		__proto.getScaleY = function () {
			return this.c === 0 ? this.d : Math.sqrt(this.c * this.c + this.d * this.d);
		}

		/**
		*执行原始矩阵的逆转换。
		*@return 当前矩阵对象。
		*/
		__proto.invert = function () {
			var a1 = this.a;
			var b1 = this.b;
			var c1 = this.c;
			var d1 = this.d;
			var tx1 = this.tx;
			var n = a1 * d1 - b1 * c1;
			this.a = d1 / n;
			this.b = -b1 / n;
			this.c = -c1 / n;
			this.d = a1 / n;
			this.tx = (c1 * this.ty - d1 * tx1) / n;
			this.ty = -(a1 * this.ty - b1 * tx1) / n;
			return this;
		}

		/**
		*将 Matrix 的成员设置为指定值。
		*@param a 缩放或旋转图像时影响像素沿 x 轴定位的值。
		*@param b 旋转或倾斜图像时影响像素沿 y 轴定位的值。
		*@param c 旋转或倾斜图像时影响像素沿 x 轴定位的值。
		*@param d 缩放或旋转图像时影响像素沿 y 轴定位的值。
		*@param tx 沿 x 轴平移每个点的距离。
		*@param ty 沿 y 轴平移每个点的距离。
		*@return 当前矩阵对象。
		*/
		__proto.setTo = function (a, b, c, d, tx, ty) {
			this.a = a, this.b = b, this.c = c, this.d = d, this.tx = tx, this.ty = ty;
			return this;
		}

		/**
		*将指定矩阵与当前矩阵连接，从而将这两个矩阵的几何效果有效地结合在一起。
		*@param matrix 要连接到源矩阵的矩阵。
		*@return 当前矩阵。
		*/
		__proto.concat = function (matrix) {
			var a = this.a;
			var c = this.c;
			var tx = this.tx;
			this.a = a * matrix.a + this.b * matrix.c;
			this.b = a * matrix.b + this.b * matrix.d;
			this.c = c * matrix.a + this.d * matrix.c;
			this.d = c * matrix.b + this.d * matrix.d;
			this.tx = tx * matrix.a + this.ty * matrix.c + matrix.tx;
			this.ty = tx * matrix.b + this.ty * matrix.d + matrix.ty;
			return this;
		}

		/**
		*@private
		*对矩阵应用缩放转换。反向相乘
		*@param x 用于沿 x 轴缩放对象的乘数。
		*@param y 用于沿 y 轴缩放对象的乘数。
		*/
		__proto.scaleEx = function (x, y) {
			var ba = this.a, bb = this.b, bc = this.c, bd = this.d;
			if (bb !== 0 || bc !== 0) {
				this.a = x * ba;
				this.b = x * bb;
				this.c = y * bc;
				this.d = y * bd;
			} else {
				this.a = x * ba;
				this.b = 0 * bd;
				this.c = 0 * ba;
				this.d = y * bd;
			}
			this.bTransform = true;
		}

		/**
		*@private
		*对 Matrix 对象应用旋转转换。反向相乘
		*@param angle 以弧度为单位的旋转角度。
		*/
		__proto.rotateEx = function (angle) {
			var cos = Math.cos(angle);
			var sin = Math.sin(angle);
			var ba = this.a, bb = this.b, bc = this.c, bd = this.d;
			if (bb !== 0 || bc !== 0) {
				this.a = cos * ba + sin * bc;
				this.b = cos * bb + sin * bd;
				this.c = -sin * ba + cos * bc;
				this.d = -sin * bb + cos * bd;
			} else {
				this.a = cos * ba;
				this.b = sin * bd;
				this.c = -sin * ba;
				this.d = cos * bd;
			}
			this.bTransform = true;
		}

		/**
		*返回此 Matrix 对象的副本。
		*@return 与原始实例具有完全相同的属性的新 Matrix 实例。
		*/
		__proto.clone = function () {
			var dec = Matrix.create();
			dec.a = this.a;
			dec.b = this.b;
			dec.c = this.c;
			dec.d = this.d;
			dec.tx = this.tx;
			dec.ty = this.ty;
			dec.bTransform = this.bTransform;
			return dec;
		}

		/**
		*将当前 Matrix 对象中的所有矩阵数据复制到指定的 Matrix 对象中。
		*@param dec 要复制当前矩阵数据的 Matrix 对象。
		*@return 已复制当前矩阵数据的 Matrix 对象。
		*/
		__proto.copyTo = function (dec) {
			dec.a = this.a;
			dec.b = this.b;
			dec.c = this.c;
			dec.d = this.d;
			dec.tx = this.tx;
			dec.ty = this.ty;
			dec.bTransform = this.bTransform;
			return dec;
		}

		/**
		*返回列出该 Matrix 对象属性的文本值。
		*@return 一个字符串，它包含 Matrix 对象的属性值：a、b、c、d、tx 和 ty。
		*/
		__proto.toString = function () {
			return this.a + "," + this.b + "," + this.c + "," + this.d + "," + this.tx + "," + this.ty;
		}

		/**
		*销毁此对象。
		*/
		__proto.destroy = function () {
			if (this.inPool) return;
			var cache = Matrix._cache;
			this.inPool = true;
			cache._length || (cache._length = 0);
			cache[cache._length++] = this;
			this.a = this.d = 1;
			this.b = this.c = this.tx = this.ty = 0;
			this.bTransform = false;
		}

		Matrix.mul = function (m1, m2, out) {
			var aa = m1.a, ab = m1.b, ac = m1.c, ad = m1.d, atx = m1.tx, aty = m1.ty;
			var ba = m2.a, bb = m2.b, bc = m2.c, bd = m2.d, btx = m2.tx, bty = m2.ty;
			if (bb !== 0 || bc !== 0) {
				out.a = aa * ba + ab * bc;
				out.b = aa * bb + ab * bd;
				out.c = ac * ba + ad * bc;
				out.d = ac * bb + ad * bd;
				out.tx = ba * atx + bc * aty + btx;
				out.ty = bb * atx + bd * aty + bty;
			} else {
				out.a = aa * ba;
				out.b = ab * bd;
				out.c = ac * ba;
				out.d = ad * bd;
				out.tx = ba * atx + btx;
				out.ty = bd * aty + bty;
			}
			return out;
		}

		Matrix.mul16 = function (m1, m2, out) {
			var aa = m1.a, ab = m1.b, ac = m1.c, ad = m1.d, atx = m1.tx, aty = m1.ty;
			var ba = m2.a, bb = m2.b, bc = m2.c, bd = m2.d, btx = m2.tx, bty = m2.ty;
			if (bb !== 0 || bc !== 0) {
				out[0] = aa * ba + ab * bc;
				out[1] = aa * bb + ab * bd;
				out[4] = ac * ba + ad * bc;
				out[5] = ac * bb + ad * bd;
				out[12] = ba * atx + bc * aty + btx;
				out[13] = bb * atx + bd * aty + bty;
			} else {
				out[0] = aa * ba;
				out[1] = ab * bd;
				out[4] = ac * ba;
				out[5] = ad * bd;
				out[12] = ba * atx + btx;
				out[13] = bd * aty + bty;
			}
			return out;
		}

		Matrix.mulPre = function (m1, ba, bb, bc, bd, btx, bty, out) {
			var aa = m1.a, ab = m1.b, ac = m1.c, ad = m1.d, atx = m1.tx, aty = m1.ty;
			if (bb !== 0 || bc !== 0) {
				out.a = aa * ba + ab * bc;
				out.b = aa * bb + ab * bd;
				out.c = ac * ba + ad * bc;
				out.d = ac * bb + ad * bd;
				out.tx = ba * atx + bc * aty + btx;
				out.ty = bb * atx + bd * aty + bty;
			} else {
				out.a = aa * ba;
				out.b = ab * bd;
				out.c = ac * ba;
				out.d = ad * bd;
				out.tx = ba * atx + btx;
				out.ty = bd * aty + bty;
			}
			return out;
		}

		Matrix.mulPos = function (m1, aa, ab, ac, ad, atx, aty, out) {
			var ba = m1.a, bb = m1.b, bc = m1.c, bd = m1.d, btx = m1.tx, bty = m1.ty;
			if (bb !== 0 || bc !== 0) {
				out.a = aa * ba + ab * bc;
				out.b = aa * bb + ab * bd;
				out.c = ac * ba + ad * bc;
				out.d = ac * bb + ad * bd;
				out.tx = ba * atx + bc * aty + btx;
				out.ty = bb * atx + bd * aty + bty;
			} else {
				out.a = aa * ba;
				out.b = ab * bd;
				out.c = ac * ba;
				out.d = ad * bd;
				out.tx = ba * atx + btx;
				out.ty = bd * aty + bty;
			}
			return out;
		}

		Matrix.preMul = function (parent, self, out) {
			var pa = parent.a, pb = parent.b, pc = parent.c, pd = parent.d;
			var na = self.a, nb = self.b, nc = self.c, nd = self.d, ntx = self.tx, nty = self.ty;
			out.a = na * pa;
			out.b = out.c = 0;
			out.d = nd * pd;
			out.tx = ntx * pa + parent.tx;
			out.ty = nty * pd + parent.ty;
			if (nb !== 0 || nc !== 0 || pb !== 0 || pc !== 0) {
				out.a += nb * pc;
				out.d += nc * pb;
				out.b += na * pb + nb * pd;
				out.c += nc * pa + nd * pc;
				out.tx += nty * pc;
				out.ty += ntx * pb;
			}
			return out;
		}

		Matrix.preMulXY = function (parent, x, y, out) {
			var pa = parent.a, pb = parent.b, pc = parent.c, pd = parent.d;
			out.a = pa;
			out.b = pb;
			out.c = pc;
			out.d = pd;
			out.tx = x * pa + parent.tx + y * pc;
			out.ty = y * pd + parent.ty + x * pb;
			return out;
		}

		Matrix.create = function () {
			var cache = Matrix._cache;
			var mat = !cache._length ? (new Matrix()) : cache[--cache._length];
			mat.inPool = false;
			return mat;
		}

		Matrix.EMPTY = new Matrix();
		Matrix.TEMP = new Matrix();
		Matrix._cache = [];
		return Matrix;
	})()


	/**
	*<code>Point</code> 对象表示二维坐标系统中的某个位置，其中 x 表示水平轴，y 表示垂直轴。
	*/
	//class laya.maths.Point
	var Point = (function () {
		function Point(x, y) {
			/**该点的水平坐标。*/
			//this.x=NaN;
			/**该点的垂直坐标。*/
			//this.y=NaN;
			(x === void 0) && (x = 0);
			(y === void 0) && (y = 0);
			this.x = x;
			this.y = y;
		}

		__class(Point, 'laya.maths.Point');
		var __proto = Point.prototype;
		/**
		*将 <code>Point</code> 的成员设置为指定值。
		*@param x 水平坐标。
		*@param y 垂直坐标。
		*@return 当前 Point 对象。
		*/
		__proto.setTo = function (x, y) {
			this.x = x;
			this.y = y;
			return this;
		}

		/**
		*计算当前点和目标点(x，y)的距离。
		*@param x 水平坐标。
		*@param y 垂直坐标。
		*@return 返回当前点和目标点之间的距离。
		*/
		__proto.distance = function (x, y) {
			return Math.sqrt((this.x - x) * (this.x - x) + (this.y - y) * (this.y - y));
		}

		/**返回包含 x 和 y 坐标的值的字符串。*/
		__proto.toString = function () {
			return this.x + "," + this.y;
		}

		/**
		*标准化向量。
		*/
		__proto.normalize = function () {
			var d = Math.sqrt(this.x * this.x + this.y * this.y);
			if (d > 0) {
				var id = 1.0 / d;
				this.x *= id;
				this.y *= id;
			}
		}

		Point.TEMP = new Point();
		Point.EMPTY = new Point();
		return Point;
	})()


	/**
	*<p><code>Rectangle</code> 对象是按其位置（由它左上角的点 (x,y)确定）以及宽度和高度定义的区域。</p>
	*<p>Rectangle 类的 x、y、width 和 height 属性相互独立；更改一个属性的值不会影响其他属性。</p>
	*/
	//class laya.maths.Rectangle
	var Rectangle = (function () {
		function Rectangle(x, y, width, height) {
			/**矩形左上角的 X 轴坐标。*/
			//this.x=NaN;
			/**矩形左上角的 Y 轴坐标。*/
			//this.y=NaN;
			/**矩形的宽度。*/
			//this.width=NaN;
			/**矩形的高度。*/
			//this.height=NaN;
			(x === void 0) && (x = 0);
			(y === void 0) && (y = 0);
			(width === void 0) && (width = 0);
			(height === void 0) && (height = 0);
			this.x = x;
			this.y = y;
			this.width = width;
			this.height = height;
		}

		__class(Rectangle, 'laya.maths.Rectangle');
		var __proto = Rectangle.prototype;
		/**
		*将 Rectangle 的属性设置为指定值。
		*@param x x 矩形左上角的 X 轴坐标。
		*@param y x 矩形左上角的 Y 轴坐标。
		*@param width 矩形的宽度。
		*@param height 矩形的高。
		*@return 返回属性值修改后的矩形对象本身。
		*/
		__proto.setTo = function (x, y, width, height) {
			this.x = x;
			this.y = y;
			this.width = width;
			this.height = height;
			return this;
		}

		/**
		*复制 source 对象的属性值到此矩形对象中。
		*@param sourceRect 源 Rectangle 对象。
		*@return 返回属性值修改后的矩形对象本身。
		*/
		__proto.copyFrom = function (source) {
			this.x = source.x;
			this.y = source.y;
			this.width = source.width;
			this.height = source.height;
			return this;
		}

		/**
		*确定由此 Rectangle 对象定义的矩形区域内是否包含指定的点。
		*@param x 点的 X 轴坐标值（水平位置）。
		*@param y 点的 Y 轴坐标值（垂直位置）。
		*@return 如果 Rectangle 对象包含指定的点，则值为 true；否则为 false。
		*/
		__proto.contains = function (x, y) {
			if (this.width <= 0 || this.height <= 0) return false;
			if (x >= this.x && x < this.right) {
				if (y >= this.y && y < this.bottom) {
					return true;
				}
			}
			return false;
		}

		/**
		*确定在 rect 参数中指定的对象是否与此 Rectangle 对象相交。此方法检查指定的 Rectangle 对象的 x、y、width 和 height 属性，以查看它是否与此 Rectangle 对象相交。
		*@param rect Rectangle 对象。
		*@return 如果传入的矩形对象与此对象相交，则返回 true 值，否则返回 false。
		*/
		__proto.intersects = function (rect) {
			return !(rect.x > (this.x + this.width) || (rect.x + rect.width) < this.x || rect.y > (this.y + this.height) || (rect.y + rect.height) < this.y);
		}

		/**
		*如果在 rect 参数中指定的 Rectangle 对象与此 Rectangle 对象相交，则返回交集区域作为 Rectangle 对象。如果矩形不相交，则此方法返回null。
		*@param rect 待比较的矩形区域。
		*@param out （可选）待输出的矩形区域。如果为空则创建一个新的。建议：尽量复用对象，减少对象创建消耗。
		*@return 返回相交的矩形区域对象。
		*/
		__proto.intersection = function (rect, out) {
			if (!this.intersects(rect)) return null;
			out || (out = new Rectangle());
			out.x = Math.max(this.x, rect.x);
			out.y = Math.max(this.y, rect.y);
			out.width = Math.min(this.right, rect.right) - out.x;
			out.height = Math.min(this.bottom, rect.bottom) - out.y;
			return out;
		}

		/**
		*<p>矩形联合，通过填充两个矩形之间的水平和垂直空间，将这两个矩形组合在一起以创建一个新的 Rectangle 对象。</p>
		*<p>注意：union()方法忽略高度或宽度值为 0 的矩形，如：var rect2:Rectangle=new Rectangle(300,300,50,0);</p>
		*@param 要添加到此 Rectangle 对象的 Rectangle 对象。
		*@param out 用于存储输出结果的矩形对象。如果为空，则创建一个新的。建议：尽量复用对象，减少对象创建消耗。Rectangle.TEMP对象用于对象复用。
		*@return 充当两个矩形的联合的新 Rectangle 对象。
		*/
		__proto.union = function (source, out) {
			out || (out = new Rectangle());
			this.clone(out);
			if (source.width <= 0 || source.height <= 0) return out;
			out.addPoint(source.x, source.y);
			out.addPoint(source.right, source.bottom);
			return this;
		}

		/**
		*返回一个 Rectangle 对象，其 x、y、width 和 height 属性的值与当前 Rectangle 对象的对应值相同。
		*@param out （可选）用于存储结果的矩形对象。如果为空，则创建一个新的。建议：尽量复用对象，减少对象创建消耗。。Rectangle.TEMP对象用于对象复用。
		*@return Rectangle 对象，其 x、y、width 和 height 属性的值与当前 Rectangle 对象的对应值相同。
		*/
		__proto.clone = function (out) {
			out || (out = new Rectangle());
			out.x = this.x;
			out.y = this.y;
			out.width = this.width;
			out.height = this.height;
			return out;
		}

		/**
		*当前 Rectangle 对象的水平位置 x 和垂直位置 y 以及高度 width 和宽度 height 以逗号连接成的字符串。
		*/
		__proto.toString = function () {
			return this.x + "," + this.y + "," + this.width + "," + this.height;
		}

		/**
		*检测传入的 Rectangle 对象的属性是否与当前 Rectangle 对象的属性 x、y、width、height 属性值都相等。
		*@param rect 待比较的 Rectangle 对象。
		*@return 如果判断的属性都相等，则返回 true ,否则返回 false。
		*/
		__proto.equals = function (rect) {
			if (!rect || rect.x !== this.x || rect.y !== this.y || rect.width !== this.width || rect.height !== this.height) return false;
			return true;
		}

		/**
		*<p>为当前矩形对象加一个点，以使当前矩形扩展为包含当前矩形和此点的最小矩形。</p>
		*<p>此方法会修改本对象。</p>
		*@param x 点的 X 坐标。
		*@param y 点的 Y 坐标。
		*@return 返回此 Rectangle 对象。
		*/
		__proto.addPoint = function (x, y) {
			this.x > x && (this.width += this.x - x, this.x = x);
			this.y > y && (this.height += this.y - y, this.y = y);
			if (this.width < x - this.x) this.width = x - this.x;
			if (this.height < y - this.y) this.height = y - this.y;
			return this;
		}

		/**
		*@private
		*返回代表当前矩形的顶点数据。
		*@return 顶点数据。
		*/
		__proto._getBoundPoints = function () {
			var rst = Rectangle._temB;
			rst.length = 0;
			if (this.width == 0 || this.height == 0) return rst;
			rst.push(this.x, this.y, this.x + this.width, this.y, this.x, this.y + this.height, this.x + this.width, this.y + this.height);
			return rst;
		}

		/**
		*确定此 Rectangle 对象是否为空。
		*@return 如果 Rectangle 对象的宽度或高度小于等于 0，则返回 true 值，否则返回 false。
		*/
		__proto.isEmpty = function () {
			if (this.width <= 0 || this.height <= 0) return true;
			return false;
		}

		/**此矩形右侧的 X 轴坐标。 x 和 width 属性的和。*/
		__getset(0, __proto, 'right', function () {
			return this.x + this.width;
		});

		/**此矩形底端的 Y 轴坐标。y 和 height 属性的和。*/
		__getset(0, __proto, 'bottom', function () {
			return this.y + this.height;
		});

		Rectangle._getBoundPointS = function (x, y, width, height) {
			var rst = Rectangle._temA;
			rst.length = 0;
			if (width == 0 || height == 0) return rst;
			rst.push(x, y, x + width, y, x, y + height, x + width, y + height);
			return rst;
		}

		Rectangle._getWrapRec = function (pointList, rst) {
			if (!pointList || pointList.length < 1) return rst ? rst.setTo(0, 0, 0, 0) : Rectangle.TEMP.setTo(0, 0, 0, 0);
			rst = rst ? rst : new Rectangle();
			var i, len = pointList.length, minX, maxX, minY, maxY, tPoint = Point.TEMP;
			minX = minY = 99999;
			maxX = maxY = -minX;
			for (i = 0; i < len; i += 2) {
				tPoint.x = pointList[i];
				tPoint.y = pointList[i + 1];
				minX = minX < tPoint.x ? minX : tPoint.x;
				minY = minY < tPoint.y ? minY : tPoint.y;
				maxX = maxX > tPoint.x ? maxX : tPoint.x;
				maxY = maxY > tPoint.y ? maxY : tPoint.y;
			}
			return rst.setTo(minX, minY, maxX - minX, maxY - minY);
		}

		Rectangle.EMPTY = new Rectangle();
		Rectangle.TEMP = new Rectangle();
		Rectangle._temB = [];
		Rectangle._temA = [];
		return Rectangle;
	})()


	/**
	*<code>SoundManager</code> 是一个声音管理类。提供了对背景音乐、音效的播放控制方法。
	*引擎默认有两套声音方案：WebAudio和H5Audio
	*播放音效，优先使用WebAudio播放声音，如果WebAudio不可用，则用H5Audio播放，H5Audio在部分机器上有兼容问题（比如不能混音，播放有延迟等）。
	*播放背景音乐，则使用H5Audio播放（使用WebAudio会增加特别大的内存，并且要等加载完毕后才能播放，有延迟）
	*建议背景音乐用mp3类型，音效用wav或者mp3类型（如果打包为app，音效只能用wav格式）。
	*详细教程及声音格式请参考：http://ldc.the3box.com/doc/?nav=ch-as-1-7-0
	*/
	//class laya.media.SoundManager
	var SoundManager = (function () {
		function SoundManager() { }
		__class(SoundManager, 'laya.media.SoundManager');
		__getset(1, SoundManager, 'useAudioMusic', function () {
			return SoundManager._useAudioMusic;
		}, function (value) {
			SoundManager._useAudioMusic = value;
			if (value) SoundManager._musicClass = AudioSound;
		});

		/**
		*失去焦点后是否自动停止背景音乐。
		*@param v Boolean 失去焦点后是否自动停止背景音乐。
		*
		*/
		/**
		*失去焦点后是否自动停止背景音乐。
		*/
		__getset(1, SoundManager, 'autoStopMusic', function () {
			return SoundManager._autoStopMusic;
		}, function (v) {
			Laya.stage.off(/*laya.events.Event.BLUR*/"blur", null, SoundManager._stageOnBlur);
			Laya.stage.off(/*laya.events.Event.FOCUS*/"focus", null, SoundManager._stageOnFocus);
			Laya.stage.off(/*laya.events.Event.VISIBILITY_CHANGE*/"visibilitychange", null, SoundManager._visibilityChange);
			SoundManager._autoStopMusic = v;
			if (v) {
				Laya.stage.on(/*laya.events.Event.BLUR*/"blur", null, SoundManager._stageOnBlur);
				Laya.stage.on(/*laya.events.Event.FOCUS*/"focus", null, SoundManager._stageOnFocus);
				Laya.stage.on(/*laya.events.Event.VISIBILITY_CHANGE*/"visibilitychange", null, SoundManager._visibilityChange);
			}
		});

		/**
		*背景音乐和所有音效是否静音。
		*/
		__getset(1, SoundManager, 'muted', function () {
			return SoundManager._muted;
		}, function (value) {
			if (value == SoundManager._muted) return;
			if (value) {
				SoundManager.stopAllSound();
			}
			SoundManager.musicMuted = value;
			SoundManager._muted = value;
		});

		/**
		*背景音乐（不包括音效）是否静音。
		*/
		__getset(1, SoundManager, 'musicMuted', function () {
			return SoundManager._musicMuted;
		}, function (value) {
			if (value == SoundManager._musicMuted) return;
			if (value) {
				if (SoundManager._tMusic) {
					if (SoundManager._musicChannel && !SoundManager._musicChannel.isStopped) {
						SoundManager._musicChannel.pause();
					} else {
						SoundManager._musicChannel = null;
					}
				} else {
					SoundManager._musicChannel = null;
				}
				SoundManager._musicMuted = value;
			} else {
				SoundManager._musicMuted = value;
				if (SoundManager._tMusic) {
					if (SoundManager._musicChannel) {
						SoundManager._musicChannel.resume();
					}
				}
			}
		});

		/**
		*所有音效（不包括背景音乐）是否静音。
		*/
		__getset(1, SoundManager, 'soundMuted', function () {
			return SoundManager._soundMuted;
		}, function (value) {
			SoundManager._soundMuted = value;
		});

		SoundManager.addChannel = function (channel) {
			if (SoundManager._channels.indexOf(channel) >= 0) return;
			SoundManager._channels.push(channel);
		}

		SoundManager.removeChannel = function (channel) {
			var i = 0;
			for (i = SoundManager._channels.length - 1; i >= 0; i--) {
				if (SoundManager._channels[i] == channel) {
					SoundManager._channels.splice(i, 1);
				}
			}
		}

		SoundManager.disposeSoundIfNotUsed = function (url) {
			var i = 0;
			for (i = SoundManager._channels.length - 1; i >= 0; i--) {
				if (SoundManager._channels[i].url == url) {
					return;
				}
			}
			SoundManager.destroySound(url);
		}

		SoundManager._visibilityChange = function () {
			if (Laya.stage.isVisibility) {
				SoundManager._stageOnFocus();
			} else {
				SoundManager._stageOnBlur();
			}
		}

		SoundManager._stageOnBlur = function () {
			SoundManager._isActive = false;
			if (SoundManager._musicChannel) {
				if (!SoundManager._musicChannel.isStopped) {
					SoundManager._blurPaused = true;
					SoundManager._musicChannel.pause();
					Laya.stage.once(/*laya.events.Event.MOUSE_DOWN*/"mousedown", null, SoundManager._stageOnFocus);
				}
			}
			SoundManager.stopAllSound();
		}

		SoundManager._stageOnFocus = function () {
			SoundManager._isActive = true;
			Laya.stage.off(/*laya.events.Event.MOUSE_DOWN*/"mousedown", null, SoundManager._stageOnFocus);
			if (SoundManager._blurPaused) {
				if (SoundManager._musicChannel && SoundManager._musicChannel.isStopped) {
					SoundManager._blurPaused = false;
					SoundManager._musicChannel.resume();
				}
			}
		}

		SoundManager.playSound = function (url, loops, playbackRate, complete, soundClass, startTime) {
			(loops === void 0) && (loops = 1);
			(startTime === void 0) && (startTime = 0);
			(playbackRate === void 0) && (playbackRate = 1);
			if (!SoundManager._isActive || !url) return null;
			if (SoundManager._muted) return null;
			url = URL.formatURL(url);
			if (url == SoundManager._tMusic) {
				if (SoundManager._musicMuted) return null;
			} else {
				if (Render.isConchApp) {
					var ext = Utils.getFileExtension(url);
					if (ext != "wav" && ext != "ogg") {
						alert("The sound only supports wav or ogg format,for optimal performance reason,please refer to the official website document.");
						return null;
					}
				}
				if (SoundManager._soundMuted) return null;
			};
			var tSound;
			if (!Browser.onMiniGame) {
				tSound = Laya.loader.getRes(url);
			}
			if (!soundClass) soundClass = SoundManager._soundClass;
			if (!tSound) {
				tSound = new soundClass();
				tSound.load(url);
				Loader.cacheRes(url, tSound);
			};
			var channel;
			channel = tSound.play(startTime, loops, playbackRate);
			if (!channel) return null;
			channel.url = url;
			channel.volume = (url == SoundManager._tMusic) ? SoundManager.musicVolume : SoundManager.soundVolume;
			channel.completeHandler = complete;
			return channel;
		}

		SoundManager.destroySound = function (url) {
			var tSound = Laya.loader.getRes(url);
			if (tSound) {
				Loader.clearRes(url);
				tSound.dispose();
			}
		}

		SoundManager.playMusic = function (url, loops, complete, startTime) {
			(loops === void 0) && (loops = 0);
			(startTime === void 0) && (startTime = 0);
			url = URL.formatURL(url);
			SoundManager._tMusic = url;
			if (SoundManager._musicChannel) SoundManager._musicChannel.stop();
			return SoundManager._musicChannel = SoundManager.playSound(url, loops, complete, SoundManager._musicClass, startTime);
		}

		SoundManager.stopSound = function (url) {
			url = URL.formatURL(url);
			var i = 0;
			var channel;
			for (i = SoundManager._channels.length - 1; i >= 0; i--) {
				channel = SoundManager._channels[i];
				if (channel.url == url) {
					channel.stop();
				}
			}
		}

		SoundManager.stopAll = function () {
			SoundManager._tMusic = null;
			var i = 0;
			var channel;
			for (i = SoundManager._channels.length - 1; i >= 0; i--) {
				channel = SoundManager._channels[i];
				channel.stop();
			}
		}

		SoundManager.stopAllSound = function () {
			var i = 0;
			var channel;
			for (i = SoundManager._channels.length - 1; i >= 0; i--) {
				channel = SoundManager._channels[i];
				if (channel.url != SoundManager._tMusic) {
					channel.stop();
				}
			}
		}

		SoundManager.stopMusic = function () {
			if (SoundManager._musicChannel) SoundManager._musicChannel.stop();
			SoundManager._tMusic = null;
		}

		SoundManager.setSoundVolume = function (volume, url) {
			if (url) {
				url = URL.formatURL(url);
				SoundManager._setVolume(url, volume);
			} else {
				SoundManager.soundVolume = volume;
				var i = 0;
				var channel;
				for (i = SoundManager._channels.length - 1; i >= 0; i--) {
					channel = SoundManager._channels[i];
					if (channel.url != SoundManager._tMusic) {
						channel.volume = volume;
					}
				}
			}
		}

		SoundManager.setMusicVolume = function (volume) {
			SoundManager.musicVolume = volume;
			SoundManager._setVolume(SoundManager._tMusic, volume);
		}

		SoundManager._setVolume = function (url, volume) {
			url = URL.formatURL(url);
			var i = 0;
			var channel;
			for (i = SoundManager._channels.length - 1; i >= 0; i--) {
				channel = SoundManager._channels[i];
				if (channel.url == url) {
					channel.volume = volume;
				}
			}
		}

		SoundManager.musicVolume = 1;
		SoundManager.soundVolume = 1;
		SoundManager.playbackRate = 1;
		SoundManager._useAudioMusic = true;
		SoundManager._muted = false;
		SoundManager._soundMuted = false;
		SoundManager._musicMuted = false;
		SoundManager._tMusic = null;
		SoundManager._musicChannel = null;
		SoundManager._channels = [];
		SoundManager._autoStopMusic = false;
		SoundManager._blurPaused = false;
		SoundManager._isActive = true;
		SoundManager._soundClass = null;
		SoundManager._musicClass = null;
		SoundManager.autoReleaseSound = true;
		return SoundManager;
	})()


	/**
	*<p> <code>LocalStorage</code> 类用于没有时间限制的数据存储。</p>
	*/
	//class laya.net.LocalStorage
	var LocalStorage = (function () {
		var Storage;
		function LocalStorage() { }
		__class(LocalStorage, 'laya.net.LocalStorage');
		LocalStorage.__init__ = function () {
			if (!LocalStorage._baseClass) {
				LocalStorage._baseClass = Storage;
				Storage.init();
			}
			LocalStorage.items = LocalStorage._baseClass.items;
			LocalStorage.support = LocalStorage._baseClass.support;
		}

		LocalStorage.setItem = function (key, value) {
			LocalStorage._baseClass.setItem(key, value);
		}

		LocalStorage.getItem = function (key) {
			return LocalStorage._baseClass.getItem(key);
		}

		LocalStorage.setJSON = function (key, value) {
			LocalStorage._baseClass.setJSON(key, value);
		}

		LocalStorage.getJSON = function (key) {
			return LocalStorage._baseClass.getJSON(key);
		}

		LocalStorage.removeItem = function (key) {
			LocalStorage._baseClass.removeItem(key);
		}

		LocalStorage.clear = function () {
			LocalStorage._baseClass.clear();
		}

		LocalStorage._baseClass = null;
		LocalStorage.items = null;
		LocalStorage.support = false;
		LocalStorage.__init$ = function () {
			//class Storage
			Storage = (function () {
				function Storage() { }
				__class(Storage, '');
				Storage.init = function () {
				/*__JS__ */try { Storage.items = window.localStorage; Storage.setItem('laya', '1'); Storage.removeItem('laya'); Storage.support = true; } catch (e) { } if (!Storage.support) console.log('LocalStorage is not supprot or browser is private mode.');
				}
				Storage.setItem = function (key, value) {
					try {
						Storage.support && Storage.items.setItem(key, value);
					} catch (e) {
						console.warn("set localStorage failed", e);
					}
				}
				Storage.getItem = function (key) {
					return Storage.support ? Storage.items.getItem(key) : null;
				}
				Storage.setJSON = function (key, value) {
					try {
						Storage.support && Storage.items.setItem(key, JSON.stringify(value));
					} catch (e) {
						console.warn("set localStorage failed", e);
					}
				}
				Storage.getJSON = function (key) {
					return JSON.parse(Storage.support ? Storage.items.getItem(key) : null);
				}
				Storage.removeItem = function (key) {
					Storage.support && Storage.items.removeItem(key);
				}
				Storage.clear = function () {
					Storage.support && Storage.items.clear();
				}
				Storage.items = null;
				Storage.support = false;
				return Storage;
			})()
		}

		return LocalStorage;
	})()


	/**
	*<p>资源版本的生成由the3cmd或IDE完成，使用 <code>ResourceVersion</code> 简化使用过程。</p>
	*<p>调用 <code>enable</code> 启用资源版本管理。</p>
	*/
	//class laya.net.ResourceVersion
	var ResourceVersion = (function () {
		function ResourceVersion() { }
		__class(ResourceVersion, 'laya.net.ResourceVersion');
		ResourceVersion.enable = function (manifestFile, callback, type) {
			(type === void 0) && (type = 2);
			laya.net.ResourceVersion.type = type;
			Laya.loader.load(manifestFile, Handler.create(null, ResourceVersion.onManifestLoaded, [callback]), null,/*laya.net.Loader.JSON*/"json");
			URL.customFormat = ResourceVersion.addVersionPrefix;
		}

		ResourceVersion.onManifestLoaded = function (callback, data) {
			ResourceVersion.manifest = data;
			callback.run();
			if (!data) {
				console.warn("资源版本清单文件不存在，不使用资源版本管理。忽略ERR_FILE_NOT_FOUND错误。");
			}
		}

		ResourceVersion.addVersionPrefix = function (originURL) {
			if (ResourceVersion.manifest && ResourceVersion.manifest[originURL]) {
				if (ResourceVersion.type == 2) return ResourceVersion.manifest[originURL];
				return ResourceVersion.manifest[originURL] + "/" + originURL;
			}
			return originURL;
		}

		ResourceVersion.FOLDER_VERSION = 1;
		ResourceVersion.FILENAME_VERSION = 2;
		ResourceVersion.manifest = null;
		ResourceVersion.type = 1;
		return ResourceVersion;
	})()


	/**
	*@private
	*/
	//class laya.net.TTFLoader
	var TTFLoader = (function () {
		function TTFLoader() {
			this.fontName = null;
			this.complete = null;
			this.err = null;
			this._fontTxt = null;
			this._url = null;
			this._div = null;
			this._txtWidth = NaN;
			this._http = null;
		}

		__class(TTFLoader, 'laya.net.TTFLoader');
		var __proto = TTFLoader.prototype;
		__proto.load = function (fontPath) {
			this._url = fontPath;
			var tArr = fontPath.split(".ttf")[0].split("/");
			this.fontName = tArr[tArr.length - 1];
			if (Browser.window.conch) {
				this._loadConch();
			} else
				if (Browser.window.FontFace) {
					this._loadWithFontFace()
				}
				else {
					this._loadWithCSS();
				}
		}

		__proto._loadConch = function () {
			this._http = new HttpRequest();
			this._http.on(/*laya.events.Event.ERROR*/"error", this, this._onErr);
			this._http.on(/*laya.events.Event.COMPLETE*/"complete", this, this._onHttpLoaded);
			this._http.send(this._url, null, "get",/*laya.net.Loader.BUFFER*/"arraybuffer");
		}

		__proto._onHttpLoaded = function (data) {
			Browser.window.conch.setFontFaceFromBuffer(this.fontName, data);
			this._clearHttp();
			this._complete();
		}

		__proto._clearHttp = function () {
			if (this._http) {
				this._http.off(/*laya.events.Event.ERROR*/"error", this, this._onErr);
				this._http.off(/*laya.events.Event.COMPLETE*/"complete", this, this._onHttpLoaded);
				this._http = null;
			}
		}

		__proto._onErr = function () {
			this._clearHttp();
			if (this.err) {
				this.err.runWith("fail:" + this._url);
				this.err = null;
			}
		}

		__proto._complete = function () {
			Laya.timer.clear(this, this._complete);
			Laya.timer.clear(this, this._checkComplete);
			if (this._div && this._div.parentNode) {
				this._div.parentNode.removeChild(this._div);
				this._div = null;
			}
			if (this.complete) {
				this.complete.runWith(this);
				this.complete = null;
			}
		}

		__proto._checkComplete = function () {
			if (RunDriver.measureText("The3TTFFont", this._fontTxt).width != this._txtWidth) {
				this._complete();
			}
		}

		__proto._loadWithFontFace = function () {
			var fontFace = new Browser.window.FontFace(this.fontName, "url('" + this._url + "')");
			Browser.window.document.fonts.add(fontFace);
			var self = this;
			fontFace.loaded.then((function () {
				self._complete()
			}));
			fontFace.load();
		}

		__proto._createDiv = function () {
			this._div = Browser.createElement("div");
			this._div.innerHTML = "laya";
			var _style = this._div.style;
			_style.fontFamily = this.fontName;
			_style.position = "absolute";
			_style.left = "-100px";
			_style.top = "-100px";
			Browser.document.body.appendChild(this._div);
		}

		__proto._loadWithCSS = function () {
			var _$this = this;
			var fontStyle = Browser.createElement("style");
			fontStyle.type = "text/css";
			Browser.document.body.appendChild(fontStyle);
			fontStyle.textContent = "@font-face { font-family:'" + this.fontName + "'; src:url('" + this._url + "');}";
			this._fontTxt = "40px " + this.fontName;
			this._txtWidth = RunDriver.measureText("The3TTFFont", this._fontTxt).width;
			var self = this;
			fontStyle.onload = function () {
				Laya.timer.once(10000, self, _$this._complete);
			};
			Laya.timer.loop(20, this, this._checkComplete);
			this._createDiv();
		}

		TTFLoader._testString = "The3TTFFont";
		return TTFLoader;
	})()


	/**
	*<p> <code>URL</code> 类用于定义地址信息。</p>
	*/
	//class laya.net.URL
	var URL = (function () {
		function URL(url) {
			/**@private */
			this._url = null;
			/**@private */
			this._path = null;
			this._url = URL.formatURL(url);
			this._path = URL.getPath(url);
		}

		__class(URL, 'laya.net.URL');
		var __proto = URL.prototype;
		/**地址的路径。*/
		__getset(0, __proto, 'path', function () {
			return this._path;
		});

		/**格式化后的地址。*/
		__getset(0, __proto, 'url', function () {
			return this._url;
		});

		URL.formatURL = function (url, base) {
			if (!url) return "null path";
			if (url.indexOf(":") > 0) return url;
			if (URL.customFormat != null) url = URL.customFormat(url, base);
			var char1 = url.charAt(0);
			if (char1 === ".") {
				return URL.formatRelativePath((base || URL.basePath) + url);
			} else if (char1 === '~') {
				return URL.rootPath + url.substring(1);
			} else if (char1 === "d") {
				if (url.indexOf("data:image") === 0) return url;
			} else if (char1 === "/") {
				return url;
			}
			return (base || URL.basePath) + url;
		}

		URL.formatRelativePath = function (value) {
			var parts = value.split("/");
			for (var i = 0, len = parts.length; i < len; i++) {
				if (parts[i] == '..') {
					parts.splice(i - 1, 2);
					i -= 2;
				}
			}
			return parts.join('/');
		}

		URL.isAbsolute = function (url) {
			return url.indexOf(":") > 0 || url.charAt(0) == '/';
		}

		URL.getPath = function (url) {
			var ofs = url.lastIndexOf('/');
			return ofs > 0 ? url.substr(0, ofs + 1) : "";
		}

		URL.getFileName = function (url) {
			var ofs = url.lastIndexOf('/');
			return ofs > 0 ? url.substr(ofs + 1) : url;
		}

		URL.version = {};
		URL.basePath = "";
		URL.rootPath = "";
		URL.customFormat = function (url) {
			var newUrl = URL.version[url];
			if (!Render.isConchApp && newUrl) url += "?v=" + newUrl;
			return url;
		}

		return URL;
	})()


	/**
	*@private
	*<code>Render</code> 是渲染管理类。它是一个单例，可以使用 Laya.render 访问。
	*/
	//class laya.renders.Render
	var Render = (function () {
		function Render(width, height) {
			/**@private */
			this._timeId = 0;
			var style = Render._mainCanvas.source.style;
			style.position = 'absolute';
			style.top = style.left = "0px";
			style.background = "#000000";
			Render._mainCanvas.source.id = "the3Canvas";
			var isWebGl = laya.renders.Render.isWebGL;
			Render._mainCanvas.source.width = width;
			Render._mainCanvas.source.height = height;
			isWebGl && Render.WebGL.init(Render._mainCanvas, width, height);
			Browser.container.appendChild(Render._mainCanvas.source);
			Render._context = new RenderContext(width, height, isWebGl ? null : Render._mainCanvas);
			Render._context.ctx.setIsMainContext();
			Browser.window.requestAnimationFrame(loop);
			function loop() {
				Laya.stage._loop();
				Browser.window.requestAnimationFrame(loop);
			}
			Laya.stage.on("visibilitychange", this, this._onVisibilitychange);
		}

		__class(Render, 'laya.renders.Render');
		var __proto = Render.prototype;
		/**@private */
		__proto._onVisibilitychange = function () {
			if (!Laya.stage.isVisibility) {
				this._timeId = Browser.window.setInterval(this._enterFrame, 1000);
			} else if (this._timeId != 0) {
				Browser.window.clearInterval(this._timeId);
			}
		}

		/**@private */
		__proto._enterFrame = function (e) {
			Laya.stage._loop();
		}

		/**目前使用的渲染器。*/
		__getset(1, Render, 'context', function () {
			return Render._context;
		});

		/**渲染使用的原生画布引用。 */
		__getset(1, Render, 'canvas', function () {
			return Render._mainCanvas.source;
		});

		Render._context = null;
		Render._mainCanvas = null;
		Render.WebGL = null;
		Render.isConchNode = false;
		Render.isConchApp = false;
		Render.isConchWebGL = false;
		Render.isWebGL = false;
		Render.is3DMode = false;
		Render.optimizeTextureMemory = function (url, texture) {
			return true;
		}

		Render.__init$ = function () {
		/*__JS__ */window.ConchRenderType = window.ConchRenderType || 1;
		/*__JS__ */window.ConchRenderType |= (!window.conch ? 0 : 0x04);; {
				Render.isConchNode =/*__JS__ */(window.ConchRenderType & 5) == 5;
				Render.isConchApp =/*__JS__ */(window.ConchRenderType & 0x04) == 0x04;
				Render.isConchWebGL =/*__JS__ */window.ConchRenderType == 6;
			};;
		}

		return Render;
	})()


	/**
	*@private
	*渲染环境
	*/
	//class laya.renders.RenderContext
	var RenderContext = (function () {
		function RenderContext(width, height, canvas) {
			/**全局x坐标 */
			this.x = 0;
			/**全局y坐标 */
			this.y = 0;
			/**当前使用的画布 */
			//this.canvas=null;
			/**当前使用的画布上下文 */
			//this.ctx=null;
			this._drawTexture = function (x, y, args) {
				if (args[0].loaded) this.ctx.drawTexture(args[0], args[1], args[2], args[3], args[4], x, y);
			}
			this._fillTexture = function (x, y, args) {
				if (args[0].loaded) this.ctx.fillTexture(args[0], args[1] + x, args[2] + y, args[3], args[4], args[5], args[6], args[7]);
			}
			this._drawTextureWithTransform = function (x, y, args) {
				if (args[0].loaded) this.ctx.drawTextureWithTransform(args[0], args[1], args[2], args[3], args[4], args[5], x, y, args[6]);
			}
			this._fillQuadrangle = function (x, y, args) {
				this.ctx.fillQuadrangle(args[0], args[1], args[2], args[3], args[4]);
			}
			this._drawRect = function (x, y, args) {
				var ctx = this.ctx;
				if (args[4] != null) {
					ctx.fillStyle = args[4];
					ctx.fillRect(x + args[0], y + args[1], args[2], args[3], null);
				}
				if (args[5] != null) {
					ctx.strokeStyle = args[5];
					ctx.lineWidth = args[6];
					ctx.strokeRect(x + args[0], y + args[1], args[2], args[3], args[6]);
				}
			}
			//矢量方法
			this._drawPie = function (x, y, args) {
				var ctx = this.ctx;
				Render.isWebGL && ctx.setPathId(args[8]);
				ctx.beginPath();
				if (Render.isWebGL) {
					ctx.movePath(args[0] + x, args[1] + y);
					ctx.moveTo(0, 0);
				} else {
					ctx.moveTo(x + args[0], y + args[1]);
				}
				ctx.arc(x + args[0], y + args[1], args[2], args[3], args[4]);
				ctx.closePath();
				this._fillAndStroke(args[5], args[6], args[7], true);
			}
			this._clipRect = function (x, y, args) {
				this.ctx.clipRect(x + args[0], y + args[1], args[2], args[3]);
			}
			this._fillRect = function (x, y, args) {
				this.ctx.fillRect(x + args[0], y + args[1], args[2], args[3], args[4]);
			}
			this._drawCircle = function (x, y, args) {
				var ctx = this.ctx;
				Render.isWebGL && ctx.setPathId(args[6]);
				Stat.drawCall++;
				ctx.beginPath();
				Render.isWebGL && ctx.movePath(args[0] + x, args[1] + y);
				ctx.arc(args[0] + x, args[1] + y, args[2], 0, RenderContext.PI2);
				ctx.closePath();
				this._fillAndStroke(args[3], args[4], args[5], true);
			}
			this._fillCircle = function (x, y, args) {
				Stat.drawCall++;
				var ctx = this.ctx;
				ctx.beginPath();
				ctx.fillStyle = args[3];
				ctx.arc(args[0] + x, args[1] + y, args[2], 0, RenderContext.PI2);
				ctx.fill();
			}
			this._setShader = function (x, y, args) {
				this.ctx.setShader(args[0]);
			}
			this._drawLine = function (x, y, args) {
				var ctx = this.ctx;
				Render.isWebGL && ctx.setPathId(args[6]);
				ctx.beginPath();
				ctx.strokeStyle = args[4];
				ctx.lineWidth = args[5];
				if (Render.isWebGL) {
					ctx.movePath(x, y);
					ctx.moveTo(args[0], args[1]);
					ctx.lineTo(args[2], args[3]);
				} else {
					ctx.moveTo(x + args[0], y + args[1]);
					ctx.lineTo(x + args[2], y + args[3]);
				}
				ctx.stroke();
			}
			this._drawLines = function (x, y, args) {
				var ctx = this.ctx;
				Render.isWebGL && ctx.setPathId(args[5]);
				ctx.beginPath();
				x += args[0], y += args[1];
				Render.isWebGL && ctx.movePath(x, y);
				ctx.strokeStyle = args[3];
				ctx.lineWidth = args[4];
				var points = args[2];
				var i = 2, n = points.length;
				if (Render.isWebGL) {
					ctx.moveTo(points[0], points[1]);
					while (i < n) {
						ctx.lineTo(points[i++], points[i++]);
					}
				} else {
					ctx.moveTo(x + points[0], y + points[1]);
					while (i < n) {
						ctx.lineTo(x + points[i++], y + points[i++]);
					}
				}
				ctx.stroke();
			}
			this._drawLinesWebGL = function (x, y, args) {
				this.ctx.drawLines(x + this.x + args[0], y + this.y + args[1], args[2], args[3], args[4]);
			}
			//x:Number,y:Number,points:Array,lineColor:String,lineWidth:Number=1
			this._drawCurves = function (x, y, args) {
				this.ctx.drawCurves(x, y, args);
			}
			this._draw = function (x, y, args) {
				args[0].call(null, this, x, y);
			}
			this._transformByMatrix = function (x, y, args) {
				this.ctx.transformByMatrix(args[0]);
			}
			this._setTransform = function (x, y, args) {
				this.ctx.setTransform(args[0], args[1], args[2], args[3], args[4], args[5]);
			}
			this._setTransformByMatrix = function (x, y, args) {
				this.ctx.setTransformByMatrix(args[0]);
			}
			this._save = function (x, y, args) {
				this.ctx.save();
			}
			this._restore = function (x, y, args) {
				this.ctx.restore();
			}
			this._translate = function (x, y, args) {
				this.ctx.translate(args[0], args[1]);
			}
			this._transform = function (x, y, args) {
				this.ctx.translate(args[1] + x, args[2] + y);
				var mat = args[0];
				this.ctx.transform(mat.a, mat.b, mat.c, mat.d, mat.tx, mat.ty);
				this.ctx.translate(-x - args[1], -y - args[2]);
			}
			this._rotate = function (x, y, args) {
				this.ctx.translate(args[1] + x, args[2] + y);
				this.ctx.rotate(args[0]);
				this.ctx.translate(-x - args[1], -y - args[2]);
			}
			this._scale = function (x, y, args) {
				this.ctx.translate(args[2] + x, args[3] + y);
				this.ctx.scale(args[0], args[1]);
				this.ctx.translate(-x - args[2], -y - args[3]);
			}
			this._alpha = function (x, y, args) {
				this.ctx.globalAlpha *= args[0];
			}
			this._setAlpha = function (x, y, args) {
				this.ctx.globalAlpha = args[0];
			}
			this._fillText = function (x, y, args) {
				this.ctx.fillText(args[0], args[1] + x, args[2] + y, args[3], args[4], args[5]);
			}
			this._strokeText = function (x, y, args) {
				this.ctx.strokeText(args[0], args[1] + x, args[2] + y, args[3], args[4], args[5], args[6]);
			}
			this._fillBorderText = function (x, y, args) {
				this.ctx.fillBorderText(args[0], args[1] + x, args[2] + y, args[3], args[4], args[5], args[6], args[7]);
			}
			this._blendMode = function (x, y, args) {
				this.ctx.globalCompositeOperation = args[0];
			}
			this._beginClip = function (x, y, args) {
				this.ctx.beginClip && this.ctx.beginClip(x + args[0], y + args[1], args[2], args[3]);
			}
			this._setIBVB = function (x, y, args) {
				this.ctx.setIBVB(args[0] + x, args[1] + y, args[2], args[3], args[4], args[5], args[6], args[7]);
			}
			this._fillTrangles = function (x, y, args) {
				this.ctx.fillTrangles(args[0], args[1] + x, args[2] + y, args[3], args[4]);
			}
			//x:Number,y:Number,paths:Array,brush:Object=null,pen:Object=null
			this._drawPath = function (x, y, args) {
				var ctx = this.ctx;
				Render.isWebGL && ctx.setPathId(-1);
				ctx.beginPath();
				x += args[0], y += args[1];
				Render.isWebGL && ctx.movePath(x, y);
				var paths = args[2];
				for (var i = 0, n = paths.length; i < n; i++) {
					var path = paths[i];
					switch (path[0]) {
						case "moveTo":
							Render.isWebGL ? ctx.moveTo(path[1], path[2]) : ctx.moveTo(x + path[1], y + path[2]);
							break;
						case "lineTo":
							Render.isWebGL ? ctx.lineTo(path[1], path[2]) : ctx.lineTo(x + path[1], y + path[2]);
							break;
						case "arcTo":
							Render.isWebGL ? ctx.arcTo(path[1], path[2], path[3], path[4], path[5]) : ctx.arcTo(x + path[1], y + path[2], x + path[3], y + path[4], path[5]);
							break;
						case "closePath":
							ctx.closePath();
							break;
					}
				};
				var brush = args[3];
				if (brush != null) {
					ctx.fillStyle = brush.fillStyle;
					ctx.fill();
				};
				var pen = args[4];
				if (pen != null) {
					ctx.strokeStyle = pen.strokeStyle;
					ctx.lineWidth = pen.lineWidth || 1;
					ctx.lineJoin = pen.lineJoin;
					ctx.lineCap = pen.lineCap;
					ctx.miterLimit = pen.miterLimit;
					ctx.stroke();
				}
			}
			// polygon(x:Number,y:Number,r:Number,edges:Number,color:uint,borderWidth:int=2,borderColor:uint=0)
			this.drawPoly = function (x, y, args) {
				this.ctx.drawPoly(x + this.x + args[0], y + this.y + args[1], args[2], args[3], args[4], args[5], args[6]);
			}
			//x:Number,y:Number,points:Array,fillColor:String,lineColor:String=null,lineWidth:Number=1
			this._drawPoly = function (x, y, args) {
				var ctx = this.ctx;
				var points = args[2];
				var i = 2, n = points.length;
				if (Render.isWebGL) {
					ctx.setPathId(args[6]);
					ctx.beginPath();
					x += args[0], y += args[1];
					ctx.movePath(x, y);
					ctx.moveTo(points[0], points[1]);
					while (i < n) {
						ctx.lineTo(points[i++], points[i++]);
					}
				} else {
					ctx.beginPath();
					x += args[0], y += args[1];
					ctx.moveTo(x + points[0], y + points[1]);
					while (i < n) {
						ctx.lineTo(x + points[i++], y + points[i++]);
					}
				}
				ctx.closePath();
				this._fillAndStroke(args[3], args[4], args[5], args[7]);
			}
			this._drawSkin = function (x, y, args) {
				var tSprite = args[0];
				if (tSprite) {
					var ctx = this.ctx;
					tSprite.render(ctx, x, y);
				}
			}
			this._drawParticle = function (x, y, args) {
				this.ctx.drawParticle(x + this.x, y + this.y, args[0]);
			}
			this._setFilters = function (x, y, args) {
				this.ctx.setFilters(args);
			}
			if (canvas) {
				this.ctx = canvas.getContext('2d');
			} else {
				canvas = HTMLCanvas.create("3D");
				this.ctx = RunDriver.createWebGLContext2D(canvas);
				canvas._setContext(this.ctx);
			}
			canvas.size(width, height);
			this.canvas = canvas;
		}

		__class(RenderContext, 'laya.renders.RenderContext');
		var __proto = RenderContext.prototype;
		/**销毁当前渲染环境*/
		__proto.destroy = function () {
			if (this.canvas) {
				this.canvas.destroy();
				this.canvas = null;
				this.ctx = null;
			}
			if (this.ctx) {
				this.ctx.destroy();
				this.ctx = null;
			}
		}

		__proto.drawTexture = function (tex, x, y, width, height) {
			if (tex.loaded) this.ctx.drawTexture(tex, x, y, width, height, this.x, this.y);
		}

		__proto._drawTextures = function (x, y, args) {
			if (args[0].loaded) this.ctx.drawTextures(args[0], args[1], x + this.x, y + this.y);
		}

		__proto.drawTextureWithTransform = function (tex, x, y, width, height, m, alpha) {
			if (tex.loaded) this.ctx.drawTextureWithTransform(tex, x, y, width, height, m, this.x, this.y, alpha);
		}

		__proto.fillQuadrangle = function (tex, x, y, point4, m) {
			this.ctx.fillQuadrangle(tex, x, y, point4, m);
		}

		__proto.drawCanvas = function (canvas, x, y, width, height) {
			this.ctx.drawCanvas(canvas, x + this.x, y + this.y, width, height);
		}

		__proto.drawRect = function (x, y, width, height, color, lineWidth) {
			(lineWidth === void 0) && (lineWidth = 1);
			var ctx = this.ctx;
			ctx.strokeStyle = color;
			ctx.lineWidth = lineWidth;
			ctx.strokeRect(x + this.x, y + this.y, width, height, lineWidth);
		}

		__proto._fillAndStroke = function (fillColor, strokeColor, lineWidth, isConvexPolygon) {
			(isConvexPolygon === void 0) && (isConvexPolygon = false);
			var ctx = this.ctx;
			if (fillColor != null) {
				ctx.fillStyle = fillColor;
				if (Render.isWebGL) {
					ctx.fill(isConvexPolygon);
				} else {
					ctx.fill();
				}
			}
			if (strokeColor != null && lineWidth > 0) {
				ctx.strokeStyle = strokeColor;
				ctx.lineWidth = lineWidth;
				ctx.stroke();
			}
		}

		//ctx.translate(-x-args[0],-y-args[1]);
		__proto.clipRect = function (x, y, width, height) {
			this.ctx.clipRect(x + this.x, y + this.y, width, height);
		}

		__proto.fillRect = function (x, y, width, height, fillStyle) {
			this.ctx.fillRect(x + this.x, y + this.y, width, height, fillStyle);
		}

		__proto.drawCircle = function (x, y, radius, color, lineWidth) {
			(lineWidth === void 0) && (lineWidth = 1);
			Stat.drawCall++;
			var ctx = this.ctx;
			ctx.beginPath();
			ctx.strokeStyle = color;
			ctx.lineWidth = lineWidth;
			ctx.arc(x + this.x, y + this.y, radius, 0, RenderContext.PI2);
			ctx.stroke();
		}

		/**
		*绘制三角形
		*@param x
		*@param y
		*@param tex
		*@param args [x,y,texture,vertices,indices,uvs,matrix]
		*/
		__proto.drawTriangles = function (x, y, args) {
			if (Render.isWebGL) {
				this.ctx.drawTriangles(args[0], x + args[1], y + args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9]);
			} else {
				var indices = args[5];
				var i = 0, len = indices.length;
				var ctx = this.ctx;
				for (i = 0; i < len; i += 3) {
					var index0 = indices[i] * 2;
					var index1 = indices[i + 1] * 2;
					var index2 = indices[i + 2] * 2;
					ctx.drawTriangle(args[0], args[3], args[4], index0, index1, index2, args[6], true);
				}
			}
		}

		__proto.fillCircle = function (x, y, radius, color) {
			Stat.drawCall++;
			var ctx = this.ctx;
			ctx.beginPath();
			ctx.fillStyle = color;
			ctx.arc(x + this.x, y + this.y, radius, 0, RenderContext.PI2);
			ctx.fill();
		}

		__proto.setShader = function (shader) {
			this.ctx.setShader(shader);
		}

		__proto.drawLine = function (fromX, fromY, toX, toY, color, lineWidth) {
			(lineWidth === void 0) && (lineWidth = 1);
			var ctx = this.ctx;
			ctx.beginPath();
			ctx.strokeStyle = color;
			ctx.lineWidth = lineWidth;
			ctx.moveTo(this.x + fromX, this.y + fromY);
			ctx.lineTo(this.x + toX, this.y + toY);
			ctx.stroke();
		}

		__proto.clear = function () {
			this.ctx.clear();
		}

		__proto.transformByMatrix = function (value) {
			this.ctx.transformByMatrix(value);
		}

		__proto.setTransform = function (a, b, c, d, tx, ty) {
			this.ctx.setTransform(a, b, c, d, tx, ty);
		}

		__proto.setTransformByMatrix = function (value) {
			this.ctx.setTransformByMatrix(value);
		}

		__proto.save = function () {
			this.ctx.save();
		}

		__proto.restore = function () {
			this.ctx.restore();
		}

		__proto.translate = function (x, y) {
			this.ctx.translate(x, y);
		}

		__proto.transform = function (a, b, c, d, tx, ty) {
			this.ctx.transform(a, b, c, d, tx, ty);
		}

		__proto.rotate = function (angle) {
			this.ctx.rotate(angle);
		}

		__proto.scale = function (scaleX, scaleY) {
			this.ctx.scale(scaleX, scaleY);
		}

		__proto.alpha = function (value) {
			this.ctx.globalAlpha *= value;
		}

		__proto.setAlpha = function (value) {
			this.ctx.globalAlpha = value;
		}

		__proto.fillWords = function (words, x, y, font, color, underLine) {
			(underLine === void 0) && (underLine = 0);
			this.ctx.fillWords(words, x, y, font, color, underLine);
		}

		/***@private */
		__proto.fillBorderWords = function (words, x, y, font, fillColor, borderColor, lineWidth) {
			this.ctx.fillBorderWords(words, x, y, font, fillColor, borderColor, lineWidth);
		}

		__proto.fillText = function (text, x, y, font, color, textAlign) {
			this.ctx.fillText(text, x + this.x, y + this.y, font, color, textAlign);
		}

		__proto.strokeText = function (text, x, y, font, color, lineWidth, textAlign) {
			this.ctx.strokeText(text, x + this.x, y + this.y, font, color, lineWidth, textAlign);
		}

		__proto.blendMode = function (type) {
			this.ctx.globalCompositeOperation = type;
		}

		__proto.flush = function () {
			this.ctx.flush && this.ctx.flush();
		}

		__proto.addRenderObject = function (o) {
			this.ctx.addRenderObject(o);
		}

		__proto.beginClip = function (x, y, w, h) {
			this.ctx.beginClip && this.ctx.beginClip(x, y, w, h);
		}

		__proto.endClip = function () {
			this.ctx.endClip && this.ctx.endClip();
		}

		__proto.fillTrangles = function (x, y, args) {
			this.ctx.fillTrangles(args[0], args[1], args[2], args[3], args.length > 4 ? args[4] : null);
		}

		RenderContext.PI2 = 2 * Math.PI;
		return RenderContext;
	})()


	/**
	*@private
	*精灵渲染器
	*/
	//class laya.renders.RenderSprite
	var RenderSprite = (function () {
		function RenderSprite(type, next) {
			/**@private */
			//this._next=null;
			/**@private */
			//this._fun=null;
			this._next = next || RenderSprite.NORENDER;
			switch (type) {
				case 0:
					this._fun = this._no;
					return;
				case 0x01:
					this._fun = this._image;
					return;
				case 0x02:
					this._fun = this._alpha;
					return;
				case 0x04:
					this._fun = this._transform;
					return;
				case 0x08:
					this._fun = this._blend;
					return;
				case 0x10:
					this._fun = this._canvas;
					return;
				case 0x40:
					this._fun = this._mask;
					return;
				case 0x80:
					this._fun = this._clip;
					return;
				case 0x100:
					this._fun = this._style;
					return;
				case 0x200:
					this._fun = this._graphics;
					return;
				case 0x800:
					this._fun = this._childs;
					return;
				case 0x400:
					this._fun = this._custom;
					return;
				case 0x01 | 0x200:
					this._fun = this._image2;
					return;
				case 0x01 | 0x04 | 0x200:
					this._fun = this._image2;
					return;
				case 0x20:
					this._fun = Filter._filter;
					return;
				case 0x11111:
					this._fun = RenderSprite._initRenderFun;
					return;
			}
			this.onCreate(type);
		}

		__class(RenderSprite, 'laya.renders.RenderSprite');
		var __proto = RenderSprite.prototype;
		__proto.onCreate = function (type) { }
		__proto._style = function (sprite, context, x, y) {
			sprite._style.render(sprite, context, x, y);
			var next = this._next;
			next._fun.call(next, sprite, context, x, y);
		}

		__proto._no = function (sprite, context, x, y) { }
		__proto._custom = function (sprite, context, x, y) {
			sprite.customRender(context, x, y);
			var tf = sprite._style._tf;
			this._next._fun.call(this._next, sprite, context, x - tf.translateX, y - tf.translateY);
		}

		__proto._clip = function (sprite, context, x, y) {
			var next = this._next;
			if (next == RenderSprite.NORENDER) return;
			var r = sprite._style.scrollRect;
			context.ctx.save();
			context.ctx.clipRect(x, y, r.width, r.height);
			next._fun.call(next, sprite, context, x - r.x, y - r.y);
			context.ctx.restore();
		}

		__proto._blend = function (sprite, context, x, y) {
			var style = sprite._style;
			if (style.blendMode) {
				context.ctx.globalCompositeOperation = style.blendMode;
			};
			var next = this._next;
			next._fun.call(next, sprite, context, x, y);
			context.ctx.globalCompositeOperation = "source-over";
		}

		__proto._mask = function (sprite, context, x, y) {
			var next = this._next;
			next._fun.call(next, sprite, context, x, y);
			var mask = sprite.mask;
			if (mask) {
				context.ctx.globalCompositeOperation = "destination-in";
				if (mask.numChildren > 0 || !mask.graphics._isOnlyOne()) {
					mask.cacheAsBitmap = true;
				}
				mask.render(context, x - sprite.pivotX, y - sprite.pivotY);
			}
			context.ctx.globalCompositeOperation = "source-over";
		}

		__proto._graphics = function (sprite, context, x, y) {
			var tf = sprite._style._tf;
			sprite._graphics && sprite._graphics._render(sprite, context, x - tf.translateX, y - tf.translateY);
			var next = this._next;
			next._fun.call(next, sprite, context, x, y);
		}

		__proto._image = function (sprite, context, x, y) {
			var style = sprite._style;
			context.ctx.drawTexture2(x, y, style._tf.translateX, style._tf.translateY, sprite.transform, style.alpha, style.blendMode, sprite._graphics._one);
		}

		__proto._image2 = function (sprite, context, x, y) {
			var tf = sprite._style._tf;
			context.ctx.drawTexture2(x, y, tf.translateX, tf.translateY, sprite.transform, 1, null, sprite._graphics._one);
		}

		__proto._alpha = function (sprite, context, x, y) {
			var style = sprite._style;
			var alpha;
			if ((alpha = style.alpha) > 0.01 || sprite._needRepaint()) {
				var temp = context.ctx.globalAlpha;
				context.ctx.globalAlpha *= alpha;
				var next = this._next;
				next._fun.call(next, sprite, context, x, y);
				context.ctx.globalAlpha = temp;
			}
		}

		__proto._transform = function (sprite, context, x, y) {
			var transform = sprite.transform, _next = this._next;
			if (transform && _next != RenderSprite.NORENDER) {
				context.save();
				context.transform(transform.a, transform.b, transform.c, transform.d, transform.tx + x, transform.ty + y);
				_next._fun.call(_next, sprite, context, 0, 0);
				context.restore();
			} else
				_next._fun.call(_next, sprite, context, x, y);
		}

		__proto._childs = function (sprite, context, x, y) {
			var style = sprite._style;
			var tf = style._tf;
			x = x - tf.translateX + style.paddingLeft;
			y = y - tf.translateY + style.paddingTop;
			if (style._calculation) {
				var words = sprite._getWords();
				if (words) {
					var tStyle = style;
					if (tStyle) {
						if (tStyle.stroke) {
							context.fillBorderWords(words, x, y, tStyle.font, tStyle.color, tStyle.strokeColor, tStyle.stroke);
						} else {
							context.fillWords(words, x, y, tStyle.font, tStyle.color, tStyle.underLine);
						}
					}
				}
			};
			var childs = sprite._childs, n = childs.length, ele;
			if (sprite.viewport || (sprite.optimizeScrollRect && sprite._style.scrollRect)) {
				var rect = sprite.viewport || sprite._style.scrollRect;
				var left = rect.x;
				var top = rect.y;
				var right = rect.right;
				var bottom = rect.bottom;
				var _x = NaN, _y = NaN;
				for (i = 0; i < n; ++i) {
					if ((ele = childs[i]).visible && ((_x = ele._x) < right && (_x + ele.width) > left && (_y = ele._y) < bottom && (_y + ele.height) > top)) {
						ele.render(context, x, y);
					}
				}
			} else {
				for (var i = 0; i < n; ++i)
					(ele = (childs[i]))._style.visible && ele.render(context, x, y);
			}
		}

		//}
		__proto._canvas = function (sprite, context, x, y) {
			var _cacheCanvas = sprite._$P.cacheCanvas;
			if (!_cacheCanvas) {
				this._next._fun.call(this._next, sprite, context, x, y);
				return;
			}
			_cacheCanvas.type === 'bitmap' ? (Stat.canvasBitmap++) : (Stat.canvasNormal++);
			var tx = _cacheCanvas.ctx;
			if (sprite._needRepaint() || !tx) {
				this._canvas_repaint(sprite, context, x, y);
			}
			else {
				var tRec = _cacheCanvas._cacheRec;
				context.drawCanvas(tx.canvas, x + tRec.x, y + tRec.y, tRec.width, tRec.height);
			}
		}

		__proto._canvas_repaint = function (sprite, context, x, y) {
			var _cacheCanvas = sprite._$P.cacheCanvas;
			var _next = this._next;
			if (!_cacheCanvas) {
				_next._fun.call(_next, sprite, tx, x, y);
				return;
			};
			var tx = _cacheCanvas.ctx;
			var _repaint = sprite._needRepaint() || (!tx);
			var canvas;
			var left;
			var top;
			var tRec;
			var tCacheType = _cacheCanvas.type;
			tCacheType === 'bitmap' ? (Stat.canvasBitmap++) : (Stat.canvasNormal++);
			if (_repaint) {
				if (!_cacheCanvas._cacheRec)
					_cacheCanvas._cacheRec = new Rectangle();
				var w, h;
				if (!Render.isWebGL || tCacheType === "bitmap") {
					tRec = sprite.getSelfBounds();
					tRec.x = tRec.x - sprite.pivotX;
					tRec.y = tRec.y - sprite.pivotY;
					tRec.x = tRec.x - 16;
					tRec.y = tRec.y - 16;
					tRec.width = tRec.width + 32;
					tRec.height = tRec.height + 32;
					tRec.x = Math.floor(tRec.x + x) - x;
					tRec.y = Math.floor(tRec.y + y) - y;
					tRec.width = Math.floor(tRec.width);
					tRec.height = Math.floor(tRec.height);
					_cacheCanvas._cacheRec.copyFrom(tRec);
				} else {
					_cacheCanvas._cacheRec.setTo(-sprite.pivotX, -sprite.pivotY, 1, 1);
				}
				tRec = _cacheCanvas._cacheRec;
				var scaleX = Render.isWebGL ? 1 : Browser.pixelRatio * Laya.stage.clientScaleX;
				var scaleY = Render.isWebGL ? 1 : Browser.pixelRatio * Laya.stage.clientScaleY;
				if (!Render.isWebGL) {
					var chainScaleX = 1;
					var chainScaleY = 1;
					var tar;
					tar = sprite;
					while (tar && tar != Laya.stage) {
						chainScaleX *= tar.scaleX;
						chainScaleY *= tar.scaleY;
						tar = tar.parent;
					}
					if (Render.isWebGL) {
						if (chainScaleX < 1) scaleX *= chainScaleX;
						if (chainScaleY < 1) scaleY *= chainScaleY;
					} else {
						if (chainScaleX > 1) scaleX *= chainScaleX;
						if (chainScaleY > 1) scaleY *= chainScaleY;
					}
				}
				if (sprite.scrollRect) {
					var scrollRect = sprite.scrollRect;
					tRec.x -= scrollRect.x;
					tRec.y -= scrollRect.y;
				}
				w = tRec.width * scaleX;
				h = tRec.height * scaleY;
				left = tRec.x;
				top = tRec.y;
				if (Render.isWebGL && tCacheType === 'bitmap' && (w > 2048 || h > 2048)) {
					console.warn("cache bitmap size larger than 2048,cache ignored");
					if (_cacheCanvas.ctx) {
						Pool.recover("RenderContext", _cacheCanvas.ctx);
						_cacheCanvas.ctx.canvas.size(0, 0);
						_cacheCanvas.ctx = null;
					}
					_next._fun.call(_next, sprite, context, x, y);
					return;
				}
				if (!tx) {
					tx = _cacheCanvas.ctx = Pool.getItem("RenderContext") || new RenderContext(w, h, HTMLCanvas.create(/*laya.resource.HTMLCanvas.TYPEAUTO*/"AUTO"));
				}
				tx.ctx.sprite = sprite;
				canvas = tx.canvas;
				canvas.clear();
				(canvas.width != w || canvas.height != h) && canvas.size(w, h);
				if (tCacheType === 'bitmap') canvas.context.asBitmap = true;
				else if (tCacheType === 'normal') canvas.context.asBitmap = false;
				var t;
				if (scaleX != 1 || scaleY != 1) {
					var ctx = (tx).ctx;
					ctx.save();
					ctx.scale(scaleX, scaleY);
					if (!Render.isConchWebGL && Render.isConchApp) {
						t = sprite._$P.cf;
						t && ctx.setFilterMatrix && ctx.setFilterMatrix(t._mat, t._alpha);
					}
					_next._fun.call(_next, sprite, tx, -left, -top);
					ctx.restore();
					if (!Render.isConchApp || Render.isConchWebGL) sprite._applyFilters();
				} else {
					ctx = (tx).ctx;
					if (!Render.isConchWebGL && Render.isConchApp) {
						t = sprite._$P.cf;
						t && ctx.setFilterMatrix && ctx.setFilterMatrix(t._mat, t._alpha);
					}
					_next._fun.call(_next, sprite, tx, -left, -top);
					if (!Render.isConchApp || Render.isConchWebGL) sprite._applyFilters();
				}
				if (sprite._$P.staticCache) _cacheCanvas.reCache = false;
				Stat.canvasReCache++;
			} else {
				tRec = _cacheCanvas._cacheRec;
				left = tRec.x;
				top = tRec.y;
				canvas = tx.canvas;
			}
			context.drawCanvas(canvas, x + left, y + top, tRec.width, tRec.height);
		}

		RenderSprite.__init__ = function () {
			var i = 0, len = 0;
			var initRender;
			initRender = RunDriver.createRenderSprite(0x11111, null);
			len = RenderSprite.renders.length = 0x800 * 2;
			for (i = 0; i < len; i++)
				RenderSprite.renders[i] = initRender;
			RenderSprite.renders[0] = RunDriver.createRenderSprite(0, null);
			function _initSame(value, o) {
				var n = 0;
				for (var i = 0; i < value.length; i++) {
					n |= value[i];
					RenderSprite.renders[n] = o;
				}
			}
			_initSame([0x01, 0x200, 0x04, 0x02], new RenderSprite(0x01, null));
			RenderSprite.renders[0x01 | 0x200] = RunDriver.createRenderSprite(0x01 | 0x200, null);
			RenderSprite.renders[0x01 | 0x04 | 0x200] = new RenderSprite(0x01 | 0x04 | 0x200, null);
		}

		RenderSprite._initRenderFun = function (sprite, context, x, y) {
			var type = sprite._renderType;
			var r = RenderSprite.renders[type] = RenderSprite._getTypeRender(type);
			r._fun(sprite, context, x, y);
		}

		RenderSprite._getTypeRender = function (type) {
			var rst = null;
			var tType = 0x800;
			while (tType > 1) {
				if (tType & type)
					rst = RunDriver.createRenderSprite(tType, rst);
				tType = tType >> 1;
			}
			return rst;
		}

		RenderSprite.IMAGE = 0x01;
		RenderSprite.ALPHA = 0x02;
		RenderSprite.TRANSFORM = 0x04;
		RenderSprite.BLEND = 0x08;
		RenderSprite.CANVAS = 0x10;
		RenderSprite.FILTERS = 0x20;
		RenderSprite.MASK = 0x40;
		RenderSprite.CLIP = 0x80;
		RenderSprite.STYLE = 0x100;
		RenderSprite.GRAPHICS = 0x200;
		RenderSprite.CUSTOM = 0x400;
		RenderSprite.CHILDS = 0x800;
		RenderSprite.INIT = 0x11111;
		RenderSprite.renders = [];
		RenderSprite.NORENDER = new RenderSprite(0, null);
		return RenderSprite;
	})()


	/**
	*@private
	*Context扩展类
	*/
	//class laya.resource.Context
	var Context = (function () {
		function Context() {
			/***@private */
			//this._canvas=null;
			this._repaint = false;
		}

		__class(Context, 'laya.resource.Context');
		var __proto = Context.prototype;
		__proto.replaceReset = function () {
			var i = 0, len = 0;
			len = Context.replaceKeys.length;
			var key;
			for (i = 0; i < len; i++) {
				key = Context.replaceKeys[i];
				this[Context.newKeys[i]] = this[key];
			}
		}

		__proto.replaceResotre = function () {
		/*__JS__ */this.__restore();
		/*__JS__ */this.__reset();
		}

		__proto.setIsMainContext = function () { }
		__proto.drawTextures = function (tex, pos, tx, ty) {
			Stat.drawCall += pos.length / 2;
			var w = tex.width;
			var h = tex.height;
			for (var i = 0, sz = pos.length; i < sz; i += 2) {
				this.drawTexture(tex, pos[i], pos[i + 1], w, h, tx, ty);
			}
		}

		/***@private */
		__proto.drawCanvas = function (canvas, x, y, width, height) {
			Stat.drawCall++;
			this.drawImage(canvas.source, x, y, width, height);
		}

		/***@private */
		__proto.fillRect = function (x, y, width, height, style) {
			Stat.drawCall++;
			style && (this.fillStyle = style);
		/*__JS__ */this.__fillRect(x, y, width, height);
		}

		/***@private */
		__proto.fillText = function (text, x, y, font, color, textAlign) {
			Stat.drawCall++;
			if (arguments.length > 3 && font != null) {
				this.font = font;
				this.fillStyle = color;
			/*__JS__ */this.textAlign = textAlign;
				this.textBaseline = "top";
			}
		/*__JS__ */this.__fillText(text, x, y);
		}

		/***@private */
		__proto.fillBorderText = function (text, x, y, font, fillColor, borderColor, lineWidth, textAlign) {
			Stat.drawCall++;
			this.font = font;
			this.fillStyle = fillColor;
			this.textBaseline = "top";
		/*__JS__ */this.strokeStyle = borderColor;
		/*__JS__ */this.lineWidth = lineWidth;
		/*__JS__ */this.textAlign = textAlign;
		/*__JS__ */this.__strokeText(text, x, y);
		/*__JS__ */this.__fillText(text, x, y);
		}

		/***@private */
		__proto.strokeText = function (text, x, y, font, color, lineWidth, textAlign) {
			Stat.drawCall++;
			if (arguments.length > 3 && font != null) {
				this.font = font;
			/*__JS__ */this.strokeStyle = color;
			/*__JS__ */this.lineWidth = lineWidth;
			/*__JS__ */this.textAlign = textAlign;
				this.textBaseline = "top";
			}
		/*__JS__ */this.__strokeText(text, x, y);
		}

		/***@private */
		__proto.transformByMatrix = function (value) {
			this.transform(value.a, value.b, value.c, value.d, value.tx, value.ty);
		}

		/***@private */
		__proto.setTransformByMatrix = function (value) {
			this.setTransform(value.a, value.b, value.c, value.d, value.tx, value.ty);
		}

		/***@private */
		__proto.clipRect = function (x, y, width, height) {
			Stat.drawCall++;
			this.beginPath();
			this.rect(x, y, width, height);
			this.clip();
		}

		/***@private */
		__proto.drawTexture = function (tex, x, y, width, height, tx, ty) {
			Stat.drawCall++;
			var uv = tex.uv, w = tex.bitmap.width, h = tex.bitmap.height;
			this.drawImage(tex.source, uv[0] * w, uv[1] * h, (uv[2] - uv[0]) * w, (uv[5] - uv[3]) * h, x + tx, y + ty, width, height);
		}

		/***@private */
		__proto.drawTextureWithTransform = function (tex, x, y, width, height, m, tx, ty, alpha) {
			Stat.drawCall++;
			var uv = tex.uv, w = tex.bitmap.width, h = tex.bitmap.height;
			this.save();
			alpha != 1 && (this.globalAlpha *= alpha);
			if (m) {
				this.transform(m.a, m.b, m.c, m.d, m.tx + tx, m.ty + ty);
				this.drawImage(tex.source, uv[0] * w, uv[1] * h, (uv[2] - uv[0]) * w, (uv[5] - uv[3]) * h, x, y, width, height);
			} else {
				this.drawImage(tex.source, uv[0] * w, uv[1] * h, (uv[2] - uv[0]) * w, (uv[5] - uv[3]) * h, x + tx, y + ty, width, height);
			}
			this.restore();
		}

		/***@private */
		__proto.drawTexture2 = function (x, y, pivotX, pivotY, m, alpha, blendMode, args2) {
			'use strict';
			var tex = args2[0];
			if (!(tex.loaded && tex.bitmap && tex.source)) {
				return;
			}
			Stat.drawCall++;
			var alphaChanged = alpha !== 1;
			if (alphaChanged) {
				var temp = this.globalAlpha;
				this.globalAlpha *= alpha;
			};
			var uv = tex.uv, w = tex.bitmap.width, h = tex.bitmap.height;
			if (m) {
				this.save();
				this.transform(m.a, m.b, m.c, m.d, m.tx + x, m.ty + y);
				this.drawImage(tex.source, uv[0] * w, uv[1] * h, (uv[2] - uv[0]) * w, (uv[5] - uv[3]) * h, args2[1] - pivotX, args2[2] - pivotY, args2[3], args2[4]);
				this.restore();
			} else {
				this.drawImage(tex.source, uv[0] * w, uv[1] * h, (uv[2] - uv[0]) * w, (uv[5] - uv[3]) * h, args2[1] - pivotX + x, args2[2] - pivotY + y, args2[3], args2[4]);
			}
			if (alphaChanged) this.globalAlpha = temp;
		}

		__proto.fillTexture = function (texture, x, y, width, height, type, offset, other) {
			if (!other.pat) {
				if (texture.uv != Texture.DEF_UV) {
					var canvas = new HTMLCanvas("2D");
					canvas.getContext('2d');
					canvas.size(texture.width, texture.height);
					canvas.context.drawTexture(texture, 0, 0, texture.width, texture.height, 0, 0);
					texture = new Texture(canvas);
				}
				other.pat = this.createPattern(texture.bitmap.source, type);
			};
			var oX = x, oY = y;
			var sX = 0, sY = 0;
			if (offset) {
				oX += offset.x % texture.width;
				oY += offset.y % texture.height;
				sX -= offset.x % texture.width;
				sY -= offset.y % texture.height;
			}
			this.translate(oX, oY);
			this.fillRect(sX, sY, width, height, other.pat);
			this.translate(-oX, -oY);
		}

		__proto.drawTriangle = function (texture, vertices, uvs, index0, index1, index2, matrix, canvasPadding) {
			var source = texture.bitmap;
			var textureSource = source.source;
			var textureWidth = texture.width;
			var textureHeight = texture.height;
			var sourceWidth = source.width;
			var sourceHeight = source.height;
			var u0 = uvs[index0] * sourceWidth;
			var u1 = uvs[index1] * sourceWidth;
			var u2 = uvs[index2] * sourceWidth;
			var v0 = uvs[index0 + 1] * sourceHeight;
			var v1 = uvs[index1 + 1] * sourceHeight;
			var v2 = uvs[index2 + 1] * sourceHeight;
			var x0 = vertices[index0];
			var x1 = vertices[index1];
			var x2 = vertices[index2];
			var y0 = vertices[index0 + 1];
			var y1 = vertices[index1 + 1];
			var y2 = vertices[index2 + 1];
			if (canvasPadding) {
				var paddingX = 1;
				var paddingY = 1;
				var centerX = (x0 + x1 + x2) / 3;
				var centerY = (y0 + y1 + y2) / 3;
				var normX = x0 - centerX;
				var normY = y0 - centerY;
				var dist = Math.sqrt((normX * normX) + (normY * normY));
				x0 = centerX + ((normX / dist) * (dist + paddingX));
				y0 = centerY + ((normY / dist) * (dist + paddingY));
				normX = x1 - centerX;
				normY = y1 - centerY;
				dist = Math.sqrt((normX * normX) + (normY * normY));
				x1 = centerX + ((normX / dist) * (dist + paddingX));
				y1 = centerY + ((normY / dist) * (dist + paddingY));
				normX = x2 - centerX;
				normY = y2 - centerY;
				dist = Math.sqrt((normX * normX) + (normY * normY));
				x2 = centerX + ((normX / dist) * (dist + paddingX));
				y2 = centerY + ((normY / dist) * (dist + paddingY));
			}
			this.save();
			if (matrix)
				this.transform(matrix.a, matrix.b, matrix.c, matrix.d, matrix.tx, matrix.ty);
			this.beginPath();
			this.moveTo(x0, y0);
			this.lineTo(x1, y1);
			this.lineTo(x2, y2);
			this.closePath();
			this.clip();
			var delta = (u0 * v1) + (v0 * u2) + (u1 * v2) - (v1 * u2) - (v0 * u1) - (u0 * v2);
			var dDelta = 1 / delta;
			var deltaA = (x0 * v1) + (v0 * x2) + (x1 * v2) - (v1 * x2) - (v0 * x1) - (x0 * v2);
			var deltaB = (u0 * x1) + (x0 * u2) + (u1 * x2) - (x1 * u2) - (x0 * u1) - (u0 * x2);
			var deltaC = (u0 * v1 * x2) + (v0 * x1 * u2) + (x0 * u1 * v2) - (x0 * v1 * u2) - (v0 * u1 * x2) - (u0 * x1 * v2);
			var deltaD = (y0 * v1) + (v0 * y2) + (y1 * v2) - (v1 * y2) - (v0 * y1) - (y0 * v2);
			var deltaE = (u0 * y1) + (y0 * u2) + (u1 * y2) - (y1 * u2) - (y0 * u1) - (u0 * y2);
			var deltaF = (u0 * v1 * y2) + (v0 * y1 * u2) + (y0 * u1 * v2) - (y0 * v1 * u2) - (v0 * u1 * y2) - (u0 * y1 * v2);
			this.transform(deltaA * dDelta, deltaD * dDelta, deltaB * dDelta, deltaE * dDelta, deltaC * dDelta, deltaF * dDelta);
			this.drawImage(textureSource, texture.uv[0] * sourceWidth, texture.uv[1] * sourceHeight, textureWidth, textureHeight, texture.uv[0] * sourceWidth, texture.uv[1] * sourceHeight, textureWidth, textureHeight);
			this.restore();
		}

		/***@private */
		__proto.flush = function () {
			return 0;
		}

		/***@private */
		__proto.fillWords = function (words, x, y, font, color, underLine) {
			font && (this.font = font);
			color && (this.fillStyle = color);
			var _this = this;
			this.textBaseline = "top";
		/*__JS__ */this.textAlign = 'left';
			for (var i = 0, n = words.length; i < n; i++) {
				var a = words[i];
			/*__JS__ */this.__fillText(a.char, a.x + x, a.y + y);
				if (underLine === 1) {
					var tHeight = a.height;
					var dX = a.style.letterSpacing * 0.5;
					if (!dX) dX = 0;
					this.beginPath();
					this.strokeStyle = color;
					this.lineWidth = 1;
					this.moveTo(x + a.x - dX + 0.5, y + a.y + tHeight + 0.5);
					this.lineTo(x + a.x + a.width + dX + 0.5, y + a.y + tHeight + 0.5);
					this.stroke();
				}
			}
		}

		/***@private */
		__proto.fillBorderWords = function (words, x, y, font, color, borderColor, lineWidth) {
			font && (this.font = font);
			color && (this.fillStyle = color);
			this.textBaseline = "top";
		/*__JS__ */this.lineWidth = lineWidth;
		/*__JS__ */this.textAlign = 'left';
		/*__JS__ */this.strokeStyle = borderColor;
			for (var i = 0, n = words.length; i < n; i++) {
				var a = words[i];
			/*__JS__ */this.__strokeText(a.char, a.x + x, a.y + y);
			/*__JS__ */this.__fillText(a.char, a.x + x, a.y + y);
			}
		}

		/***@private */
		__proto.destroy = function () {
		/*__JS__ */this.canvas.width = this.canvas.height = 0;
		}

		/***@private */
		__proto.clear = function () {
			this.clearRect(0, 0, this._canvas.width, this._canvas.height);
			this._repaint = false;
		}

		__proto.drawCurves = function (x, y, args) {
			this.beginPath();
			this.strokeStyle = args[3];
			this.lineWidth = args[4];
			var points = args[2];
			x += args[0], y += args[1];
			this.moveTo(x + points[0], y + points[1]);
			var i = 2, n = points.length;
			while (i < n) {
				this.quadraticCurveTo(x + points[i++], y + points[i++], x + points[i++], y + points[i++]);
			}
			this.stroke();
		}

		Context.__init__ = function (to) {
			var from = laya.resource.Context.prototype;
			to = to || /*__JS__ */CanvasRenderingContext2D.prototype;
			if (to.inited) return;
			to.inited = true;
			to.__fillText = to.fillText;
			to.__fillRect = to.fillRect;
			to.__strokeText = to.strokeText;
			var funs = ['drawTextures', "drawTriangle", 'fillWords', 'fillBorderWords', 'setIsMainContext', 'fillRect', 'strokeText', 'fillTexture', 'fillText', 'transformByMatrix', 'setTransformByMatrix', 'clipRect', 'drawTexture', 'drawTexture2', 'drawTextureWithTransform', 'flush', 'clear', 'destroy', 'drawCanvas', 'fillBorderText', 'drawCurves'];
			funs.forEach(function (i) {
				to[i] = from[i];
			});
		}

		Context.replaceCanvasGetSet = function (tar, key) {
			var oldO =/*__JS__ */Object.getOwnPropertyDescriptor(tar, key);
			if (!oldO || !oldO.configurable) return false;
			var newO = {};
			var tkey;
			for (tkey in oldO) {
				if (tkey != "set") {
					newO[tkey] = oldO[tkey];
				}
			};
			var preFun = oldO["set"];
			newO["set"] = function (v) {
				var _self =/*__JS__ */this;
				preFun.call(_self, v);
				var _ct = _self.getContext("2d");
				if (_ct && "__reset" in _ct) {
					_ct.__reset();
				}
			}
		/*__JS__ */Object.defineProperty(tar, key, newO);
			return true;
		}

		Context.replaceGetSet = function (tar, key) {
			var oldO =/*__JS__ */Object.getOwnPropertyDescriptor(tar, key);
			if (!oldO || !oldO.configurable) return false;
			var newO = {};
			var tkey;
			for (tkey in oldO) {
				if (tkey != "set") {
					newO[tkey] = oldO[tkey];
				}
			};
			var preFun = oldO["set"];
			var dataKey = "___" + key + "__";
			Context.newKeys.push(dataKey);
			newO["set"] = function (v) {
				var _self =/*__JS__ */this;
				if (v != _self[dataKey]) {
					_self[dataKey] = v;
					preFun.call(_self, v);
				}
			}
		/*__JS__ */Object.defineProperty(tar, key, newO);
			return true;
		}

		Context._default = new Context();
		Context.newKeys = [];
		__static(Context,
			['replaceKeys', function () { return this.replaceKeys = ["font", "fillStyle", "textBaseline"]; }
			]);
		return Context;
	})()


	/**
	*@private
	*<code>ResourceManager</code> 是资源管理类。它用于资源的载入、获取、销毁。
	*/
	//class laya.resource.ResourceManager
	var ResourceManager = (function () {
		function ResourceManager(name) {
			/**唯一标识ID。*/
			this._id = 0;
			/**名字。*/
			this._name = null;
			/**所管理资源。*/
			this._resources = null;
			/**所管理资源的累计内存,以字节为单位。*/
			this._memorySize = 0;
			/**垃圾回收比例，范围是0到1。*/
			this._garbageCollectionRate = NaN;
			/**自动释放机制中内存是否溢出。*/
			this._isOverflow = false;
			/**是否启用自动释放机制。*/
			this.autoRelease = false;
			/**自动释放机制的内存触发上限,以字节为单位。*/
			this.autoReleaseMaxSize = 0;
			this._id = ++ResourceManager._uniqueIDCounter;
			this._name = name ? name : "Content Manager";
			ResourceManager._isResourceManagersSorted = false;
			this._memorySize = 0;
			this._isOverflow = false;
			this.autoRelease = false;
			this.autoReleaseMaxSize = 1024 * 1024 * 512;
			this._garbageCollectionRate = 0.2;
			ResourceManager._resourceManagers.push(this);
			this._resources = [];
		}

		__class(ResourceManager, 'laya.resource.ResourceManager');
		var __proto = ResourceManager.prototype;
		Laya.imps(__proto, { "laya.resource.IDispose": true })
		/**
		*获取指定索引的资源 Resource 对象。
		*@param 索引。
		*@return 资源 Resource 对象。
		*/
		__proto.getResourceByIndex = function (index) {
			return this._resources[index];
		}

		/**
		*获取此管理器所管理的资源个数。
		*@return 资源个数。
		*/
		__proto.getResourcesLength = function () {
			return this._resources.length;
		}

		/**
		*添加指定资源。
		*@param resource 需要添加的资源 Resource 对象。
		*@return 是否添加成功。
		*/
		__proto.addResource = function (resource) {
			if (resource.resourceManager)
				resource.resourceManager.removeResource(resource);
			var index = this._resources.indexOf(resource);
			if (index === -1) {
				resource._resourceManager = this;
				this._resources.push(resource);
				this.addSize(resource.memorySize);
				return true;
			}
			return false;
		}

		/**
		*移除指定资源。
		*@param resource 需要移除的资源 Resource 对象
		*@return 是否移除成功。
		*/
		__proto.removeResource = function (resource) {
			var index = this._resources.indexOf(resource);
			if (index !== -1) {
				this._resources.splice(index, 1);
				resource._resourceManager = null;
				this._memorySize -= resource.memorySize;
				return true;
			}
			return false;
		}

		/**
		*卸载此资源管理器载入的资源。
		*/
		__proto.unload = function () {
			var tempResources = this._resources.slice(0, this._resources.length);
			for (var i = 0; i < tempResources.length; i++) {
				var resource = tempResources[i];
				resource.destroy();
			}
			tempResources.length = 0;
		}

		/**释放资源。*/
		__proto.dispose = function () {
			if (this === ResourceManager._systemResourceManager)
				throw new Error("systemResourceManager不能被释放！");
			ResourceManager._resourceManagers.splice(ResourceManager._resourceManagers.indexOf(this), 1);
			ResourceManager._isResourceManagersSorted = false;
			var tempResources = this._resources.slice(0, this._resources.length);
			for (var i = 0; i < tempResources.length; i++) {
				var resource = tempResources[i];
				resource.resourceManager.removeResource(resource);
				resource.destroy();
			}
			tempResources.length = 0;
		}

		/**
		*增加内存。
		*@param add 需要增加的内存大小。
		*/
		__proto.addSize = function (add) {
			if (add) {
				if (this.autoRelease && add > 0)
					((this._memorySize + add) > this.autoReleaseMaxSize) && (this.garbageCollection((1 - this._garbageCollectionRate) * this.autoReleaseMaxSize));
				this._memorySize += add;
			}
		}

		/**
		*垃圾回收。
		*@param reserveSize 保留尺寸。
		*/
		__proto.garbageCollection = function (reserveSize) {
			var all = this._resources;
			all = all.slice();
			all.sort(function (a, b) {
				if (!a || !b)
					throw new Error("a或b不能为空！");
				if (a.released && b.released)
					return 0;
				else if (a.released)
					return 1;
				else if (b.released)
					return -1;
				return a._lastUseFrameCount - b._lastUseFrameCount;
			});
			var currentFrameCount = Stat.loopCount;
			for (var i = 0, n = all.length; i < n; i++) {
				var resou = all[i];
				if (currentFrameCount - resou._lastUseFrameCount > 1) {
					resou.releaseResource();
				} else {
					if (this._memorySize >= reserveSize)
						this._isOverflow = true;
					return;
				}
				if (this._memorySize < reserveSize) {
					this._isOverflow = false;
					return;
				}
			}
		}

		/**
		*唯一标识 ID 。
		*/
		__getset(0, __proto, 'id', function () {
			return this._id;
		});

		/**
		*名字。
		*/
		__getset(0, __proto, 'name', function () {
			return this._name;
		}, function (value) {
			if ((value || value !== "") && this._name !== value) {
				this._name = value;
				ResourceManager._isResourceManagersSorted = false;
			}
		});

		/**
		*此管理器所管理资源的累计内存，以字节为单位。
		*/
		__getset(0, __proto, 'memorySize', function () {
			return this._memorySize;
		});

		/**
		*系统资源管理器。
		*/
		__getset(1, ResourceManager, 'systemResourceManager', function () {
			return ResourceManager._systemResourceManager;
		});

		ResourceManager.__init__ = function () {
			ResourceManager.currentResourceManager = ResourceManager.systemResourceManager;
		}

		ResourceManager.getLoadedResourceManagerByIndex = function (index) {
			return ResourceManager._resourceManagers[index];
		}

		ResourceManager.getLoadedResourceManagersCount = function () {
			return ResourceManager._resourceManagers.length;
		}

		ResourceManager.recreateContentManagers = function (force) {
			(force === void 0) && (force = false);
			var temp = ResourceManager.currentResourceManager;
			for (var i = 0; i < ResourceManager._resourceManagers.length; i++) {
				ResourceManager.currentResourceManager = ResourceManager._resourceManagers[i];
				for (var j = 0; j < ResourceManager.currentResourceManager._resources.length; j++) {
					ResourceManager.currentResourceManager._resources[j].releaseResource(force);
					ResourceManager.currentResourceManager._resources[j].activeResource(force);
				}
			}
			ResourceManager.currentResourceManager = temp;
		}

		ResourceManager.releaseContentManagers = function (force) {
			(force === void 0) && (force = false);
			var temp = ResourceManager.currentResourceManager;
			for (var i = 0; i < ResourceManager._resourceManagers.length; i++) {
				ResourceManager.currentResourceManager = ResourceManager._resourceManagers[i];
				for (var j = 0; j < ResourceManager.currentResourceManager._resources.length; j++) {
					var resource = ResourceManager.currentResourceManager._resources[j];
					(!resource.released) && (resource.releaseResource(force));
				}
			}
			ResourceManager.currentResourceManager = temp;
		}

		ResourceManager._uniqueIDCounter = 0;
		ResourceManager._isResourceManagersSorted = false;
		ResourceManager._resourceManagers = [];
		__static(ResourceManager,
			['_systemResourceManager', function () { return this._systemResourceManager = new ResourceManager("System Resource Manager"); }, 'currentResourceManager', function () { return this.currentResourceManager = ResourceManager._systemResourceManager; }
			]);
		return ResourceManager;
	})()


	/**
	*@private
	*/
	//class laya.system.System
	var System = (function () {
		function System() { }
		__class(System, 'laya.system.System');
		System.changeDefinition = function (name, classObj) {
			Laya[name] = classObj;
			var str = name + "=classObj";
		/*__JS__ */eval(str);
		}

		System.__init__ = function () {
			if (Render.isConchApp) {
			/*__JS__ */conch.disableConchResManager();
			/*__JS__ */conch.disableConchAutoRestoreLostedDevice();
			}
		}

		return System;
	})()


	SoundManager;
	/**
	*<code>Browser</code> 是浏览器代理类。封装浏览器及原生 js 提供的一些功能。
	*/
	//class laya.utils.Browser
	var Browser = (function () {
		function Browser() { }
		__class(Browser, 'laya.utils.Browser');
		/**设备像素比。*/
		__getset(1, Browser, 'pixelRatio', function () {
			Browser.__init__();
			if (Browser.userAgent.indexOf("Mozilla/6.0(Linux; Android 6.0; HUAWEI NXT-AL10 Build/HUAWEINXT-AL10)") > -1) return 2;
			return RunDriver.getPixelRatio();
		});

		/**浏览器窗口物理高度，其值等于clientHeight *pixelRatio，并且浏览器发生反转之后，宽高会互换。*/
		__getset(1, Browser, 'height', function () {
			Browser.__init__();
			return ((Laya.stage && Laya.stage.canvasRotation) ? Browser.clientWidth : Browser.clientHeight) * Browser.pixelRatio;
		});

		/**
		*浏览器窗口可视宽度。
		*通过分析浏览器信息获得。浏览器多个属性值优先级为：window.innerWidth(包含滚动条宽度)> document.body.clientWidth(不包含滚动条宽度)，如果前者为0或为空，则选择后者。
		*/
		__getset(1, Browser, 'clientWidth', function () {
			Browser.__init__();
			return Browser.window.innerWidth || Browser.document.body.clientWidth;
		});

		/**浏览器原生 window 对象的引用。*/
		__getset(1, Browser, 'window', function () {
			Browser.__init__();
			return Browser._window;
		});

		/**
		*浏览器窗口可视高度。
		*通过分析浏览器信息获得。浏览器多个属性值优先级为：window.innerHeight(包含滚动条高度)> document.body.clientHeight(不包含滚动条高度)> document.documentElement.clientHeight(不包含滚动条高度)，如果前者为0或为空，则选择后者。
		*/
		__getset(1, Browser, 'clientHeight', function () {
			Browser.__init__();
			return Browser.window.innerHeight || Browser.document.body.clientHeight || Browser.document.documentElement.clientHeight;
		});

		/**浏览器窗口物理宽度，其值等于clientWidth *pixelRatio，并且浏览器发生反转之后，宽高会互换。*/
		__getset(1, Browser, 'width', function () {
			Browser.__init__();
			return ((Laya.stage && Laya.stage.canvasRotation) ? Browser.clientHeight : Browser.clientWidth) * Browser.pixelRatio;
		});

		/**画布容器，用来盛放画布的容器。方便对画布进行控制*/
		__getset(1, Browser, 'container', function () {
			Browser.__init__();
			if (!Browser._container) {
				Browser._container = Browser.createElement("div");
				Browser._container.id = "the3Container";
				Browser.document.body.appendChild(Browser._container);
			}
			return Browser._container;
		}, function (value) {
			Browser._container = value;
		});

		/**浏览器原生 document 对象的引用。*/
		__getset(1, Browser, 'document', function () {
			Browser.__init__();
			return Browser._document;
		});

		Browser.__init__ = function () {
			SoundManager;
			if (Browser._window) return;
			Browser._window = RunDriver.getWindow();
			Browser._document = Browser.window.document;
			Browser._window.addEventListener('message', function (e) {
				laya.utils.Browser._onMessage(e);
			}, false);
		/*__JS__ */Browser.document.__createElement = Browser.document.createElement;
		/*__JS__ */window.requestAnimationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (c) { return window.setTimeout(c, 1000 / 60); };;
			Browser.userAgent =/*[SAFE]*/ Browser.window.navigator.userAgent;
			Browser.u =/*[SAFE]*/ Browser.userAgent;
			Browser.onIOS =/*[SAFE]*/ !!Browser.u.match(/\(i[^;]+;(U;)? CPU.+Mac OS X/);
			Browser.onMobile =/*[SAFE]*/ Browser.u.indexOf("Mobile") > -1;
			Browser.onIPhone =/*[SAFE]*/ Browser.u.indexOf("iPhone") > -1;
			Browser.onMac =/*[SAFE]*/ Browser.u.indexOf("Mac OS X") > -1;
			Browser.onIPad =/*[SAFE]*/ Browser.u.indexOf("iPad") > -1;
			Browser.onAndriod =/*[SAFE]*/ Browser.u.indexOf('Android') > -1 || Browser.u.indexOf('Adr') > -1;
			Browser.onWP =/*[SAFE]*/ Browser.u.indexOf("Windows Phone") > -1;
			Browser.onQQBrowser =/*[SAFE]*/ Browser.u.indexOf("QQBrowser") > -1;
			Browser.onMQQBrowser =/*[SAFE]*/ Browser.u.indexOf("MQQBrowser") > -1 || (Browser.u.indexOf("Mobile") > -1 && Browser.u.indexOf("QQ") > -1);
			Browser.onIE =/*[SAFE]*/ !!Browser.window.ActiveXObject || "ActiveXObject" in Browser.window;
			Browser.onWeiXin =/*[SAFE]*/ Browser.u.indexOf('MicroMessenger') > -1;
			Browser.onPC =/*[SAFE]*/ !Browser.onMobile;
			Browser.onSafari =/*[SAFE]*/ !!Browser.u.match(/Version\/\d+\.\d\x20Mobile\/\S+\x20Safari/);
			Browser.onFirefox =/*[SAFE]*/ Browser.u.indexOf('Firefox') > -1;
			Browser.onEdge =/*[SAFE]*/ Browser.u.indexOf('Edge') > -1;
			Browser.onMiniGame =/*[SAFE]*/ Browser.u.indexOf('MiniGame') > -1;
			Browser.onLimixiu =/*[SAFE]*/ Browser.u.indexOf('limixiu') > -1;
			Browser.httpProtocol =/*[SAFE]*/ Browser.window.location.protocol == "http:";
			if (Browser.onMiniGame && Browser.window.focus == null) {
				console.error("请先初始化小游戏适配库，详细教程https://ldc.the3box.com/doc/?nav=zh-ts-5-0-0");
			}
			Browser.webAudioEnabled =/*[SAFE]*/ Browser.window["AudioContext"] || Browser.window["webkitAudioContext"] || Browser.window["mozAudioContext"] ? true : false;
			Browser.soundType =/*[SAFE]*/ Browser.webAudioEnabled ? "WEBAUDIOSOUND" : "AUDIOSOUND";
		/*__JS__ */Sound = Browser.webAudioEnabled ? WebAudioSound : AudioSound;;
		/*__JS__ */if (Browser.webAudioEnabled) WebAudioSound.initWebAudio();;
			AudioSound._initMusicAudio();
		/*__JS__ */Browser.enableTouch = (('ontouchstart' in window) || window.DocumentTouch && document instanceof DocumentTouch);
		/*__JS__ */window.focus();
		/*__JS__ */SoundManager._soundClass = Sound;;
			Render._mainCanvas = Render._mainCanvas || HTMLCanvas.create('2D');
			if (Browser.canvas) return;
			Browser.canvas = HTMLCanvas.create('2D');
			Browser.context = Browser.canvas.getContext('2d');
		}

		Browser._onMessage = function (e) {
			if (!e.data) return;
			if (e.data.name == "size") {
				Browser.window.innerWidth = e.data.width;
				Browser.window.innerHeight = e.data.height;
				Browser.window.__innerHeight = e.data.clientHeight;
				if (!Browser.document.createEvent) {
					console.warn("no document.createEvent");
					return;
				};
				var evt = Browser.document.createEvent("HTMLEvents");
				evt.initEvent("resize", false, false);
				Browser.window.dispatchEvent(evt);
				return;
			}
		}

		Browser.createElement = function (type) {
			Browser.__init__();
			return Browser.document.__createElement(type);
		}

		Browser.getElementById = function (type) {
			Browser.__init__();
			return Browser.document.getElementById(type);
		}

		Browser.removeElement = function (ele) {
			if (ele && ele.parentNode) ele.parentNode.removeChild(ele);
		}

		Browser.now = function () {
			return RunDriver.now();
		}

		Browser._window = null;
		Browser._document = null;
		Browser._container = null;
		Browser.userAgent = null;
		Browser.u = null;
		Browser.onIOS = false;
		Browser.onMac = false;
		Browser.onMobile = false;
		Browser.onIPhone = false;
		Browser.onIPad = false;
		Browser.onAndriod = false;
		Browser.onAndroid = false;
		Browser.onWP = false;
		Browser.onQQBrowser = false;
		Browser.onMQQBrowser = false;
		Browser.onSafari = false;
		Browser.onFirefox = false;
		Browser.onEdge = false;
		Browser.onIE = false;
		Browser.onWeiXin = false;
		Browser.onMiniGame = false;
		Browser.onLimixiu = false;
		Browser.onPC = false;
		Browser.httpProtocol = false;
		Browser.webAudioEnabled = false;
		Browser.soundType = null;
		Browser.enableTouch = false;
		Browser.canvas = null;
		Browser.context = null;
		Browser.__init$ = function () {
			AudioSound;
			WebAudioSound;
		}

		return Browser;
	})()


	/**
	*<p> <code>Byte</code> 类提供用于优化读取、写入以及处理二进制数据的方法和属性。</p>
	*<p><b>注意：</b> <code>Byte</code> 类适用于需要在字节层访问数据的高级开发人员。</p>
	*/
	//class laya.utils.Byte
	var Byte = (function () {
		function Byte(data) {
			/**
			*@private
			*是否为小端数据。
			*/
			this._xd_ = true;
			this._allocated_ = 8;
			/**
			*@private
			*原始数据。
			*/
			//this._d_=null;
			/**
			*@private
			*DataView
			*/
			//this._u8d_=null;
			/**@private */
			this._pos_ = 0;
			/**@private */
			this._length = 0;
			if (data) {
				this._u8d_ = new Uint8Array(data);
				this._d_ = new DataView(this._u8d_.buffer);
				this._length = this._d_.byteLength;
			} else {
				this.___resizeBuffer(this._allocated_);
			}
		}

		__class(Byte, 'laya.utils.Byte');
		var __proto = Byte.prototype;
		/**@private */
		__proto.___resizeBuffer = function (len) {
			try {
				var newByteView = new Uint8Array(len);
				if (this._u8d_ != null) {
					if (this._u8d_.length <= len) newByteView.set(this._u8d_);
					else newByteView.set(this._u8d_.subarray(0, len));
				}
				this._u8d_ = newByteView;
				this._d_ = new DataView(newByteView.buffer);
			} catch (err) {
				throw "___resizeBuffer err:" + len;
			}
		}

		/**
		*<p>常用于解析固定格式的字节流。</p>
		*<p>先从字节流的当前字节偏移位置处读取一个 <code>Uint16</code> 值，然后以此值为长度，读取此长度的字符串。</p>
		*@return 读取的字符串。
		*/
		__proto.getString = function () {
			return this.rUTF(this.getUint16());
		}

		/**
		*从字节流中 <code>start</code> 参数指定的位置开始，读取 <code>len</code> 参数指定的字节数的数据，用于创建一个 <code>Float32Array</code> 对象并返回此对象。
		*@param start 开始位置。
		*@param len 需要读取的字节长度。如果要读取的长度超过可读取范围，则只返回可读范围内的值。
		*@return 读取的 Float32Array 对象。
		*/
		__proto.getFloat32Array = function (start, len) {
			var end = start + len;
			end = (end > this._length) ? this._length : end;
			var v = new Float32Array(this._d_.buffer.slice(start, end));
			this._pos_ = end;
			return v;
		}

		/**
		*从字节流中 <code>start</code> 参数指定的位置开始，读取 <code>len</code> 参数指定的字节数的数据，用于创建一个 <code>Uint8Array</code> 对象并返回此对象。
		*@param start 开始位置。
		*@param len 需要读取的字节长度。如果要读取的长度超过可读取范围，则只返回可读范围内的值。
		*@return 读取的 Uint8Array 对象。
		*/
		__proto.getUint8Array = function (start, len) {
			var end = start + len;
			end = (end > this._length) ? this._length : end;
			var v = new Uint8Array(this._d_.buffer.slice(start, end));
			this._pos_ = end;
			return v;
		}

		/**
		*从字节流中 <code>start</code> 参数指定的位置开始，读取 <code>len</code> 参数指定的字节数的数据，用于创建一个 <code>Int16Array</code> 对象并返回此对象。
		*@param start 开始读取的字节偏移量位置。
		*@param len 需要读取的字节长度。如果要读取的长度超过可读取范围，则只返回可读范围内的值。
		*@return 读取的 Uint8Array 对象。
		*/
		__proto.getInt16Array = function (start, len) {
			var end = start + len;
			end = (end > this._length) ? this._length : end;
			var v = new Int16Array(this._d_.buffer.slice(start, end));
			this._pos_ = end;
			return v;
		}

		/**
		*从字节流的当前字节偏移位置处读取一个 IEEE 754 单精度（32 位）浮点数。
		*@return 单精度（32 位）浮点数。
		*/
		__proto.getFloat32 = function () {
			if (this._pos_ + 4 > this._length) throw "getFloat32 error - Out of bounds";
			var v = this._d_.getFloat32(this._pos_, this._xd_);
			this._pos_ += 4;
			return v;
		}

		/**
		*从字节流的当前字节偏移量位置处读取一个 IEEE 754 双精度（64 位）浮点数。
		*@return 双精度（64 位）浮点数。
		*/
		__proto.getFloat64 = function () {
			if (this._pos_ + 8 > this._length) throw "getFloat64 error - Out of bounds";
			var v = this._d_.getFloat64(this._pos_, this._xd_);
			this._pos_ += 8;
			return v;
		}

		/**
		*在字节流的当前字节偏移量位置处写入一个 IEEE 754 单精度（32 位）浮点数。
		*@param value 单精度（32 位）浮点数。
		*/
		__proto.writeFloat32 = function (value) {
			this.ensureWrite(this._pos_ + 4);
			this._d_.setFloat32(this._pos_, value, this._xd_);
			this._pos_ += 4;
		}

		/**
		*在字节流的当前字节偏移量位置处写入一个 IEEE 754 双精度（64 位）浮点数。
		*@param value 双精度（64 位）浮点数。
		*/
		__proto.writeFloat64 = function (value) {
			this.ensureWrite(this._pos_ + 8);
			this._d_.setFloat64(this._pos_, value, this._xd_);
			this._pos_ += 8;
		}

		/**
		*从字节流的当前字节偏移量位置处读取一个 Int32 值。
		*@return Int32 值。
		*/
		__proto.getInt32 = function () {
			if (this._pos_ + 4 > this._length) throw "getInt32 error - Out of bounds";
			var float = this._d_.getInt32(this._pos_, this._xd_);
			this._pos_ += 4;
			return float;
		}

		/**
		*从字节流的当前字节偏移量位置处读取一个 Uint32 值。
		*@return Uint32 值。
		*/
		__proto.getUint32 = function () {
			if (this._pos_ + 4 > this._length) throw "getUint32 error - Out of bounds";
			var v = this._d_.getUint32(this._pos_, this._xd_);
			this._pos_ += 4;
			return v;
		}

		/**
		*在字节流的当前字节偏移量位置处写入指定的 Int32 值。
		*@param value 需要写入的 Int32 值。
		*/
		__proto.writeInt32 = function (value) {
			this.ensureWrite(this._pos_ + 4);
			this._d_.setInt32(this._pos_, value, this._xd_);
			this._pos_ += 4;
		}

		/**
		*在字节流的当前字节偏移量位置处写入 Uint32 值。
		*@param value 需要写入的 Uint32 值。
		*/
		__proto.writeUint32 = function (value) {
			this.ensureWrite(this._pos_ + 4);
			this._d_.setUint32(this._pos_, value, this._xd_);
			this._pos_ += 4;
		}

		/**
		*从字节流的当前字节偏移量位置处读取一个 Int16 值。
		*@return Int16 值。
		*/
		__proto.getInt16 = function () {
			if (this._pos_ + 2 > this._length) throw "getInt16 error - Out of bounds";
			var us = this._d_.getInt16(this._pos_, this._xd_);
			this._pos_ += 2;
			return us;
		}

		/**
		*从字节流的当前字节偏移量位置处读取一个 Uint16 值。
		*@return Uint16 值。
		*/
		__proto.getUint16 = function () {
			if (this._pos_ + 2 > this._length) throw "getUint16 error - Out of bounds";
			var us = this._d_.getUint16(this._pos_, this._xd_);
			this._pos_ += 2;
			return us;
		}

		/**
		*在字节流的当前字节偏移量位置处写入指定的 Uint16 值。
		*@param value 需要写入的Uint16 值。
		*/
		__proto.writeUint16 = function (value) {
			this.ensureWrite(this._pos_ + 2);
			this._d_.setUint16(this._pos_, value, this._xd_);
			this._pos_ += 2;
		}

		/**
		*在字节流的当前字节偏移量位置处写入指定的 Int16 值。
		*@param value 需要写入的 Int16 值。
		*/
		__proto.writeInt16 = function (value) {
			this.ensureWrite(this._pos_ + 2);
			this._d_.setInt16(this._pos_, value, this._xd_);
			this._pos_ += 2;
		}

		/**
		*从字节流的当前字节偏移量位置处读取一个 Uint8 值。
		*@return Uint8 值。
		*/
		__proto.getUint8 = function () {
			if (this._pos_ + 1 > this._length) throw "getUint8 error - Out of bounds";
			return this._d_.getUint8(this._pos_++);
		}

		/**
		*在字节流的当前字节偏移量位置处写入指定的 Uint8 值。
		*@param value 需要写入的 Uint8 值。
		*/
		__proto.writeUint8 = function (value) {
			this.ensureWrite(this._pos_ + 1);
			this._d_.setUint8(this._pos_, value);
			this._pos_++;
		}

		/**
		*@private
		*从字节流的指定字节偏移量位置处读取一个 Uint8 值。
		*@param pos 字节读取位置。
		*@return Uint8 值。
		*/
		__proto._getUInt8 = function (pos) {
			return this._d_.getUint8(pos);
		}

		/**
		*@private
		*从字节流的指定字节偏移量位置处读取一个 Uint16 值。
		*@param pos 字节读取位置。
		*@return Uint16 值。
		*/
		__proto._getUint16 = function (pos) {
			return this._d_.getUint16(pos, this._xd_);
		}

		/**
		*@private
		*使用 getFloat32()读取6个值，用于创建并返回一个 Matrix 对象。
		*@return Matrix 对象。
		*/
		__proto._getMatrix = function () {
			var rst = new Matrix(this.getFloat32(), this.getFloat32(), this.getFloat32(), this.getFloat32(), this.getFloat32(), this.getFloat32());
			return rst;
		}

		/**
		*@private
		*读取指定长度的 UTF 型字符串。
		*@param len 需要读取的长度。
		*@return 读取的字符串。
		*/
		__proto.rUTF = function (len) {
			var v = "", max = this._pos_ + len, c = 0, c2 = 0, c3 = 0, f = String.fromCharCode;
			var u = this._u8d_, i = 0;
			while (this._pos_ < max) {
				c = u[this._pos_++];
				if (c < 0x80) {
					if (c != 0) {
						v += f(c);
					}
				} else if (c < 0xE0) {
					v += f(((c & 0x3F) << 6) | (u[this._pos_++] & 0x7F));
				} else if (c < 0xF0) {
					c2 = u[this._pos_++];
					v += f(((c & 0x1F) << 12) | ((c2 & 0x7F) << 6) | (u[this._pos_++] & 0x7F));
				} else {
					c2 = u[this._pos_++];
					c3 = u[this._pos_++];
					v += f(((c & 0x0F) << 18) | ((c2 & 0x7F) << 12) | ((c3 << 6) & 0x7F) | (u[this._pos_++] & 0x7F));
				}
				i++;
			}
			return v;
		}

		/**
		*@private
		*读取 <code>len</code> 参数指定的长度的字符串。
		*@param len 要读取的字符串的长度。
		*@return 指定长度的字符串。
		*/
		__proto.getCustomString = function (len) {
			var v = "", ulen = 0, c = 0, c2 = 0, f = String.fromCharCode;
			var u = this._u8d_, i = 0;
			while (len > 0) {
				c = u[this._pos_];
				if (c < 0x80) {
					v += f(c);
					this._pos_++;
					len--;
				} else {
					ulen = c - 0x80;
					this._pos_++;
					len -= ulen;
					while (ulen > 0) {
						c = u[this._pos_++];
						c2 = u[this._pos_++];
						v += f((c2 << 8) | c);
						ulen--;
					}
				}
			}
			return v;
		}

		/**
		*清除字节数组的内容，并将 length 和 pos 属性重置为 0。调用此方法将释放 Byte 实例占用的内存。
		*/
		__proto.clear = function () {
			this._pos_ = 0;
			this.length = 0;
		}

		/**
		*@private
		*获取此对象的 ArrayBuffer 引用。
		*@return
		*/
		__proto.__getBuffer = function () {
			return this._d_.buffer;
		}

		/**
		*<p>将 UTF-8 字符串写入字节流。类似于 writeUTF()方法，但 writeUTFBytes()不使用 16 位长度的字为字符串添加前缀。</p>
		*<p>对应的读取方法为： getUTFBytes 。</p>
		*@param value 要写入的字符串。
		*/
		__proto.writeUTFBytes = function (value) {
			value = value + "";
			for (var i = 0, sz = value.length; i < sz; i++) {
				var c = value.charCodeAt(i);
				if (c <= 0x7F) {
					this.writeByte(c);
				} else if (c <= 0x7FF) {
					this.ensureWrite(this._pos_ + 2);
					this._u8d_.set([0xC0 | (c >> 6), 0x80 | (c & 0x3F)], this._pos_);
					this._pos_ += 2;
				} else if (c <= 0xFFFF) {
					this.ensureWrite(this._pos_ + 3);
					this._u8d_.set([0xE0 | (c >> 12), 0x80 | ((c >> 6) & 0x3F), 0x80 | (c & 0x3F)], this._pos_);
					this._pos_ += 3;
				} else {
					this.ensureWrite(this._pos_ + 4);
					this._u8d_.set([0xF0 | (c >> 18), 0x80 | ((c >> 12) & 0x3F), 0x80 | ((c >> 6) & 0x3F), 0x80 | (c & 0x3F)], this._pos_);
					this._pos_ += 4;
				}
			}
		}

		/**
		*<p>将 UTF-8 字符串写入字节流。先写入以字节表示的 UTF-8 字符串长度（作为 16 位整数），然后写入表示字符串字符的字节。</p>
		*<p>对应的读取方法为： getUTFString 。</p>
		*@param value 要写入的字符串值。
		*/
		__proto.writeUTFString = function (value) {
			var tPos = this.pos;
			this.writeUint16(1);
			this.writeUTFBytes(value);
			var dPos = this.pos - tPos - 2;
			if (dPos >= 65536) {
				throw "writeUTFString byte len more than 65536";
			}
			this._d_.setUint16(tPos, dPos, this._xd_);
		}

		/**
		*@private
		*读取 UTF-8 字符串。
		*@return 读取的字符串。
		*/
		__proto.readUTFString = function () {
			return this.readUTFBytes(this.getUint16());
		}

		/**
		*<p>从字节流中读取一个 UTF-8 字符串。假定字符串的前缀是一个无符号的短整型（以此字节表示要读取的长度）。</p>
		*<p>对应的写入方法为： writeUTFString 。</p>
		*@return 读取的字符串。
		*/
		__proto.getUTFString = function () {
			return this.readUTFString();
		}

		/**
		*@private
		*读字符串，必须是 writeUTFBytes 方法写入的字符串。
		*@param len 要读的buffer长度，默认将读取缓冲区全部数据。
		*@return 读取的字符串。
		*/
		__proto.readUTFBytes = function (len) {
			(len === void 0) && (len = -1);
			if (len == 0) return "";
			var lastBytes = this.bytesAvailable;
			if (len > lastBytes) throw "readUTFBytes error - Out of bounds";
			len = len > 0 ? len : lastBytes;
			return this.rUTF(len);
		}

		/**
		*<p>从字节流中读取一个由 length 参数指定的长度的 UTF-8 字节序列，并返回一个字符串。</p>
		*<p>一般读取的是由 writeUTFBytes 方法写入的字符串。</p>
		*@param len 要读的buffer长度，默认将读取缓冲区全部数据。
		*@return 读取的字符串。
		*/
		__proto.getUTFBytes = function (len) {
			(len === void 0) && (len = -1);
			return this.readUTFBytes(len);
		}

		/**
		*<p>在字节流中写入一个字节。</p>
		*<p>使用参数的低 8 位。忽略高 24 位。</p>
		*@param value
		*/
		__proto.writeByte = function (value) {
			this.ensureWrite(this._pos_ + 1);
			this._d_.setInt8(this._pos_, value);
			this._pos_ += 1;
		}

		/**
		*@private
		*从字节流中读取带符号的字节。
		*/
		__proto.readByte = function () {
			if (this._pos_ + 1 > this._length) throw "readByte error - Out of bounds";
			return this._d_.getInt8(this._pos_++);
		}

		/**
		*<p>从字节流中读取带符号的字节。</p>
		*<p>返回值的范围是从-128 到 127。</p>
		*@return 介于-128 和 127 之间的整数。
		*/
		__proto.getByte = function () {
			return this.readByte();
		}

		/**
		*<p>保证该字节流的可用长度不小于 <code>lengthToEnsure</code> 参数指定的值。</p>
		*@param lengthToEnsure 指定的长度。
		*/
		__proto.ensureWrite = function (lengthToEnsure) {
			if (this._length < lengthToEnsure) this._length = lengthToEnsure;
			if (this._allocated_ < lengthToEnsure) this.length = lengthToEnsure;
		}

		/**
		*<p>将指定 arraybuffer 对象中的以 offset 为起始偏移量， length 为长度的字节序列写入字节流。</p>
		*<p>如果省略 length 参数，则使用默认长度 0，该方法将从 offset 开始写入整个缓冲区；如果还省略了 offset 参数，则写入整个缓冲区。</p>
		*<p>如果 offset 或 length 小于0，本函数将抛出异常。</p>
		*$NEXTBIG 由于没有判断length和arraybuffer的合法性，当开发者填写了错误的length值时，会导致写入多余的空白数据甚至内存溢出，为了避免影响开发者正在使用此方法的功能，下个重大版本会修复这些问题。
		*@param arraybuffer 需要写入的 Arraybuffer 对象。
		*@param offset Arraybuffer 对象的索引的偏移量（以字节为单位）
		*@param length 从 Arraybuffer 对象写入到 Byte 对象的长度（以字节为单位）
		*/
		__proto.writeArrayBuffer = function (arraybuffer, offset, length) {
			(offset === void 0) && (offset = 0);
			(length === void 0) && (length = 0);
			if (offset < 0 || length < 0) throw "writeArrayBuffer error - Out of bounds";
			if (length == 0) length = arraybuffer.byteLength - offset;
			this.ensureWrite(this._pos_ + length);
			var uint8array = new Uint8Array(arraybuffer);
			this._u8d_.set(uint8array.subarray(offset, offset + length), this._pos_);
			this._pos_ += length;
		}

		/**
		*获取此对象的 ArrayBuffer 数据，数据只包含有效数据部分。
		*/
		__getset(0, __proto, 'buffer', function () {
			var rstBuffer = this._d_.buffer;
			if (rstBuffer.byteLength == this.length) return rstBuffer;
			return rstBuffer.slice(0, this.length);
		});

		/**
		*<p> <code>Byte</code> 实例的字节序。取值为：<code>BIG_ENDIAN</code> 或 <code>BIG_ENDIAN</code> 。</p>
		*<p>主机字节序，是 CPU 存放数据的两种不同顺序，包括小端字节序和大端字节序。通过 <code>getSystemEndian</code> 可以获取当前系统的字节序。</p>
		*<p> <code>BIG_ENDIAN</code> ：大端字节序，地址低位存储值的高位，地址高位存储值的低位。有时也称之为网络字节序。<br/>
		*<code>LITTLE_ENDIAN</code> ：小端字节序，地址低位存储值的低位，地址高位存储值的高位。</p>
		*/
		__getset(0, __proto, 'endian', function () {
			return this._xd_ ? "littleEndian" : "bigEndian";
		}, function (endianStr) {
			this._xd_ = (endianStr == "littleEndian");
		});

		/**
		*<p> <code>Byte</code> 对象的长度（以字节为单位）。</p>
		*<p>如果将长度设置为大于当前长度的值，则用零填充字节数组的右侧；如果将长度设置为小于当前长度的值，将会截断该字节数组。</p>
		*<p>如果要设置的长度大于当前已分配的内存空间的字节长度，则重新分配内存空间，大小为以下两者较大者：要设置的长度、当前已分配的长度的2倍，并将原有数据拷贝到新的内存空间中；如果要设置的长度小于当前已分配的内存空间的字节长度，也会重新分配内存空间，大小为要设置的长度，并将原有数据从头截断为要设置的长度存入新的内存空间中。</p>
		*/
		__getset(0, __proto, 'length', function () {
			return this._length;
		}, function (value) {
			if (this._allocated_ < value)
				this.___resizeBuffer(this._allocated_ = Math.floor(Math.max(value, this._allocated_ * 2)));
			else if (this._allocated_ > value)
				this.___resizeBuffer(this._allocated_ = value);
			this._length = value;
		});

		/**
		*移动或返回 Byte 对象的读写指针的当前位置（以字节为单位）。下一次调用读取方法时将在此位置开始读取，或者下一次调用写入方法时将在此位置开始写入。
		*/
		__getset(0, __proto, 'pos', function () {
			return this._pos_;
		}, function (value) {
			this._pos_ = value;
		});

		/**
		*可从字节流的当前位置到末尾读取的数据的字节数。
		*/
		__getset(0, __proto, 'bytesAvailable', function () {
			return this._length - this._pos_;
		});

		Byte.getSystemEndian = function () {
			if (!Byte._sysEndian) {
				var buffer = new ArrayBuffer(2);
				new DataView(buffer).setInt16(0, 256, true);
				Byte._sysEndian = (new Int16Array(buffer))[0] === 256 ? /*CLASS CONST:laya.utils.Byte.LITTLE_ENDIAN*/"littleEndian" :/*CLASS CONST:laya.utils.Byte.BIG_ENDIAN*/"bigEndian";
			}
			return Byte._sysEndian;
		}

		Byte.BIG_ENDIAN = "bigEndian";
		Byte.LITTLE_ENDIAN = "littleEndian";
		Byte._sysEndian = null;
		return Byte;
	})()


	/**
	*@private
	*对象缓存统一管理类
	*/
	//class laya.utils.CacheManager
	var CacheManager = (function () {
		function CacheManager() { }
		__class(CacheManager, 'laya.utils.CacheManager');
		CacheManager.regCacheByFunction = function (disposeFunction, getCacheListFunction) {
			CacheManager.unRegCacheByFunction(disposeFunction, getCacheListFunction);
			var cache;
			cache = { tryDispose: disposeFunction, getCacheList: getCacheListFunction };
			CacheManager._cacheList.push(cache);
		}

		CacheManager.unRegCacheByFunction = function (disposeFunction, getCacheListFunction) {
			var i = 0, len = 0;
			len = CacheManager._cacheList.length;
			for (i = 0; i < len; i++) {
				if (CacheManager._cacheList[i].tryDispose == disposeFunction && CacheManager._cacheList[i].getCacheList == getCacheListFunction) {
					CacheManager._cacheList.splice(i, 1);
					return;
				}
			}
		}

		CacheManager.forceDispose = function () {
			var i = 0, len = CacheManager._cacheList.length;
			for (i = 0; i < len; i++) {
				CacheManager._cacheList[i].tryDispose(true);
			}
		}

		CacheManager.beginCheck = function (waitTime) {
			(waitTime === void 0) && (waitTime = 15000);
			Laya.timer.loop(waitTime, null, CacheManager._checkLoop);
		}

		CacheManager.stopCheck = function () {
			Laya.timer.clear(null, CacheManager._checkLoop);
		}

		CacheManager._checkLoop = function () {
			var cacheList = CacheManager._cacheList;
			if (cacheList.length < 1) return;
			var tTime = Browser.now();
			var count = 0;
			var len = 0;
			len = count = cacheList.length;
			while (count > 0) {
				CacheManager._index++;
				CacheManager._index = CacheManager._index % len;
				cacheList[CacheManager._index].tryDispose(false);
				if (Browser.now() - tTime > CacheManager.loopTimeLimit) break;
				count--;
			}
		}

		CacheManager.loopTimeLimit = 2;
		CacheManager._cacheList = [];
		CacheManager._index = 0;
		return CacheManager;
	})()


	/**
	*<code>ClassUtils</code> 是一个类工具类。
	*/
	//class laya.utils.ClassUtils
	var ClassUtils = (function () {
		function ClassUtils() { }
		__class(ClassUtils, 'laya.utils.ClassUtils');
		ClassUtils.regClass = function (className, classDef) {
			ClassUtils._classMap[className] = classDef;
		}

		ClassUtils.getRegClass = function (className) {
			return ClassUtils._classMap[className];
		}

		ClassUtils.getInstance = function (className) {
			var compClass = ClassUtils.getClass(className);
			if (compClass)
				return new compClass();
			else
				console.warn("[error] Undefined class:", className);
			return null;
		}

		ClassUtils.createByJson = function (json, node, root, customHandler, instanceHandler) {
			if ((typeof json == 'string'))
				json = JSON.parse(json);
			var props = json.props;
			if (!node) {
				node = instanceHandler ? instanceHandler.runWith(json) : ClassUtils.getInstance(props.runtime || json.type);
				if (!node)
					return null;
			};
			var child = json.child;
			if (child) {
				for (var i = 0, n = child.length; i < n; i++) {
					var data = child[i];
					if ((data.props.name === "render" || data.props.renderType === "render") && node["_$set_itemRender"])
						node.itemRender = data;
					else {
						if (data.type == "Graphic") {
							ClassUtils.addGraphicsToSprite(data, node);
						} else if (ClassUtils.isDrawType(data.type)) {
							ClassUtils.addGraphicToSprite(data, node, true);
						} else {
							var tChild = ClassUtils.createByJson(data, null, root, customHandler, instanceHandler)
							if (data.type == "Script") {
								if (tChild.hasOwnProperty("owner")) {
									tChild["owner"] = node;
								} else if (tChild.hasOwnProperty("target")) {
									tChild["target"] = node;
								}
							} else if (data.props.renderType == "mask") {
								node.mask = tChild;
							} else {
								node.addChild(tChild);
							}
						}
					}
				}
			}
			if (props) {
				for (var prop in props) {
					var value = props[prop];
					if (prop === "var" && root) {
						root[value] = node;
					} else if ((value instanceof Array) && (typeof (node[prop]) == 'function')) {
						node[prop].apply(node, value);
					} else {
						node[prop] = value;
					}
				}
			}
			if (customHandler && json.customProps) {
				customHandler.runWith([node, json]);
			}
			if (node["created"])
				node.created();
			return node;
		}

		ClassUtils.addGraphicsToSprite = function (graphicO, sprite) {
			var graphics;
			graphics = graphicO.child;
			if (!graphics || graphics.length < 1)
				return;
			var g;
			g = ClassUtils._getGraphicsFromSprite(graphicO, sprite);
			var ox = 0;
			var oy = 0;
			if (graphicO.props) {
				ox = ClassUtils._getObjVar(graphicO.props, "x", 0);
				oy = ClassUtils._getObjVar(graphicO.props, "y", 0);
			}
			if (ox != 0 && oy != 0) {
				g.translate(ox, oy);
			};
			var i = 0, len = 0;
			len = graphics.length;
			for (i = 0; i < len; i++) {
				ClassUtils._addGraphicToGraphics(graphics[i], g);
			}
			if (ox != 0 && oy != 0) {
				g.translate(-ox, -oy);
			}
		}

		ClassUtils.addGraphicToSprite = function (graphicO, sprite, isChild) {
			(isChild === void 0) && (isChild = false);
			var g;
			g = isChild ? ClassUtils._getGraphicsFromSprite(graphicO, sprite) : sprite.graphics;
			ClassUtils._addGraphicToGraphics(graphicO, g);
		}

		ClassUtils._getGraphicsFromSprite = function (dataO, sprite) {
			var g;
			if (!dataO || !dataO.props)
				return sprite.graphics;
			var propsName;
			propsName = dataO.props.renderType;
			switch (propsName) {
				case "hit":
				case "unHit": ;
					var hitArea;
					if (!sprite.hitArea) {
						sprite.hitArea = new HitArea();
					}
					hitArea = sprite.hitArea;
					if (!hitArea[propsName]) {
						hitArea[propsName] = new Graphics();
					}
					g = hitArea[propsName];
					break;
				default:
			}
			if (!g)
				g = sprite.graphics;
			return g;
		}

		ClassUtils._getTransformData = function (propsO) {
			var m;
			if (propsO.hasOwnProperty("pivotX") || propsO.hasOwnProperty("pivotY")) {
				m = m || new Matrix();
				m.translate(-ClassUtils._getObjVar(propsO, "pivotX", 0), -ClassUtils._getObjVar(propsO, "pivotY", 0));
			};
			var sx = ClassUtils._getObjVar(propsO, "scaleX", 1), sy = ClassUtils._getObjVar(propsO, "scaleY", 1);
			var rotate = ClassUtils._getObjVar(propsO, "rotation", 0);
			var skewX = ClassUtils._getObjVar(propsO, "skewX", 0);
			var skewY = ClassUtils._getObjVar(propsO, "skewY", 0);
			if (sx != 1 || sy != 1 || rotate != 0) {
				m = m || new Matrix();
				m.scale(sx, sy);
				m.rotate(rotate * 0.0174532922222222);
			}
			return m;
		}

		ClassUtils._addGraphicToGraphics = function (graphicO, graphic) {
			var propsO;
			propsO = graphicO.props;
			if (!propsO)
				return;
			var drawConfig;
			drawConfig = ClassUtils.DrawTypeDic[graphicO.type];
			if (!drawConfig)
				return;
			var g;
			g = graphic;
			var m;
			var params = ClassUtils._getParams(propsO, drawConfig[1], drawConfig[2], drawConfig[3]);
			m = ClassUtils._tM;
			if (m || ClassUtils._alpha != 1) {
				g.save();
				if (m)
					g.transform(m);
				if (ClassUtils._alpha != 1)
					g.alpha(ClassUtils._alpha);
			}
			g[drawConfig[0]].apply(g, params);
			if (m || ClassUtils._alpha != 1) {
				g.restore();
			}
		}

		ClassUtils._adptLineData = function (params) {
			params[2] = parseFloat(params[0]) + parseFloat(params[2]);
			params[3] = parseFloat(params[1]) + parseFloat(params[3]);
			return params;
		}

		ClassUtils._adptTextureData = function (params) {
			params[0] = Loader.getRes(params[0]);
			return params;
		}

		ClassUtils._adptLinesData = function (params) {
			params[2] = ClassUtils._getPointListByStr(params[2]);
			return params;
		}

		ClassUtils.isDrawType = function (type) {
			if (type == "Image")
				return false;
			return ClassUtils.DrawTypeDic.hasOwnProperty(type);
		}

		ClassUtils._getParams = function (obj, params, xPos, adptFun) {
			(xPos === void 0) && (xPos = 0);
			var rst;
			rst = ClassUtils._temParam;
			rst.length = params.length;
			var i = 0, len = 0;
			len = params.length;
			for (i = 0; i < len; i++) {
				rst[i] = ClassUtils._getObjVar(obj, params[i][0], params[i][1]);
			}
			ClassUtils._alpha = ClassUtils._getObjVar(obj, "alpha", 1);
			var m;
			m = ClassUtils._getTransformData(obj);
			if (m) {
				if (!xPos) xPos = 0;
				m.translate(rst[xPos], rst[xPos + 1]);
				rst[xPos] = rst[xPos + 1] = 0;
				ClassUtils._tM = m;
			} else {
				ClassUtils._tM = null;
			}
			if (adptFun && ClassUtils[adptFun]) {
				rst = ClassUtils[adptFun](rst);
			}
			return rst;
		}

		ClassUtils._getPointListByStr = function (str) {
			var pointArr;
			pointArr = str.split(",");
			var i = 0, len = 0;
			len = pointArr.length;
			for (i = 0; i < len; i++) {
				pointArr[i] = parseFloat(pointArr[i]);
			}
			return pointArr;
		}

		ClassUtils._getObjVar = function (obj, key, noValue) {
			if (obj.hasOwnProperty(key)) {
				return obj[key];
			}
			return noValue;
		}

		ClassUtils._temParam = [];
		ClassUtils._classMap = { 'Sprite': 'laya.display.Sprite', 'Text': 'laya.display.Text', 'Animation': 'laya.display.Animation', 'Skeleton': 'laya.ani.bone.Skeleton', 'Particle2D': 'laya.particle.Particle2D', 'div': 'laya.html.dom.HTMLDivElement', 'p': 'laya.html.dom.HTMLElement', 'img': 'laya.html.dom.HTMLImageElement', 'span': 'laya.html.dom.HTMLElement', 'br': 'laya.html.dom.HTMLBrElement', 'style': 'laya.html.dom.HTMLStyleElement', 'font': 'laya.html.dom.HTMLElement', 'a': 'laya.html.dom.HTMLElement', '#text': 'laya.html.dom.HTMLElement' };
		ClassUtils.getClass = function (className) {
			var classObject = ClassUtils._classMap[className] || className;
			if ((typeof classObject == 'string'))
				return Laya["__classmap"][classObject];
			return classObject;
		}

		ClassUtils._tM = null;
		ClassUtils._alpha = NaN;
		__static(ClassUtils,
			['DrawTypeDic', function () { return this.DrawTypeDic = { "Rect": ["drawRect", [["x", 0], ["y", 0], ["width", 0], ["height", 0], ["fillColor", null], ["lineColor", null], ["lineWidth", 1]]], "Circle": ["drawCircle", [["x", 0], ["y", 0], ["radius", 0], ["fillColor", null], ["lineColor", null], ["lineWidth", 1]]], "Pie": ["drawPie", [["x", 0], ["y", 0], ["radius", 0], ["startAngle", 0], ["endAngle", 0], ["fillColor", null], ["lineColor", null], ["lineWidth", 1]]], "Image": ["drawTexture", [["x", 0], ["y", 0], ["width", 0], ["height", 0]]], "Texture": ["drawTexture", [["skin", null], ["x", 0], ["y", 0], ["width", 0], ["height", 0]], 1, "_adptTextureData"], "FillTexture": ["fillTexture", [["skin", null], ["x", 0], ["y", 0], ["width", 0], ["height", 0], ["repeat", null]], 1, "_adptTextureData"], "FillText": ["fillText", [["text", ""], ["x", 0], ["y", 0], ["font", null], ["color", null], ["textAlign", null]], 1], "Line": ["drawLine", [["x", 0], ["y", 0], ["toX", 0], ["toY", 0], ["lineColor", null], ["lineWidth", 0]], 0, "_adptLineData"], "Lines": ["drawLines", [["x", 0], ["y", 0], ["points", ""], ["lineColor", null], ["lineWidth", 0]], 0, "_adptLinesData"], "Curves": ["drawCurves", [["x", 0], ["y", 0], ["points", ""], ["lineColor", null], ["lineWidth", 0]], 0, "_adptLinesData"], "Poly": ["drawPoly", [["x", 0], ["y", 0], ["points", ""], ["fillColor", null], ["lineColor", null], ["lineWidth", 1]], 0, "_adptLinesData"] }; }
			]);
		return ClassUtils;
	})()


	/**
	*@private
	*<code>Color</code> 是一个颜色值处理类。
	*/
	//class laya.utils.Color
	var Color = (function () {
		function Color(str) {
			/**@private */
			this._color = [];
			/**字符串型颜色值。*/
			//this.strColor=null;
			/**uint 型颜色值。*/
			//this.numColor=0;
			//this._drawStyle=null;
			if ((typeof str == 'string')) {
				this.strColor = str;
				if (str === null) str = "#000000";
				str.charAt(0) == '#' && (str = str.substr(1));
				var len = str.length;
				if (len == 3 || len == 4) {
					var temp = "";
					for (var i = 0; i < len; i++) {
						temp += (str[i] + str[i]);
					}
					str = temp;
				};
				var color = this.numColor = parseInt(str, 16);
				var flag = (str.length == 8);
				if (flag) {
					this._color = [parseInt(str.substr(0, 2), 16) / 255, ((0x00FF0000 & color) >> 16) / 255, ((0x0000FF00 & color) >> 8) / 255, (0x000000FF & color) / 255];
					return;
				}
			} else {
				color = this.numColor = str;
				this.strColor = Utils.toHexColor(color);
			}
			this._color = [((0xFF0000 & color) >> 16) / 255, ((0xFF00 & color) >> 8) / 255, (0xFF & color) / 255, 1];
			(this._color).__id = ++Color._COLODID;
		}

		__class(Color, 'laya.utils.Color');
		Color._initDefault = function () {
			Color._DEFAULT = {};
			for (var i in Color._COLOR_MAP) Color._SAVE[i] = Color._DEFAULT[i] = new Color(Color._COLOR_MAP[i]);
			return Color._DEFAULT;
		}

		Color._initSaveMap = function () {
			Color._SAVE_SIZE = 0;
			Color._SAVE = {};
			for (var i in Color._DEFAULT) Color._SAVE[i] = Color._DEFAULT[i];
		}

		Color.create = function (str) {
			var color = Color._SAVE[str + ""];
			if (color != null) return color;
			(Color._SAVE_SIZE < 1000) || Color._initSaveMap();
			return Color._SAVE[str + ""] = new Color(str);
		}

		Color._SAVE = {};
		Color._SAVE_SIZE = 0;
		Color._COLOR_MAP = { "white": '#FFFFFF', "red": '#FF0000', "green": '#00FF00', "blue": '#0000FF', "black": '#000000', "yellow": '#FFFF00', 'gray': '#AAAAAA' };
		Color._DEFAULT = Color._initDefault();
		Color._COLODID = 1;
		return Color;
	})()


	/**
	*<code>Dictionary</code> 是一个字典型的数据存取类。
	*/
	//class laya.utils.Dictionary
	var Dictionary = (function () {
		function Dictionary() {
			this._values = [];
			this._keys = [];
		}

		__class(Dictionary, 'laya.utils.Dictionary');
		var __proto = Dictionary.prototype;
		/**
		*给指定的键名设置值。
		*@param key 键名。
		*@param value 值。
		*/
		__proto.set = function (key, value) {
			var index = this.indexOf(key);
			if (index >= 0) {
				this._values[index] = value;
				return;
			}
			this._keys.push(key);
			this._values.push(value);
		}

		/**
		*获取指定对象的键名索引。
		*@param key 键名对象。
		*@return 键名索引。
		*/
		__proto.indexOf = function (key) {
			var index = this._keys.indexOf(key);
			if (index >= 0) return index;
			key = ((typeof key == 'string')) ? Number(key) : (((typeof key == 'number')) ? key.toString() : key);
			return this._keys.indexOf(key);
		}

		/**
		*返回指定键名的值。
		*@param key 键名对象。
		*@return 指定键名的值。
		*/
		__proto.get = function (key) {
			var index = this.indexOf(key);
			return index < 0 ? null : this._values[index];
		}

		/**
		*移除指定键名的值。
		*@param key 键名对象。
		*@return 是否成功移除。
		*/
		__proto.remove = function (key) {
			var index = this.indexOf(key);
			if (index >= 0) {
				this._keys.splice(index, 1);
				this._values.splice(index, 1);
				return true;
			}
			return false;
		}

		/**
		*清除此对象的键名列表和键值列表。
		*/
		__proto.clear = function () {
			this._values.length = 0;
			this._keys.length = 0;
		}

		/**
		*获取所有的子元素列表。
		*/
		__getset(0, __proto, 'values', function () {
			return this._values;
		});

		/**
		*获取所有的子元素键名列表。
		*/
		__getset(0, __proto, 'keys', function () {
			return this._keys;
		});

		return Dictionary;
	})()


	/**
	*@private
	*<code>Dragging</code> 类是触摸滑动控件。
	*/
	//class laya.utils.Dragging
	var Dragging = (function () {
		function Dragging() {
			/**被拖动的对象。*/
			//this.target=null;
			/**缓动衰减系数。*/
			this.ratio = 0.92;
			/**单帧最大偏移量。*/
			this.maxOffset = 60;
			/**滑动范围。*/
			//this.area=null;
			/**表示拖动是否有惯性。*/
			//this.hasInertia=false;
			/**橡皮筋最大值。*/
			//this.elasticDistance=NaN;
			/**橡皮筋回弹时间，单位为毫秒。*/
			//this.elasticBackTime=NaN;
			/**事件携带数据。*/
			//this.data=null;
			this._dragging = false;
			this._clickOnly = true;
			//this._elasticRateX=NaN;
			//this._elasticRateY=NaN;
			//this._lastX=NaN;
			//this._lastY=NaN;
			//this._offsetX=NaN;
			//this._offsetY=NaN;
			//this._offsets=null;
			//this._disableMouseEvent=false;
			//this._tween=null;
			//this._parent=null;
		}

		__class(Dragging, 'laya.utils.Dragging');
		var __proto = Dragging.prototype;
		/**
		*开始拖拽。
		*@param target 待拖拽的 <code>Sprite</code> 对象。
		*@param area 滑动范围。
		*@param hasInertia 拖动是否有惯性。
		*@param elasticDistance 橡皮筋最大值。
		*@param elasticBackTime 橡皮筋回弹时间，单位为毫秒。
		*@param data 事件携带数据。
		*@param disableMouseEvent 鼠标事件是否有效。
		*@param ratio 惯性阻尼系数
		*/
		__proto.start = function (target, area, hasInertia, elasticDistance, elasticBackTime, data, disableMouseEvent, ratio) {
			(ratio === void 0) && (ratio = 0.92);
			this.clearTimer();
			this.target = target;
			this.area = area;
			this.hasInertia = hasInertia;
			this.elasticDistance = area ? elasticDistance : 0;
			this.elasticBackTime = elasticBackTime;
			this.data = data;
			this._disableMouseEvent = disableMouseEvent;
			this.ratio = ratio;
			if (target.globalScaleX != 1 || target.globalScaleY != 1) {
				this._parent = target.parent;
			} else {
				this._parent = Laya.stage;
			}
			this._clickOnly = true;
			this._dragging = true;
			this._elasticRateX = this._elasticRateY = 1;
			this._lastX = this._parent.mouseX;
			this._lastY = this._parent.mouseY;
			Laya.stage.on(/*laya.events.Event.MOUSE_UP*/"mouseup", this, this.onStageMouseUp);
			Laya.stage.on(/*laya.events.Event.MOUSE_OUT*/"mouseout", this, this.onStageMouseUp);
			Laya.timer.frameLoop(1, this, this.loop);
		}

		/**
		*清除计时器。
		*/
		__proto.clearTimer = function () {
			Laya.timer.clear(this, this.loop);
			Laya.timer.clear(this, this.tweenMove);
			if (this._tween) {
				this._tween.recover();
				this._tween = null;
			}
		}

		/**
		*停止拖拽。
		*/
		__proto.stop = function () {
			if (this._dragging) {
				MouseManager.instance.disableMouseEvent = false;
				Laya.stage.off(/*laya.events.Event.MOUSE_UP*/"mouseup", this, this.onStageMouseUp);
				Laya.stage.off(/*laya.events.Event.MOUSE_OUT*/"mouseout", this, this.onStageMouseUp);
				this._dragging = false;
				this.target && this.area && this.backToArea();
				this.clear();
			}
		}

		/**
		*拖拽的循环处理函数。
		*/
		__proto.loop = function () {
			var point = this._parent.getMousePoint();
			var mouseX = point.x;
			var mouseY = point.y;
			var offsetX = mouseX - this._lastX;
			var offsetY = mouseY - this._lastY;
			if (this._clickOnly) {
				if (Math.abs(offsetX * Laya.stage._canvasTransform.getScaleX()) > 1 || Math.abs(offsetY * Laya.stage._canvasTransform.getScaleY()) > 1) {
					this._clickOnly = false;
					this._offsets || (this._offsets = []);
					this._offsets.length = 0;
					this.target.event(/*laya.events.Event.DRAG_START*/"dragstart", this.data);
					MouseManager.instance.disableMouseEvent = this._disableMouseEvent;
					this.target._set$P("$_MOUSEDOWN", false);
				} else return;
			} else {
				this._offsets.push(offsetX, offsetY);
			}
			if (offsetX === 0 && offsetY === 0) return;
			this._lastX = mouseX;
			this._lastY = mouseY;
			this.target.x += offsetX * this._elasticRateX;
			this.target.y += offsetY * this._elasticRateY;
			this.area && this.checkArea();
			this.target.event(/*laya.events.Event.DRAG_MOVE*/"dragmove", this.data);
		}

		/**
		*拖拽区域检测。
		*/
		__proto.checkArea = function () {
			if (this.elasticDistance <= 0) {
				this.backToArea();
			} else {
				if (this.target.x < this.area.x) {
					var offsetX = this.area.x - this.target.x;
				} else if (this.target.x > this.area.x + this.area.width) {
					offsetX = this.target.x - this.area.x - this.area.width;
				} else {
					offsetX = 0;
				}
				this._elasticRateX = Math.max(0, 1 - (offsetX / this.elasticDistance));
				if (this.target.y < this.area.y) {
					var offsetY = this.area.y - this.target.y;
				} else if (this.target.y > this.area.y + this.area.height) {
					offsetY = this.target.y - this.area.y - this.area.height;
				} else {
					offsetY = 0;
				}
				this._elasticRateY = Math.max(0, 1 - (offsetY / this.elasticDistance));
			}
		}

		/**
		*移动至设定的拖拽区域。
		*/
		__proto.backToArea = function () {
			this.target.x = Math.min(Math.max(this.target.x, this.area.x), this.area.x + this.area.width);
			this.target.y = Math.min(Math.max(this.target.y, this.area.y), this.area.y + this.area.height);
		}

		/**
		*舞台的抬起事件侦听函数。
		*@param e Event 对象。
		*/
		__proto.onStageMouseUp = function (e) {
			MouseManager.instance.disableMouseEvent = false;
			Laya.stage.off(/*laya.events.Event.MOUSE_UP*/"mouseup", this, this.onStageMouseUp);
			Laya.stage.off(/*laya.events.Event.MOUSE_OUT*/"mouseout", this, this.onStageMouseUp);
			Laya.timer.clear(this, this.loop);
			if (this._clickOnly || !this.target) return;
			if (this.hasInertia) {
				if (this._offsets.length < 1) {
					this._offsets.push(this._parent.mouseX - this._lastX, this._parent.mouseY - this._lastY);
				}
				this._offsetX = this._offsetY = 0;
				var len = this._offsets.length;
				var n = Math.min(len, 6);
				var m = this._offsets.length - n;
				for (var i = len - 1; i > m; i--) {
					this._offsetY += this._offsets[i--];
					this._offsetX += this._offsets[i];
				}
				this._offsetX = this._offsetX / n * 2;
				this._offsetY = this._offsetY / n * 2;
				if (Math.abs(this._offsetX) > this.maxOffset) this._offsetX = this._offsetX > 0 ? this.maxOffset : -this.maxOffset;
				if (Math.abs(this._offsetY) > this.maxOffset) this._offsetY = this._offsetY > 0 ? this.maxOffset : -this.maxOffset;
				Laya.timer.frameLoop(1, this, this.tweenMove);
			} else if (this.elasticDistance > 0) {
				this.checkElastic();
			} else {
				this.clear();
			}
		}

		/**
		*橡皮筋效果检测。
		*/
		__proto.checkElastic = function () {
			var tx = NaN;
			var ty = NaN;
			if (this.target.x < this.area.x) tx = this.area.x;
			else if (this.target.x > this.area.x + this.area.width) tx = this.area.x + this.area.width;
			if (this.target.y < this.area.y) ty = this.area.y;
			else if (this.target.y > this.area.y + this.area.height) ty = this.area.y + this.area.height;
			if (!isNaN(tx) || !isNaN(ty)) {
				var obj = {};
				if (!isNaN(tx)) obj.x = tx;
				if (!isNaN(ty)) obj.y = ty;
				this._tween = Tween.to(this.target, obj, this.elasticBackTime, Ease.sineOut, Handler.create(this, this.clear), 0, false, false);
			} else {
				this.clear();
			}
		}

		/**
		*移动。
		*/
		__proto.tweenMove = function () {
			this._offsetX *= this.ratio * this._elasticRateX;
			this._offsetY *= this.ratio * this._elasticRateY;
			this.target.x += this._offsetX;
			this.target.y += this._offsetY;
			this.area && this.checkArea();
			this.target.event(/*laya.events.Event.DRAG_MOVE*/"dragmove", this.data);
			if ((Math.abs(this._offsetX) < 1 && Math.abs(this._offsetY) < 1) || this._elasticRateX < 0.5 || this._elasticRateY < 0.5) {
				Laya.timer.clear(this, this.tweenMove);
				if (this.elasticDistance > 0) this.checkElastic();
				else this.clear();
			}
		}

		/**
		*结束拖拽。
		*/
		__proto.clear = function () {
			if (this.target) {
				this.clearTimer();
				var sp = this.target;
				this.target = null;
				this._parent = null;
				sp.event(/*laya.events.Event.DRAG_END*/"dragend", this.data);
			}
		}

		return Dragging;
	})()


	/**
	*<code>Ease</code> 类定义了缓动函数，以便实现 <code>Tween</code> 动画的缓动效果。
	*/
	//class laya.utils.Ease
	var Ease = (function () {
		function Ease() { }
		__class(Ease, 'laya.utils.Ease');
		Ease.linearNone = function (t, b, c, d) {
			return c * t / d + b;
		}

		Ease.linearIn = function (t, b, c, d) {
			return c * t / d + b;
		}

		Ease.linearInOut = function (t, b, c, d) {
			return c * t / d + b;
		}

		Ease.linearOut = function (t, b, c, d) {
			return c * t / d + b;
		}

		Ease.bounceIn = function (t, b, c, d) {
			return c - Ease.bounceOut(d - t, 0, c, d) + b;
		}

		Ease.bounceInOut = function (t, b, c, d) {
			if (t < d * 0.5) return Ease.bounceIn(t * 2, 0, c, d) * .5 + b;
			else return Ease.bounceOut(t * 2 - d, 0, c, d) * .5 + c * .5 + b;
		}

		Ease.bounceOut = function (t, b, c, d) {
			if ((t /= d) < (1 / 2.75)) return c * (7.5625 * t * t) + b;
			else if (t < (2 / 2.75)) return c * (7.5625 * (t -= (1.5 / 2.75)) * t + .75) + b;
			else if (t < (2.5 / 2.75)) return c * (7.5625 * (t -= (2.25 / 2.75)) * t + .9375) + b;
			else return c * (7.5625 * (t -= (2.625 / 2.75)) * t + .984375) + b;
		}

		Ease.backIn = function (t, b, c, d, s) {
			(s === void 0) && (s = 1.70158);
			return c * (t /= d) * t * ((s + 1) * t - s) + b;
		}

		Ease.backInOut = function (t, b, c, d, s) {
			(s === void 0) && (s = 1.70158);
			if ((t /= d * 0.5) < 1) return c * 0.5 * (t * t * (((s *= (1.525)) + 1) * t - s)) + b;
			return c / 2 * ((t -= 2) * t * (((s *= (1.525)) + 1) * t + s) + 2) + b;
		}

		Ease.backOut = function (t, b, c, d, s) {
			(s === void 0) && (s = 1.70158);
			return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;
		}

		Ease.elasticIn = function (t, b, c, d, a, p) {
			(a === void 0) && (a = 0);
			(p === void 0) && (p = 0);
			var s;
			if (t == 0) return b;
			if ((t /= d) == 1) return b + c;
			if (!p) p = d * .3;
			if (!a || (c > 0 && a < c) || (c < 0 && a < -c)) {
				a = c;
				s = p / 4;
			} else s = p / Ease.PI2 * Math.asin(c / a);
			return -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * Ease.PI2 / p)) + b;
		}

		Ease.elasticInOut = function (t, b, c, d, a, p) {
			(a === void 0) && (a = 0);
			(p === void 0) && (p = 0);
			var s;
			if (t == 0) return b;
			if ((t /= d * 0.5) == 2) return b + c;
			if (!p) p = d * (.3 * 1.5);
			if (!a || (c > 0 && a < c) || (c < 0 && a < -c)) {
				a = c;
				s = p / 4;
			} else s = p / Ease.PI2 * Math.asin(c / a);
			if (t < 1) return -.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * Ease.PI2 / p)) + b;
			return a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t * d - s) * Ease.PI2 / p) * .5 + c + b;
		}

		Ease.elasticOut = function (t, b, c, d, a, p) {
			(a === void 0) && (a = 0);
			(p === void 0) && (p = 0);
			var s;
			if (t == 0) return b;
			if ((t /= d) == 1) return b + c;
			if (!p) p = d * .3;
			if (!a || (c > 0 && a < c) || (c < 0 && a < -c)) {
				a = c;
				s = p / 4;
			} else s = p / Ease.PI2 * Math.asin(c / a);
			return (a * Math.pow(2, -10 * t) * Math.sin((t * d - s) * Ease.PI2 / p) + c + b);
		}

		Ease.strongIn = function (t, b, c, d) {
			return c * (t /= d) * t * t * t * t + b;
		}

		Ease.strongInOut = function (t, b, c, d) {
			if ((t /= d * 0.5) < 1) return c * 0.5 * t * t * t * t * t + b;
			return c * 0.5 * ((t -= 2) * t * t * t * t + 2) + b;
		}

		Ease.strongOut = function (t, b, c, d) {
			return c * ((t = t / d - 1) * t * t * t * t + 1) + b;
		}

		Ease.sineInOut = function (t, b, c, d) {
			return -c * 0.5 * (Math.cos(Math.PI * t / d) - 1) + b;
		}

		Ease.sineIn = function (t, b, c, d) {
			return -c * Math.cos(t / d * Ease.HALF_PI) + c + b;
		}

		Ease.sineOut = function (t, b, c, d) {
			return c * Math.sin(t / d * Ease.HALF_PI) + b;
		}

		Ease.quintIn = function (t, b, c, d) {
			return c * (t /= d) * t * t * t * t + b;
		}

		Ease.quintInOut = function (t, b, c, d) {
			if ((t /= d * 0.5) < 1) return c * 0.5 * t * t * t * t * t + b;
			return c * 0.5 * ((t -= 2) * t * t * t * t + 2) + b;
		}

		Ease.quintOut = function (t, b, c, d) {
			return c * ((t = t / d - 1) * t * t * t * t + 1) + b;
		}

		Ease.quartIn = function (t, b, c, d) {
			return c * (t /= d) * t * t * t + b;
		}

		Ease.quartInOut = function (t, b, c, d) {
			if ((t /= d * 0.5) < 1) return c * 0.5 * t * t * t * t + b;
			return -c * 0.5 * ((t -= 2) * t * t * t - 2) + b;
		}

		Ease.quartOut = function (t, b, c, d) {
			return -c * ((t = t / d - 1) * t * t * t - 1) + b;
		}

		Ease.cubicIn = function (t, b, c, d) {
			return c * (t /= d) * t * t + b;
		}

		Ease.cubicInOut = function (t, b, c, d) {
			if ((t /= d * 0.5) < 1) return c * 0.5 * t * t * t + b;
			return c * 0.5 * ((t -= 2) * t * t + 2) + b;
		}

		Ease.cubicOut = function (t, b, c, d) {
			return c * ((t = t / d - 1) * t * t + 1) + b;
		}

		Ease.quadIn = function (t, b, c, d) {
			return c * (t /= d) * t + b;
		}

		Ease.quadInOut = function (t, b, c, d) {
			if ((t /= d * 0.5) < 1) return c * 0.5 * t * t + b;
			return -c * 0.5 * ((--t) * (t - 2) - 1) + b;
		}

		Ease.quadOut = function (t, b, c, d) {
			return -c * (t /= d) * (t - 2) + b;
		}

		Ease.expoIn = function (t, b, c, d) {
			return (t == 0) ? b : c * Math.pow(2, 10 * (t / d - 1)) + b - c * 0.001;
		}

		Ease.expoInOut = function (t, b, c, d) {
			if (t == 0) return b;
			if (t == d) return b + c;
			if ((t /= d * 0.5) < 1) return c * 0.5 * Math.pow(2, 10 * (t - 1)) + b;
			return c * 0.5 * (-Math.pow(2, -10 * --t) + 2) + b;
		}

		Ease.expoOut = function (t, b, c, d) {
			return (t == d) ? b + c : c * (-Math.pow(2, -10 * t / d) + 1) + b;
		}

		Ease.circIn = function (t, b, c, d) {
			return -c * (Math.sqrt(1 - (t /= d) * t) - 1) + b;
		}

		Ease.circInOut = function (t, b, c, d) {
			if ((t /= d * 0.5) < 1) return -c * 0.5 * (Math.sqrt(1 - t * t) - 1) + b;
			return c * 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1) + b;
		}

		Ease.circOut = function (t, b, c, d) {
			return c * Math.sqrt(1 - (t = t / d - 1) * t) + b;
		}

		Ease.HALF_PI = Math.PI * 0.5;
		Ease.PI2 = Math.PI * 2;
		return Ease;
	})()


	/**
	*鼠标点击区域，可以设置绘制一系列矢量图作为点击区域和非点击区域（目前只支持圆形，矩形，多边形）
	*/
	//class laya.utils.HitArea
	var HitArea = (function () {
		function HitArea() {
			/**@private */
			this._hit = null;
			/**@private */
			this._unHit = null;
		}

		__class(HitArea, 'laya.utils.HitArea');
		var __proto = HitArea.prototype;
		/**
		*是否包含某个点
		*@param x x坐标
		*@param y y坐标
		*@return 是否点击到
		*/
		__proto.isHit = function (x, y) {
			if (!HitArea.isHitGraphic(x, y, this.hit)) return false;
			return !HitArea.isHitGraphic(x, y, this.unHit);
		}

		/**
		*检测对象是否包含指定的点。
		*@param x 点的 X 轴坐标值（水平位置）。
		*@param y 点的 Y 轴坐标值（垂直位置）。
		*@return 如果包含指定的点，则值为 true；否则为 false。
		*/
		__proto.contains = function (x, y) {
			return this.isHit(x, y);
		}

		/**
		*可点击区域，可以设置绘制一系列矢量图作为点击区域（目前只支持圆形，矩形，多边形）
		*/
		__getset(0, __proto, 'hit', function () {
			if (!this._hit) this._hit = new Graphics();
			return this._hit;
		}, function (value) {
			this._hit = value;
		});

		/**
		*不可点击区域，可以设置绘制一系列矢量图作为非点击区域（目前只支持圆形，矩形，多边形）
		*/
		__getset(0, __proto, 'unHit', function () {
			if (!this._unHit) this._unHit = new Graphics();
			return this._unHit;
		}, function (value) {
			this._unHit = value;
		});

		HitArea.isHitGraphic = function (x, y, graphic) {
			if (!graphic) return false;
			var cmds;
			cmds = graphic.cmds;
			if (!cmds && graphic._one) {
				cmds = HitArea._cmds;
				cmds.length = 1;
				cmds[0] = graphic._one;
			}
			if (!cmds) return false;
			var i = 0, len = 0;
			len = cmds.length;
			var cmd;
			for (i = 0; i < len; i++) {
				cmd = cmds[i];
				if (!cmd) continue;
				var context = Render._context;
				switch (cmd.callee) {
					case context._translate:
					case 6:
						x -= cmd[0];
						y -= cmd[1];
					default:
				}
				if (HitArea.isHitCmd(x, y, cmd)) return true;
			}
			return false;
		}

		HitArea.isHitCmd = function (x, y, cmd) {
			if (!cmd) return false;
			var context = Render._context;
			var rst = false;
			switch (cmd["callee"]) {
				case context._drawRect:
				case 13:
					HitArea._rec.setTo(cmd[0], cmd[1], cmd[2], cmd[3]);
					rst = HitArea._rec.contains(x, y);
					break;
				case context._drawCircle:
				case context._fillCircle:
				case 14: ;
					var d = NaN;
					x -= cmd[0];
					y -= cmd[1];
					d = x * x + y * y;
					rst = d < cmd[2] * cmd[2];
					break;
				case context._drawPoly:
				case 18:
					x -= cmd[0];
					y -= cmd[1];
					rst = HitArea.ptInPolygon(x, y, cmd[2]);
					break;
				default:
					break;
			}
			return rst;
		}

		HitArea.ptInPolygon = function (x, y, areaPoints) {
			var p;
			p = HitArea._ptPoint;
			p.setTo(x, y);
			var nCross = 0;
			var p1x = NaN, p1y = NaN, p2x = NaN, p2y = NaN;
			var len = 0;
			len = areaPoints.length;
			for (var i = 0; i < len; i += 2) {
				p1x = areaPoints[i];
				p1y = areaPoints[i + 1];
				p2x = areaPoints[(i + 2) % len];
				p2y = areaPoints[(i + 3) % len];
				if (p1y == p2y)
					continue;
				if (p.y < Math.min(p1y, p2y))
					continue;
				if (p.y >= Math.max(p1y, p2y))
					continue;
				var tx = (p.y - p1y) * (p2x - p1x) / (p2y - p1y) + p1x;
				if (tx > p.x) {
					nCross++;
				}
			}
			return (nCross % 2 == 1);
		}

		HitArea._cmds = [];
		__static(HitArea,
			['_rec', function () { return this._rec = new Rectangle(); }, '_ptPoint', function () { return this._ptPoint = new Point(); }
			]);
		return HitArea;
	})()


	/**
	*@private
	*<code>HTMLChar</code> 是一个 HTML 字符类。
	*/
	//class laya.utils.HTMLChar
	var HTMLChar = (function () {
		function HTMLChar(char, w, h, style) {
			//this._sprite=null;
			//this._x=NaN;
			//this._y=NaN;
			//this._w=NaN;
			//this._h=NaN;
			/**表示是否是正常单词(英文|.|数字)。*/
			//this.isWord=false;
			/**字符。*/
			//this.char=null;
			/**字符数量。*/
			//this.charNum=NaN;
			/**CSS 样式。*/
			//this.style=null;
			this.char = char;
			this.charNum = char.charCodeAt(0);
			this._x = this._y = 0;
			this.width = w;
			this.height = h;
			this.style = style;
			this.isWord = !HTMLChar._isWordRegExp.test(char);
		}

		__class(HTMLChar, 'laya.utils.HTMLChar');
		var __proto = HTMLChar.prototype;
		Laya.imps(__proto, { "laya.display.ILayout": true })
		/**
		*设置与此对象绑定的显示对象 <code>Sprite</code> 。
		*@param sprite 显示对象 <code>Sprite</code> 。
		*/
		__proto.setSprite = function (sprite) {
			this._sprite = sprite;
		}

		/**
		*获取与此对象绑定的显示对象 <code>Sprite</code>。
		*@return
		*/
		__proto.getSprite = function () {
			return this._sprite;
		}

		/**@private */
		__proto._isChar = function () {
			return true;
		}

		/**@private */
		__proto._getCSSStyle = function () {
			return this.style;
		}

		/**
		*宽度。
		*/
		__getset(0, __proto, 'width', function () {
			return this._w;
		}, function (value) {
			this._w = value;
		});

		/**
		*此对象存储的 X 轴坐标值。
		*当设置此值时，如果此对象有绑定的 Sprite 对象，则改变 Sprite 对象的属性 x 的值。
		*/
		__getset(0, __proto, 'x', function () {
			return this._x;
		}, function (value) {
			if (this._sprite) {
				this._sprite.x = value;
			}
			this._x = value;
		});

		/**
		*此对象存储的 Y 轴坐标值。
		*当设置此值时，如果此对象有绑定的 Sprite 对象，则改变 Sprite 对象的属性 y 的值。
		*/
		__getset(0, __proto, 'y', function () {
			return this._y;
		}, function (value) {
			if (this._sprite) {
				this._sprite.y = value;
			}
			this._y = value;
		});

		/**
		*高度。
		*/
		__getset(0, __proto, 'height', function () {
			return this._h;
		}, function (value) {
			this._h = value;
		});

		HTMLChar._isWordRegExp = new RegExp("[\\w\.]", "");
		return HTMLChar;
	})()


	/**
	*<code>Log</code> 类用于在界面内显示日志记录信息。
	*/
	//class laya.utils.Log
	var Log = (function () {
		function Log() { }
		__class(Log, 'laya.utils.Log');
		Log.enable = function () {
			if (!Log._logdiv) {
				Log._logdiv = Browser.window.document.createElement('div');
				Browser.window.document.body.appendChild(Log._logdiv);
				Log._logdiv.style.cssText = "pointer-events:none;border:white;overflow:hidden;z-index:1000000;background:rgba(100,100,100,0.6);color:white;position: absolute;left:0px;top:0px;width:50%;height:50%;";
			}
		}

		Log.toggle = function () {
			var style = Log._logdiv.style;
			if (style.width == "1px") {
				style.width = style.height = "50%";
			} else {
				style.width = style.height = "1px";
			}
		}

		Log.print = function (value) {
			if (Log._logdiv) {
				if (Log._count >= Log.maxCount) Log.clear();
				Log._count++;
				Log._logdiv.innerText += value + "\n";
				Log._logdiv.scrollTop = Log._logdiv.scrollHeight;
			}
		}

		Log.clear = function () {
			Log._logdiv.innerText = "";
			Log._count = 0;
		}

		Log._logdiv = null;
		Log._count = 0;
		Log.maxCount = 20;
		return Log;
	})()


	/**
	*<code>Mouse</code> 类用于控制鼠标光标。
	*/
	//class laya.utils.Mouse
	var Mouse = (function () {
		function Mouse() { }
		__class(Mouse, 'laya.utils.Mouse');
		/**
		*设置鼠标样式
		*@param cursorStr
		*例如auto move no-drop col-resize
		*all-scroll pointer not-allowed row-resize
		*crosshair progress e-resize ne-resize
		*default text n-resize nw-resize
		*help vertical-text s-resize se-resize
		*inherit wait w-resize sw-resize
		*
		*/
		__getset(1, Mouse, 'cursor', function () {
			return Mouse._style.cursor;
		}, function (cursorStr) {
			Mouse._style.cursor = cursorStr;
		});

		Mouse.hide = function () {
			if (Mouse.cursor != "none") {
				Mouse._preCursor = Mouse.cursor;
				Mouse.cursor = "none";
			}
		}

		Mouse.show = function () {
			if (Mouse.cursor == "none") {
				if (Mouse._preCursor) {
					Mouse.cursor = Mouse._preCursor;
				} else {
					Mouse.cursor = "auto";
				}
			}
		}

		Mouse._preCursor = null;
		__static(Mouse,
			['_style', function () { return this._style = Browser.document.body.style; }
			]);
		return Mouse;
	})()


	/**
	*<p> <code>Pool</code> 是对象池类，用于对象的存贮、重复使用。</p>
	*<p>合理使用对象池，可以有效减少对象创建的开销，避免频繁的垃圾回收，从而优化游戏流畅度。</p>
	*/
	//class laya.utils.Pool
	var Pool = (function () {
		function Pool() { }
		__class(Pool, 'laya.utils.Pool');
		Pool.getPoolBySign = function (sign) {
			return Pool._poolDic[sign] || (Pool._poolDic[sign] = []);
		}

		Pool.clearBySign = function (sign) {
			if (Pool._poolDic[sign]) Pool._poolDic[sign].length = 0;
		}

		Pool.recover = function (sign, item) {
			if (item["__InPool"]) return;
			item["__InPool"] = true;
			Pool.getPoolBySign(sign).push(item);
		}

		Pool.getItemByClass = function (sign, cls) {
			var pool = Pool.getPoolBySign(sign);
			var rst = pool.length ? pool.pop() : new cls();
			rst["__InPool"] = false;
			return rst;
		}

		Pool.getItemByCreateFun = function (sign, createFun) {
			var pool = Pool.getPoolBySign(sign);
			var rst = pool.length ? pool.pop() : createFun();
			rst["__InPool"] = false;
			return rst;
		}

		Pool.getItem = function (sign) {
			var pool = Pool.getPoolBySign(sign);
			var rst = pool.length ? pool.pop() : null;
			if (rst) {
				rst["__InPool"] = false;
			}
			return rst;
		}

		Pool._poolDic = {};
		Pool.InPoolSign = "__InPool";
		return Pool;
	})()


	/**
	*@private
	*基于个数的对象缓存管理器
	*/
	//class laya.utils.PoolCache
	var PoolCache = (function () {
		function PoolCache() {
			/**
			*对象在Pool中的标识
			*/
			this.sign = null;
			/**
			*允许缓存的最大数量
			*/
			this.maxCount = 1000;
		}

		__class(PoolCache, 'laya.utils.PoolCache');
		var __proto = PoolCache.prototype;
		/**
		*获取缓存的对象列表
		*@return
		*
		*/
		__proto.getCacheList = function () {
			return Pool.getPoolBySign(this.sign);
		}

		/**
		*尝试清理缓存
		*@param force 是否强制清理
		*
		*/
		__proto.tryDispose = function (force) {
			var list;
			list = Pool.getPoolBySign(this.sign);
			if (list.length > this.maxCount) {
				list.splice(this.maxCount, list.length - this.maxCount);
			}
		}

		PoolCache.addPoolCacheManager = function (sign, maxCount) {
			(maxCount === void 0) && (maxCount = 100);
			var cache;
			cache = new PoolCache();
			cache.sign = sign;
			cache.maxCount = maxCount;
			CacheManager.regCacheByFunction(Utils.bind(cache.tryDispose, cache), Utils.bind(cache.getCacheList, cache));
		}

		return PoolCache;
	})()


	/**
	*<p> <code>Stat</code> 是一个性能统计面板，可以实时更新相关的性能参数。</p>
	*<p>参与统计的性能参数如下（所有参数都是每大约1秒进行更新）：<br/>
	*FPS(Canvas)/FPS(WebGL)：Canvas 模式或者 WebGL 模式下的帧频，也就是每秒显示的帧数，值越高、越稳定，感觉越流畅；<br/>
	*Sprite：统计所有渲染节点（包括容器）数量，它的大小会影响引擎进行节点遍历、数据组织和渲染的效率。其值越小，游戏运行效率越高；<br/>
	*DrawCall：此值是决定性能的重要指标，其值越小，游戏运行效率越高。Canvas模式下表示每大约1秒的图像绘制次数；WebGL模式下表示每大约1秒的渲染提交批次，每次准备数据并通知GPU渲染绘制的过程称为1次DrawCall，在每次DrawCall中除了在通知GPU的渲染上比较耗时之外，切换材质与shader也是非常耗时的操作；<br/>
	*CurMem：Canvas模式下，表示内存占用大小，值越小越好，过高会导致游戏闪退；WebGL模式下，表示内存与显存的占用，值越小越好；<br/>
	*Shader：是 WebGL 模式独有的性能指标，表示每大约1秒 Shader 提交次数，值越小越好；<br/>
	*Canvas：由三个数值组成，只有设置 CacheAs 后才会有值，默认为0/0/0。从左到右数值的意义分别为：每帧重绘的画布数量 / 缓存类型为"normal"类型的画布数量 / 缓存类型为"bitmap"类型的画布数量。</p>
	*/
	//class laya.utils.Stat
	var Stat = (function () {
		function Stat() { }
		__class(Stat, 'laya.utils.Stat');
		/**
		*点击性能统计显示区域的处理函数。
		*/
		__getset(1, Stat, 'onclick', null, function (fn) {
			if (Stat._sp) {
				Stat._sp.on("click", Stat._sp, fn);
			}
			if (Stat._canvas) {
				Stat._canvas.source.onclick = fn;
				Stat._canvas.source.style.pointerEvents = '';
			}
		});

		Stat.show = function (x, y) {
			(x === void 0) && (x = 0);
			(y === void 0) && (y = 0);
			if (Render.isConchApp) {
				Browser.window.conch.showFPS && Browser.window.conch.showFPS(x, y);
				return;
			}
			if (!Browser.onMiniGame && !Browser.onLimixiu) Stat._useCanvas = true;
			Stat._show = true;
			Stat._fpsData.length = 60;
			Stat._view[0] = { title: "FPS(Canvas)", value: "_fpsStr", color: "yellow", units: "int" };
			Stat._view[1] = { title: "Sprite", value: "_spriteStr", color: "white", units: "int" };
			Stat._view[2] = { title: "DrawCall", value: "drawCall", color: "white", units: "int" };
			Stat._view[3] = { title: "CurMem", value: "currentMemorySize", color: "yellow", units: "M" };
			if (Render.isWebGL) {
				Stat._view[4] = { title: "Shader", value: "shaderCall", color: "white", units: "int" };
				if (!Render.is3DMode) {
					Stat._view[0].title = "FPS(WebGL)";
					Stat._view[5] = { title: "Canvas", value: "_canvasStr", color: "white", units: "int" };
				} else {
					Stat._view[0].title = "FPS(3D)";
					Stat._view[5] = { title: "TriFaces", value: "trianglesFaces", color: "white", units: "int" };
					Stat._view[6] = { title: "treeNodeColl", value: "treeNodeCollision", color: "white", units: "int" };
					Stat._view[7] = { title: "treeSpriteColl", value: "treeSpriteCollision", color: "white", units: "int" };
				}
			} else {
				Stat._view[4] = { title: "Canvas", value: "_canvasStr", color: "white", units: "int" };
			}
			if (Stat._useCanvas) {
				Stat.createUIPre(x, y);
			} else
				Stat.createUI(x, y);
			Stat.enable();
		}

		Stat.createUIPre = function (x, y) {
			var pixel = Browser.pixelRatio;
			Stat._width = pixel * 130;
			Stat._vx = pixel * 75;
			Stat._height = pixel * (Stat._view.length * 12 + 3 * pixel) + 4;
			Stat._fontSize = 12 * pixel;
			for (var i = 0; i < Stat._view.length; i++) {
				Stat._view[i].x = 4;
				Stat._view[i].y = i * Stat._fontSize + 2 * pixel;
			}
			if (!Stat._canvas) {
				Stat._canvas = new HTMLCanvas('2D');
				Stat._canvas.size(Stat._width, Stat._height);
				Stat._ctx = Stat._canvas.getContext('2d');
				Stat._ctx.textBaseline = "top";
				Stat._ctx.font = Stat._fontSize + "px Sans-serif";
				Stat._canvas.source.style.cssText = "pointer-events:none;background:rgba(150,150,150,0.8);z-index:100000;position: absolute;direction:ltr;left:" + x + "px;top:" + y + "px;width:" + (Stat._width / pixel) + "px;height:" + (Stat._height / pixel) + "px;";
			}
			Stat._first = true;
			Stat.loop();
			Stat._first = false;
			Browser.container.appendChild(Stat._canvas.source);
		}

		Stat.createUI = function (x, y) {
			var stat = Stat._sp;
			var pixel = Browser.pixelRatio;
			if (!stat) {
				stat = new Sprite();
				Stat._leftText = new Text();
				Stat._leftText.pos(5, 5);
				Stat._leftText.color = "#ffffff";
				stat.addChild(Stat._leftText);
				Stat._txt = new Text();
				Stat._txt.pos(80 * pixel, 5);
				Stat._txt.color = "#ffffff";
				stat.addChild(Stat._txt);
				Stat._sp = stat;
			}
			stat.pos(x, y);
			var text = "";
			for (var i = 0; i < Stat._view.length; i++) {
				var one = Stat._view[i];
				text += one.title + "\n";
			}
			Stat._leftText.text = text;
			var width = pixel * 138;
			var height = pixel * (Stat._view.length * 12 + 3 * pixel) + 4;
			Stat._txt.fontSize = Stat._fontSize * pixel;
			Stat._leftText.fontSize = Stat._fontSize * pixel;
			stat.size(width, height);
			stat.graphics.clear();
			stat.graphics.setAlpha(0.5);
			stat.graphics.drawRect(0, 0, width, height, "#999999");
			stat.graphics.setAlpha(1);
			Stat.loop();
		}

		Stat.enable = function () {
			Laya.timer.frameLoop(1, Stat, Stat.loop);
		}

		Stat.hide = function () {
			Stat._show = false;
			Laya.timer.clear(Stat, Stat.loop);
			if (Stat._canvas) {
				Browser.removeElement(Stat._canvas.source);
			}
		}

		Stat.clear = function () {
			Stat.trianglesFaces = Stat.drawCall = Stat.shaderCall = Stat.spriteCount = Stat.spriteRenderUseCacheCount = Stat.treeNodeCollision = Stat.treeSpriteCollision = Stat.canvasNormal = Stat.canvasBitmap = Stat.canvasReCache = 0;
		}

		Stat.loop = function () {
			Stat._count++;
			var timer = Browser.now();
			if (timer - Stat._timer < 1000) return;
			var count = Stat._count;
			Stat.FPS = Math.round((count * 1000) / (timer - Stat._timer));
			if (Stat._show) {
				Stat.trianglesFaces = Math.round(Stat.trianglesFaces / count);
				if (!Stat._useCanvas) {
					Stat.drawCall = Math.round(Stat.drawCall / count) - 2;
					Stat.shaderCall = Math.round(Stat.shaderCall / count) - 4;
					Stat.spriteCount = Math.round(Stat.spriteCount / count) - 4;
				} else {
					Stat.drawCall = Math.round(Stat.drawCall / count) - 2;
					Stat.shaderCall = Math.round(Stat.shaderCall / count);
					Stat.spriteCount = Math.round(Stat.spriteCount / count) - 1;
				}
				Stat.spriteRenderUseCacheCount = Math.round(Stat.spriteRenderUseCacheCount / count);
				Stat.canvasNormal = Math.round(Stat.canvasNormal / count);
				Stat.canvasBitmap = Math.round(Stat.canvasBitmap / count);
				Stat.canvasReCache = Math.ceil(Stat.canvasReCache / count);
				Stat.treeNodeCollision = Math.round(Stat.treeNodeCollision / count);
				Stat.treeSpriteCollision = Math.round(Stat.treeSpriteCollision / count);
				var delay = Stat.FPS > 0 ? Math.floor(1000 / Stat.FPS).toString() : " ";
				Stat._fpsStr = Stat.FPS + (Stat.renderSlow ? " slow" : "") + " " + delay;
				Stat._spriteStr = Stat.spriteCount + (Stat.spriteRenderUseCacheCount ? ("/" + Stat.spriteRenderUseCacheCount) : '');
				Stat._canvasStr = Stat.canvasReCache + "/" + Stat.canvasNormal + "/" + Stat.canvasBitmap;
				Stat.currentMemorySize = ResourceManager.systemResourceManager.memorySize;
				if (Stat._useCanvas) {
					Stat.renderInfoPre();
				} else
					Stat.renderInfo();
				Stat.clear();
			}
			Stat._count = 0;
			Stat._timer = timer;
		}

		Stat.renderInfoPre = function () {
			if (Stat._canvas) {
				var ctx = Stat._ctx;
				ctx.clearRect(Stat._first ? 0 : Stat._vx, 0, Stat._width, Stat._height);
				for (var i = 0; i < Stat._view.length; i++) {
					var one = Stat._view[i];
					if (Stat._first) {
						ctx.fillStyle = "white";
						ctx.fillText(one.title, one.x, one.y, null, null, null);
					}
					ctx.fillStyle = one.color;
					var value = Stat[one.value];
					(one.units == "M") && (value = Math.floor(value / (1024 * 1024) * 100) / 100 + " M");
					ctx.fillText(value + "", one.x + Stat._vx, one.y, null, null, null);
				}
			}
		}

		Stat.renderInfo = function () {
			var text = "";
			for (var i = 0; i < Stat._view.length; i++) {
				var one = Stat._view[i];
				var value = Stat[one.value];
				(one.units == "M") && (value = Math.floor(value / (1024 * 1024) * 100) / 100 + " M");
				(one.units == "K") && (value = Math.floor(value / (1024) * 100) / 100 + " K");
				text += value + "\n";
			}
			Stat._txt.text = text;
		}

		Stat.FPS = 0;
		Stat.loopCount = 0;
		Stat.shaderCall = 0;
		Stat.drawCall = 0;
		Stat.trianglesFaces = 0;
		Stat.spriteCount = 0;
		Stat.spriteRenderUseCacheCount = 0;
		Stat.treeNodeCollision = 0;
		Stat.treeSpriteCollision = 0;
		Stat.canvasNormal = 0;
		Stat.canvasBitmap = 0;
		Stat.canvasReCache = 0;
		Stat.renderSlow = false;
		Stat.currentMemorySize = 0;
		Stat._fpsStr = null;
		Stat._canvasStr = null;
		Stat._spriteStr = null;
		Stat._fpsData = [];
		Stat._timer = 0;
		Stat._count = 0;
		Stat._view = [];
		Stat._fontSize = 12;
		Stat._txt = null;
		Stat._leftText = null;
		Stat._sp = null;
		Stat._show = false;
		Stat._useCanvas = false;
		Stat._canvas = null;
		Stat._ctx = null;
		Stat._first = false;
		Stat._vx = NaN;
		Stat._width = 0;
		Stat._height = 100;
		return Stat;
	})()


	/**
	*@private
	*<code>StringKey</code> 类用于存取字符串对应的数字。
	*/
	//class laya.utils.StringKey
	var StringKey = (function () {
		function StringKey() {
			this._strsToID = {};
			this._idToStrs = [];
			this._length = 0;
		}

		__class(StringKey, 'laya.utils.StringKey');
		var __proto = StringKey.prototype;
		/**
		*添加一个字符。
		*@param str 字符，将作为key 存储相应生成的数字。
		*@return 此字符对应的数字。
		*/
		__proto.add = function (str) {
			var index = this._strsToID[str];
			if (index != null) return index;
			this._idToStrs[this._length] = str;
			return this._strsToID[str] = this._length++;
		}

		/**
		*获取指定字符对应的ID。
		*@param str 字符。
		*@return 此字符对应的ID。
		*/
		__proto.getID = function (str) {
			var index = this._strsToID[str];
			return index == null ? -1 : index;
		}

		/**
		*根据指定ID获取对应字符。
		*@param id ID。
		*@return 此id对应的字符。
		*/
		__proto.getName = function (id) {
			var str = this._idToStrs[id];
			return str == null ? undefined : str;
		}

		return StringKey;
	})()


	/**
	*<code>Timer</code> 是时钟管理类。它是一个单例，不要手动实例化此类，应该通过 Laya.timer 访问。
	*/
	//class laya.utils.Timer
	var Timer = (function () {
		var TimerHandler;
		function Timer() {
			/**两帧之间的时间间隔,单位毫秒。*/
			this._delta = 0;
			/**时针缩放。*/
			this.scale = 1;
			/**当前的帧数。*/
			this.currFrame = 0;
			/**@private */
			this._mid = 1;
			/**@private */
			this._map = [];
			/**@private */
			this._laters = [];
			/**@private */
			this._handlers = [];
			/**@private */
			this._temp = [];
			/**@private */
			this._count = 0;
			this.currTimer = this._now();
			this._lastTimer = this._now();
			this._init();
		}

		__class(Timer, 'laya.utils.Timer');
		var __proto = Timer.prototype;
		/**@private */
		__proto._init = function () {
			Laya.timer && Laya.timer.frameLoop(1, this, this._update);
		}

		/**@private */
		__proto._now = function () {
			return /*__JS__ */Date.now();
		}

		/**
		*@private
		*帧循环处理函数。
		*/
		__proto._update = function () {
			if (this.scale <= 0) {
				this._lastTimer = this._now();
				return;
			};
			var frame = this.currFrame = this.currFrame + this.scale;
			var now = this._now();
			this._delta = (now - this._lastTimer) * this.scale;
			var timer = this.currTimer = this.currTimer + this._delta;
			this._lastTimer = now;
			var handlers = this._handlers;
			this._count = 0;
			for (i = 0, n = handlers.length; i < n; i++) {
				handler = handlers[i];
				if (handler.method !== null) {
					var t = handler.userFrame ? frame : timer;
					if (t >= handler.exeTime) {
						if (handler.repeat) {
							if (!handler.jumpFrame) {
								handler.exeTime += handler.delay;
								handler.run(false);
								if (t > handler.exeTime) {
									handler.exeTime += Math.ceil((t - handler.exeTime) / handler.delay) * handler.delay;
								}
							} else {
								while (t >= handler.exeTime) {
									handler.exeTime += handler.delay;
									handler.run(false);
								}
							}
						} else {
							handler.run(true);
						}
					}
				} else {
					this._count++;
				}
			}
			if (this._count > 30 || frame % 200 === 0) this._clearHandlers();
			var laters = this._laters;
			for (var i = 0, n = laters.length - 1; i <= n; i++) {
				var handler = laters[i];
				if (handler.method !== null) {
					this._map[handler.key] = null;
					handler.run(false);
				}
				this._recoverHandler(handler);
				i === n && (n = laters.length - 1);
			}
			laters.length = 0;
		}

		/**@private */
		__proto._clearHandlers = function () {
			var handlers = this._handlers;
			for (var i = 0, n = handlers.length; i < n; i++) {
				var handler = handlers[i];
				if (handler.method !== null) this._temp.push(handler);
				else this._recoverHandler(handler);
			}
			this._handlers = this._temp;
			this._temp = handlers;
			this._temp.length = 0;
		}

		/**@private */
		__proto._recoverHandler = function (handler) {
			if (this._map[handler.key] == handler) this._map[handler.key] = null;
			handler.clear();
			Timer._pool.push(handler);
		}

		/**@private */
		__proto._create = function (useFrame, repeat, delay, caller, method, args, coverBefore) {
			if (!delay) {
				method.apply(caller, args);
				return null;
			}
			if (coverBefore) {
				var handler = this._getHandler(caller, method);
				if (handler) {
					handler.repeat = repeat;
					handler.userFrame = useFrame;
					handler.delay = delay;
					handler.caller = caller;
					handler.method = method;
					handler.args = args;
					handler.exeTime = delay + (useFrame ? this.currFrame : this.currTimer + this._now() - this._lastTimer);
					return handler;
				}
			}
			handler = Timer._pool.length > 0 ? Timer._pool.pop() : new TimerHandler();
			handler.repeat = repeat;
			handler.userFrame = useFrame;
			handler.delay = delay;
			handler.caller = caller;
			handler.method = method;
			handler.args = args;
			handler.exeTime = delay + (useFrame ? this.currFrame : this.currTimer + this._now() - this._lastTimer) + 1;
			this._indexHandler(handler);
			this._handlers.push(handler);
			return handler;
		}

		/**@private */
		__proto._indexHandler = function (handler) {
			var caller = handler.caller;
			var method = handler.method;
			var cid = caller ? caller.$_GID || (caller.$_GID = Utils.getGID()) : 0;
			var mid = method.$_TID || (method.$_TID = (this._mid++) * 100000);
			handler.key = cid + mid;
			this._map[handler.key] = handler;
		}

		/**
		*定时执行一次。
		*@param delay 延迟时间(单位为毫秒)。
		*@param caller 执行域(this)。
		*@param method 定时器回调函数。
		*@param args 回调参数。
		*@param coverBefore 是否覆盖之前的延迟执行，默认为 true 。
		*/
		__proto.once = function (delay, caller, method, args, coverBefore) {
			(coverBefore === void 0) && (coverBefore = true);
			this._create(false, false, delay, caller, method, args, coverBefore);
		}

		/**
		*定时重复执行。
		*@param delay 间隔时间(单位毫秒)。
		*@param caller 执行域(this)。
		*@param method 定时器回调函数。
		*@param args 回调参数。
		*@param coverBefore 是否覆盖之前的延迟执行，默认为 true 。
		*@param jumpFrame 时钟是否跳帧。基于时间的循环回调，单位时间间隔内，如能执行多次回调，出于性能考虑，引擎默认只执行一次，设置jumpFrame=true后，则回调会连续执行多次
		*/
		__proto.loop = function (delay, caller, method, args, coverBefore, jumpFrame) {
			(coverBefore === void 0) && (coverBefore = true);
			(jumpFrame === void 0) && (jumpFrame = false);
			var handler = this._create(false, true, delay, caller, method, args, coverBefore);
			if (handler) handler.jumpFrame = jumpFrame;
		}

		/**
		*定时执行一次(基于帧率)。
		*@param delay 延迟几帧(单位为帧)。
		*@param caller 执行域(this)。
		*@param method 定时器回调函数。
		*@param args 回调参数。
		*@param coverBefore 是否覆盖之前的延迟执行，默认为 true 。
		*/
		__proto.frameOnce = function (delay, caller, method, args, coverBefore) {
			(coverBefore === void 0) && (coverBefore = true);
			this._create(true, false, delay, caller, method, args, coverBefore);
		}

		/**
		*定时重复执行(基于帧率)。
		*@param delay 间隔几帧(单位为帧)。
		*@param caller 执行域(this)。
		*@param method 定时器回调函数。
		*@param args 回调参数。
		*@param coverBefore 是否覆盖之前的延迟执行，默认为 true 。
		*/
		__proto.frameLoop = function (delay, caller, method, args, coverBefore) {
			(coverBefore === void 0) && (coverBefore = true);
			this._create(true, true, delay, caller, method, args, coverBefore);
		}

		/**返回统计信息。*/
		__proto.toString = function () {
			return "callLater:" + this._laters.length + " handlers:" + this._handlers.length + " pool:" + Timer._pool.length;
		}

		/**
		*清理定时器。
		*@param caller 执行域(this)。
		*@param method 定时器回调函数。
		*/
		__proto.clear = function (caller, method) {
			var handler = this._getHandler(caller, method);
			if (handler) {
				this._map[handler.key] = null; handler.key = 0;
				handler.clear();
			}
		}

		/**
		*清理对象身上的所有定时器。
		*@param caller 执行域(this)。
		*/
		__proto.clearAll = function (caller) {
			if (!caller) return;
			for (var i = 0, n = this._handlers.length; i < n; i++) {
				var handler = this._handlers[i];
				if (handler.caller === caller) {
					this._map[handler.key] = null; handler.key = 0;
					handler.clear();
				}
			}
		}

		/**@private */
		__proto._getHandler = function (caller, method) {
			var cid = caller ? caller.$_GID || (caller.$_GID = Utils.getGID()) : 0;
			var mid = method.$_TID || (method.$_TID = (this._mid++) * 100000);
			return this._map[cid + mid];
		}

		/**
		*延迟执行。
		*@param caller 执行域(this)。
		*@param method 定时器回调函数。
		*@param args 回调参数。
		*/
		__proto.callLater = function (caller, method, args) {
			if (this._getHandler(caller, method) == null) {
				if (Timer._pool.length)
					var handler = Timer._pool.pop();
				else handler = new TimerHandler();
				handler.caller = caller;
				handler.method = method;
				handler.args = args;
				this._indexHandler(handler);
				this._laters.push(handler);
			}
		}

		/**
		*立即执行 callLater 。
		*@param caller 执行域(this)。
		*@param method 定时器回调函数。
		*/
		__proto.runCallLater = function (caller, method) {
			var handler = this._getHandler(caller, method);
			if (handler && handler.method != null) {
				this._map[handler.key] = null;
				handler.run(true);
			}
		}

		/**
		*立即提前执行定时器，执行之后从队列中删除
		*@param caller 执行域(this)。
		*@param method 定时器回调函数。
		*/
		__proto.runTimer = function (caller, method) {
			this.runCallLater(caller, method);
		}

		/**
		*两帧之间的时间间隔,单位毫秒。
		*/
		__getset(0, __proto, 'delta', function () {
			return this._delta;
		});

		Timer._pool = [];
		Timer.__init$ = function () {
			/**@private */
			//class TimerHandler
			TimerHandler = (function () {
				function TimerHandler() {
					this.key = 0;
					this.repeat = false;
					this.delay = 0;
					this.userFrame = false;
					this.exeTime = 0;
					this.caller = null;
					this.method = null;
					this.args = null;
					this.jumpFrame = false;
				}
				__class(TimerHandler, '');
				var __proto = TimerHandler.prototype;
				__proto.clear = function () {
					this.caller = null;
					this.method = null;
					this.args = null;
				}
				__proto.run = function (withClear) {
					var caller = this.caller;
					if (caller && caller.destroyed) return this.clear();
					var method = this.method;
					var args = this.args;
					withClear && this.clear();
					if (method == null) return;
					args ? method.apply(caller, args) : method.call(caller);
				}
				return TimerHandler;
			})()
		}

		return Timer;
	})()


	/**
	*<code>Tween</code> 是一个缓动类。使用此类能够实现对目标对象属性的渐变。
	*/
	//class laya.utils.Tween
	var Tween = (function () {
		function Tween() {
			/**@private */
			//this._complete=null;
			/**@private */
			//this._target=null;
			/**@private */
			//this._ease=null;
			/**@private */
			//this._props=null;
			/**@private */
			//this._duration=0;
			/**@private */
			//this._delay=0;
			/**@private */
			//this._startTimer=0;
			/**@private */
			//this._usedTimer=0;
			/**@private */
			//this._usedPool=false;
			/**@private */
			//this._delayParam=null;
			/**@private 唯一标识，TimeLintLite用到*/
			this.gid = 0;
			/**更新回调，缓动数值发生变化时，回调变化的值*/
			//this.update=null;
		}

		__class(Tween, 'laya.utils.Tween');
		var __proto = Tween.prototype;
		/**
		*缓动对象的props属性到目标值。
		*@param target 目标对象(即将更改属性值的对象)。
		*@param props 变化的属性列表，比如{x:100,y:20,ease:Ease.backOut,complete:Handler.create(this,onComplete),update:new Handler(this,onComplete)}。
		*@param duration 花费的时间，单位毫秒。
		*@param ease 缓动类型，默认为匀速运动。
		*@param complete 结束回调函数。
		*@param delay 延迟执行时间。
		*@param coverBefore 是否覆盖之前的缓动。
		*@return 返回Tween对象。
		*/
		__proto.to = function (target, props, duration, ease, complete, delay, coverBefore) {
			(delay === void 0) && (delay = 0);
			(coverBefore === void 0) && (coverBefore = false);
			return this._create(target, props, duration, ease, complete, delay, coverBefore, true, false, true);
		}

		/**
		*从props属性，缓动到当前状态。
		*@param target 目标对象(即将更改属性值的对象)。
		*@param props 变化的属性列表，比如{x:100,y:20,ease:Ease.backOut,complete:Handler.create(this,onComplete),update:new Handler(this,onComplete)}。
		*@param duration 花费的时间，单位毫秒。
		*@param ease 缓动类型，默认为匀速运动。
		*@param complete 结束回调函数。
		*@param delay 延迟执行时间。
		*@param coverBefore 是否覆盖之前的缓动。
		*@return 返回Tween对象。
		*/
		__proto.from = function (target, props, duration, ease, complete, delay, coverBefore) {
			(delay === void 0) && (delay = 0);
			(coverBefore === void 0) && (coverBefore = false);
			return this._create(target, props, duration, ease, complete, delay, coverBefore, false, false, true);
		}

		/**@private */
		__proto._create = function (target, props, duration, ease, complete, delay, coverBefore, isTo, usePool, runNow) {
			if (!target) throw new Error("Tween:target is null");
			this._target = target;
			this._duration = duration;
			this._ease = ease || props.ease || Tween.easeNone;
			this._complete = complete || props.complete;
			this._delay = delay;
			this._props = [];
			this._usedTimer = 0;
			this._startTimer = Browser.now();
			this._usedPool = usePool;
			this._delayParam = null;
			this.update = props.update;
			var gid = (target.$_GID || (target.$_GID = Utils.getGID()));
			if (!Tween.tweenMap[gid]) {
				Tween.tweenMap[gid] = [this];
			} else {
				if (coverBefore) Tween.clearTween(target);
				Tween.tweenMap[gid].push(this);
			}
			if (runNow) {
				if (delay <= 0) this.firstStart(target, props, isTo);
				else {
					this._delayParam = [target, props, isTo];
					Laya.scaleTimer.once(delay, this, this.firstStart, this._delayParam);
				}
			} else {
				this._initProps(target, props, isTo);
			}
			return this;
		}

		__proto.firstStart = function (target, props, isTo) {
			this._delayParam = null;
			if (target.destroyed) {
				this.clear();
				return;
			}
			this._initProps(target, props, isTo);
			this._beginLoop();
		}

		__proto._initProps = function (target, props, isTo) {
			for (var p in props) {
				if ((typeof (target[p]) == 'number')) {
					var start = isTo ? target[p] : props[p];
					var end = isTo ? props[p] : target[p];
					this._props.push([p, start, end - start]);
					if (!isTo) target[p] = start;
				}
			}
		}

		__proto._beginLoop = function () {
			Laya.scaleTimer.frameLoop(1, this, this._doEase);
		}

		/**执行缓动**/
		__proto._doEase = function () {
			this._updateEase(Browser.now());
		}

		/**@private */
		__proto._updateEase = function (time) {
			var target = this._target;
			if (!target) return;
			if (target.destroyed) return Tween.clearTween(target);
			var usedTimer = this._usedTimer = time - this._startTimer - this._delay;
			if (usedTimer < 0) return;
			if (usedTimer >= this._duration) return this.complete();
			var ratio = usedTimer > 0 ? this._ease(usedTimer, 0, 1, this._duration) : 0;
			var props = this._props;
			for (var i = 0, n = props.length; i < n; i++) {
				var prop = props[i];
				target[prop[0]] = prop[1] + (ratio * prop[2]);
			}
			if (this.update) this.update.run();
		}

		/**
		*立即结束缓动并到终点。
		*/
		__proto.complete = function () {
			if (!this._target) return;
			Laya.scaleTimer.runTimer(this, this.firstStart);
			var target = this._target;
			var props = this._props;
			var handler = this._complete;
			for (var i = 0, n = props.length; i < n; i++) {
				var prop = props[i];
				target[prop[0]] = prop[1] + prop[2];
			}
			if (this.update) this.update.run();
			this.clear();
			handler && handler.run();
		}

		/**
		*暂停缓动，可以通过resume或restart重新开始。
		*/
		__proto.pause = function () {
			Laya.scaleTimer.clear(this, this._beginLoop);
			Laya.scaleTimer.clear(this, this._doEase);
			Laya.scaleTimer.clear(this, this.firstStart);
			var time = Browser.now();
			var dTime = NaN;
			dTime = time - this._startTimer - this._delay;
			if (dTime < 0) {
				this._usedTimer = dTime;
			}
		}

		/**
		*设置开始时间。
		*@param startTime 开始时间。
		*/
		__proto.setStartTime = function (startTime) {
			this._startTimer = startTime;
		}

		/**
		*停止并清理当前缓动。
		*/
		__proto.clear = function () {
			if (this._target) {
				this._remove();
				this._clear();
			}
		}

		/**
		*@private
		*/
		__proto._clear = function () {
			this.pause();
			Laya.scaleTimer.clear(this, this.firstStart);
			this._complete = null;
			this._target = null;
			this._ease = null;
			this._props = null;
			this._delayParam = null;
			if (this._usedPool) {
				this.update = null;
				Pool.recover("tween", this);
			}
		}

		/**回收到对象池。*/
		__proto.recover = function () {
			this._usedPool = true;
			this._clear();
		}

		__proto._remove = function () {
			var tweens = Tween.tweenMap[this._target.$_GID];
			if (tweens) {
				for (var i = 0, n = tweens.length; i < n; i++) {
					if (tweens[i] === this) {
						tweens.splice(i, 1);
						break;
					}
				}
			}
		}

		/**
		*重新开始暂停的缓动。
		*/
		__proto.restart = function () {
			this.pause();
			this._usedTimer = 0;
			this._startTimer = Browser.now();
			if (this._delayParam) {
				Laya.scaleTimer.once(this._delay, this, this.firstStart, this._delayParam);
				return;
			};
			var props = this._props;
			for (var i = 0, n = props.length; i < n; i++) {
				var prop = props[i];
				this._target[prop[0]] = prop[1];
			}
			Laya.scaleTimer.once(this._delay, this, this._beginLoop);
		}

		/**
		*恢复暂停的缓动。
		*/
		__proto.resume = function () {
			if (this._usedTimer >= this._duration) return;
			this._startTimer = Browser.now() - this._usedTimer - this._delay;
			if (this._delayParam) {
				if (this._usedTimer < 0) {
					Laya.scaleTimer.once(-this._usedTimer, this, this.firstStart, this._delayParam);
				} else {
					this.firstStart.apply(this, this._delayParam);
				}
			} else {
				this._beginLoop();
			}
		}

		/**设置当前执行比例**/
		__getset(0, __proto, 'progress', function(){
			return Math.min(Math.max((Browser.now()-this._startTimer)/this._duration,0),1);
		}, function (v) {
			var uTime = v * this._duration;
			this._startTimer = Browser.now() - this._delay - uTime;
		});

		Tween.to = function (target, props, duration, ease, complete, delay, coverBefore, autoRecover) {
			(delay === void 0) && (delay = 0);
			(coverBefore === void 0) && (coverBefore = false);
			(autoRecover === void 0) && (autoRecover = true);
			return Pool.getItemByClass("tween", Tween)._create(target, props, duration, ease, complete, delay, coverBefore, true, autoRecover, true);
		}

		Tween.from = function (target, props, duration, ease, complete, delay, coverBefore, autoRecover) {
			(delay === void 0) && (delay = 0);
			(coverBefore === void 0) && (coverBefore = false);
			(autoRecover === void 0) && (autoRecover = true);
			return Pool.getItemByClass("tween", Tween)._create(target, props, duration, ease, complete, delay, coverBefore, false, autoRecover, true);
		}

		Tween.clearAll = function (target) {
			if (!target || !target.$_GID) return;
			var tweens = Tween.tweenMap[target.$_GID];
			if (tweens) {
				for (var i = 0, n = tweens.length; i < n; i++) {
					tweens[i]._clear();
				}
				tweens.length = 0;
			}
		}

		Tween.clear = function (tween) {
			tween.clear();
		}

		Tween.clearTween = function (target) {
			Tween.clearAll(target);
		}

		Tween.easeNone = function (t, b, c, d) {
			return c * t / d + b;
		}

		Tween.tweenMap = {};
		return Tween;
	})()


	/**
	*<code>Utils</code> 是工具类。
	*/
	//class laya.utils.Utils
	var Utils = (function () {
		function Utils() { }
		__class(Utils, 'laya.utils.Utils');
		Utils.toRadian = function (angle) {
			return angle * Utils._pi2;
		}

		Utils.toAngle = function (radian) {
			return radian * Utils._pi;
		}

		Utils.toHexColor = function (color) {
			if (color < 0 || isNaN(color)) return null;
			var str = color.toString(16);
			while (str.length < 6) str = "0" + str;
			return "#" + str;
		}

		Utils.getGID = function () {
			return Utils._gid++;
		}

		Utils.concatArray = function (source, array) {
			if (!array) return source;
			if (!source) return array;
			var i = 0, len = array.length;
			for (i = 0; i < len; i++) {
				source.push(array[i]);
			}
			return source;
		}

		Utils.clearArray = function (array) {
			if (!array) return array;
			array.length = 0;
			return array;
		}

		Utils.copyArray = function (source, array) {
			source || (source = []);
			if (!array) return source;
			source.length = array.length;
			var i = 0, len = array.length;
			for (i = 0; i < len; i++) {
				source[i] = array[i];
			}
			return source;
		}

		Utils.getGlobalRecByPoints = function (sprite, x0, y0, x1, y1) {
			var newLTPoint;
			newLTPoint = new Point(x0, y0);
			newLTPoint = sprite.localToGlobal(newLTPoint);
			var newRBPoint;
			newRBPoint = new Point(x1, y1);
			newRBPoint = sprite.localToGlobal(newRBPoint);
			return Rectangle._getWrapRec([newLTPoint.x, newLTPoint.y, newRBPoint.x, newRBPoint.y]);
		}

		Utils.getGlobalPosAndScale = function (sprite) {
			return Utils.getGlobalRecByPoints(sprite, 0, 0, 1, 1);
		}

		Utils.bind = function (fun, scope) {
			var rst = fun;
		/*__JS__ */rst = fun.bind(scope);;
			return rst;
		}

		Utils.measureText = function (txt, font) {
			return RunDriver.measureText(txt, font);
		}

		Utils.updateOrder = function (array) {
			if (!array || array.length < 2) return false;
			var i = 1, j = 0, len = array.length, key = NaN, c;
			while (i < len) {
				j = i;
				c = array[j];
				key = array[j]._zOrder;
				while (--j > -1) {
					if (array[j]._zOrder > key) array[j + 1] = array[j];
					else break;
				}
				array[j + 1] = c;
				i++;
			};
			var model = c.parent.conchModel;
			if (model) {
				if (model.updateZOrder != null) {
					model.updateZOrder();
				} else {
					for (i = 0; i < len; i++) {
						model.removeChild(array[i].conchModel);
					}
					for (i = 0; i < len; i++) {
						model.addChildAt(array[i].conchModel, i);
					}
				}
			}
			return true;
		}

		Utils.transPointList = function (points, x, y) {
			var i = 0, len = points.length;
			for (i = 0; i < len; i += 2) {
				points[i] += x;
				points[i + 1] += y;
			}
		}

		Utils.parseInt = function (str, radix) {
			(radix === void 0) && (radix = 0);
			var result = Browser.window.parseInt(str, radix);
			if (isNaN(result)) return 0;
			return result;
		}

		Utils.getFileExtension = function (path) {
			Utils._extReg.lastIndex = path.lastIndexOf(".");
			var result = Utils._extReg.exec(path);
			if (result && result.length > 1) {
				return result[1].toLowerCase();
			}
			return null;
		}

		Utils.getTransformRelativeToWindow = function (coordinateSpace, x, y) {
			var stage = Laya.stage;
			var globalTransform = laya.utils.Utils.getGlobalPosAndScale(coordinateSpace);
			var canvasMatrix = stage._canvasTransform.clone();
			var canvasLeft = canvasMatrix.tx;
			var canvasTop = canvasMatrix.ty;
			canvasMatrix.rotate(-Math.PI / 180 * Laya.stage.canvasDegree);
			canvasMatrix.scale(Laya.stage.clientScaleX, Laya.stage.clientScaleY);
			var perpendicular = (Laya.stage.canvasDegree % 180 != 0);
			var tx = NaN, ty = NaN;
			if (perpendicular) {
				tx = y + globalTransform.y;
				ty = x + globalTransform.x;
				tx *= canvasMatrix.d;
				ty *= canvasMatrix.a;
				if (Laya.stage.canvasDegree == 90) {
					tx = canvasLeft - tx;
					ty += canvasTop;
				}
				else {
					tx += canvasLeft;
					ty = canvasTop - ty;
				}
			}
			else {
				tx = x + globalTransform.x;
				ty = y + globalTransform.y;
				tx *= canvasMatrix.a;
				ty *= canvasMatrix.d;
				tx += canvasLeft;
				ty += canvasTop;
			};
			var domScaleX = NaN, domScaleY = NaN;
			if (perpendicular) {
				domScaleX = canvasMatrix.d * globalTransform.height;
				domScaleY = canvasMatrix.a * globalTransform.width;
			} else {
				domScaleX = canvasMatrix.a * globalTransform.width;
				domScaleY = canvasMatrix.d * globalTransform.height;
			}
			return { x: tx, y: ty, scaleX: domScaleX, scaleY: domScaleY };
		}

		Utils.fitDOMElementInArea = function (dom, coordinateSpace, x, y, width, height) {
			if (!dom._fitThe3AirInitialized) {
				dom._fitThe3AirInitialized = true;
				dom.style.transformOrigin = dom.style.webKittransformOrigin = "left top";
				dom.style.position = "absolute"
			};
			var transform = Utils.getTransformRelativeToWindow(coordinateSpace, x, y);
			dom.style.transform = dom.style.webkitTransform = "scale(" + transform.scaleX + "," + transform.scaleY + ") rotate(" + (Laya.stage.canvasDegree) + "deg)";
			dom.style.width = width + 'px';
			dom.style.height = height + 'px';
			dom.style.left = transform.x + 'px';
			dom.style.top = transform.y + 'px';
		}

		Utils.isOkTextureList = function (textureList) {
			if (!textureList) return false;
			var i = 0, len = textureList.length;
			var tTexture;
			for (i = 0; i < len; i++) {
				tTexture = textureList[i];
				if (!tTexture || !tTexture.source) return false;
			}
			return true;
		}

		Utils.isOKCmdList = function (cmds) {
			if (!cmds) return false;
			var i = 0, len = cmds.length;
			var context = Render._context;
			var cmd;
			var tex;
			for (i = 0; i < len; i++) {
				cmd = cmds[i];
				switch (cmd.callee) {
					case context._drawTexture:
					case context._fillTexture:
					case context._drawTextureWithTransform:
						tex = cmd[0];
						if (!tex || !tex.source) return false;
				}
			}
			return true;
		}

		Utils._gid = 1;
		Utils._pi = 180 / Math.PI;
		Utils._pi2 = Math.PI / 180;
		Utils._extReg = /\.(\w+)\??/g;
		Utils.parseXMLFromString = function (value) {
			var rst;
			value = value.replace(/>\s+</g, '><');
		/*__JS__ */rst = (new DOMParser()).parseFromString(value, 'text/xml');
			if (rst.firstChild.textContent.indexOf("This page contains the following errors") > -1) {
				throw new Error(rst.firstChild.firstChild.textContent);
			}
			return rst;
		}

		return Utils;
	})()


	/**
	*@private
	*/
	//class laya.utils.VectorGraphManager
	var VectorGraphManager = (function () {
		function VectorGraphManager() {
			this.useDic = {};
			this.shapeDic = {};
			this.shapeLineDic = {};
			this._id = 0;
			this._checkKey = false;
			this._freeIdArray = [];
			if (Render.isWebGL) {
				CacheManager.regCacheByFunction(Utils.bind(this.startDispose, this), Utils.bind(this.getCacheList, this));
			}
		}

		__class(VectorGraphManager, 'laya.utils.VectorGraphManager');
		var __proto = VectorGraphManager.prototype;
		/**
		*得到个空闲的ID
		*@return
		*/
		__proto.getId = function () {
			return this._id++;
		}

		/**
		*添加一个图形到列表中
		*@param id
		*@param shape
		*/
		__proto.addShape = function (id, shape) {
			this.shapeDic[id] = shape;
			if (!this.useDic[id]) {
				this.useDic[id] = true;
			}
		}

		/**
		*添加一个线图形到列表中
		*@param id
		*@param Line
		*/
		__proto.addLine = function (id, Line) {
			this.shapeLineDic[id] = Line;
			if (!this.shapeLineDic[id]) {
				this.shapeLineDic[id] = true;
			}
		}

		/**
		*检测一个对象是否在使用中
		*@param id
		*/
		__proto.getShape = function (id) {
			if (this._checkKey) {
				if (this.useDic[id] != null) {
					this.useDic[id] = true;
				}
			}
		}

		/**
		*删除一个图形对象
		*@param id
		*/
		__proto.deleteShape = function (id) {
			if (this.shapeDic[id]) {
				this.shapeDic[id] = null;
				delete this.shapeDic[id];
			}
			if (this.shapeLineDic[id]) {
				this.shapeLineDic[id] = null;
				delete this.shapeLineDic[id];
			}
			if (this.useDic[id] != null) {
				delete this.useDic[id];
			}
		}

		/**
		*得到缓存列表
		*@return
		*/
		__proto.getCacheList = function () {
			var str;
			var list = [];
			for (str in this.shapeDic) {
				list.push(this.shapeDic[str]);
			}
			for (str in this.shapeLineDic) {
				list.push(this.shapeLineDic[str]);
			}
			return list;
		}

		/**
		*开始清理状态，准备销毁
		*/
		__proto.startDispose = function (key) {
			var str;
			for (str in this.useDic) {
				this.useDic[str] = false;
			}
			this._checkKey = true;
		}

		/**
		*确认销毁
		*/
		__proto.endDispose = function () {
			if (this._checkKey) {
				var str;
				for (str in this.useDic) {
					if (!this.useDic[str]) {
						this.deleteShape(str);
					}
				}
				this._checkKey = false;
			}
		}

		VectorGraphManager.getInstance = function () {
			return VectorGraphManager.instance = VectorGraphManager.instance || new VectorGraphManager();
		}

		VectorGraphManager.instance = null;
		return VectorGraphManager;
	})()


	/**
	*封装弱引用WeakMap
	*如果支持WeakMap，则使用WeakMap，如果不支持，则用Object代替
	*注意：如果采用Object，为了防止内存泄漏，则采用定时清理缓存策略
	*/
	//class laya.utils.WeakObject
	var WeakObject = (function () {
		function WeakObject() {
			/**@private */
			this._obj = null;
			this._obj = WeakObject.supportWeakMap ? new Browser.window.WeakMap() : {};
			if (!WeakObject.supportWeakMap) WeakObject._maps.push(this);
		}

		__class(WeakObject, 'laya.utils.WeakObject');
		var __proto = WeakObject.prototype;
		/**
		*设置缓存
		*@param key kye对象，可被回收
		*@param value object对象，可被回收
		*/
		__proto.set = function (key, value) {
			if (key == null) return;
			if (WeakObject.supportWeakMap) {
				var objKey = key;
				if ((typeof key == 'string') || (typeof key == 'number')) {
					objKey = WeakObject._keys[key];
					if (!objKey) objKey = WeakObject._keys[key] = { k: key };
				}
				this._obj.set(objKey, value);
			} else {
				if ((typeof key == 'string') || (typeof key == 'number')) {
					this._obj[key] = value;
				} else {
					key.$_GID || (key.$_GID = Utils.getGID());
					this._obj[key.$_GID] = value;
				}
			}
		}

		/**
		*获取缓存
		*@param key kye对象，可被回收
		*/
		__proto.get = function (key) {
			if (key == null) return null;
			if (WeakObject.supportWeakMap) {
				var objKey = ((typeof key == 'string') || (typeof key == 'number')) ? WeakObject._keys[key] : key;
				if (!objKey) return null;
				return this._obj.get(objKey);
			} else {
				if ((typeof key == 'string') || (typeof key == 'number')) return this._obj[key];
				return this._obj[key.$_GID];
			}
		}

		/**
		*删除缓存
		*/
		__proto.del = function (key) {
			if (key == null) return;
			if (WeakObject.supportWeakMap) {
				var objKey = ((typeof key == 'string') || (typeof key == 'number')) ? WeakObject._keys[key] : key;
				if (!objKey) return;
			/*__JS__ */this._obj.delete(objKey);
			} else {
				if ((typeof key == 'string') || (typeof key == 'number')) delete this._obj[key];
				else delete this._obj[this._obj.$_GID];
			}
		}

		/**
		*是否有缓存
		*/
		__proto.has = function (key) {
			if (key == null) return false;
			if (WeakObject.supportWeakMap) {
				var objKey = ((typeof key == 'string') || (typeof key == 'number')) ? WeakObject._keys[key] : key;
				return this._obj.has(objKey);
			} else {
				if ((typeof key == 'string') || (typeof key == 'number')) return this._obj[key] != null;
				return this._obj[this._obj.$_GID] != null;
			}
		}

		WeakObject.__init__ = function () {
			WeakObject.supportWeakMap = Browser.window.WeakMap != null;
			if (!WeakObject.supportWeakMap) Laya.timer.loop(WeakObject.delInterval, null, WeakObject.clearCache);
		}

		WeakObject.clearCache = function () {
			for (var i = 0, n = WeakObject._maps.length; i < n; i++) {
				var obj = WeakObject._maps[i];
				obj._obj = {};
			}
		}

		WeakObject.supportWeakMap = false;
		WeakObject.delInterval = 5 * 60 * 1000;
		WeakObject._keys = {};
		WeakObject._maps = [];
		__static(WeakObject,
			['I', function () { return this.I = new WeakObject(); }
			]);
		return WeakObject;
	})()


	/**
	*@private
	*/
	//class laya.utils.WordText
	var WordText = (function () {
		function WordText() {
			this.id = NaN;
			this.save = [];
			this.toUpperCase = null;
			this.changed = false;
			this._text = null;
		}

		__class(WordText, 'laya.utils.WordText');
		var __proto = WordText.prototype;
		__proto.setText = function (txt) {
			this.changed = true;
			this._text = txt;
		}

		__proto.toString = function () {
			return this._text;
		}

		__proto.charCodeAt = function (i) {
			return this._text ? this._text.charCodeAt(i) : NaN;
		}

		__proto.charAt = function (i) {
			return this._text ? this._text.charAt(i) : null;
		}

		__getset(0, __proto, 'length', function () {
			return this._text ? this._text.length : 0;
		});

		return WordText;
	})()


	/**
	*<code>Node</code> 类是可放在显示列表中的所有对象的基类。该显示列表管理 Laya 运行时中显示的所有对象。使用 Node 类排列显示列表中的显示对象。Node 对象可以有子显示对象。
	*/
	//class laya.display.Node extends laya.events.EventDispatcher
	var Node = (function (_super) {
		function Node() {
			/**@private */
			this._bits = 0;
			/**@private 是否在显示列表中显示*/
			this._displayedInStage = false;
			/**@private 父节点对象*/
			this._parent = null;
			/**@private */
			this.conchModel = null;
			/**节点名称。*/
			this.name = "";
			/**[只读]是否已经销毁。对象销毁后不能再使用。*/
			this._destroyed = false;
			Node.__super.call(this);
			this._childs = Node.ARRAY_EMPTY;
			this._$P = Node.PROP_EMPTY;
			this.timer = Laya.scaleTimer;
			this.conchModel = Render.isConchNode ? this.createConchModel() : null;
		}

		__class(Node, 'laya.display.Node', _super);
		var __proto = Node.prototype;
		/**@private */
		__proto._setBit = function (type, value) {
			if (type == 0x1) {
				var preValue = this._getBit(type);
				if (preValue != value) {
					this._updateDisplayedInstage();
				}
			}
			if (value) {
				this._bits |= type;
			} else {
				this._bits &= ~type;
			}
		}

		/**@private */
		__proto._getBit = function (type) {
			return (this._bits & type) != 0;
		}

		/**@private */
		__proto._setUpNoticeChain = function () {
			if (this._getBit(0x1)) {
				this._setUpNoticeType(0x1);
			}
		}

		/**@private */
		__proto._setUpNoticeType = function (type) {
			var ele = this;
			ele._setBit(type, true);
			ele = ele.parent;
			while (ele) {
				if (ele._getBit(type)) return;
				ele._setBit(type, true);
				ele = ele.parent;
			}
		}

		/**
		*<p>增加事件侦听器，以使侦听器能够接收事件通知。</p>
		*<p>如果侦听鼠标事件，则会自动设置自己和父亲节点的属性 mouseEnabled 的值为 true(如果父节点mouseEnabled=false，则停止设置父节点mouseEnabled属性)。</p>
		*@param type 事件的类型。
		*@param caller 事件侦听函数的执行域。
		*@param listener 事件侦听函数。
		*@param args （可选）事件侦听函数的回调参数。
		*@return 此 EventDispatcher 对象。
		*/
		__proto.on = function (type, caller, listener, args) {
			if (type ===/*laya.events.Event.DISPLAY*/"display" || type ===/*laya.events.Event.UNDISPLAY*/"undisplay") {
				if (!this._getBit(0x1)) {
					this._setUpNoticeType(0x1);
				}
			}
			return this._createListener(type, caller, listener, args, false);
		}

		/**
		*<p>增加事件侦听器，以使侦听器能够接收事件通知，此侦听事件响应一次后则自动移除侦听。</p>
		*<p>如果侦听鼠标事件，则会自动设置自己和父亲节点的属性 mouseEnabled 的值为 true(如果父节点mouseEnabled=false，则停止设置父节点mouseEnabled属性)。</p>
		*@param type 事件的类型。
		*@param caller 事件侦听函数的执行域。
		*@param listener 事件侦听函数。
		*@param args （可选）事件侦听函数的回调参数。
		*@return 此 EventDispatcher 对象。
		*/
		__proto.once = function (type, caller, listener, args) {
			if (type ===/*laya.events.Event.DISPLAY*/"display" || type ===/*laya.events.Event.UNDISPLAY*/"undisplay") {
				if (!this._getBit(0x1)) {
					this._setUpNoticeType(0x1);
				}
			}
			return this._createListener(type, caller, listener, args, true);
		}

		/**@private */
		__proto.createConchModel = function () {
			return null;
		}

		/**
		*<p>销毁此对象。destroy对象默认会把自己从父节点移除，并且清理自身引用关系，等待js自动垃圾回收机制回收。destroy后不能再使用。</p>
		*<p>destroy时会移除自身的事情监听，自身的timer监听，移除子对象及从父节点移除自己。</p>
		*@param destroyChild （可选）是否同时销毁子节点，若值为true,则销毁子节点，否则不销毁子节点。
		*/
		__proto.destroy = function (destroyChild) {
			(destroyChild === void 0) && (destroyChild = true);
			this._destroyed = true;
			this._parent && this._parent.removeChild(this);
			if (this._childs) {
				if (destroyChild) this.destroyChildren();
				else this.removeChildren();
			}
			this._childs = null;
			this._$P = null;
			this.offAll();
			this.timer.clearAll(this);
		}

		/**
		*销毁所有子对象，不销毁自己本身。
		*/
		__proto.destroyChildren = function () {
			if (this._childs) {
				for (var i = this._childs.length - 1; i > -1; i--) {
					this._childs[i].destroy(true);
				}
			}
		}

		/**
		*添加子节点。
		*@param node 节点对象
		*@return 返回添加的节点
		*/
		__proto.addChild = function (node) {
			if (!node || this.destroyed || node === this) return node;
			if ((node).zOrder) this._set$P("hasZorder", true);
			if (node._parent === this) {
				var index = this.getChildIndex(node);
				if (index !== this._childs.length - 1) {
					this._childs.splice(index, 1);
					this._childs.push(node);
					if (this.conchModel) {
						this.conchModel.removeChild(node.conchModel);
						this.conchModel.addChildAt(node.conchModel, this._childs.length - 1);
					}
					this._childChanged();
				}
			} else {
				node.parent && node.parent.removeChild(node);
				this._childs === Node.ARRAY_EMPTY && (this._childs = []);
				this._childs.push(node);
				this.conchModel && this.conchModel.addChildAt(node.conchModel, this._childs.length - 1);
				node.parent = this;
				this._childChanged();
			}
			return node;
		}

		/**
		*批量增加子节点
		*@param ...args 无数子节点。
		*/
		__proto.addChildren = function (__args) {
			var args = arguments;
			var i = 0, n = args.length;
			while (i < n) {
				this.addChild(args[i++]);
			}
		}

		/**
		*添加子节点到指定的索引位置。
		*@param node 节点对象。
		*@param index 索引位置。
		*@return 返回添加的节点。
		*/
		__proto.addChildAt = function (node, index) {
			if (!node || this.destroyed || node === this) return node;
			if ((node).zOrder) this._set$P("hasZorder", true);
			if (index >= 0 && index <= this._childs.length) {
				if (node._parent === this) {
					var oldIndex = this.getChildIndex(node);
					this._childs.splice(oldIndex, 1);
					this._childs.splice(index, 0, node);
					if (this.conchModel) {
						this.conchModel.removeChild(node.conchModel);
						this.conchModel.addChildAt(node.conchModel, index);
					}
					this._childChanged();
				} else {
					node.parent && node.parent.removeChild(node);
					this._childs === Node.ARRAY_EMPTY && (this._childs = []);
					this._childs.splice(index, 0, node);
					this.conchModel && this.conchModel.addChildAt(node.conchModel, index);
					node.parent = this;
				}
				return node;
			} else {
				throw new Error("appendChildAt:The index is out of bounds");
			}
		}

		/**
		*根据子节点对象，获取子节点的索引位置。
		*@param node 子节点。
		*@return 子节点所在的索引位置。
		*/
		__proto.getChildIndex = function (node) {
			return this._childs.indexOf(node);
		}

		/**
		*根据子节点的名字，获取子节点对象。
		*@param name 子节点的名字。
		*@return 节点对象。
		*/
		__proto.getChildByName = function (name) {
			var nodes = this._childs;
			if (nodes) {
				for (var i = 0, n = nodes.length; i < n; i++) {
					var node = nodes[i];
					if (node.name === name) return node;
				}
			}
			return null;
		}

		/**@private */
		__proto._get$P = function (key) {
			return this._$P[key];
		}

		/**@private */
		__proto._set$P = function (key, value) {
			if (!this.destroyed) {
				this._$P === Node.PROP_EMPTY && (this._$P = {});
				this._$P[key] = value;
			}
			return value;
		}

		/**
		*根据子节点的索引位置，获取子节点对象。
		*@param index 索引位置
		*@return 子节点
		*/
		__proto.getChildAt = function (index) {
			return this._childs[index];
		}

		/**
		*设置子节点的索引位置。
		*@param node 子节点。
		*@param index 新的索引。
		*@return 返回子节点本身。
		*/
		__proto.setChildIndex = function (node, index) {
			var childs = this._childs;
			if (index < 0 || index >= childs.length) {
				throw new Error("setChildIndex:The index is out of bounds.");
			};
			var oldIndex = this.getChildIndex(node);
			if (oldIndex < 0) throw new Error("setChildIndex:node is must child of this object.");
			childs.splice(oldIndex, 1);
			childs.splice(index, 0, node);
			if (this.conchModel) {
				this.conchModel.removeChild(node.conchModel);
				this.conchModel.addChildAt(node.conchModel, index);
			}
			this._childChanged();
			return node;
		}

		/**
		*@private
		*子节点发生改变。
		*@param child 子节点。
		*/
		__proto._childChanged = function (child) { }
		/**
		*删除子节点。
		*@param node 子节点
		*@return 被删除的节点
		*/
		__proto.removeChild = function (node) {
			if (!this._childs) return node;
			var index = this._childs.indexOf(node);
			return this.removeChildAt(index);
		}

		/**
		*从父容器删除自己，如已经被删除不会抛出异常。
		*@return 当前节点（ Node ）对象。
		*/
		__proto.removeSelf = function () {
			this._parent && this._parent.removeChild(this);
			return this;
		}

		/**
		*根据子节点名字删除对应的子节点对象，如果找不到不会抛出异常。
		*@param name 对象名字。
		*@return 查找到的节点（ Node ）对象。
		*/
		__proto.removeChildByName = function (name) {
			var node = this.getChildByName(name);
			node && this.removeChild(node);
			return node;
		}

		/**
		*根据子节点索引位置，删除对应的子节点对象。
		*@param index 节点索引位置。
		*@return 被删除的节点。
		*/
		__proto.removeChildAt = function (index) {
			var node = this.getChildAt(index);
			if (node) {
				this._childs.splice(index, 1);
				this.conchModel && this.conchModel.removeChild(node.conchModel);
				node.parent = null;
			}
			return node;
		}

		/**
		*删除指定索引区间的所有子对象。
		*@param beginIndex 开始索引。
		*@param endIndex 结束索引。
		*@return 当前节点对象。
		*/
		__proto.removeChildren = function (beginIndex, endIndex) {
			(beginIndex === void 0) && (beginIndex = 0);
			(endIndex === void 0) && (endIndex = 0x7fffffff);
			if (this._childs && this._childs.length > 0) {
				var childs = this._childs;
				if (beginIndex === 0 && endIndex >= n) {
					var arr = childs;
					this._childs = Node.ARRAY_EMPTY;
				} else {
					arr = childs.splice(beginIndex, endIndex - beginIndex);
				}
				for (var i = 0, n = arr.length; i < n; i++) {
					arr[i].parent = null;
					this.conchModel && this.conchModel.removeChild(arr[i].conchModel);
				}
			}
			return this;
		}

		/**
		*替换子节点。
		*@internal 将传入的新节点对象替换到已有子节点索引位置处。
		*@param newNode 新节点。
		*@param oldNode 老节点。
		*@return 返回新节点。
		*/
		__proto.replaceChild = function (newNode, oldNode) {
			var index = this._childs.indexOf(oldNode);
			if (index > -1) {
				this._childs.splice(index, 1, newNode);
				if (this.conchModel) {
					this.conchModel.removeChild(oldNode.conchModel);
					this.conchModel.addChildAt(newNode.conchModel, index);
				}
				oldNode.parent = null;
				newNode.parent = this;
				return newNode;
			}
			return null;
		}

		/**@private */
		__proto._updateDisplayedInstage = function () {
			var ele;
			ele = this;
			var stage = Laya.stage;
			this._displayedInStage = false;
			while (ele) {
				if (ele._getBit(0x1)) {
					this._displayedInStage = ele._displayedInStage;
					break;
				}
				if (ele == stage || ele._displayedInStage) {
					this._displayedInStage = true;
					break;
				}
				ele = ele.parent;
			}
		}

		/**@private */
		__proto._setDisplay = function (value) {
			if (this._displayedInStage !== value) {
				this._displayedInStage = value;
				if (value) this.event(/*laya.events.Event.DISPLAY*/"display");
				else this.event(/*laya.events.Event.UNDISPLAY*/"undisplay");
			}
		}

		/**
		*@private
		*设置指定节点对象是否可见(是否在渲染列表中)。
		*@param node 节点。
		*@param display 是否可见。
		*/
		__proto._displayChild = function (node, display) {
			var childs = node._childs;
			if (childs) {
				for (var i = 0, n = childs.length; i < n; i++) {
					var child = childs[i];
					if (!child._getBit(0x1)) continue;
					if (child._childs.length > 0) {
						this._displayChild(child, display);
					} else {
						child._setDisplay(display);
					}
				}
			}
			node._setDisplay(display);
		}

		/**
		*当前容器是否包含指定的 <code>Node</code> 节点对象 。
		*@param node 指定的 <code>Node</code> 节点对象 。
		*@return 一个布尔值表示是否包含指定的 <code>Node</code> 节点对象 。
		*/
		__proto.contains = function (node) {
			if (node === this) return true;
			while (node) {
				if (node.parent === this) return true;
				node = node.parent;
			}
			return false;
		}

		/**
		*定时重复执行某函数。功能同Laya.timer.timerLoop()。
		*@param delay 间隔时间(单位毫秒)。
		*@param caller 执行域(this)。
		*@param method 结束时的回调方法。
		*@param args （可选）回调参数。
		*@param coverBefore （可选）是否覆盖之前的延迟执行，默认为true。
		*@param jumpFrame 时钟是否跳帧。基于时间的循环回调，单位时间间隔内，如能执行多次回调，出于性能考虑，引擎默认只执行一次，设置jumpFrame=true后，则回调会连续执行多次
		*/
		__proto.timerLoop = function (delay, caller, method, args, coverBefore, jumpFrame) {
			(coverBefore === void 0) && (coverBefore = true);
			(jumpFrame === void 0) && (jumpFrame = false);
			this.timer.loop(delay, caller, method, args, coverBefore, jumpFrame);
		}

		/**
		*定时执行某函数一次。功能同Laya.timer.timerOnce()。
		*@param delay 延迟时间(单位毫秒)。
		*@param caller 执行域(this)。
		*@param method 结束时的回调方法。
		*@param args （可选）回调参数。
		*@param coverBefore （可选）是否覆盖之前的延迟执行，默认为true。
		*/
		__proto.timerOnce = function (delay, caller, method, args, coverBefore) {
			(coverBefore === void 0) && (coverBefore = true);
			this.timer._create(false, false, delay, caller, method, args, coverBefore);
		}

		/**
		*定时重复执行某函数(基于帧率)。功能同Laya.timer.frameLoop()。
		*@param delay 间隔几帧(单位为帧)。
		*@param caller 执行域(this)。
		*@param method 结束时的回调方法。
		*@param args （可选）回调参数。
		*@param coverBefore （可选）是否覆盖之前的延迟执行，默认为true。
		*/
		__proto.frameLoop = function (delay, caller, method, args, coverBefore) {
			(coverBefore === void 0) && (coverBefore = true);
			this.timer._create(true, true, delay, caller, method, args, coverBefore);
		}

		/**
		*定时执行一次某函数(基于帧率)。功能同Laya.timer.frameOnce()。
		*@param delay 延迟几帧(单位为帧)。
		*@param caller 执行域(this)
		*@param method 结束时的回调方法
		*@param args （可选）回调参数
		*@param coverBefore （可选）是否覆盖之前的延迟执行，默认为true
		*/
		__proto.frameOnce = function (delay, caller, method, args, coverBefore) {
			(coverBefore === void 0) && (coverBefore = true);
			this.timer._create(true, false, delay, caller, method, args, coverBefore);
		}

		/**
		*清理定时器。功能同Laya.timer.clearTimer()。
		*@param caller 执行域(this)。
		*@param method 结束时的回调方法。
		*/
		__proto.clearTimer = function (caller, method) {
			this.timer.clear(caller, method);
		}

		/**
		*子对象数量。
		*/
		__getset(0, __proto, 'numChildren', function () {
			return this._childs.length;
		});

		/**
		*[只读]是否已经销毁。对象销毁后不能再使用。
		*@return
		*/
		__getset(0, __proto, 'destroyed', function () {
			return this._destroyed;
		});

		/**父节点。*/
		__getset(0, __proto, 'parent', function () {
			return this._parent;
		}, function (value) {
			if (this._parent !== value) {
				if (value) {
					this._parent = value;
					this.event(/*laya.events.Event.ADDED*/"added");
					if (this._getBit(0x1)) {
						this._setUpNoticeChain();
						value.displayedInStage && this._displayChild(this, true);
					}
					value._childChanged(this);
				} else {
					this.event(/*laya.events.Event.REMOVED*/"removed");
					this._parent._childChanged();
					if (this._getBit(0x1)) this._displayChild(this, false);
					this._parent = value;
				}
			}
		});

		/**表示是否在显示列表中显示。*/
		__getset(0, __proto, 'displayedInStage', function () {
			if (this._getBit(0x1)) return this._displayedInStage;
			this._setUpNoticeType(0x1);
			return this._displayedInStage;
		});

		Node.ARRAY_EMPTY = [];
		Node.PROP_EMPTY = {};
		Node.NOTICE_DISPLAY = 0x1;
		Node.MOUSEENABLE = 0x2;
		return Node;
	})(EventDispatcher)


	/**
	*@private
	*<code>CSSStyle</code> 类是元素CSS样式定义类。
	*/
	//class laya.display.css.CSSStyle extends laya.display.css.Style
	var CSSStyle = (function (_super) {
		function CSSStyle(ower) {
			this._bgground = null;
			this._border = null;
			//this._ower=null;
			this._rect = null;
			/**@private */
			this.underLine = 0;
			/**行高。 */
			this.lineHeight = 0;
			CSSStyle.__super.call(this);
			this._padding = CSSStyle._PADDING;
			this._spacing = CSSStyle._SPACING;
			this._aligns = CSSStyle._ALIGNS;
			this._font = Font.EMPTY;
			this._ower = ower;
		}

		__class(CSSStyle, 'laya.display.css.CSSStyle', _super);
		var __proto = CSSStyle.prototype;
		/**@inheritDoc */
		__proto.destroy = function () {
			this._ower = null;
			this._font = null;
			this._rect = null;
		}

		/**
		*复制传入的 CSSStyle 属性值。
		*@param src 待复制的 CSSStyle 对象。
		*/
		__proto.inherit = function (src) {
			this._font = src._font;
			this._spacing = src._spacing === CSSStyle._SPACING ? CSSStyle._SPACING : src._spacing.slice();
			this.lineHeight = src.lineHeight;
		}

		/**@private */
		__proto._widthAuto = function () {
			return (this._type & 0x40000) !== 0;
		}

		/**@inheritDoc */
		__proto.widthed = function (sprite) {
			return (this._type & 0x8) != 0;
		}

		/**
		*@private
		*/
		__proto._calculation = function (type, value) {
			if (value.indexOf('%') < 0) return false;
			var ower = this._ower;
			var parent = ower.parent;
			var rect = this._rect;
			function getValue(pw, w, nums) {
				return (pw * nums[0] + w * nums[1] + nums[2]);
			}
			function onParentResize(type) {
				var pw = parent.width, w = ower.width;
				rect.width && (ower.width = getValue(pw, w, rect.width));
				rect.height && (ower.height = getValue(pw, w, rect.height));
				rect.left && (ower.x = getValue(pw, w, rect.left));
				rect.top && (ower.y = getValue(pw, w, rect.top));
			}
			if (rect === null) {
				parent._getCSSStyle()._type |= 0x80000;
				parent.on(/*laya.events.Event.RESIZE*/"resize", this, onParentResize);
				this._rect = rect = { input: {} };
			};
			var nums = value.split(' ');
			nums[0] = parseFloat(nums[0]) / 100;
			if (nums.length == 1)
				nums[1] = nums[2] = 0;
			else {
				nums[1] = parseFloat(nums[1]) / 100;
				nums[2] = parseFloat(nums[2]);
			}
			rect[type] = nums;
			rect.input[type] = value;
			onParentResize(type);
			return true;
		}

		/**
		*是否已设置高度。
		*@param sprite 显示对象 Sprite。
		*@return 一个Boolean 表示是否已设置高度。
		*/
		__proto.heighted = function (sprite) {
			return (this._type & 0x2000) != 0;
		}

		/**
		*设置宽高。
		*@param w 宽度。
		*@param h 高度。
		*/
		__proto.size = function (w, h) {
			var ower = this._ower;
			var resize = false;
			if (w !== -1 && w != this._ower.width) {
				this._type |= 0x8;
				this._ower.width = w;
				resize = true;
			}
			if (h !== -1 && h != this._ower.height) {
				this._type |= 0x2000;
				this._ower.height = h;
				resize = true;
			}
			if (resize) {
				ower._layoutLater();
				(this._type & 0x80000) && ower.event(/*laya.events.Event.RESIZE*/"resize", this);
			}
		}

		/**@private */
		__proto._getAlign = function () {
			return this._aligns[0];
		}

		/**@private */
		__proto._getValign = function () {
			return this._aligns[1];
		}

		/**@private */
		__proto._getCssFloat = function () {
			return (this._type & 0x8000) != 0 ? 0x8000 : 0;
		}

		__proto._createFont = function () {
			return (this._type & 0x1000) ? this._font : (this._type |= 0x1000, this._font = new Font(this._font));
		}

		/**@inheritDoc */
		__proto.render = function (sprite, context, x, y) {
			var w = sprite.width;
			var h = sprite.height;
			x -= sprite.pivotX;
			y -= sprite.pivotY;
			this._bgground && this._bgground.color != null && context.ctx.fillRect(x, y, w, h, this._bgground.color);
			this._border && this._border.color && context.drawRect(x, y, w, h, this._border.color.strColor, this._border.size);
		}

		/**@inheritDoc */
		__proto.getCSSStyle = function () {
			return this;
		}

		/**
		*设置 CSS 样式字符串。
		*@param text CSS样式字符串。
		*/
		__proto.cssText = function (text) {
			this.attrs(CSSStyle.parseOneCSS(text, ';'));
		}

		/**
		*根据传入的属性名、属性值列表，设置此对象的属性值。
		*@param attrs 属性名与属性值列表。
		*/
		__proto.attrs = function (attrs) {
			if (attrs) {
				for (var i = 0, n = attrs.length; i < n; i++) {
					var attr = attrs[i];
					this[attr[0]] = attr[1];
				}
			}
		}

		/**@inheritDoc */
		__proto.setTransform = function (value) {
			(value === 'none') ? (this._tf = Style._TF_EMPTY) : this.attrs(CSSStyle.parseOneCSS(value, ','));
		}

		/**
		*定义 X 轴、Y 轴移动转换。
		*@param x X 轴平移量。
		*@param y Y 轴平移量。
		*/
		__proto.translate = function (x, y) {
			this._tf === Style._TF_EMPTY && (this._tf = new TransformInfo());
			this._tf.translateX = x;
			this._tf.translateY = y;
		}

		/**
		*定义 缩放转换。
		*@param x X 轴缩放值。
		*@param y Y 轴缩放值。
		*/
		__proto.scale = function (x, y) {
			this._tf === Style._TF_EMPTY && (this._tf = new TransformInfo());
			this._tf.scaleX = x;
			this._tf.scaleY = y;
		}

		/**@private */
		__proto._enableLayout = function () {
			return (this._type & 0x2) === 0 && (this._type & 0x4) === 0;
		}

		/**
		*是否显示为块级元素。
		*/
		__getset(0, __proto, 'block', _super.prototype._$get_block, function (value) {
			value ? (this._type |= 0x1) : (this._type &= (~0x1));
		});

		/**
		*垂直对齐方式。
		*/
		__getset(0, __proto, 'valign', function () {
			return CSSStyle._valigndef[this._aligns[1]];
		}, function (value) {
			this._aligns === CSSStyle._ALIGNS && (this._aligns = [0, 0, 0]);
			this._aligns[1] = CSSStyle._valigndef[value];
		});

		/**
		*高度。
		*/
		__getset(0, __proto, 'height', null, function (h) {
			this._type |= 0x2000;
			if ((typeof h == 'string')) {
				if (this._calculation("height", h)) return;
				h = parseInt(h);
			}
			this.size(-1, h);
		});

		/**
		*宽度。
		*/
		__getset(0, __proto, 'width', null, function (w) {
			this._type |= 0x8;
			if ((typeof w == 'string')) {
				var offset = w.indexOf('auto');
				if (offset >= 0) {
					this._type |= 0x40000;
					w = w.substr(0, offset);
				}
				if (this._calculation("width", w)) return;
				w = parseInt(w);
			}
			this.size(w, -1);
		});

		/**
		*字体粗细。
		*/
		__getset(0, __proto, 'fontWeight', function () {
			return this._font.weight;
		}, function (value) {
			this._createFont().weight = value;
		});

		/**
		*表示左边距。
		*/
		__getset(0, __proto, 'left', null, function (value) {
			var ower = this._ower;
			if (((typeof value == 'string'))) {
				if (value === "center")
					value = "50% -50% 0";
				else if (value === "right")
					value = "100% -100% 0";
				if (this._calculation("left", value)) return;
				value = parseInt(value);
			}
			ower.x = value;
		});

		__getset(0, __proto, '_translate', null, function (value) {
			this.translate(value[0], value[1]);
		});

		/**@inheritDoc */
		__getset(0, __proto, 'absolute', function () {
			return (this._type & 0x4) !== 0;
		});

		/**
		*表示上边距。
		*/
		__getset(0, __proto, 'top', null, function (value) {
			var ower = this._ower;
			if (((typeof value == 'string'))) {
				if (value === "middle")
					value = "50% -50% 0";
				else if (value === "bottom")
					value = "100% -100% 0";
				if (this._calculation("top", value)) return;
				value = parseInt(value);
			}
			ower.y = value;
		});

		/**
		*水平对齐方式。
		*/
		__getset(0, __proto, 'align', function () {
			return CSSStyle._aligndef[this._aligns[0]];
		}, function (value) {
			this._aligns === CSSStyle._ALIGNS && (this._aligns = [0, 0, 0]);
			this._aligns[0] = CSSStyle._aligndef[value];
		});

		/**
		*表示是否加粗。
		*/
		__getset(0, __proto, 'bold', function () {
			return this._font.bold;
		}, function (value) {
			this._createFont().bold = value;
		});

		/**
		*边距信息。
		*/
		__getset(0, __proto, 'padding', function () {
			return this._padding;
		}, function (value) {
			this._padding = value;
		});

		/**
		*行间距。
		*/
		__getset(0, __proto, 'leading', function () {
			return this._spacing[1];
		}, function (d) {
			((typeof d == 'string')) && (d = parseInt(d + ""));
			this._spacing === CSSStyle._SPACING && (this._spacing = [0, 0]);
			this._spacing[1] = d;
		});

		/**
		*是否是行元素。
		*/
		__getset(0, __proto, 'lineElement', function () {
			return (this._type & 0x10000) != 0;
		}, function (value) {
			value ? (this._type |= 0x10000) : (this._type &= (~0x10000));
		});

		/**
		*浮动方向。
		*/
		__getset(0, __proto, 'cssFloat', function () {
			return (this._type & 0x8000) != 0 ? "right" : "left";
		}, function (value) {
			this.lineElement = false;
			value === "right" ? (this._type |= 0x8000) : (this._type &= (~0x8000));
		});

		/**
		*添加到文本的修饰。
		*/
		__getset(0, __proto, 'textDecoration', function () {
			return this._font.decoration;
		}, function (value) {
			this._createFont().decoration = value;
		});

		/**
		*设置如何处理元素内的空白。
		*/
		__getset(0, __proto, 'whiteSpace', function () {
			return (this._type & 0x20000) ? "nowrap" : "";
		}, function (type) {
			type === "nowrap" && (this._type |= 0x20000);
			type === "none" && (this._type &= ~0x20000);
		});

		__getset(0, __proto, 'background', null, function (value) {
			if (!value) {
				this._bgground = null;
				return;
			}
			this._bgground || (this._bgground = {});
			this._bgground.color = value;
			this._ower.conchModel && this._ower.conchModel.bgColor(value);
			this._type |= 0x4000;
			this._ower._renderType |=/*laya.renders.RenderSprite.STYLE*/0x100;
		});

		/**
		*表示是否换行。
		*/
		__getset(0, __proto, 'wordWrap', function () {
			return (this._type & 0x20000) === 0;
		}, function (value) {
			value ? (this._type &= ~0x20000) : (this._type |= 0x20000);
		});

		/**
		*字体颜色。
		*/
		__getset(0, __proto, 'color', function () {
			return this._font.color;
		}, function (value) {
			this._createFont().color = value;
		});

		/**
		*<p>指定文本字段是否是密码文本字段。</p>
		*如果此属性的值为 true，则文本字段被视为密码文本字段，并使用星号而不是实际字符来隐藏输入的字符。如果为 false，则不会将文本字段视为密码文本字段。
		*/
		__getset(0, __proto, 'password', function () {
			return this._font.password;
		}, function (value) {
			this._createFont().password = value;
		});

		/**
		*背景颜色。
		*/
		__getset(0, __proto, 'backgroundColor', function () {
			return this._bgground ? this._bgground.color : null;
		}, function (value) {
			if (value === 'none') this._bgground = null;
			else (this._bgground || (this._bgground = {}), this._bgground.color = value);
			this._ower.conchModel && this._ower.conchModel.bgColor(value);
			this._ower._renderType |=/*laya.renders.RenderSprite.STYLE*/0x100;
		});

		/**
		*字体信息。
		*/
		__getset(0, __proto, 'font', function () {
			return this._font.toString();
		}, function (value) {
			this._createFont().set(value);
		});

		/**
		*文本的粗细。
		*/
		__getset(0, __proto, 'weight', null, function (value) {
			this._createFont().weight = value;
		});

		/**
		*间距。
		*/
		__getset(0, __proto, 'letterSpacing', function () {
			return this._spacing[0];
		}, function (d) {
			((typeof d == 'string')) && (d = parseInt(d + ""));
			this._spacing === CSSStyle._SPACING && (this._spacing = [0, 0]);
			this._spacing[0] = d;
		});

		/**
		*字体大小。
		*/
		__getset(0, __proto, 'fontSize', function () {
			return this._font.size;
		}, function (value) {
			this._createFont().size = value;
		});

		/**
		*表示是否为斜体。
		*/
		__getset(0, __proto, 'italic', function () {
			return this._font.italic;
		}, function (value) {
			this._createFont().italic = value;
		});

		/**
		*字体系列。
		*/
		__getset(0, __proto, 'fontFamily', function () {
			return this._font.family;
		}, function (value) {
			this._createFont().family = value;
		});

		/**
		*<p>描边宽度（以像素为单位）。</p>
		*默认值0，表示不描边。
		*@default 0
		*/
		__getset(0, __proto, 'stroke', function () {
			return this._font.stroke[0];
		}, function (value) {
			if (this._createFont().stroke === Font._STROKE) this._font.stroke = [0, "#000000"];
			this._font.stroke[0] = value;
		});

		/**
		*<p>描边颜色，以字符串表示。</p>
		*@default "#000000";
		*/
		__getset(0, __proto, 'strokeColor', function () {
			return this._font.stroke[1];
		}, function (value) {
			if (this._createFont().stroke === Font._STROKE) this._font.stroke = [0, "#000000"];
			this._font.stroke[1] = value;
		});

		/**
		*边框属性，比如border="5px solid red"
		*/
		__getset(0, __proto, 'border', function () {
			return this._border ? this._border.value : "";
		}, function (value) {
			if (value == 'none') {
				this._border = null;
				return;
			}
			this._border || (this._border = {});
			this._border.value = value;
			var values = value.split(' ');
			this._border.color = Color.create(values[values.length - 1]);
			if (values.length == 1) {
				this._border.size = 1;
				this._border.type = 'solid';
				return;
			};
			var i = 0;
			if (values[0].indexOf('px') > 0) {
				this._border.size = parseInt(values[0]);
				i++;
			} else this._border.size = 1;
			this._border.type = values[i];
			this._ower._renderType |=/*laya.renders.RenderSprite.STYLE*/0x100;
		});

		/**
		*边框的颜色。
		*/
		__getset(0, __proto, 'borderColor', function () {
			return (this._border && this._border.color) ? this._border.color.strColor : null;
		}, function (value) {
			if (!value) {
				this._border = null;
				return;
			}
			this._border || (this._border = { size: 1, type: 'solid' });
			this._border.color = (value == null) ? null : Color.create(value);
			this._ower.conchModel && this._ower.conchModel.border(this._border.color.strColor);
			this._ower._renderType |=/*laya.renders.RenderSprite.STYLE*/0x100;
		});

		/**
		*元素的定位类型。
		*/
		__getset(0, __proto, 'position', function () {
			return (this._type & 0x4) ? "absolute" : "";
		}, function (value) {
			value == "absolute" ? (this._type |= 0x4) : (this._type &= ~0x4);
		});

		/**
		*规定元素应该生成的框的类型。
		*/
		__getset(0, __proto, 'display', null, function (value) {
			switch (value) {
				case '':
					this._type &= ~0x2;
					this.visible = true;
					break;
				case 'none':
					this._type |= 0x2;
					this.visible = false;
					this._ower._layoutLater();
					break;
			}
		});

		/**@inheritDoc */
		__getset(0, __proto, 'paddingLeft', function () {
			return this.padding[3];
		});

		/**@inheritDoc */
		__getset(0, __proto, 'paddingTop', function () {
			return this.padding[0];
		});

		__getset(0, __proto, '_scale', null, function (value) {
			this._ower.scale(value[0], value[1]);
		});

		__getset(0, __proto, '_rotate', null, function (value) {
			this._ower.rotation = value;
		});

		CSSStyle.parseOneCSS = function (text, clipWord) {
			var out = [];
			var attrs = text.split(clipWord);
			var valueArray;
			for (var i = 0, n = attrs.length; i < n; i++) {
				var attr = attrs[i];
				var ofs = attr.indexOf(':');
				var name = attr.substr(0, ofs).replace(/^\s+|\s+$/g, '');
				if (name.length == 0)
					continue;
				var value = attr.substr(ofs + 1).replace(/^\s+|\s+$/g, '');
				var one = [name, value];
				switch (name) {
					case 'italic':
					case 'bold':
						one[1] = value == "true";
						break;
					case 'line-height':
						one[0] = 'lineHeight';
						one[1] = parseInt(value);
						break;
					case 'font-size':
						one[0] = 'fontSize';
						one[1] = parseInt(value);
						break;
					case 'padding':
						valueArray = value.split(' ');
						valueArray.length > 1 || (valueArray[1] = valueArray[2] = valueArray[3] = valueArray[0]);
						one[1] = [parseInt(valueArray[0]), parseInt(valueArray[1]), parseInt(valueArray[2]), parseInt(valueArray[3])];
						break;
					case 'rotate':
						one[0] = "_rotate";
						one[1] = parseFloat(value);
						break;
					case 'scale':
						valueArray = value.split(' ');
						one[0] = "_scale";
						one[1] = [parseFloat(valueArray[0]), parseFloat(valueArray[1])];
						break;
					case 'translate':
						valueArray = value.split(' ');
						one[0] = "_translate";
						one[1] = [parseInt(valueArray[0]), parseInt(valueArray[1])];
						break;
					default:
						(one[0] = CSSStyle._CSSTOVALUE[name]) || (one[0] = name);
				}
				out.push(one);
			}
			return out;
		}

		CSSStyle.parseCSS = function (text, uri) {
			var one;
			while ((one = CSSStyle._parseCSSRegExp.exec(text)) != null) {
				CSSStyle.styleSheets[one[1]] = CSSStyle.parseOneCSS(one[2], ';');
			}
		}

		CSSStyle.EMPTY = new CSSStyle(null);
		CSSStyle._CSSTOVALUE = { 'letter-spacing': 'letterSpacing', 'line-spacing': 'lineSpacing', 'white-space': 'whiteSpace', 'line-height': 'lineHeight', 'scale-x': 'scaleX', 'scale-y': 'scaleY', 'translate-x': 'translateX', 'translate-y': 'translateY', 'font-family': 'fontFamily', 'font-weight': 'fontWeight', 'vertical-align': 'valign', 'text-decoration': 'textDecoration', 'background-color': 'backgroundColor', 'border-color': 'borderColor', 'float': 'cssFloat' };
		CSSStyle._parseCSSRegExp = new RegExp("([\.\#]\\w+)\\s*{([\\s\\S]*?)}", "g");
		CSSStyle._aligndef = { 'left': 0, 'center': 1, 'right': 2, 0: 'left', 1: 'center', 2: 'right' };
		CSSStyle._valigndef = { 'top': 0, 'middle': 1, 'bottom': 2, 0: 'top', 1: 'middle', 2: 'bottom' };
		CSSStyle.styleSheets = {};
		CSSStyle.ALIGN_CENTER = 1;
		CSSStyle.ALIGN_RIGHT = 2;
		CSSStyle.VALIGN_MIDDLE = 1;
		CSSStyle.VALIGN_BOTTOM = 2;
		CSSStyle._CSS_BLOCK = 0x1;
		CSSStyle._DISPLAY_NONE = 0x2;
		CSSStyle._ABSOLUTE = 0x4;
		CSSStyle._WIDTH_SET = 0x8;
		CSSStyle._PADDING = [0, 0, 0, 0];
		CSSStyle._RECT = [-1, -1, -1, -1];
		CSSStyle._SPACING = [0, 0];
		CSSStyle._ALIGNS = [0, 0, 0];
		CSSStyle.ADDLAYOUTED = 0x200;
		CSSStyle._NEWFONT = 0x1000;
		CSSStyle._HEIGHT_SET = 0x2000;
		CSSStyle._BACKGROUND_SET = 0x4000;
		CSSStyle._FLOAT_RIGHT = 0x8000;
		CSSStyle._LINE_ELEMENT = 0x10000;
		CSSStyle._NOWARP = 0x20000;
		CSSStyle._WIDTHAUTO = 0x40000;
		CSSStyle._LISTERRESZIE = 0x80000;
		return CSSStyle;
	})(Style)


	/**
	*@private
	*使用Audio标签播放声音
	*/
	//class laya.media.h5audio.AudioSound extends laya.events.EventDispatcher
	var AudioSound = (function (_super) {
		function AudioSound() {
			/**
			*声音URL
			*/
			this.url = null;
			/**
			*播放用的audio标签
			*/
			this.audio = null;
			/**
			*是否已加载完成
			*/
			this.loaded = false;
			AudioSound.__super.call(this);
		}

		__class(AudioSound, 'laya.media.h5audio.AudioSound', _super);
		var __proto = AudioSound.prototype;
		/**
		*释放声音
		*
		*/
		__proto.dispose = function () {
			var ad = AudioSound._audioCache[this.url];
			if (ad) {
				ad.src = "";
				delete AudioSound._audioCache[this.url];
			}
		}

		/**
		*加载声音
		*@param url
		*
		*/
		__proto.load = function (url) {
			url = URL.formatURL(url);
			this.url = url;
			var ad;
			if (url == SoundManager._tMusic) {
				AudioSound._initMusicAudio();
				ad = AudioSound._musicAudio;
				if (ad.src != url) {
					AudioSound._audioCache[ad.src] = null;
					ad = null;
				}
			} else {
				ad = AudioSound._audioCache[url];
			}
			if (ad && ad.readyState >= 2) {
				this.event(/*laya.events.Event.COMPLETE*/"complete");
				return;
			}
			if (!ad) {
				if (url == SoundManager._tMusic) {
					AudioSound._initMusicAudio();
					ad = AudioSound._musicAudio;
				} else {
					ad = Browser.createElement("audio");
				}
				AudioSound._audioCache[url] = ad;
				ad.src = url;
			}
			ad.addEventListener("canplaythrough", onLoaded);
			ad.addEventListener("error", onErr);
			var me = this;
			function onLoaded() {
				offs();
				me.loaded = true;
				me.event(/*laya.events.Event.COMPLETE*/"complete");
			}
			function onErr() {
				ad.load = null;
				offs();
				me.event(/*laya.events.Event.ERROR*/"error");
			}
			function offs() {
				ad.removeEventListener("canplaythrough", onLoaded);
				ad.removeEventListener("error", onErr);
			}
			this.audio = ad;
			if (ad.load) {
				ad.load();
			} else {
				onErr();
			}
		}

		/**
		*播放声音
		*@param startTime 起始时间
		*@param loops 循环次数
		*@return
		*
		*/
		__proto.play = function (startTime, loops, playbackRate) {
			(startTime === void 0) && (startTime = 0);
			(loops === void 0) && (loops = 0);
			(playbackRate === void 0) && (playbackRate = 1);
			if (!this.url) return null;
			var ad;
			if (this.url == SoundManager._tMusic) {
				ad = AudioSound._musicAudio;
			} else {
				ad = AudioSound._audioCache[this.url];
			}
			if (!ad) return null;
			var tAd;
			tAd = Pool.getItem("audio:" + this.url);
			if (Render.isConchApp) {
				if (!tAd) {
					tAd = Browser.createElement("audio");
					tAd.src = this.url;
				}
			}
			else {
				if (this.url == SoundManager._tMusic) {
					AudioSound._initMusicAudio();
					tAd = AudioSound._musicAudio;
					tAd.src = this.url;
				} else {
					tAd = tAd ? tAd : ad.cloneNode(true);
				}
			};
			var channel = new AudioSoundChannel(tAd);
			channel.url = this.url;
			channel.loops = loops;
			channel.startTime = startTime;
			channel.playbackRate = playbackRate;
			channel.play();
			SoundManager.addChannel(channel);
			return channel;
		}

		/**
		*获取总时间。
		*/
		__getset(0, __proto, 'duration', function () {
			var ad;
			ad = AudioSound._audioCache[this.url];
			if (!ad)
				return 0;
			return ad.duration;
		});

		AudioSound._initMusicAudio = function () {
			if (AudioSound._musicAudio) return;
			if (!AudioSound._musicAudio) AudioSound._musicAudio = Browser.createElement("audio");
			if (!Render.isConchApp) {
				Browser.document.addEventListener("mousedown", AudioSound._makeMusicOK);
			}
		}

		AudioSound._makeMusicOK = function () {
			Browser.document.removeEventListener("mousedown", AudioSound._makeMusicOK);
			if (!AudioSound._musicAudio.src) {
				AudioSound._musicAudio.src = "";
				AudioSound._musicAudio.load();
			} else {
				AudioSound._musicAudio.play();
			}
		}

		AudioSound._audioCache = {};
		AudioSound._musicAudio = null;
		return AudioSound;
	})(EventDispatcher)


	/**
	*<p> <code>SoundChannel</code> 用来控制程序中的声音。每个声音均分配给一个声道，而且应用程序可以具有混合在一起的多个声道。</p>
	*<p> <code>SoundChannel</code> 类包含控制声音的播放、暂停、停止、音量的方法，以及获取声音的播放状态、总时间、当前播放时间、总循环次数、播放地址等信息的方法。</p>
	*/
	//class laya.media.SoundChannel extends laya.events.EventDispatcher
	var SoundChannel = (function (_super) {
		function SoundChannel() {
			/**
			*声音地址。
			*/
			this.url = null;
			/**
			*循环次数。
			*/
			this.loops = 0;
			/**
			*开始时间。
			*/
			this.startTime = NaN;
			/**
			*表示声音是否已暂停。
			*/
			this.isStopped = false;
			/**
			*播放完成处理器。
			*/
			this.completeHandler = null;
			SoundChannel.__super.call(this);
		}

		__class(SoundChannel, 'laya.media.SoundChannel', _super);
		var __proto = SoundChannel.prototype;
		/**
		*播放。
		*/
		__proto.play = function () { }
		/**
		*停止。
		*/
		__proto.stop = function () { }
		/**
		*暂停。
		*/
		__proto.pause = function () { }
		/**
		*继续播放。
		*/
		__proto.resume = function () { }
		/**
		*private
		*/
		__proto.__runComplete = function (handler) {
			if (handler) {
				handler.run();
			}
		}

		/**
		*音量范围从 0（静音）至 1（最大音量）。
		*/
		__getset(0, __proto, 'volume', function () {
			return 1;
		}, function (v) {
		});

		/**
		*获取当前播放时间。
		*/
		__getset(0, __proto, 'position', function () {
			return 0;
		});

		/**
		*获取总时间。
		*/
		__getset(0, __proto, 'duration', function () {
			return 0;
		});

		return SoundChannel;
	})(EventDispatcher)


	/**
	*<code>Sound</code> 类是用来播放控制声音的类。
	*/
	//class laya.media.Sound extends laya.events.EventDispatcher
	var Sound = (function (_super) {
		function Sound() {
			Sound.__super.call(this);;
		}

		__class(Sound, 'laya.media.Sound', _super);
		var __proto = Sound.prototype;
		/**
		*加载声音。
		*@param url 地址。
		*
		*/
		__proto.load = function (url) { }
		/**
		*播放声音。
		*@param startTime 开始时间,单位秒
		*@param loops 循环次数,0表示一直循环
		*@return 声道 SoundChannel 对象。
		*
		*/
		__proto.play = function (startTime, loops) {
			(startTime === void 0) && (startTime = 0);
			(loops === void 0) && (loops = 0);
			return null;
		}

		/**
		*释放声音资源。
		*
		*/
		__proto.dispose = function () { }
		/**
		*获取总时间。
		*/
		__getset(0, __proto, 'duration', function () {
			return 0;
		});

		return Sound;
	})(EventDispatcher)


	/**
	*@private
	*web audio api方式播放声音
	*/
	//class laya.media.webaudio.WebAudioSound extends laya.events.EventDispatcher
	var WebAudioSound = (function (_super) {
		function WebAudioSound() {
			/**
			*声音URL
			*/
			this.url = null;
			/**
			*是否已加载完成
			*/
			this.loaded = false;
			/**
			*声音文件数据
			*/
			this.data = null;
			/**
			*声音原始文件数据
			*/
			this.audioBuffer = null;
			/**
			*待播放的声音列表
			*/
			this.__toPlays = null;
			WebAudioSound.__super.call(this);
		}

		__class(WebAudioSound, 'laya.media.webaudio.WebAudioSound', _super);
		var __proto = WebAudioSound.prototype;
		/**
		*加载声音
		*@param url
		*
		*/
		__proto.load = function (url) {
			var me = this;
			url = URL.formatURL(url);
			this.url = url;
			this.audioBuffer = WebAudioSound._dataCache[url];
			if (this.audioBuffer) {
				this._loaded(this.audioBuffer);
				return;
			}
			WebAudioSound.e.on("loaded:" + url, this, this._loaded);
			WebAudioSound.e.on("err:" + url, this, this._err);
			if (WebAudioSound.__loadingSound[url]) {
				return;
			}
			WebAudioSound.__loadingSound[url] = true;
			var request = new Browser.window.XMLHttpRequest();
			request.open("GET", url, true);
			request.responseType = "arraybuffer";
			request.onload = function () {
				me.data = request.response;
				WebAudioSound.buffs.push({ "buffer": me.data, "url": me.url });
				WebAudioSound.decode();
			};
			request.onerror = function (e) {
				me._err();
			}
			request.send();
		}

		__proto._err = function () {
			this._removeLoadEvents();
			WebAudioSound.__loadingSound[this.url] = false;
			this.event(/*laya.events.Event.ERROR*/"error");
		}

		__proto._loaded = function (audioBuffer) {
			this._removeLoadEvents();
			this.audioBuffer = audioBuffer;
			WebAudioSound._dataCache[this.url] = this.audioBuffer;
			this.loaded = true;
			this.event(/*laya.events.Event.COMPLETE*/"complete");
		}

		__proto._removeLoadEvents = function () {
			WebAudioSound.e.off("loaded:" + this.url, this, this._loaded);
			WebAudioSound.e.off("err:" + this.url, this, this._err);
		}

		__proto.__playAfterLoaded = function () {
			if (!this.__toPlays) return;
			var i = 0, len = 0;
			var toPlays;
			toPlays = this.__toPlays;
			len = toPlays.length;
			var tParams;
			for (i = 0; i < len; i++) {
				tParams = toPlays[i];
				if (tParams[3] && !(tParams[3]).isStopped) {
					this.play(tParams[0], tParams[1], tParams[2], tParams[3]);
				}
			}
			this.__toPlays.length = 0;
		}

		/**
		*播放声音
		*@param startTime 起始时间
		*@param loops 循环次数
		*@return
		*
		*/
		__proto.play = function (startTime, loops, playbackRate, channel) {
			(startTime === void 0) && (startTime = 0);
			(loops === void 0) && (loops = 0);
			(playbackRate === void 0) && (playbackRate = 1);
			channel = channel ? channel : new WebAudioSoundChannel();
			if (!this.audioBuffer) {
				if (this.url) {
					if (!this.__toPlays) this.__toPlays = [];
					this.__toPlays.push([startTime, loops, playbackRate, channel]);
					this.once(/*laya.events.Event.COMPLETE*/"complete", this, this.__playAfterLoaded);
					this.load(this.url);
				}
			}
			channel.url = this.url;
			channel.loops = loops;
			channel["audioBuffer"] = this.audioBuffer;
			channel.playbackRate = playbackRate;
			channel.startTime = startTime;
			channel.play();
			SoundManager.addChannel(channel);
			return channel;
		}

		__proto.dispose = function () {
			delete WebAudioSound._dataCache[this.url];
			delete WebAudioSound.__loadingSound[this.url];
			this.audioBuffer = null;
			this.data = null;
			this.__toPlays = [];
		}

		__getset(0, __proto, 'duration', function () {
			if (this.audioBuffer) {
				return this.audioBuffer.duration;
			}
			return 0;
		});

		WebAudioSound.decode = function () {
			if (WebAudioSound.buffs.length <= 0 || WebAudioSound.isDecoding) {
				return;
			}
			WebAudioSound.isDecoding = true;
			WebAudioSound.tInfo = WebAudioSound.buffs.shift();
			WebAudioSound.ctx.decodeAudioData(WebAudioSound.tInfo["buffer"], WebAudioSound._done, WebAudioSound._fail);
		}

		WebAudioSound._done = function (audioBuffer) {
			WebAudioSound.e.event("loaded:" + WebAudioSound.tInfo.url, audioBuffer);
			WebAudioSound.isDecoding = false;
			WebAudioSound.decode();
		}

		WebAudioSound._fail = function () {
			WebAudioSound.e.event("err:" + WebAudioSound.tInfo.url, null);
			WebAudioSound.isDecoding = false;
			WebAudioSound.decode();
		}

		WebAudioSound._playEmptySound = function () {
			if (WebAudioSound.ctx == null) {
				return;
			};
			var source = WebAudioSound.ctx.createBufferSource();
			source.buffer = WebAudioSound._miniBuffer;
			source.connect(WebAudioSound.ctx.destination);
			source.start(0, 0, 0);
		}

		WebAudioSound._unlock = function () {
			if (WebAudioSound._unlocked) {
				return;
			}
			WebAudioSound._playEmptySound();
			if (WebAudioSound.ctx.state == "running") {
				Browser.document.removeEventListener("mousedown", WebAudioSound._unlock, true);
				Browser.document.removeEventListener("touchend", WebAudioSound._unlock, true);
				WebAudioSound._unlocked = true;
			}
		}

		WebAudioSound.initWebAudio = function () {
			if (WebAudioSound.ctx.state != "running") {
				WebAudioSound._unlock();
				Browser.document.addEventListener("mousedown", WebAudioSound._unlock, true);
				Browser.document.addEventListener("touchend", WebAudioSound._unlock, true);
			}
		}

		WebAudioSound._dataCache = {};
		WebAudioSound.buffs = [];
		WebAudioSound.isDecoding = false;
		WebAudioSound._unlocked = false;
		WebAudioSound.tInfo = null;
		WebAudioSound.__loadingSound = {};
		__static(WebAudioSound,
			['window', function () { return this.window = Browser.window; }, 'webAudioEnabled', function () { return this.webAudioEnabled = WebAudioSound.window["AudioContext"] || WebAudioSound.window["webkitAudioContext"] || WebAudioSound.window["mozAudioContext"]; }, 'ctx', function () { return this.ctx = top["audioCtx"] ? top["audioCtx"] : WebAudioSound.webAudioEnabled ? new (WebAudioSound.window["AudioContext"] || WebAudioSound.window["webkitAudioContext"] || WebAudioSound.window["mozAudioContext"])() : undefined; }, '_miniBuffer', function () { return this._miniBuffer = WebAudioSound.ctx.createBuffer(1, 1, 22050); }, 'e', function () { return this.e = new EventDispatcher(); }
			]);
		return WebAudioSound;
	})(EventDispatcher)


	/**
	*<p> <code>HttpRequest</code> 通过封装 HTML <code>XMLHttpRequest</code> 对象提供了对 HTTP 协议的完全的访问，包括做出 POST 和 HEAD 请求以及普通的 GET 请求的能力。 <code>HttpRequest</code> 只提供以异步的形式返回 Web 服务器的响应，并且能够以文本或者二进制的形式返回内容。</p>
	*<p><b>注意：</b>建议每次请求都使用新的 <code>HttpRequest</code> 对象，因为每次调用该对象的send方法时，都会清空之前设置的数据，并重置 HTTP 请求的状态，这会导致之前还未返回响应的请求被重置，从而得不到之前请求的响应结果。</p>
	*/
	//class laya.net.HttpRequest extends laya.events.EventDispatcher
	var HttpRequest = (function (_super) {
		function HttpRequest() {
			/**@private */
			this._responseType = null;
			/**@private */
			this._data = null;
			HttpRequest.__super.call(this);
			this._http = new Browser.window.XMLHttpRequest();
		}

		__class(HttpRequest, 'laya.net.HttpRequest', _super);
		var __proto = HttpRequest.prototype;
		/**
		*发送 HTTP 请求。
		*@param url 请求的地址。大多数浏览器实施了一个同源安全策略，并且要求这个 URL 与包含脚本的文本具有相同的主机名和端口。
		*@param data (default=null)发送的数据。
		*@param method (default="get")用于请求的 HTTP 方法。值包括 "get"、"post"、"head"。
		*@param responseType (default="text")Web 服务器的响应类型，可设置为 "text"、"json"、"xml"、"arraybuffer"。
		*@param headers (default=null)HTTP 请求的头部信息。参数形如key-value数组：key是头部的名称，不应该包括空白、冒号或换行；value是头部的值，不应该包括换行。比如["Content-Type","application/json"]。
		*/
		__proto.send = function (url, data, method, responseType, headers) {
			(method === void 0) && (method = "get");
			(responseType === void 0) && (responseType = "text");
			this._responseType = responseType;
			this._data = null;
			var _this = this;
			var http = this._http;
			http.open(method, url, true);
			if (headers) {
				for (var i = 0; i < headers.length; i++) {
					http.setRequestHeader(headers[i++], headers[i]);
				}
			} else if (!Render.isConchApp) {
				if (!data || (typeof data == 'string')) http.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
				else http.setRequestHeader("Content-Type", "application/json");
			}
			http.responseType = responseType !== "arraybuffer" ? "text" : "arraybuffer";
			http.onerror = function (e) {
				_this._onError(e);
			}
			http.onabort = function (e) {
				_this._onAbort(e);
			}
			http.onprogress = function (e) {
				_this._onProgress(e);
			}
			http.onload = function (e) {
				_this._onLoad(e);
			}
			http.send(data);
		}

		/**
		*@private
		*请求进度的侦听处理函数。
		*@param e 事件对象。
		*/
		__proto._onProgress = function (e) {
			if (e && e.lengthComputable) this.event(/*laya.events.Event.PROGRESS*/"progress", e.loaded / e.total);
		}

		/**
		*@private
		*请求中断的侦听处理函数。
		*@param e 事件对象。
		*/
		__proto._onAbort = function (e) {
			this.error("Request was aborted by user");
		}

		/**
		*@private
		*请求出错侦的听处理函数。
		*@param e 事件对象。
		*/
		__proto._onError = function (e) {
			this.error("Request failed Status:" + this._http.status + " text:" + this._http.statusText);
		}

		/**
		*@private
		*请求消息返回的侦听处理函数。
		*@param e 事件对象。
		*/
		__proto._onLoad = function (e) {
			var http = this._http;
			var status = http.status !== undefined ? http.status : 200;
			if (status === 200 || status === 204 || status === 0) {
				this.complete();
			} else {
				this.error("[" + http.status + "]" + http.statusText + ":" + http.responseURL);
			}
		}

		/**
		*@private
		*请求错误的处理函数。
		*@param message 错误信息。
		*/
		__proto.error = function (message) {
			this.clear();
			this.event(/*laya.events.Event.ERROR*/"error", message);
		}

		/**
		*@private
		*请求成功完成的处理函数。
		*/
		__proto.complete = function () {
			this.clear();
			var flag = true;
			try {
				if (this._responseType === "json") {
					this._data = JSON.parse(this._http.responseText);
				} else if (this._responseType === "xml") {
					this._data = Utils.parseXMLFromString(this._http.responseText);
				} else {
					this._data = this._http.response || this._http.responseText;
				}
			} catch (e) {
				flag = false;
				this.error(e.message);
			}
			flag && this.event(/*laya.events.Event.COMPLETE*/"complete", (this._data instanceof Array) ? [this._data] : this._data);
		}

		/**
		*@private
		*清除当前请求。
		*/
		__proto.clear = function () {
			var http = this._http;
			http.onerror = http.onabort = http.onprogress = http.onload = null;
		}

		/**请求的地址。*/
		__getset(0, __proto, 'url', function () {
			return this._http.responseURL;
		});

		/**
		*本对象所封装的原生 XMLHttpRequest 引用。
		*/
		__getset(0, __proto, 'http', function () {
			return this._http;
		});

		/**返回的数据。*/
		__getset(0, __proto, 'data', function () {
			return this._data;
		});

		return HttpRequest;
	})(EventDispatcher)


	/**
	*<code>Loader</code> 类可用来加载文本、JSON、XML、二进制、图像等资源。
	*/
	//class laya.net.Loader extends laya.events.EventDispatcher
	var Loader = (function (_super) {
		function Loader() {
			/**@private 加载后的数据对象，只读*/
			this._data = null;
			/**@private */
			this._class = null;
			/**@private */
			this._url = null;
			/**@private */
			this._type = null;
			/**@private */
			this._cache = false;
			/**@private */
			this._http = null;
			/**@private 自定义解析不派发complete事件，但会派发loaded事件，手动调用endLoad方法再派发complete事件*/
			this._customParse = false;
			Loader.__super.call(this);
		}

		__class(Loader, 'laya.net.Loader', _super);
		var __proto = Loader.prototype;
		/**
		*加载资源。加载错误会派发 Event.ERROR 事件，参数为错误信息。
		*@param url 资源地址。
		*@param type (default=null)资源类型。可选值为：Loader.TEXT、Loader.JSON、Loader.XML、Loader.BUFFER、Loader.IMAGE、Loader.SOUND、Loader.ATLAS、Loader.FONT。如果为null，则根据文件后缀分析类型。
		*@param cache (default=true)是否缓存数据。
		*@param group (default=null)分组名称。
		*@param ignoreCache (default=false)是否忽略缓存，强制重新加载。
		*/
		__proto.load = function (url, type, cache, group, ignoreCache) {
			(cache === void 0) && (cache = true);
			(ignoreCache === void 0) && (ignoreCache = false);
			this._url = url;
			if (url.indexOf("data:image") === 0) this._type = type = "image";
			else {
				this._type = type || (type = this.getTypeFromUrl(url));
				url = URL.formatURL(url);
			}
			this._cache = cache;
			this._data = null;
			if (!ignoreCache && Loader.loadedMap[url]) {
				this._data = Loader.loadedMap[url];
				this.event(/*laya.events.Event.PROGRESS*/"progress", 1);
				this.event(/*laya.events.Event.COMPLETE*/"complete", this._data);
				return;
			}
			if (group) Loader.setGroup(url, group);
			if (Loader.parserMap[type] != null) {
				this._customParse = true;
				if (((Loader.parserMap[type]) instanceof laya.utils.Handler)) Loader.parserMap[type].runWith(this);
				else Loader.parserMap[type].call(null, this);
				return;
			}
			if (type === "image" || type === "htmlimage" || type === "nativeimage") return this._loadImage(url);
			if (type === "sound") return this._loadSound(url);
			if (type === "ttf") return this._loadTTF(url);
			if (type == "atlas") {
				if (Loader.preLoadedAtlasConfigMap[url]) {
					this.onLoaded(Loader.preLoadedAtlasConfigMap[url]);
					delete Loader.preLoadedAtlasConfigMap[url];
					return;
				}
			}
			if (!this._http) {
				this._http = new HttpRequest();
				this._http.on(/*laya.events.Event.PROGRESS*/"progress", this, this.onProgress);
				this._http.on(/*laya.events.Event.ERROR*/"error", this, this.onError);
				this._http.on(/*laya.events.Event.COMPLETE*/"complete", this, this.onLoaded);
			};
			var contentType;
			switch (type) {
				case "atlas":
					contentType = "json";
					break;
				case "font":
					contentType = "xml";
					break;
				case "pkm":
					contentType = "arraybuffer";
					break
				default:
					contentType = type;
			}
			this._http.send(url, null, "get", contentType);
		}

		/**
		*获取指定资源地址的数据类型。
		*@param url 资源地址。
		*@return 数据类型。
		*/
		__proto.getTypeFromUrl = function (url) {
			var type = Utils.getFileExtension(url);
			if (type) return Loader.typeMap[type];
			console.warn("Not recognize the resources suffix", url);
			return "text";
		}

		/**
		*@private
		*加载TTF资源。
		*@param url 资源地址。
		*/
		__proto._loadTTF = function (url) {
			url = URL.formatURL(url);
			var ttfLoader = new TTFLoader();
			ttfLoader.complete = Handler.create(this, this.onLoaded);
			ttfLoader.load(url);
		}

		/**
		*@private
		*加载图片资源。
		*@param url 资源地址。
		*/
		__proto._loadImage = function (url) {
			url = URL.formatURL(url);
			var _this = this;
			var image;
			function clear() {
				image.onload = null;
				image.onerror = null;
				delete Loader.imgCache[url]
			};
			var onload = function () {
				clear();
				_this.onLoaded(image);
			};
			var onerror = function () {
				clear();
				_this.event(/*laya.events.Event.ERROR*/"error", "Load image failed");
			}
			if (this._type === "nativeimage") {
				image = new Browser.window.Image();
				image.crossOrigin = "";
				image.onload = onload;
				image.onerror = onerror;
				image.src = url;
				Loader.imgCache[url] = image;
			} else {
				new HTMLImage.create(url, {
					onload: onload, onerror: onerror, onCreate: function (img) {
						image = img;
						Loader.imgCache[url] = img;
					}
				});
			}
		}

		/**
		*@private
		*加载声音资源。
		*@param url 资源地址。
		*/
		__proto._loadSound = function (url) {
			var sound = (new SoundManager._soundClass());
			var _this = this;
			sound.on(/*laya.events.Event.COMPLETE*/"complete", this, soundOnload);
			sound.on(/*laya.events.Event.ERROR*/"error", this, soundOnErr);
			sound.load(url);
			function soundOnload() {
				clear();
				_this.onLoaded(sound);
			}
			function soundOnErr() {
				clear();
				sound.dispose();
				_this.event(/*laya.events.Event.ERROR*/"error", "Load sound failed");
			}
			function clear() {
				sound.offAll();
			}
		}

		/**@private */
		__proto.onProgress = function (value) {
			if (this._type === "atlas") this.event(/*laya.events.Event.PROGRESS*/"progress", value * 0.3);
			else this.event(/*laya.events.Event.PROGRESS*/"progress", value);
		}

		/**@private */
		__proto.onError = function (message) {
			this.event(/*laya.events.Event.ERROR*/"error", message);
		}

		/**
		*资源加载完成的处理函数。
		*@param data 数据。
		*/
		__proto.onLoaded = function (data) {
			var type = this._type;
			if (type === "image") {
				var tex = new Texture(data);
				tex.url = this._url;
				this.complete(tex);
			} else if (type === "sound" || type === "htmlimage" || type === "nativeimage") {
				this.complete(data);
			} else if (type === "atlas") {
				if (!data.src && !data._setContext) {
					if (!this._data) {
						this._data = data;
						if (data.meta && data.meta.image) {
							var toloadPics = data.meta.image.split(",");
							var split = this._url.indexOf("/") >= 0 ? "/" : "\\";
							var idx = this._url.lastIndexOf(split);
							var folderPath = idx >= 0 ? this._url.substr(0, idx + 1) : "";
							for (var i = 0, len = toloadPics.length; i < len; i++) {
								toloadPics[i] = folderPath + toloadPics[i];
							}
						} else {
							toloadPics = [this._url.replace(".json", ".png")];
						}
						toloadPics.reverse();
						data.toLoads = toloadPics;
						data.pics = [];
					}
					this.event(/*laya.events.Event.PROGRESS*/"progress", 0.3 + 1 / toloadPics.length * 0.6);
					return this._loadImage(toloadPics.pop());
				} else {
					this._data.pics.push(data);
					if (this._data.toLoads.length > 0) {
						this.event(/*laya.events.Event.PROGRESS*/"progress", 0.3 + 1 / this._data.toLoads.length * 0.6);
						return this._loadImage(this._data.toLoads.pop());
					};
					var frames = this._data.frames;
					var cleanUrl = this._url.split("?")[0];
					var directory = (this._data.meta && this._data.meta.prefix) ? this._data.meta.prefix : cleanUrl.substring(0, cleanUrl.lastIndexOf(".")) + "/";
					var pics = this._data.pics;
					var atlasURL = URL.formatURL(this._url);
					var map = Loader.atlasMap[atlasURL] || (Loader.atlasMap[atlasURL] = []);
					map.dir = directory;
					var scaleRate = 1;
					if (this._data.meta && this._data.meta.scale && this._data.meta.scale != 1) {
						scaleRate = parseFloat(this._data.meta.scale);
						for (var name in frames) {
							var obj = frames[name];
							var tPic = pics[obj.frame.idx ? obj.frame.idx : 0];
							var url = URL.formatURL(directory + name);
							tPic.scaleRate = scaleRate;
							Loader.cacheRes(url, Texture.create(tPic, obj.frame.x, obj.frame.y, obj.frame.w, obj.frame.h, obj.spriteSourceSize.x, obj.spriteSourceSize.y, obj.sourceSize.w, obj.sourceSize.h));
							Loader.loadedMap[url].url = url;
							map.push(url);
						}
					} else {
						for (name in frames) {
							obj = frames[name];
							tPic = pics[obj.frame.idx ? obj.frame.idx : 0];
							url = URL.formatURL(directory + name);
							Loader.cacheRes(url, Texture.create(tPic, obj.frame.x, obj.frame.y, obj.frame.w, obj.frame.h, obj.spriteSourceSize.x, obj.spriteSourceSize.y, obj.sourceSize.w, obj.sourceSize.h));
							Loader.loadedMap[url].url = url;
							map.push(url);
						}
					}
					delete this._data.pics;
					this.complete(this._data);
				}
			} else if (type == "font") {
				if (!data.src) {
					this._data = data;
					this.event(/*laya.events.Event.PROGRESS*/"progress", 0.5);
					return this._loadImage(this._url.replace(".fnt", ".png"));
				} else {
					var bFont = new BitmapFont();
					bFont.parseFont(this._data, data);
					var tArr = this._url.split(".fnt")[0].split("/");
					var fontName = tArr[tArr.length - 1];
					Text.registerBitmapFont(fontName, bFont);
					this._data = bFont;
					this.complete(this._data);
				}
			} else if (type == "pkm") {
				var image = HTMLImage.create(data, this._url);
				var tex1 = new Texture(image);
				tex1.url = this._url;
				this.complete(tex1);
			} else {
				this.complete(data);
			}
		}

		/**
		*加载完成。
		*@param data 加载的数据。
		*/
		__proto.complete = function (data) {
			this._data = data;
			if (this._customParse) {
				this.event(/*laya.events.Event.LOADED*/"loaded", (data instanceof Array) ? [data] : data);
			} else {
				Loader._loaders.push(this);
				if (!Loader._isWorking) Loader.checkNext();
			}
		}

		/**
		*结束加载，处理是否缓存及派发完成事件 <code>Event.COMPLETE</code> 。
		*@param content 加载后的数据
		*/
		__proto.endLoad = function (content) {
			content && (this._data = content);
			if (this._cache) Loader.cacheRes(this._url, this._data);
			this._customParse = false;
			this.event(/*laya.events.Event.PROGRESS*/"progress", 1);
			this.event(/*laya.events.Event.COMPLETE*/"complete", (this.data instanceof Array) ? [this.data] : this.data);
		}

		/**加载地址。*/
		__getset(0, __proto, 'url', function () {
			return this._url;
		});

		/**返回的数据。*/
		__getset(0, __proto, 'data', function () {
			return this._data;
		});

		/**是否缓存。*/
		__getset(0, __proto, 'cache', function () {
			return this._cache;
		});

		/**加载类型。*/
		__getset(0, __proto, 'type', function () {
			return this._type;
		});

		Loader.checkNext = function () {
			Loader._isWorking = true;
			var startTimer = Browser.now();
			var thisTimer = startTimer;
			while (Loader._startIndex < Loader._loaders.length) {
				thisTimer = Browser.now();
				Loader._loaders[Loader._startIndex].endLoad();
				Loader._startIndex++;
				if (Browser.now() - startTimer > Loader.maxTimeOut) {
					console.warn("loader callback cost a long time:" + (Browser.now() - startTimer) + " url=" + Loader._loaders[Loader._startIndex - 1].url);
					Laya.timer.frameOnce(1, null, Loader.checkNext);
					return;
				}
			}
			Loader._loaders.length = 0;
			Loader._startIndex = 0;
			Loader._isWorking = false;
		}

		Loader.clearRes = function (url, forceDispose) {
			(forceDispose === void 0) && (forceDispose = false);
			url = URL.formatURL(url);
			var arr = Loader.getAtlas(url);
			if (arr) {
				for (var i = 0, n = arr.length; i < n; i++) {
					var resUrl = arr[i];
					var tex = Loader.getRes(resUrl);
					delete Loader.loadedMap[resUrl];
					if (tex) tex.destroy(forceDispose);
				}
				arr.length = 0;
				delete Loader.atlasMap[url];
				delete Loader.loadedMap[url];
			} else {
				var res = Loader.loadedMap[url];
				if (res) {
					delete Loader.loadedMap[url];
					if ((res instanceof laya.resource.Texture) && res.bitmap) (res).destroy(forceDispose);
				}
			}
		}

		Loader.clearTextureRes = function (url) {
			url = URL.formatURL(url);
			var arr = laya.net.Loader.getAtlas(url);
			var res = (arr && arr.length > 0) ? laya.net.Loader.getRes(arr[0]) : laya.net.Loader.getRes(url);
			if (res && res.bitmap) {
				if (Render.isConchApp) {
					if (res.bitmap.source.releaseTexture) {
						res.bitmap.source.releaseTexture();
					}
				} else if (res.bitmap._atlaser == null) {
					res.bitmap.releaseResource(true);
				}
			}
		}

		Loader.setAtlasConfigs = function (url, config) {
			Loader.preLoadedAtlasConfigMap[URL.formatURL(url)] = config;
		}

		Loader.getRes = function (url) {
			return Loader.loadedMap[URL.formatURL(url)];
		}

		Loader.getAtlas = function (url) {
			return Loader.atlasMap[URL.formatURL(url)];
		}

		Loader.cacheRes = function (url, data) {
			url = URL.formatURL(url);
			if (Loader.loadedMap[url] != null) {
				console.warn("Resources already exist,is repeated loading:", url);
			} else {
				Loader.loadedMap[url] = data;
			}
		}

		Loader.setGroup = function (url, group) {
			if (!Loader.groupMap[group]) Loader.groupMap[group] = [];
			Loader.groupMap[group].push(url);
		}

		Loader.clearResByGroup = function (group) {
			if (!Loader.groupMap[group]) return;
			var arr = Loader.groupMap[group], i = 0, len = arr.length;
			for (i = 0; i < len; i++) {
				Loader.clearRes(arr[i]);
			}
			arr.length = 0;
		}

		Loader.TEXT = "text";
		Loader.JSON = "json";
		Loader.XML = "xml";
		Loader.BUFFER = "arraybuffer";
		Loader.IMAGE = "image";
		Loader.SOUND = "sound";
		Loader.ATLAS = "atlas";
		Loader.FONT = "font";
		Loader.TTF = "ttf";
		Loader.PKM = "pkm";
		Loader.typeMap = { "png": "image", "jpg": "image", "jpeg": "image", "txt": "text", "json": "json", "xml": "xml", "als": "atlas", "atlas": "atlas", "mp3": "sound", "ogg": "sound", "wav": "sound", "part": "json", "fnt": "font", "pkm": "pkm", "ttf": "ttf" };
		Loader.parserMap = {};
		Loader.groupMap = {};
		Loader.maxTimeOut = 100;
		Loader.loadedMap = {};
		Loader.preLoadedAtlasConfigMap = {};
		Loader.atlasMap = {};
		Loader._loaders = [];
		Loader._isWorking = false;
		Loader._startIndex = 0;
		Loader.imgCache = {};
		return Loader;
	})(EventDispatcher)


	/**
	*<p> <code>LoaderManager</code> 类用于用于批量加载资源。此类是单例，不要手动实例化此类，请通过Laya.loader访问。</p>
	*<p>全部队列加载完成，会派发 Event.COMPLETE 事件；如果队列中任意一个加载失败，会派发 Event.ERROR 事件，事件回调参数值为加载出错的资源地址。</p>
	*<p> <code>LoaderManager</code> 类提供了以下几种功能：<br/>
	*多线程：默认5个加载线程，可以通过maxLoader属性修改线程数量；<br/>
	*多优先级：有0-4共5个优先级，优先级高的优先加载。0最高，4最低；<br/>
	*重复过滤：自动过滤重复加载（不会有多个相同地址的资源同时加载）以及复用缓存资源，防止重复加载；<br/>
	*错误重试：资源加载失败后，会重试加载（以最低优先级插入加载队列），retryNum设定加载失败后重试次数，retryDelay设定加载重试的时间间隔。</p>
	*@see laya.net.Loader
	*/
	//class laya.net.LoaderManager extends laya.events.EventDispatcher
	var LoaderManager = (function (_super) {
		var ResInfo;
		function LoaderManager() {
			/**加载出错后的重试次数，默认重试一次*/
			this.retryNum = 1;
			/**延迟时间多久再进行错误重试，默认立即重试*/
			this.retryDelay = 0;
			/**最大下载线程，默认为5个*/
			this.maxLoader = 5;
			/**@private */
			this._loaders = [];
			/**@private */
			this._loaderCount = 0;
			/**@private */
			this._resInfos = [];
			/**@private */
			this._infoPool = [];
			/**@private */
			this._maxPriority = 5;
			/**@private */
			this._failRes = {};
			LoaderManager.__super.call(this);
			for (var i = 0; i < this._maxPriority; i++)this._resInfos[i] = [];
		}

		__class(LoaderManager, 'laya.net.LoaderManager', _super);
		var __proto = LoaderManager.prototype;
		/**
		*<p>根据clas类型创建一个未初始化资源的对象，随后进行异步加载，资源加载完成后，初始化对象的资源，并通过此对象派发 Event.LOADED 事件，事件回调参数值为此对象本身。套嵌资源的子资源会保留资源路径"?"后的部分。</p>
		*<p>如果url为数组，返回true；否则返回指定的资源类对象，可以通过侦听此对象的 Event.LOADED 事件来判断资源是否已经加载完毕。</p>
		*<p><b>注意：</b>cache参数只能对文件后缀为atlas的资源进行缓存控制，其他资源会忽略缓存，强制重新加载。</p>
		*@param url 资源地址或者数组。如果url和clas同时指定了资源类型，优先使用url指定的资源类型。参数形如：[{url:xx,clas:xx,priority:xx,params:xx},{url:xx,clas:xx,priority:xx,params:xx}]。
		*@param complete 加载结束回调。根据url类型不同分为2种情况：1. url为String类型，也就是单个资源地址，如果加载成功，则回调参数值为加载完成的资源，否则为null；2. url为数组类型，指定了一组要加载的资源，如果全部加载成功，则回调参数值为true，否则为false。
		*@param progress 资源加载进度回调，回调参数值为当前资源加载的进度信息(0-1)。
		*@param clas 资源类名。如果url和clas同时指定了资源类型，优先使用url指定的资源类型。参数形如：Texture。
		*@param params 资源构造参数。
		*@param priority (default=1)加载的优先级，优先级高的优先加载。有0-4共5个优先级，0最高，4最低。
		*@param cache 是否缓存加载的资源。
		*@return 如果url为数组，返回true；否则返回指定的资源类对象。
		*/
		__proto.create = function (url, complete, progress, clas, params, priority, cache, group) {
			(priority === void 0) && (priority = 1);
			(cache === void 0) && (cache = true);
			if ((url instanceof Array)) {
				var items = url;
				var itemCount = items.length;
				var loadedCount = 0;
				if (progress) {
					var progress2 = Handler.create(progress.caller, progress.method, progress.args, false);
				}
				for (var i = 0; i < itemCount; i++) {
					var item = items[i];
					if ((typeof item == 'string')) item = items[i] = { url: item };
					item.progress = 0;
					var progressHandler = progress ? Handler.create(null, onProgress, [item], false) : null;
					var completeHandler = (progress || complete) ? Handler.create(null, onComplete, [item]) : null;
					this._create(item.url, completeHandler, progressHandler, item.clas || clas, item.params || params, item.priority || priority, cache, item.group || group);
				}
				function onComplete(item, content) {
					loadedCount++;
					item.progress = 1;
					if (loadedCount === itemCount && complete) {
						complete.run();
					}
				}
				function onProgress(item, value) {
					item.progress = value;
					var num = 0;
					for (var j = 0; j < itemCount; j++) {
						var item1 = items[j];
						num += item1.progress;
					};
					var v = num / itemCount;
					progress2.runWith(v);
				}
				return true;
			} else return this._create(url, complete, progress, clas, params, priority, cache, group);
		}

		__proto._create = function (url, complete, progress, clas, params, priority, cache, group) {
			(priority === void 0) && (priority = 1);
			(cache === void 0) && (cache = true);
			var formarUrl = URL.formatURL(url);
			var item = this.getRes(formarUrl);
			if (!item) {
				var extension = Utils.getFileExtension(url);
				var creatItem = LoaderManager.createMap[extension];
				if (!creatItem)
					throw new Error("LoaderManager:unknown file(" + url + ") extension with: " + extension + ".");
				if (!clas) clas = creatItem[0];
				var type = creatItem[1];
				if (extension == "atlas") {
					this.load(url, complete, progress, type, priority, cache);
				} else {
					if (clas === Texture) type = "htmlimage";
					item = clas ? new clas() : null;
					if (item.hasOwnProperty("_loaded"))
						item._loaded = false;
					item._setUrl(url);
					(group) && (item._setGroup(group));
					this._createLoad(item, url, Handler.create(null, onLoaded), progress, type, priority, false, group, true);
					function onLoaded(data) {
						(item && !item.destroyed && data) && (item.onAsynLoaded.call(item, url, data, params));
						if (complete) complete.run();
						Laya.loader.event(url);
					}
					(cache) && (this.cacheRes(formarUrl, item));
				}
			} else {
				if (!item.hasOwnProperty("loaded") || item.loaded) {
					progress && progress.runWith(1);
					complete && complete.run();
				} else if (complete) {
					Laya.loader._createListener(url, complete.caller, complete.method, complete.args, true, false);
				}
			}
			return item;
		}

		/**
		*<p>加载资源。资源加载错误时，本对象会派发 Event.ERROR 事件，事件回调参数值为加载出错的资源地址。</p>
		*<p>因为返回值为 LoaderManager 对象本身，所以可以使用如下语法：Laya.loader.load(...).load(...);</p>
		*@param url 要加载的单个资源地址或资源信息数组。比如：简单数组：["a.png","b.png"]；复杂数组[{url:"a.png",type:Loader.IMAGE,size:100,priority:1},{url:"b.json",type:Loader.JSON,size:50,priority:1}]。
		*@param complete 加载结束回调。根据url类型不同分为2种情况：1. url为String类型，也就是单个资源地址，如果加载成功，则回调参数值为加载完成的资源，否则为null；2. url为数组类型，指定了一组要加载的资源，如果全部加载成功，则回调参数值为true，否则为false。
		*@param progress 加载进度回调。回调参数值为当前资源的加载进度信息(0-1)。
		*@param type 资源类型。比如：Loader.IMAGE。
		*@param priority (default=1)加载的优先级，优先级高的优先加载。有0-4共5个优先级，0最高，4最低。
		*@param cache 是否缓存加载结果。
		*@param group 分组，方便对资源进行管理。
		*@param ignoreCache 是否忽略缓存，强制重新加载。
		*@return 此 LoaderManager 对象本身。
		*/
		__proto.load = function (url, complete, progress, type, priority, cache, group, ignoreCache) {
			var _$this = this;
			(priority === void 0) && (priority = 1);
			(cache === void 0) && (cache = true);
			(ignoreCache === void 0) && (ignoreCache = false);
			if ((url instanceof Array)) return this._loadAssets(url, complete, progress, type, priority, cache, group);
			var content = Loader.getRes(url);
			if (content != null) {
				Laya.timer.frameOnce(1, null, function () {
					progress && progress.runWith(1);
					complete && complete.runWith(content);
					_$this._loaderCount || _$this.event(/*laya.events.Event.COMPLETE*/"complete");
				});
			} else {
				var info = LoaderManager._resMap[url];
				if (!info) {
					info = this._infoPool.length ? this._infoPool.pop() : new ResInfo();
					info.url = url;
					info.type = type;
					info.cache = cache;
					info.group = group;
					info.ignoreCache = ignoreCache;
					complete && info.on(/*laya.events.Event.COMPLETE*/"complete", complete.caller, complete.method, complete.args);
					progress && info.on(/*laya.events.Event.PROGRESS*/"progress", progress.caller, progress.method, progress.args);
					LoaderManager._resMap[url] = info;
					priority = priority < this._maxPriority ? priority : this._maxPriority - 1;
					this._resInfos[priority].push(info);
					this._next();
				} else {
					complete && info._createListener(/*laya.events.Event.COMPLETE*/"complete", complete.caller, complete.method, complete.args, false, false);
					progress && info._createListener(/*laya.events.Event.PROGRESS*/"progress", progress.caller, progress.method, progress.args, false, false);
				}
			}
			return this;
		}

		/**
		*@private
		*/
		__proto._createLoad = function (item, url, complete, progress, type, priority, cache, group, ignoreCache) {
			var _$this = this;
			(priority === void 0) && (priority = 1);
			(cache === void 0) && (cache = true);
			(ignoreCache === void 0) && (ignoreCache = false);
			if ((url instanceof Array)) return this._loadAssets(url, complete, progress, type, priority, cache, group);
			var content = Loader.getRes(url);
			if (content != null) {
				Laya.timer.frameOnce(1, null, function () {
					progress && progress.runWith(1);
					complete && complete.runWith(content);
					_$this._loaderCount || _$this.event(/*laya.events.Event.COMPLETE*/"complete");
				});
			} else {
				var info = LoaderManager._resMap[url];
				if (!info) {
					info = this._infoPool.length ? this._infoPool.pop() : new ResInfo();
					info.url = url;
					info.clas = item;
					info.type = type;
					info.cache = cache;
					info.group = group;
					info.ignoreCache = ignoreCache;
					complete && info.on(/*laya.events.Event.COMPLETE*/"complete", complete.caller, complete.method, complete.args);
					progress && info.on(/*laya.events.Event.PROGRESS*/"progress", progress.caller, progress.method, progress.args);
					LoaderManager._resMap[url] = info;
					priority = priority < this._maxPriority ? priority : this._maxPriority - 1;
					this._resInfos[priority].push(info);
					this._next();
				} else {
					complete && info._createListener(/*laya.events.Event.COMPLETE*/"complete", complete.caller, complete.method, complete.args, false, false);
					progress && info._createListener(/*laya.events.Event.PROGRESS*/"progress", progress.caller, progress.method, progress.args, false, false);
				}
			}
			return this;
		}

		__proto._next = function () {
			if (this._loaderCount >= this.maxLoader) return;
			for (var i = 0; i < this._maxPriority; i++) {
				var infos = this._resInfos[i];
				while (infos.length > 0) {
					var info = infos.shift();
					if (info) return this._doLoad(info);
				}
			}
			this._loaderCount || this.event(/*laya.events.Event.COMPLETE*/"complete");
		}

		__proto._doLoad = function (resInfo) {
			this._loaderCount++;
			var loader = this._loaders.length ? this._loaders.pop() : new Loader();
			loader.on(/*laya.events.Event.COMPLETE*/"complete", null, onLoaded);
			loader.on(/*laya.events.Event.PROGRESS*/"progress", null, function (num) {
				resInfo.event(/*laya.events.Event.PROGRESS*/"progress", num);
			});
			loader.on(/*laya.events.Event.ERROR*/"error", null, function (msg) {
				onLoaded(null);
			});
			var _this = this;
			function onLoaded(data) {
				loader.offAll();
				loader._data = null;
				_this._loaders.push(loader);
				_this._endLoad(resInfo, (data instanceof Array) ? [data] : data);
				_this._loaderCount--;
				_this._next();
			}
			loader._class = resInfo.clas;
			loader.load(resInfo.url, resInfo.type, resInfo.cache, resInfo.group, resInfo.ignoreCache);
		}

		__proto._endLoad = function (resInfo, content) {
			var url = resInfo.url;
			if (content == null) {
				var errorCount = this._failRes[url] || 0;
				if (errorCount < this.retryNum) {
					console.warn("[warn]Retry to load:", url);
					this._failRes[url] = errorCount + 1;
					Laya.timer.once(this.retryDelay, this, this._addReTry, [resInfo], false);
					return;
				} else {
					console.warn("[error]Failed to load:", url);
					this.event(/*laya.events.Event.ERROR*/"error", url);
				}
			}
			if (this._failRes[url]) this._failRes[url] = 0;
			delete LoaderManager._resMap[url];
			resInfo.event(/*laya.events.Event.COMPLETE*/"complete", content);
			resInfo.offAll();
			this._infoPool.push(resInfo);
		}

		__proto._addReTry = function (resInfo) {
			this._resInfos[this._maxPriority - 1].push(resInfo);
			this._next();
		}

		/**
		*清理指定资源地址缓存。
		*@param url 资源地址。
		*@param forceDispose 是否强制销毁，有些资源是采用引用计数方式销毁，如果forceDispose=true，则忽略引用计数，直接销毁，比如Texture，默认为false
		*/
		__proto.clearRes = function (url, forceDispose) {
			(forceDispose === void 0) && (forceDispose = false);
			Loader.clearRes(url, forceDispose);
		}

		/**
		*获取指定资源地址的资源。
		*@param url 资源地址。
		*@return 返回资源。
		*/
		__proto.getRes = function (url) {
			return Loader.getRes(url);
		}

		/**
		*缓存资源。
		*@param url 资源地址。
		*@param data 要缓存的内容。
		*/
		__proto.cacheRes = function (url, data) {
			Loader.cacheRes(url, data);
		}

		/**
		*销毁Texture使用的图片资源，保留texture壳，如果下次渲染的时候，发现texture使用的图片资源不存在，则会自动恢复
		*相比clearRes，clearTextureRes只是清理texture里面使用的图片资源，并不销毁texture，再次使用到的时候会自动恢复图片资源
		*而clearRes会彻底销毁texture，导致不能再使用；clearTextureRes能确保立即销毁图片资源，并且不用担心销毁错误，clearRes则采用引用计数方式销毁
		*【注意】如果图片本身在自动合集里面（默认图片小于512*512），内存是不能被销毁的，此图片被大图合集管理器管理
		*@param url 图集地址或者texture地址，比如 Loader.clearTextureRes("res/atlas/comp.atlas");Loader.clearTextureRes("hall/bg.jpg");
		*/
		__proto.clearTextureRes = function (url) {
			Loader.clearTextureRes(url);
		}

		/**
		*设置资源分组。
		*@param url 资源地址。
		*@param group 分组名
		*/
		__proto.setGroup = function (url, group) {
			Loader.setGroup(url, group);
		}

		/**
		*根据分组清理资源。
		*@param group 分组名
		*/
		__proto.clearResByGroup = function (group) {
			Loader.clearResByGroup(group);
		}

		/**清理当前未完成的加载，所有未加载的内容全部停止加载。*/
		__proto.clearUnLoaded = function () {
			for (var i = 0; i < this._maxPriority; i++) {
				var infos = this._resInfos[i];
				for (var j = infos.length - 1; j > -1; j--) {
					var info = infos[j];
					if (info) {
						info.offAll();
						this._infoPool.push(info);
					}
				}
				infos.length = 0;
			}
			this._loaderCount = 0;
			LoaderManager._resMap = {};
		}

		/**
		*根据地址集合清理掉未加载的内容
		*@param urls 资源地址集合
		*/
		__proto.cancelLoadByUrls = function (urls) {
			if (!urls) return;
			for (var i = 0, n = urls.length; i < n; i++) {
				this.cancelLoadByUrl(urls[i]);
			}
		}

		/**
		*根据地址清理掉未加载的内容
		*@param url 资源地址
		*/
		__proto.cancelLoadByUrl = function (url) {
			for (var i = 0; i < this._maxPriority; i++) {
				var infos = this._resInfos[i];
				for (var j = infos.length - 1; j > -1; j--) {
					var info = infos[j];
					if (info && info.url === url) {
						infos[j] = null;
						info.offAll();
						this._infoPool.push(info);
					}
				}
			}
			if (LoaderManager._resMap[url]) delete LoaderManager._resMap[url];
		}

		/**
		*@private
		*加载数组里面的资源。
		*@param arr 简单：["a.png","b.png"]，复杂[{url:"a.png",type:Loader.IMAGE,size:100,priority:1},{url:"b.json",type:Loader.JSON,size:50,priority:1}]*/
		__proto._loadAssets = function (arr, complete, progress, type, priority, cache, group) {
			(priority === void 0) && (priority = 1);
			(cache === void 0) && (cache = true);
			var itemCount = arr.length;
			var loadedCount = 0;
			var totalSize = 0;
			var items = [];
			var success = true;
			for (var i = 0; i < itemCount; i++) {
				var item = arr[i];
				if ((typeof item == 'string')) item = { url: item, type: type, size: 1, priority: priority };
				if (!item.size) item.size = 1;
				item.progress = 0;
				totalSize += item.size;
				items.push(item);
				var progressHandler = progress ? Handler.create(null, loadProgress, [item], false) : null;
				var completeHandler = (complete || progress) ? Handler.create(null, loadComplete, [item]) : null;
				this.load(item.url, completeHandler, progressHandler, item.type, item.priority || 1, cache, item.group || group);
			}
			function loadComplete(item, content) {
				loadedCount++;
				item.progress = 1;
				if (!content) success = false;
				if (loadedCount === itemCount && complete) {
					complete.runWith(success);
				}
			}
			function loadProgress(item, value) {
				if (progress != null) {
					item.progress = value;
					var num = 0;
					for (var j = 0; j < items.length; j++) {
						var item1 = items[j];
						num += item1.size * item1.progress;
					};
					var v = num / totalSize;
					progress.runWith(v);
				}
			}
			return this;
		}

		LoaderManager.cacheRes = function (url, data) {
			Loader.cacheRes(url, data);
		}

		LoaderManager._resMap = {};
		__static(LoaderManager,
			['createMap', function () { return this.createMap = { atlas: [null,/*laya.net.Loader.ATLAS*/"atlas"] }; }
			]);
		LoaderManager.__init$ = function () {
			//class ResInfo extends laya.events.EventDispatcher
			ResInfo = (function (_super) {
				function ResInfo() {
					this.url = null;
					this.type = null;
					this.cache = false;
					this.group = null;
					this.ignoreCache = false;
					this.clas = null;
					ResInfo.__super.call(this);
				}
				__class(ResInfo, '', _super);
				return ResInfo;
			})(EventDispatcher)
		}

		return LoaderManager;
	})(EventDispatcher)


	/**
	*<p><code>ColorFilter</code> 是颜色滤镜。使用 ColorFilter 类可以将 4 x 5 矩阵转换应用于输入图像上的每个像素的 RGBA 颜色和 Alpha 值，以生成具有一组新的 RGBA 颜色和 Alpha 值的结果。该类允许饱和度更改、色相旋转、亮度转 Alpha 以及各种其他效果。您可以将滤镜应用于任何显示对象（即，从 Sprite 类继承的对象）。</p>
	*<p>注意：对于 RGBA 值，最高有效字节代表红色通道值，其后的有效字节分别代表绿色、蓝色和 Alpha 通道值。</p>
	*/
	//class laya.filters.ColorFilter extends laya.filters.Filter
	var ColorFilter = (function (_super) {
		function ColorFilter(mat) {
			/**@private */
			//this._mat=null;
			/**@private */
			//this._alpha=null;
			ColorFilter.__super.call(this);
			if (!mat) {
				mat = [0.3, 0.59, 0.11, 0, 0, 0.3, 0.59, 0.11, 0, 0, 0.3, 0.59, 0.11, 0, 0, 0, 0, 0, 1, 0];
			}
			this._mat = new Float32Array(16);
			this._alpha = new Float32Array(4);
			var j = 0;
			var z = 0;
			for (var i = 0; i < 20; i++) {
				if (i % 5 != 4) {
					this._mat[j++] = mat[i];
				} else {
					this._alpha[z++] = mat[i];
				}
			}
			this._action = RunDriver.createFilterAction(0x20);
			this._action.data = this;
		}

		__class(ColorFilter, 'laya.filters.ColorFilter', _super);
		var __proto = ColorFilter.prototype;
		Laya.imps(__proto, { "laya.filters.IFilter": true })
		/**
		*@private 通知微端
		*/
		__proto.callNative = function (sp) {
			var t = sp._$P.cf = this;
			sp.conchModel && sp.conchModel.setFilterMatrix && sp.conchModel.setFilterMatrix(this._mat, this._alpha);
		}

		/**@private */
		__getset(0, __proto, 'type', function () {
			return 0x20;
		});

		/**@private */
		__getset(0, __proto, 'action', function () {
			return this._action;
		});

		return ColorFilter;
	})(Filter)


	/**
	*<p> <code>Socket</code> 封装了 HTML5 WebSocket ，允许服务器端与客户端进行全双工（full-duplex）的实时通信，并且允许跨域通信。在建立连接后，服务器和 Browser/Client Agent 都能主动的向对方发送或接收文本和二进制数据。</p>
	*<p>要使用 <code>Socket</code> 类的方法，请先使用构造函数 <code>new Socket</code> 创建一个 <code>Socket</code> 对象。 <code>Socket</code> 以异步方式传输和接收数据。</p>
	*/
	//class laya.net.Socket extends laya.events.EventDispatcher
	var Socket = (function (_super) {
		function Socket(host, port, byteClass) {
			/**@private */
			this._endian = null;
			/**@private */
			this._stamp = NaN;
			/**@private */
			this._socket = null;
			/**@private */
			this._connected = false;
			/**@private */
			this._addInputPosition = 0;
			/**@private */
			this._input = null;
			/**@private */
			this._output = null;
			/**
			*@private
			*表示建立连接时需等待的毫秒数。
			*/
			this.timeout = 0;
			/**
			*@private
			*在写入或读取对象时，控制所使用的 AMF 的版本。
			*/
			this.objectEncoding = 0;
			/**
			*不再缓存服务端发来的数据。
			*/
			this.disableInput = false;
			/**
			*用来发送和接收数据的 <code>Byte</code> 类。
			*/
			this._byteClass = null;
			/**
			*<p>子协议名称。子协议名称字符串，或由多个子协议名称字符串构成的数组。必须在调用 connect 或者 connectByUrl 之前进行赋值，否则无效。</p>
			*<p>指定后，只有当服务器选择了其中的某个子协议，连接才能建立成功，否则建立失败，派发 Event.ERROR 事件。</p>
			*@see https://html.spec.whatwg.org/multipage/comms.html#dom-websocket
			*/
			this.protocols = [];
			(port === void 0) && (port = 0);
			Socket.__super.call(this);
			this._byteClass = byteClass ? byteClass : Byte;
			this.endian = "bigEndian";
			this.timeout = 20000;
			this._addInputPosition = 0;
			if (host && port > 0 && port < 65535)
				this.connect(host, port);
		}

		__class(Socket, 'laya.net.Socket', _super);
		var __proto = Socket.prototype;
		/**
		*<p>连接到指定的主机和端口。</p>
		*<p>连接成功派发 Event.OPEN 事件；连接失败派发 Event.ERROR 事件；连接被关闭派发 Event.CLOSE 事件；接收到数据派发 Event.MESSAGE 事件； 除了 Event.MESSAGE 事件参数为数据内容，其他事件参数都是原生的 HTML DOM Event 对象。</p>
		*@param host 服务器地址。
		*@param port 服务器端口。
		*/
		__proto.connect = function (host, port) {
			var url = "ws://" + host + ":" + port;
			if (Browser.window.location.protocol == "https:") {
				url = "wss://" + host + ":" + port;
			} else {
				url = "ws://" + host + ":" + port;
			}
			this.connectByUrl(url);
		}

		/**
		*<p>连接到指定的服务端 WebSocket URL。 URL 类似 ws://yourdomain:port。</p>
		*<p>连接成功派发 Event.OPEN 事件；连接失败派发 Event.ERROR 事件；连接被关闭派发 Event.CLOSE 事件；接收到数据派发 Event.MESSAGE 事件； 除了 Event.MESSAGE 事件参数为数据内容，其他事件参数都是原生的 HTML DOM Event 对象。</p>
		*@param url 要连接的服务端 WebSocket URL。 URL 类似 ws://yourdomain:port。
		*/
		__proto.connectByUrl = function (url) {
			var _$this = this;
			if (this._socket != null)
				this.close();
			this._socket && this.cleanSocket();
			if (!this.protocols || this.protocols.length == 0) {
				this._socket = new Browser.window.WebSocket(url);
			} else {
				this._socket = new Browser.window.WebSocket(url, this.protocols);
			}
			this._socket.binaryType = "arraybuffer";
			this._output = new this._byteClass();
			this._output.endian = this.endian;
			this._input = new this._byteClass();
			this._input.endian = this.endian;
			this._addInputPosition = 0;
			this._socket.onopen = function (e) {
				_$this._onOpen(e);
			};
			this._socket.onmessage = function (msg) {
				_$this._onMessage(msg);
			};
			this._socket.onclose = function (e) {
				_$this._onClose(e);
			};
			this._socket.onerror = function (e) {
				_$this._onError(e);
			};
		}

		/**
		*清理socket。
		*/
		__proto.cleanSocket = function () {
			try {
				this._socket.close();
			} catch (e) { }
			this._connected = false;
			this._socket.onopen = null;
			this._socket.onmessage = null;
			this._socket.onclose = null;
			this._socket.onerror = null;
			this._socket = null;
		}

		/**
		*关闭连接。
		*/
		__proto.close = function () {
			if (this._socket != null) {
				try {
					this._socket.close();
				} catch (e) { }
			}
		}

		/**
		*@private
		*连接建立成功 。
		*/
		__proto._onOpen = function (e) {
			this._connected = true;
			this.event(/*laya.events.Event.OPEN*/"open", e);
		}

		/**
		*@private
		*接收到数据处理方法。
		*@param msg 数据。
		*/
		__proto._onMessage = function (msg) {
			if (!msg || !msg.data) return;
			var data = msg.data;
			if (this.disableInput && data) {
				this.event(/*laya.events.Event.MESSAGE*/"message", data);
				return;
			}
			if (this._input.length > 0 && this._input.bytesAvailable < 1) {
				this._input.clear();
				this._addInputPosition = 0;
			};
			var pre = this._input.pos;
			!this._addInputPosition && (this._addInputPosition = 0);
			this._input.pos = this._addInputPosition;
			if (data) {
				if ((typeof data == 'string')) {
					this._input.writeUTFBytes(data);
				} else {
					this._input.writeArrayBuffer(data);
				}
				this._addInputPosition = this._input.pos;
				this._input.pos = pre;
			}
			this.event(/*laya.events.Event.MESSAGE*/"message", data);
		}

		/**
		*@private
		*连接被关闭处理方法。
		*/
		__proto._onClose = function (e) {
			this._connected = false;
			this.event(/*laya.events.Event.CLOSE*/"close", e)
		}

		/**
		*@private
		*出现异常处理方法。
		*/
		__proto._onError = function (e) {
			this.event(/*laya.events.Event.ERROR*/"error", e)
		}

		/**
		*发送数据到服务器。
		*@param data 需要发送的数据，可以是String或者ArrayBuffer。
		*/
		__proto.send = function (data) {
			this._socket.send(data);
		}

		/**
		*发送缓冲区中的数据到服务器。
		*/
		__proto.flush = function () {
			if (this._output && this._output.length > 0) {
				var evt;
				try {
					this._socket && this._socket.send(this._output.__getBuffer().slice(0, this._output.length));
				} catch (e) {
					evt = e;
				}
				this._output.endian = this.endian;
				this._output.clear();
				if (evt) this.event(/*laya.events.Event.ERROR*/"error", evt);
			}
		}

		/**
		*缓存的服务端发来的数据。
		*/
		__getset(0, __proto, 'input', function () {
			return this._input;
		});

		/**
		*表示需要发送至服务端的缓冲区中的数据。
		*/
		__getset(0, __proto, 'output', function () {
			return this._output;
		});

		/**
		*表示此 Socket 对象目前是否已连接。
		*/
		__getset(0, __proto, 'connected', function () {
			return this._connected;
		});

		/**
		*<p>主机字节序，是 CPU 存放数据的两种不同顺序，包括小端字节序和大端字节序。</p>
		*<p> LITTLE_ENDIAN ：小端字节序，地址低位存储值的低位，地址高位存储值的高位。</p>
		*<p> BIG_ENDIAN ：大端字节序，地址低位存储值的高位，地址高位存储值的低位。</p>
		*/
		__getset(0, __proto, 'endian', function () {
			return this._endian;
		}, function (value) {
			this._endian = value;
			if (this._input != null) this._input.endian = value;
			if (this._output != null) this._output.endian = value;
		});

		Socket.LITTLE_ENDIAN = "littleEndian";
		Socket.BIG_ENDIAN = "bigEndian";
		return Socket;
	})(EventDispatcher)


	/**
	*@private
	*Worker Image加载器
	*/
	//class laya.net.WorkerLoader extends laya.events.EventDispatcher
	var WorkerLoader = (function (_super) {
		function WorkerLoader() {
			/**
			*使用的Worker对象。
			*/
			this.worker = null;
			WorkerLoader.__super.call(this);
			var _$this = this;
			this.worker = new Browser.window.Worker(WorkerLoader.workerPath);
			this.worker.onmessage = function (evt) {
				_$this.workerMessage(evt.data);
			}
		}

		__class(WorkerLoader, 'laya.net.WorkerLoader', _super);
		var __proto = WorkerLoader.prototype;
		/**
		*@private
		*/
		__proto.workerMessage = function (data) {
			if (data) {
				switch (data.type) {
					case "Image":
						this.imageLoaded(data);
						break;
					case "Msg":
						this.event("image_msg", data.msg);
						break;
				}
			}
		}

		/**
		*@private
		*/
		__proto.imageLoaded = function (data) {
			if (data && data.buffer && data.buffer.length < 10) {
				WorkerLoader._enable = false;
				this._myTrace("buffer lost when postmessage ,disable workerloader");
				this.event(data.url, null);
				this.event("image_err", data.url + "\n" + data.msg);
				return;
			}
			if (!data.dataType) {
				this.event(data.url, null);
				this.event("image_err", data.url + "\n" + data.msg);
				return;
			};
			var canvas, ctx;
			var imageData;
			switch (data.dataType) {
				case "buffer":
					canvas = new HTMLCanvas("2D");
					ctx = canvas.source.getContext("2d");
					imageData = ctx.createImageData(data.width, data.height);
					imageData.data.set(data.buffer);
					canvas.size(imageData.width, imageData.height);
					ctx.putImageData(imageData, 0, 0);
					canvas.memorySize = 0;
					break;
				case "imagedata":
					canvas = new HTMLCanvas("2D");
					ctx = canvas.source.getContext("2d");
					imageData = data.imagedata;
					canvas.size(imageData.width, imageData.height);
					ctx.putImageData(imageData, 0, 0);
					imageData = data.imagedata;
					canvas.memorySize = 0;
					break;
				case "imageBitmap":
					imageData = data.imageBitmap;
					if (!Render.isWebGL) {
						canvas = new HTMLCanvas("2D");
						ctx = canvas.source.getContext("2d");
						canvas.size(imageData.width, imageData.height);
						ctx.drawImage(imageData, 0, 0);
						canvas.src = data.url;
					} else
						canvas = imageData;
					break;
			}
			if (Render.isWebGL)
			/*__JS__ */canvas = new laya.webgl.resource.WebGLImage(canvas, data.url);;
			this.event(data.url, canvas);
		}

		/**
		*@private
		*/
		__proto._myTrace = function (__arg) {
			var arg = arguments;
			var rst = [];
			var i = 0, len = arg.length;
			for (i = 0; i < len; i++) {
				rst.push(arg[i]);
			}
			this.event("image_msg", rst.join(" "));
		}

		/**
		*加载图片
		*@param url 图片地址
		*/
		__proto.loadImage = function (url) {
			var data;
			data = {};
			data.type = "load";
			data.url = url;
			this.worker.postMessage(data);
		}

		/**
		*@private
		*加载图片资源。
		*@param url 资源地址。
		*/
		__proto._loadImage = function (url) {
			var _this = this;
			if (!WorkerLoader._enable || url.toLowerCase().indexOf(".png") < 0) {
				WorkerLoader._preLoadFun.call(_this, url);
				return;
			}
			url = URL.formatURL(url);
			function clear() {
				laya.net.WorkerLoader.I.off(url, _this, onload);
			};
			var onload = function (image) {
				clear();
				if (image) {
					_this["onLoaded"](image);
				} else {
					WorkerLoader._preLoadFun.call(_this, url);
				}
			};
			laya.net.WorkerLoader.I.on(url, _this, onload);
			laya.net.WorkerLoader.I.loadImage(url);
		}

		/**
		*是否启用。
		*/
		__getset(1, WorkerLoader, 'enable', function () {
			return WorkerLoader._enable;
		}, function (v) {
			if (WorkerLoader.disableJSDecode && (!Browser.window.createImageBitmap)) return;
			WorkerLoader._enable = v;
			if (WorkerLoader._enable && WorkerLoader._preLoadFun == null) WorkerLoader._enable = WorkerLoader.__init__();
		});

		WorkerLoader.__init__ = function () {
			if (WorkerLoader._preLoadFun != null) return false;
			if (!Browser.window.Worker) return false;
			WorkerLoader._preLoadFun = Loader["prototype"]["_loadImage"];
			Loader["prototype"]["_loadImage"] = WorkerLoader["prototype"]["_loadImage"];
			if (!WorkerLoader.I) WorkerLoader.I = new WorkerLoader();
			return true;
		}

		WorkerLoader.workerSupported = function () {
			return Browser.window.Worker ? true : false;
		}

		WorkerLoader.IMAGE_LOADED = "image_loaded";
		WorkerLoader.IMAGE_ERR = "image_err";
		WorkerLoader.IMAGE_MSG = "image_msg";
		WorkerLoader.I = null;
		WorkerLoader._preLoadFun = null;
		WorkerLoader._enable = false;
		WorkerLoader.workerPath = "libs/worker.js";
		WorkerLoader.disableJSDecode = true;
		return WorkerLoader;
	})(EventDispatcher)


	/**
	*@private
	*<code>Resource</code> 资源存取类。
	*/
	//class laya.resource.Resource extends laya.events.EventDispatcher
	var Resource = (function (_super) {
		function Resource() {
			/**@private */
			//this.__loaded=false;
			/**@private */
			//this._id=0;
			/**@private */
			//this._memorySize=0;
			/**@private */
			//this._released=false;
			/**@private */
			//this._destroyed=false;
			/**@private */
			//this._referenceCount=0;
			/**@private */
			//this._group=null;
			/**@private */
			//this._url=null;
			/**@private */
			//this._resourceManager=null;
			/**@private */
			//this._lastUseFrameCount=0;
			/**是否加锁，如果true为不能使用自动释放机制。*/
			//this.lock=false;
			/**名称。 */
			//this.name=null;
			Resource.__super.call(this);
			this._$1__id = ++Resource._uniqueIDCounter;
			this.__loaded = true;
			this._destroyed = false;
			this._referenceCount = 0;
			Resource._idResourcesMap[this.id] = this;
			this._released = true;
			this.lock = false;
			this._memorySize = 0;
			this._lastUseFrameCount = -1;
			(ResourceManager.currentResourceManager) && (ResourceManager.currentResourceManager.addResource(this));
		}

		__class(Resource, 'laya.resource.Resource', _super);
		var __proto = Resource.prototype;
		Laya.imps(__proto, { "laya.resource.ICreateResource": true, "laya.resource.IDispose": true })
		/**
		*@private
		*/
		__proto._setUrl = function (url) {
			if (this._url !== url) {
				var resList;
				if (this._url) {
					resList = Resource._urlResourcesMap[this._url];
					resList.splice(resList.indexOf(this), 1);
					(resList.length === 0) && (delete Resource._urlResourcesMap[this._url]);
				}
				if (url) {
					resList = Resource._urlResourcesMap[url];
					(resList) || (Resource._urlResourcesMap[url] = resList = []);
					resList.push(this);
				}
				this._url = url;
			}
		}

		/**
		*@private
		*/
		__proto._getGroup = function () {
			return this._group;
		}

		/**
		*@private
		*/
		__proto._setGroup = function (value) {
			if (this._group !== value) {
				var groupList;
				if (this._group) {
					groupList = Resource._groupResourcesMap[this._group];
					groupList.splice(groupList.indexOf(this), 1);
					(groupList.length === 0) && (delete Resource._groupResourcesMap[this._group]);
				}
				if (value) {
					groupList = Resource._groupResourcesMap[value];
					(groupList) || (Resource._groupResourcesMap[value] = groupList = []);
					groupList.push(this);
				}
				this._group = value;
			}
		}

		/**
		*@private
		*/
		__proto._addReference = function () {
			this._referenceCount++;
		}

		/**
		*@private
		*/
		__proto._removeReference = function () {
			this._referenceCount--;
		}

		/**
		*@private
		*/
		__proto._clearReference = function () {
			this._referenceCount = 0;
		}

		/**
		*@private
		*/
		__proto._endLoaded = function () {
			this.__loaded = true;
			this.event(/*laya.events.Event.LOADED*/"loaded", this);
		}

		/**
		*@private
		*/
		__proto.recreateResource = function () {
			this.completeCreate();
		}

		/**
		*@private
		*/
		__proto.disposeResource = function () { }
		/**
		*激活资源，使用资源前应先调用此函数激活。
		*@param force 是否强制创建。
		*/
		__proto.activeResource = function (force) {
			(force === void 0) && (force = false);
			this._lastUseFrameCount = Stat.loopCount;
			if (!this._destroyed && this.__loaded && (this._released || force))
				this.recreateResource();
		}

		/**
		*释放资源。
		*@param force 是否强制释放。
		*@return 是否成功释放。
		*/
		__proto.releaseResource = function (force) {
			(force === void 0) && (force = false);
			if (!force && this.lock)
				return false;
			if (!this._released || force) {
				this.disposeResource();
				this._released = true;
				this._lastUseFrameCount = -1;
				this.event(/*laya.events.Event.RELEASED*/"released", this);
				return true;
			} else {
				return false;
			}
		}

		/**
		*@private
		*/
		__proto.onAsynLoaded = function (url, data, params) {
			throw new Error("Resource: must override this function!");
		}

		/**
		*<p>彻底处理资源，处理后不能恢复。</p>
		*<p><b>注意：</b>会强制解锁清理。</p>
		*/
		__proto.destroy = function () {
			if (this._destroyed)
				return;
			if (this._resourceManager !== null)
				this._resourceManager.removeResource(this);
			this._destroyed = true;
			this.lock = false;
			this.releaseResource();
			delete Resource._idResourcesMap[this.id];
			var resList;
			if (this._url) {
				resList = Resource._urlResourcesMap[this._url];
				if (resList) {
					resList.splice(resList.indexOf(this), 1);
					(resList.length === 0) && (delete Resource._urlResourcesMap[this.url]);
				}
				Loader.clearRes(this._url);
				(this.__loaded) || (RunDriver.cancelLoadByUrl(this._url));
			}
			if (this._group) {
				resList = Resource._groupResourcesMap[this._group];
				resList.splice(resList.indexOf(this), 1);
				(resList.length === 0) && (delete Resource._groupResourcesMap[this.url]);
			}
		}

		/**完成资源激活。*/
		__proto.completeCreate = function () {
			this._released = false;
			this.event(/*laya.events.Event.RECOVERED*/"recovered", this);
		}

		/**
		*@private
		*/
		__proto.dispose = function () {
			this.destroy();
		}

		/**
		*@private
		*/
		/**
		*占用内存尺寸。
		*/
		__getset(0, __proto, 'memorySize', function () {
			return this._memorySize;
		}, function (value) {
			var offsetValue = value - this._memorySize;
			this._memorySize = value;
			this.resourceManager && this.resourceManager.addSize(offsetValue);
		});

		/**
		*@private
		*/
		__getset(0, __proto, '_loaded', null, function (value) {
			this.__loaded = value;
		});

		/**
		*获取是否已加载完成。
		*/
		__getset(0, __proto, 'loaded', function () {
			return this.__loaded;
		});

		/**
		*获取唯一标识ID,通常用于识别。
		*/
		__getset(0, __proto, 'id', function () {
			return this._$1__id;
		});

		/**
		*是否已处理。
		*/
		__getset(0, __proto, 'destroyed', function () {
			return this._destroyed;
		});

		/**
		*设置资源组名。
		*/
		/**
		*获取资源组名。
		*/
		__getset(0, __proto, 'group', function () {
			return this._getGroup();
		}, function (value) {
			this._setGroup(value);
		});

		/**
		*资源管理员。
		*/
		__getset(0, __proto, 'resourceManager', function () {
			return this._resourceManager;
		});

		/**
		*获取资源的URL地址。
		*@return URL地址。
		*/
		__getset(0, __proto, 'url', function () {
			return this._url;
		});

		/**
		*是否已释放。
		*/
		__getset(0, __proto, 'released', function () {
			return this._released;
		});

		/**
		*获取资源的引用计数。
		*/
		__getset(0, __proto, 'referenceCount', function () {
			return this._referenceCount;
		});

		Resource.getResourceByID = function (id) {
			return Resource._idResourcesMap[id];
		}

		Resource.getResourceByURL = function (url, index) {
			(index === void 0) && (index = 0);
			return Resource._urlResourcesMap[url][index];
		}

		Resource.getResourceCountByURL = function (url) {
			return Resource._urlResourcesMap[url].length;
		}

		Resource.destroyUnusedResources = function (group) {
			var res;
			if (group) {
				var resouList = Resource._groupResourcesMap[group];
				if (resouList) {
					var tempResouList = resouList.slice();
					for (var i = 0, n = tempResouList.length; i < n; i++) {
						res = tempResouList[i];
						if (!res.lock && res._referenceCount === 0)
							res.destroy();
					}
				}
			} else {
				for (var k in Resource._idResourcesMap) {
					res = Resource._idResourcesMap[k];
					if (!res.lock && res._referenceCount === 0)
						res.destroy();
				}
			}
		}

		Resource._uniqueIDCounter = 0;
		Resource._idResourcesMap = {};
		Resource._urlResourcesMap = {};
		Resource._groupResourcesMap = {};
		return Resource;
	})(EventDispatcher)


	/**
	*<code>Texture</code> 是一个纹理处理类。
	*/
	//class laya.resource.Texture extends laya.events.EventDispatcher
	var Texture = (function (_super) {
		function Texture(bitmap, uv) {
			/**图片或者canvas 。*/
			//this.bitmap=null;
			/**UV信息。*/
			//this.uv=null;
			/**沿 X 轴偏移量。*/
			this.offsetX = 0;
			/**沿 Y 轴偏移量。*/
			this.offsetY = 0;
			/**原始宽度（包括被裁剪的透明区域）。*/
			this.sourceWidth = 0;
			/**原始高度（包括被裁剪的透明区域）。*/
			this.sourceHeight = 0;
			/**@private */
			//this._loaded=false;
			/**@private */
			this._w = 0;
			/**@private */
			this._h = 0;
			/**@private 唯一ID*/
			//this.$_GID=NaN;
			/**图片地址*/
			//this.url=null;
			/**@private */
			this._uvID = 0;
			this._atlasID = -1;
			/**@private */
			this.scaleRate = 1;
			Texture.__super.call(this);
			if (bitmap) {
				bitmap._addReference();
			}
			this.setTo(bitmap, uv);
		}

		__class(Texture, 'laya.resource.Texture', _super);
		var __proto = Texture.prototype;
		/**
		*@private
		*/
		__proto._setUrl = function (url) {
			this.url = url;
		}

		/**
		*设置此对象的位图资源、UV数据信息。
		*@param bitmap 位图资源
		*@param uv UV数据信息
		*/
		__proto.setTo = function (bitmap, uv) {
			if (/*__JS__ */bitmap instanceof window.HTMLElement) {
				var canvas = HTMLCanvas.create("2D", bitmap);
				this.bitmap = canvas;
			} else {
				this.bitmap = bitmap;
			}
			this.uv = uv || Texture.DEF_UV;
			if (bitmap) {
				this._w = bitmap.width;
				this._h = bitmap.height;
				this.sourceWidth = this.sourceWidth || this._w;
				this.sourceHeight = this.sourceHeight || this._h
				this._loaded = this._w > 0;
				var _this = this;
				if (this._loaded) {
					RunDriver.addToAtlas && RunDriver.addToAtlas(_this);
				} else {
					var bm = bitmap;
					if ((bm instanceof laya.resource.HTMLImage) && bm.image)
						bm.image.addEventListener('load', function (e) {
							RunDriver.addToAtlas && RunDriver.addToAtlas(_this);
						}, false);
				}
			}
		}

		/**@private 激活资源。*/
		__proto.active = function () {
			if (this.bitmap) this.bitmap.activeResource();
		}

		/**
		*销毁纹理（分直接销毁，跟计数销毁两种）。
		*@param forceDispose (default=false)true为强制销毁主纹理，false是通过计数销毁纹理。
		*/
		__proto.destroy = function (forceDispose) {
			(forceDispose === void 0) && (forceDispose = false);
			if (this.bitmap && (this.bitmap).referenceCount > 0) {
				var temp = this.bitmap;
				if (forceDispose) {
					if (Render.isConchApp && temp.source && temp.source.conchDestroy) {
						this.bitmap.source.conchDestroy();
					}
					this.bitmap = null;
					temp.dispose();
					(temp)._clearReference();
				} else {
					(temp)._removeReference();
					if ((temp).referenceCount == 0) {
						if (Render.isConchApp && temp.source && temp.source.conchDestroy) {
							this.bitmap.source.conchDestroy();
						}
						this.bitmap = null;
						temp.dispose();
					}
				}
				if (this.url && this === Laya.loader.getRes(this.url)) Laya.loader.clearRes(this.url, forceDispose);
				this._loaded = false;
			}
		}

		/**
		*加载指定地址的图片。
		*@param url 图片地址。
		*/
		__proto.load = function (url) {
			var _$this = this;
			this._loaded = false;
			url = URL.customFormat(url);
			var fileBitmap = (this.bitmap || (this.bitmap = HTMLImage.create(url)));
			if (fileBitmap) fileBitmap._addReference();
			var _this = this;
			fileBitmap.onload = function () {
				fileBitmap.onload = null;
				_this._loaded = true;
				_$this.sourceWidth = _$this._w = fileBitmap.width;
				_$this.sourceHeight = _$this._h = fileBitmap.height;
				_this.event(/*laya.events.Event.LOADED*/"loaded", this);
				(RunDriver.addToAtlas) && (RunDriver.addToAtlas(_this));
			};
		}

		/**@private */
		__proto.addTextureToAtlas = function (e) {
			RunDriver.addTextureToAtlas(this);
		}

		/**
		*获取Texture上的某个区域的像素点
		*@param x
		*@param y
		*@param width
		*@param height
		*@return 返回像素点集合
		*/
		__proto.getPixels = function (x, y, width, height) {
			if (Render.isConchApp) {
				var temp = this.bitmap;
				if (temp.source && temp.source.getImageData) {
					var arraybuffer = temp.source.getImageData(x, y, width, height);
					var tUint8Array = new Uint8Array(arraybuffer);
					return /*__JS__ */Array.from(tUint8Array);
				}
				return null;
			} else if (Render.isWebGL) {
				return RunDriver.getTexturePixels(this, x, y, width, height);
			} else {
				Browser.canvas.size(width, height);
				Browser.canvas.clear();
				Browser.context.drawTexture(this, -x, -y, this.width, this.height, 0, 0);
				var info = Browser.context.getImageData(0, 0, width, height);
			}
			return info.data;
		}

		/**@private */
		__proto.onAsynLoaded = function (url, bitmap) {
			if (bitmap) bitmap._addReference();
			this.setTo(bitmap, this.uv);
		}

		/**激活并获取资源。*/
		__getset(0, __proto, 'source', function () {
			if (!this.bitmap) return null;
			this.bitmap.activeResource();
			return this.bitmap.source;
		});

		/**
		*表示是否加载成功，只能表示初次载入成功（通常包含下载和载入）,并不能完全表示资源是否可立即使用（资源管理机制释放影响等）。
		*/
		__getset(0, __proto, 'loaded', function () {
			return this._loaded;
		});

		/**
		*表示资源是否已释放。
		*/
		__getset(0, __proto, 'released', function () {
			if (!this.bitmap) return true;
			return this.bitmap.released;
		});

		/**实际宽度。*/
		__getset(0, __proto, 'width', function () {
			if (this._w) return this._w;
			return (this.uv && this.uv !== Texture.DEF_UV) ? (this.uv[2] - this.uv[0]) * this.bitmap.width : this.bitmap.width;
		}, function (value) {
			this._w = value;
			this.sourceWidth || (this.sourceWidth = value);
		});

		/**
		*通过外部设置是否启用纹理平铺(后面要改成在着色器里计算)
		*/
		/**
		*获取当前纹理是否启用了纹理平铺
		*/
		__getset(0, __proto, 'repeat', function () {
			if (Render.isWebGL && this.bitmap) {
				return this.bitmap.repeat;
			}
			return true;
		}, function (value) {
			if (value) {
				if (Render.isWebGL && this.bitmap) {
					this.bitmap.repeat = value;
					if (value) {
						this.bitmap.enableMerageInAtlas = false;
					}
				}
			}
		});

		/**实际高度。*/
		__getset(0, __proto, 'height', function () {
			if (this._h) return this._h;
			return (this.uv && this.uv !== Texture.DEF_UV) ? (this.uv[5] - this.uv[1]) * this.bitmap.height : this.bitmap.height;
		}, function (value) {
			this._h = value;
			this.sourceHeight || (this.sourceHeight = value);
		});

		/**
		*设置线性采样的状态（目前只能第一次绘制前设置false生效,来关闭线性采样）。
		*/
		/**
		*获取当前纹理是否启用了线性采样。
		*/
		__getset(0, __proto, 'isLinearSampling', function () {
			return Render.isWebGL ? (this.bitmap.minFifter != 0x2600) : true;
		}, function (value) {
			if (!value && Render.isWebGL) {
				if (!value && (this.bitmap.minFifter == -1) && (this.bitmap.magFifter == -1)) {
					this.bitmap.minFifter = 0x2600;
					this.bitmap.magFifter = 0x2600;
					this.bitmap.enableMerageInAtlas = false;
				}
			}
		});

		Texture.moveUV = function (offsetX, offsetY, uv) {
			for (var i = 0; i < 8; i += 2) {
				uv[i] += offsetX;
				uv[i + 1] += offsetY;
			}
			return uv;
		}

		Texture.create = function (source, x, y, width, height, offsetX, offsetY, sourceWidth, sourceHeight) {
			(offsetX === void 0) && (offsetX = 0);
			(offsetY === void 0) && (offsetY = 0);
			(sourceWidth === void 0) && (sourceWidth = 0);
			(sourceHeight === void 0) && (sourceHeight = 0);
			var btex = (source instanceof laya.resource.Texture);
			var uv = btex ? source.uv : Texture.DEF_UV;
			var bitmap = btex ? source.bitmap : source;
			var bIsAtlas = RunDriver.isAtlas(bitmap);
			if (bIsAtlas) {
				var atlaser = bitmap._atlaser;
				var nAtlasID = (source)._atlasID;
				if (nAtlasID == -1) {
					throw new Error("create texture error");
				}
				bitmap = atlaser._inAtlasTextureBitmapValue[nAtlasID];
				uv = atlaser._inAtlasTextureOriUVValue[nAtlasID];
			};
			var tex = new Texture(bitmap, null);
			if (bitmap.width && (x + width) > bitmap.width) width = bitmap.width - x;
			if (bitmap.height && (y + height) > bitmap.height) height = bitmap.height - y;
			tex.width = width;
			tex.height = height;
			tex.offsetX = offsetX;
			tex.offsetY = offsetY;
			tex.sourceWidth = sourceWidth || width;
			tex.sourceHeight = sourceHeight || height;
			var dwidth = 1 / bitmap.width;
			var dheight = 1 / bitmap.height;
			x *= dwidth;
			y *= dheight;
			width *= dwidth;
			height *= dheight;
			var u1 = tex.uv[0], v1 = tex.uv[1], u2 = tex.uv[4], v2 = tex.uv[5];
			var inAltasUVWidth = (u2 - u1), inAltasUVHeight = (v2 - v1);
			var oriUV = Texture.moveUV(uv[0], uv[1], [x, y, x + width, y, x + width, y + height, x, y + height]);
			tex.uv = [u1 + oriUV[0] * inAltasUVWidth, v1 + oriUV[1] * inAltasUVHeight, u2 - (1 - oriUV[2]) * inAltasUVWidth, v1 + oriUV[3] * inAltasUVHeight, u2 - (1 - oriUV[4]) * inAltasUVWidth, v2 - (1 - oriUV[5]) * inAltasUVHeight, u1 + oriUV[6] * inAltasUVWidth, v2 - (1 - oriUV[7]) * inAltasUVHeight];
			if (bIsAtlas) {
				tex.addTextureToAtlas();
			};
			var bitmapScale = bitmap.scaleRate;
			if (bitmapScale && bitmapScale != 1) {
				tex.sourceWidth /= bitmapScale;
				tex.sourceHeight /= bitmapScale;
				tex.width /= bitmapScale;
				tex.height /= bitmapScale;
				tex.scaleRate = bitmapScale;
				tex.offsetX /= bitmapScale;
				tex.offsetY /= bitmapScale;
			} else {
				tex.scaleRate = 1;
			}
			return tex;
		}

		Texture.createFromTexture = function (texture, x, y, width, height) {
			var texScaleRate = texture.scaleRate;
			if (texScaleRate != 1) {
				x *= texScaleRate;
				y *= texScaleRate;
				width *= texScaleRate;
				height *= texScaleRate;
			};
			var rect = Rectangle.TEMP.setTo(x - texture.offsetX, y - texture.offsetY, width, height);
			var result = rect.intersection(Texture._rect1.setTo(0, 0, texture.width, texture.height), Texture._rect2);
			if (result)
				var tex = Texture.create(texture, result.x, result.y, result.width, result.height, result.x - rect.x, result.y - rect.y, width, height);
			else return null;
			tex.bitmap._removeReference();
			return tex;
		}

		Texture.DEF_UV = [0, 0, 1.0, 0, 1.0, 1.0, 0, 1.0];
		Texture.INV_UV = [0, 1, 1.0, 1, 1.0, 0.0, 0, 0.0];
		Texture._rect1 = new Rectangle();
		Texture._rect2 = new Rectangle();
		return Texture;
	})(EventDispatcher)


	/**
	*<code>TimeLine</code> 是一个用来创建时间轴动画的类。
	*/
	//class laya.utils.TimeLine extends laya.events.EventDispatcher
	var TimeLine = (function (_super) {
		var tweenData;
		function TimeLine() {
			this._labelDic = null;
			this._tweenDic = {};
			this._tweenDataList = [];
			this._endTweenDataList = null;
			//以结束时间进行排序
			this._currTime = 0;
			this._lastTime = 0;
			this._startTime = 0;
			/**当前动画数据播放到第几个了*/
			this._index = 0;
			/**为TWEEN创建属于自己的唯一标识，方便管理*/
			this._gidIndex = 0;
			/**保留所有对象第一次注册动画时的状态（根据时间跳转时，需要把对象的回复，再计算接下来的状态）*/
			this._firstTweenDic = {};
			/**是否需要排序*/
			this._startTimeSort = false;
			this._endTimeSort = false;
			/**是否循环*/
			this._loopKey = false;
			/**缩放动画播放的速度。*/
			this.scale = 1;
			this._frameRate = 60;
			this._frameIndex = 0;
			this._total = 0;
			TimeLine.__super.call(this);
		}

		__class(TimeLine, 'laya.utils.TimeLine', _super);
		var __proto = TimeLine.prototype;
		/**
		*控制一个对象，从当前点移动到目标点。
		*@param target 要控制的对象。
		*@param props 要控制对象的属性。
		*@param duration 对象TWEEN的时间。
		*@param ease 缓动类型
		*@param offset 相对于上一个对象，偏移多长时间（单位：毫秒）。
		*/
		__proto.to = function (target, props, duration, ease, offset) {
			(offset === void 0) && (offset = 0);
			return this._create(target, props, duration, ease, offset, true);
		}

		/**
		*从 props 属性，缓动到当前状态。
		*@param target target 目标对象(即将更改属性值的对象)
		*@param props 要控制对象的属性
		*@param duration 对象TWEEN的时间
		*@param ease 缓动类型
		*@param offset 相对于上一个对象，偏移多长时间（单位：毫秒）
		*/
		__proto.from = function (target, props, duration, ease, offset) {
			(offset === void 0) && (offset = 0);
			return this._create(target, props, duration, ease, offset, false);
		}

		/**@private */
		__proto._create = function (target, props, duration, ease, offset, isTo) {
			var tTweenData = Pool.getItemByClass("tweenData", tweenData);
			tTweenData.isTo = isTo;
			tTweenData.type = 0;
			tTweenData.target = target;
			tTweenData.duration = duration;
			tTweenData.data = props;
			tTweenData.startTime = this._startTime + offset;
			tTweenData.endTime = tTweenData.startTime + tTweenData.duration;
			tTweenData.ease = ease;
			this._startTime = Math.max(tTweenData.endTime, this._startTime);
			this._tweenDataList.push(tTweenData);
			this._startTimeSort = true;
			this._endTimeSort = true;
			return this;
		}

		/**
		*在时间队列中加入一个标签。
		*@param label 标签名称。
		*@param offset 标签相对于上个动画的偏移时间(单位：毫秒)。
		*/
		__proto.addLabel = function (label, offset) {
			var tTweenData = Pool.getItemByClass("tweenData", tweenData);
			tTweenData.type = 1;
			tTweenData.data = label;
			tTweenData.endTime = tTweenData.startTime = this._startTime + offset;
			this._labelDic || (this._labelDic = {});
			this._labelDic[label] = tTweenData;
			this._tweenDataList.push(tTweenData);
			return this;
		}

		/**
		*移除指定的标签
		*@param label
		*/
		__proto.removeLabel = function (label) {
			if (this._labelDic && this._labelDic[label]) {
				var tTweenData = this._labelDic[label];
				if (tTweenData) {
					var tIndex = this._tweenDataList.indexOf(tTweenData);
					if (tIndex > -1) {
						this._tweenDataList.splice(tIndex, 1);
					}
				}
				delete this._labelDic[label];
			}
		}

		/**
		*动画从整个动画的某一时间开始。
		*@param time(单位：毫秒)。
		*/
		__proto.gotoTime = function (time) {
			if (this._tweenDataList == null || this._tweenDataList.length == 0) return;
			var tTween;
			var tObject;
			for (var p in this._firstTweenDic) {
				tObject = this._firstTweenDic[p];
				if (tObject) {
					for (var tDataP in tObject) {
						if (tObject.diyTarget.hasOwnProperty(tDataP)) {
							tObject.diyTarget[tDataP] = tObject[tDataP];
						}
					}
				}
			}
			for (p in this._tweenDic) {
				tTween = this._tweenDic[p];
				tTween.clear();
				delete this._tweenDic[p];
			}
			this._index = 0;
			this._gidIndex = 0;
			this._currTime = time;
			this._lastTime = Browser.now();
			var tTweenDataCopyList;
			if (this._endTweenDataList == null || this._endTimeSort) {
				this._endTimeSort = false;
				this._endTweenDataList = tTweenDataCopyList = this._tweenDataList.concat();
				function Compare(paraA, paraB) {
					if (paraA.endTime > paraB.endTime) {
						return 1;
					} else if (paraA.endTime < paraB.endTime) {
						return -1;
					} else {
						return 0;
					}
				}
				tTweenDataCopyList.sort(Compare);
			} else {
				tTweenDataCopyList = this._endTweenDataList
			};
			var tTweenData;
			for (var i = 0, n = tTweenDataCopyList.length; i < n; i++) {
				tTweenData = tTweenDataCopyList[i];
				if (tTweenData.type == 0) {
					if (time >= tTweenData.endTime) {
						this._index = Math.max(this._index, i + 1);
						var props = tTweenData.data;
						if (tTweenData.isTo) {
							for (var tP in props) {
								tTweenData.target[tP] = props[tP];
							}
						}
					} else {
						break;
					}
				}
			}
			for (i = 0, n = this._tweenDataList.length; i < n; i++) {
				tTweenData = this._tweenDataList[i];
				if (tTweenData.type == 0) {
					if (time >= tTweenData.startTime && time < tTweenData.endTime) {
						this._index = Math.max(this._index, i + 1);
						this._gidIndex++;
						tTween = Pool.getItemByClass("tween", Tween);
						tTween._create(tTweenData.target, tTweenData.data, tTweenData.duration, tTweenData.ease, Handler.create(this, this._animComplete, [this._gidIndex]), 0, false, tTweenData.isTo, true, false);
						tTween.setStartTime(this._currTime - (time - tTweenData.startTime));
						tTween._updateEase(this._currTime);
						tTween.gid = this._gidIndex;
						this._tweenDic[this._gidIndex] = tTween;
					}
				}
			}
		}

		/**
		*从指定的标签开始播。
		*@param Label 标签名。
		*/
		__proto.gotoLabel = function (Label) {
			if (this._labelDic == null) return;
			var tLabelData = this._labelDic[Label];
			if (tLabelData) this.gotoTime(tLabelData.startTime);
		}

		/**
		*暂停整个动画。
		*/
		__proto.pause = function () {
			Laya.timer.clear(this, this._update);
		}

		/**
		*恢复暂停动画的播放。
		*/
		__proto.resume = function () {
			this.play(this._currTime, this._loopKey);
		}

		/**
		*播放动画。
		*@param timeOrLabel 开启播放的时间点或标签名。
		*@param loop 是否循环播放。
		*/
		__proto.play = function (timeOrLabel, loop) {
			(timeOrLabel === void 0) && (timeOrLabel = 0);
			(loop === void 0) && (loop = false);
			if (!this._tweenDataList) return;
			if (this._startTimeSort) {
				this._startTimeSort = false;
				function Compare(paraA, paraB) {
					if (paraA.startTime > paraB.startTime) {
						return 1;
					} else if (paraA.startTime < paraB.startTime) {
						return -1;
					} else {
						return 0;
					}
				}
				this._tweenDataList.sort(Compare);
				for (var i = 0, n = this._tweenDataList.length; i < n; i++) {
					var tTweenData = this._tweenDataList[i];
					if (tTweenData != null && tTweenData.type == 0) {
						var tTarget = tTweenData.target;
						var gid = (tTarget.$_GID || (tTarget.$_GID = Utils.getGID()));
						var tSrcData = null;
						if (this._firstTweenDic[gid] == null) {
							tSrcData = {};
							tSrcData.diyTarget = tTarget;
							this._firstTweenDic[gid] = tSrcData;
						} else {
							tSrcData = this._firstTweenDic[gid];
						}
						for (var p in tTweenData.data) {
							if (tSrcData[p] == null) {
								tSrcData[p] = tTarget[p];
							}
						}
					}
				}
			}
			if ((typeof timeOrLabel == 'string')) {
				this.gotoLabel(timeOrLabel);
			} else {
				this.gotoTime(timeOrLabel);
			}
			this._loopKey = loop;
			this._lastTime = Browser.now();
			Laya.timer.frameLoop(1, this, this._update);
		}

		/**
		*更新当前动画。
		*/
		__proto._update = function () {
			if (this._currTime >= this._startTime) {
				if (this._loopKey) {
					this._complete();
					if (!this._tweenDataList) return;
					this.gotoTime(0);
				} else {
					for (var p in this._tweenDic) {
						tTween = this._tweenDic[p];
						tTween.complete();
					}
					this._complete();
					this.pause();
					return;
				}
			};
			var tNow = Browser.now();
			var tFrameTime = tNow - this._lastTime;
			var tCurrTime = this._currTime += tFrameTime * this.scale;
			this._lastTime = tNow;
			for (p in this._tweenDic) {
				tTween = this._tweenDic[p];
				tTween._updateEase(tCurrTime);
			};
			var tTween;
			if (this._tweenDataList.length != 0 && this._index < this._tweenDataList.length) {
				var tTweenData = this._tweenDataList[this._index];
				if (tCurrTime >= tTweenData.startTime) {
					this._index++;
					if (tTweenData.type == 0) {
						this._gidIndex++;
						tTween = Pool.getItemByClass("tween", Tween);
						tTween._create(tTweenData.target, tTweenData.data, tTweenData.duration, tTweenData.ease, Handler.create(this, this._animComplete, [this._gidIndex]), 0, false, tTweenData.isTo, true, false);
						tTween.setStartTime(tCurrTime);
						tTween.gid = this._gidIndex;
						this._tweenDic[this._gidIndex] = tTween;
						tTween._updateEase(tCurrTime);
					} else {
						this.event(/*laya.events.Event.LABEL*/"label", tTweenData.data);
					}
				}
			}
		}

		/**
		*指定的动画索引处的动画播放完成后，把此动画从列表中删除。
		*@param index
		*/
		__proto._animComplete = function (index) {
			var tTween = this._tweenDic[index];
			if (tTween) delete this._tweenDic[index];
		}

		/**@private */
		__proto._complete = function () {
			this.event(/*laya.events.Event.COMPLETE*/"complete");
		}

		/**
		*重置所有对象，复用对象的时候使用。
		*/
		__proto.reset = function () {
			var p;
			if (this._labelDic) {
				for (p in this._labelDic) {
					delete this._labelDic[p];
				}
			};
			var tTween;
			for (p in this._tweenDic) {
				tTween = this._tweenDic[p];
				tTween.clear();
				delete this._tweenDic[p];
			}
			for (p in this._firstTweenDic) {
				delete this._firstTweenDic[p];
			}
			this._endTweenDataList = null;
			if (this._tweenDataList && this._tweenDataList.length) {
				var i = 0, len = 0;
				len = this._tweenDataList.length;
				for (i = 0; i < len; i++) {
					if (this._tweenDataList[i])
						this._tweenDataList[i].destroy();
				}
			}
			this._tweenDataList.length = 0;
			this._currTime = 0;
			this._lastTime = 0;
			this._startTime = 0;
			this._index = 0;
			this._gidIndex = 0;
			this.scale = 1;
			Laya.timer.clear(this, this._update);
		}

		/**
		*彻底销毁此对象。
		*/
		__proto.destroy = function () {
			this.reset();
			this._labelDic = null;
			this._tweenDic = null;
			this._tweenDataList = null;
			this._firstTweenDic = null;
		}

		/**
		*@private
		*设置帧索引
		*/
		/**
		*@private
		*得到帧索引
		*/
		__getset(0, __proto, 'index', function () {
			return this._frameIndex;
		}, function (value) {
			this._frameIndex = value;
			this.gotoTime(this._frameIndex / this._frameRate * 1000);
		});

		/**
		*得到总帧数。
		*/
		__getset(0, __proto, 'total', function () {
			this._total = Math.floor(this._startTime / 1000 * this._frameRate);
			return this._total;
		});

		TimeLine.to = function (target, props, duration, ease, offset) {
			(offset === void 0) && (offset = 0);
			return (new TimeLine()).to(target, props, duration, ease, offset);
		}

		TimeLine.from = function (target, props, duration, ease, offset) {
			(offset === void 0) && (offset = 0);
			return (new TimeLine()).from(target, props, duration, ease, offset);
		}

		TimeLine.__init$ = function () {
			//class tweenData
			tweenData = (function () {
				function tweenData() {
					this.type = 0;
					//0代表TWEEN,1代表标签
					this.isTo = true;
					this.startTime = NaN;
					this.endTime = NaN;
					this.target = null;
					this.duration = NaN;
					this.ease = null;
					this.data = null;
				}
				__class(tweenData, '');
				var __proto = tweenData.prototype;
				__proto.destroy = function () {
					this.target = null;
					this.ease = null;
					this.data = null;
					this.isTo = true;
					this.type = 0;
					Pool.recover("tweenData", this);
				}
				return tweenData;
			})()
		}

		return TimeLine;
	})(EventDispatcher)


	/**
	*<p> <code>Sprite</code> 是基本的显示图形的显示列表节点。 <code>Sprite</code> 默认没有宽高，默认不接受鼠标事件。通过 <code>graphics</code> 可以绘制图片或者矢量图，支持旋转，缩放，位移等操作。<code>Sprite</code>同时也是容器类，可用来添加多个子节点。</p>
	*<p>注意： <code>Sprite</code> 默认没有宽高，可以通过<code>getBounds</code>函数获取；也可手动设置宽高；还可以设置<code>autoSize=true</code>，然后再获取宽高。<code>Sprite</code>的宽高一般用于进行碰撞检测和排版，并不影响显示图像大小，如果需要更改显示图像大小，请使用 <code>scaleX</code> ， <code>scaleY</code> ， <code>scale</code>。</p>
	*<p> <code>Sprite</code> 默认不接受鼠标事件，即<code>mouseEnabled=false</code>，但是只要对其监听任意鼠标事件，会自动打开自己以及所有父对象的<code>mouseEnabled=true</code>。所以一般也无需手动设置<code>mouseEnabled</code>。</p>
	*<p>The3Air引擎API设计精简巧妙。核心显示类只有一个<code>Sprite</code>。<code>Sprite</code>针对不同的情况做了渲染优化，所以保证一个类实现丰富功能的同时，又达到高性能。</p>
	*
	*@example <caption>创建了一个 <code>Sprite</code> 实例。</caption>
	*package
	*{
		*import laya.display.Sprite;
		*import laya.events.Event;
		*
		*public class Sprite_Example
		*{
			*private var sprite:Sprite;
			*private var shape:Sprite
			*public function Sprite_Example()
			*{
				*Laya.init(640,800);//设置游戏画布宽高、渲染模式。
				*Laya.stage.bgColor="#efefef";//设置画布的背景颜色。
				*onInit();
				*}
			*private function onInit():void
			*{
				*sprite=new Sprite();//创建一个 Sprite 类的实例对象 sprite 。
				*sprite.loadImage("resource/ui/bg.png");//加载并显示图片。
				*sprite.x=200;//设置 sprite 对象相对于父容器的水平方向坐标值。
				*sprite.y=200;//设置 sprite 对象相对于父容器的垂直方向坐标值。
				*sprite.pivotX=0;//设置 sprite 对象的水平方法轴心点坐标。
				*sprite.pivotY=0;//设置 sprite 对象的垂直方法轴心点坐标。
				*Laya.stage.addChild(sprite);//将此 sprite 对象添加到显示列表。
				*sprite.on(Event.CLICK,this,onClickSprite);//给 sprite 对象添加点击事件侦听。
				*shape=new Sprite();//创建一个 Sprite 类的实例对象 sprite 。
				*shape.graphics.drawRect(0,0,100,100,"#ccff00","#ff0000",2);//绘制一个有边框的填充矩形。
				*shape.x=400;//设置 shape 对象相对于父容器的水平方向坐标值。
				*shape.y=200;//设置 shape 对象相对于父容器的垂直方向坐标值。
				*shape.width=100;//设置 shape 对象的宽度。
				*shape.height=100;//设置 shape 对象的高度。
				*shape.pivotX=50;//设置 shape 对象的水平方法轴心点坐标。
				*shape.pivotY=50;//设置 shape 对象的垂直方法轴心点坐标。
				*Laya.stage.addChild(shape);//将此 shape 对象添加到显示列表。
				*shape.on(Event.CLICK,this,onClickShape);//给 shape 对象添加点击事件侦听。
				*}
			*private function onClickSprite():void
			*{
				*trace("点击 sprite 对象。");
				*sprite.rotation+=5;//旋转 sprite 对象。
				*}
			*private function onClickShape():void
			*{
				*trace("点击 shape 对象。");
				*shape.rotation+=5;//旋转 shape 对象。
				*}
			*}
		*}
	*
	*@example
	*var sprite;
	*var shape;
	*Sprite_Example();
	*function Sprite_Example()
	*{
		*Laya.init(640,800);//设置游戏画布宽高、渲染模式。
		*Laya.stage.bgColor="#efefef";//设置画布的背景颜色。
		*onInit();
		*}
	*function onInit()
	*{
		*sprite=new laya.display.Sprite();//创建一个 Sprite 类的实例对象 sprite 。
		*sprite.loadImage("resource/ui/bg.png");//加载并显示图片。
		*sprite.x=200;//设置 sprite 对象相对于父容器的水平方向坐标值。
		*sprite.y=200;//设置 sprite 对象相对于父容器的垂直方向坐标值。
		*sprite.pivotX=0;//设置 sprite 对象的水平方法轴心点坐标。
		*sprite.pivotY=0;//设置 sprite 对象的垂直方法轴心点坐标。
		*Laya.stage.addChild(sprite);//将此 sprite 对象添加到显示列表。
		*sprite.on(Event.CLICK,this,onClickSprite);//给 sprite 对象添加点击事件侦听。
		*shape=new laya.display.Sprite();//创建一个 Sprite 类的实例对象 sprite 。
		*shape.graphics.drawRect(0,0,100,100,"#ccff00","#ff0000",2);//绘制一个有边框的填充矩形。
		*shape.x=400;//设置 shape 对象相对于父容器的水平方向坐标值。
		*shape.y=200;//设置 shape 对象相对于父容器的垂直方向坐标值。
		*shape.width=100;//设置 shape 对象的宽度。
		*shape.height=100;//设置 shape 对象的高度。
		*shape.pivotX=50;//设置 shape 对象的水平方法轴心点坐标。
		*shape.pivotY=50;//设置 shape 对象的垂直方法轴心点坐标。
		*Laya.stage.addChild(shape);//将此 shape 对象添加到显示列表。
		*shape.on(laya.events.Event.CLICK,this,onClickShape);//给 shape 对象添加点击事件侦听。
		*}
	*function onClickSprite()
	*{
		*console.log("点击 sprite 对象。");
		*sprite.rotation+=5;//旋转 sprite 对象。
		*}
	*function onClickShape()
	*{
		*console.log("点击 shape 对象。");
		*shape.rotation+=5;//旋转 shape 对象。
		*}
	*
	*@example
	*import Sprite=laya.display.Sprite;
	*class Sprite_Example {
		*private sprite:Sprite;
		*private shape:Sprite
		*public Sprite_Example(){
			*Laya.init(640,800);//设置游戏画布宽高、渲染模式。
			*Laya.stage.bgColor="#efefef";//设置画布的背景颜色。
			*this.onInit();
			*}
		*private onInit():void {
			*this.sprite=new Sprite();//创建一个 Sprite 类的实例对象 sprite 。
			*this.sprite.loadImage("resource/ui/bg.png");//加载并显示图片。
			*this.sprite.x=200;//设置 sprite 对象相对于父容器的水平方向坐标值。
			*this.sprite.y=200;//设置 sprite 对象相对于父容器的垂直方向坐标值。
			*this.sprite.pivotX=0;//设置 sprite 对象的水平方法轴心点坐标。
			*this.sprite.pivotY=0;//设置 sprite 对象的垂直方法轴心点坐标。
			*Laya.stage.addChild(this.sprite);//将此 sprite 对象添加到显示列表。
			*this.sprite.on(laya.events.Event.CLICK,this,this.onClickSprite);//给 sprite 对象添加点击事件侦听。
			*this.shape=new Sprite();//创建一个 Sprite 类的实例对象 sprite 。
			*this.shape.graphics.drawRect(0,0,100,100,"#ccff00","#ff0000",2);//绘制一个有边框的填充矩形。
			*this.shape.x=400;//设置 shape 对象相对于父容器的水平方向坐标值。
			*this.shape.y=200;//设置 shape 对象相对于父容器的垂直方向坐标值。
			*this.shape.width=100;//设置 shape 对象的宽度。
			*this.shape.height=100;//设置 shape 对象的高度。
			*this.shape.pivotX=50;//设置 shape 对象的水平方法轴心点坐标。
			*this.shape.pivotY=50;//设置 shape 对象的垂直方法轴心点坐标。
			*Laya.stage.addChild(this.shape);//将此 shape 对象添加到显示列表。
			*this.shape.on(laya.events.Event.CLICK,this,this.onClickShape);//给 shape 对象添加点击事件侦听。
			*}
		*private onClickSprite():void {
			*console.log("点击 sprite 对象。");
			*this.sprite.rotation+=5;//旋转 sprite 对象。
			*}
		*private onClickShape():void {
			*console.log("点击 shape 对象。");
			*this.shape.rotation+=5;//旋转 shape 对象。
			*}
		*}
	*/
	//class laya.display.Sprite extends laya.display.Node
	var Sprite = (function (_super) {
		function Sprite() {
			/**@private 矩阵变换信息。*/
			this._transform = null;
			/**@private */
			this._tfChanged = false;
			/**@private */
			this._x = 0;
			/**@private */
			this._y = 0;
			/**@private */
			this._width = 0;
			/**@private */
			this._height = 0;
			/**@private */
			this._repaint = 1;
			/**@private 鼠标状态，0:auto,1:mouseEnabled=false,2:mouseEnabled=true。*/
			this._mouseEnableState = 0;
			/**@private Z排序，数值越大越靠前。*/
			this._zOrder = 0;
			/**@private */
			this._graphics = null;
			/**@private */
			this._renderType = 0;
			/**@private */
			this._optimizeScrollRect = false;
			/**@private */
			this._texture = null;
			/**
			*<p>鼠标事件与此对象的碰撞检测是否可穿透。碰撞检测发生在鼠标事件的捕获阶段，此阶段引擎会从stage开始递归检测stage及其子对象，直到找到命中的目标对象或者未命中任何对象。</p>
			*<p>穿透表示鼠标事件发生的位置处于本对象绘图区域内时，才算命中，而与对象宽高和值为Rectangle对象的hitArea属性无关。如果sprite.hitArea值是HitArea对象，表示显式声明了此对象的鼠标事件响应区域，而忽略对象的宽高、mouseThrough属性。</p>
			*<p>影响对象鼠标事件响应区域的属性为：width、height、hitArea，优先级顺序为：hitArea(type:HitArea)>hitArea(type:Rectangle)>width/height。</p>
			*@default false 不可穿透，此对象的鼠标响应区域由width、height、hitArea属性决定。</p>
			*/
			this.mouseThrough = false;
			/**
			*<p>指定是否自动计算宽高数据。默认值为 false 。</p>
			*<p>Sprite宽高默认为0，并且不会随着绘制内容的变化而变化，如果想根据绘制内容获取宽高，可以设置本属性为true，或者通过getBounds方法获取。设置为true，对性能有一定影响。</p>
			*/
			this.autoSize = false;
			/**
			*<p>指定鼠标事件检测是优先检测自身，还是优先检测其子对象。鼠标事件检测发生在鼠标事件的捕获阶段，此阶段引擎会从stage开始递归检测stage及其子对象，直到找到命中的目标对象或者未命中任何对象。</p>
			*<p>如果为false，优先检测子对象，当有子对象被命中时，中断检测，获得命中目标。如果未命中任何子对象，最后再检测此对象；如果为true，则优先检测本对象，如果本对象没有被命中，直接中断检测，表示没有命中目标；如果本对象被命中，则进一步递归检测其子对象，以确认最终的命中目标。</p>
			*<p>合理使用本属性，能减少鼠标事件检测的节点，提高性能。可以设置为true的情况：开发者并不关心此节点的子节点的鼠标事件检测结果，也就是以此节点作为其子节点的鼠标事件检测依据。</p>
			*<p>Stage对象和UI的View组件默认为true。</p>
			*@default false 优先检测此对象的子对象，当递归检测完所有子对象后，仍然没有找到目标对象，最后再检测此对象。
			*/
			this.hitTestPrior = false;
			/**
			*<p>视口大小，视口外的子对象，将不被渲染(如果想实现裁剪效果，请使用srollRect)，合理使用能提高渲染性能。比如由一个个小图片拼成的地图块，viewport外面的小图片将不渲染</p>
			*<p>srollRect和viewport的区别：<br/>
			*1. srollRect自带裁剪效果，viewport只影响子对象渲染是否渲染，不具有裁剪效果（性能更高）。<br/>
			*2. 设置rect的x,y属性均能实现区域滚动效果，但scrollRect会保持0,0点位置不变。</p>
			*@default null
			*/
			this.viewport = null;
			Sprite.__super.call(this);
			this._style = Style.EMPTY;
		}

		__class(Sprite, 'laya.display.Sprite', _super);
		var __proto = Sprite.prototype;
		Laya.imps(__proto, { "laya.display.ILayout": true })
		/**@private */
		__proto.createConchModel = function () {
			return /*__JS__ */new ConchNode();
		}

		/**@inheritDoc */
		__proto.destroy = function (destroyChild) {
			(destroyChild === void 0) && (destroyChild = true);
			this._releaseMem();
			_super.prototype.destroy.call(this, destroyChild);
			this._style && this._style.destroy();
			this._transform && this._transform.destroy();
			this._transform = null;
			this._style = null;
			this._graphics = null;
		}

		/**根据zOrder进行重新排序。*/
		__proto.updateZOrder = function () {
			Utils.updateOrder(this._childs) && this.repaint();
		}

		/**在设置cacheAs的情况下，调用此方法会重新刷新缓存。*/
		__proto.reCache = function () {
			if (this._$P.cacheCanvas) this._$P.cacheCanvas.reCache = true;
			this._repaint = 1;
		}

		/**
		*<p>设置对象在自身坐标系下的边界范围。与 <code>getSelfBounds</code> 对应。当 autoSize==true 时，会影响对象宽高。设置后，当需要获取自身边界范围时，就不再需要计算，合理使用能提高性能。比如 <code>getBounds</code> 会优先使用 <code>setBounds</code> 指定的值，如果没有指定则进行计算，此计算会对性能消耗比较大。</p>
		*<p><b>注意：</b> <code>setBounds</code> 与 <code>getBounds</code> 并非对应相等关系， <code>getBounds</code> 获取的是本对象在父容器坐标系下的边界范围，通过设置 <code>setBounds</code> 会影响 <code>getBounds</code> 的结果。</p>
		*@param bound bounds矩形区域
		*/
		__proto.setBounds = function (bound) {
			this._set$P("uBounds", bound);
		}

		/**
		*<p>获取本对象在父容器坐标系的矩形显示区域。</p>
		*<p><b>注意：</b> 1.计算量较大，尽量少用，如果需要频繁使用，可以通过手动设置 <code>setBounds</code> 来缓存自身边界信息，从而避免比较消耗性能的计算。2. <code>setBounds</code> 与 <code>getBounds</code> 并非对应相等关系， <code>getBounds</code> 获取的是本对象在父容器坐标系下的边界范围，通过设置 <code>setBounds</code> 会影响 <code>getBounds</code> 的结果。</p>
		*@return 矩形区域。
		*/
		__proto.getBounds = function () {
			if (!this._$P.mBounds) this._set$P("mBounds", new Rectangle());
			return Rectangle._getWrapRec(this._boundPointsToParent(), this._$P.mBounds);
		}

		/**
		*获取对象在自身坐标系的边界范围。与 <code>setBounds</code> 对应。
		*<p><b>注意：</b>计算量较大，尽量少用，如果需要频繁使用，可以提前手动设置 <code>setBounds</code> 来缓存自身边界信息，从而避免比较消耗性能的计算。</p>
		*@return 矩形区域。
		*/
		__proto.getSelfBounds = function () {
			if (this._$P.uBounds) return this._$P.uBounds;
			if (!this._$P.mBounds) this._set$P("mBounds", new Rectangle());
			return Rectangle._getWrapRec(this._getBoundPointsM(false), this._$P.mBounds);
		}

		/**
		*@private
		*获取本对象在父容器坐标系的显示区域多边形顶点列表。
		*当显示对象链中有旋转时，返回多边形顶点列表，无旋转时返回矩形的四个顶点。
		*@param ifRotate （可选）之前的对象链中是否有旋转。
		*@return 顶点列表。结构：[x1,y1,x2,y2,x3,y3,...]。
		*/
		__proto._boundPointsToParent = function (ifRotate) {
			(ifRotate === void 0) && (ifRotate = false);
			var pX = 0, pY = 0;
			if (this._style) {
				pX = this._style._tf.translateX;
				pY = this._style._tf.translateY;
				ifRotate = ifRotate || (this._style._tf.rotate !== 0);
				if (this._style.scrollRect) {
					pX += this._style.scrollRect.x;
					pY += this._style.scrollRect.y;
				}
			};
			var pList = this._getBoundPointsM(ifRotate);
			if (!pList || pList.length < 1) return pList;
			if (pList.length != 8) {
				pList = ifRotate ? GrahamScan.scanPList(pList) : Rectangle._getWrapRec(pList, Rectangle.TEMP)._getBoundPoints();
			}
			if (!this.transform) {
				Utils.transPointList(pList, this._x - pX, this._y - pY);
				return pList;
			};
			var tPoint = Point.TEMP;
			var i = 0, len = pList.length;
			for (i = 0; i < len; i += 2) {
				tPoint.x = pList[i];
				tPoint.y = pList[i + 1];
				this.toParentPoint(tPoint);
				pList[i] = tPoint.x;
				pList[i + 1] = tPoint.y;
			}
			return pList;
		}

		/**
		*返回此实例中的绘图对象（ <code>Graphics</code> ）的显示区域，不包括子对象。
		*@param realSize （可选）使用图片的真实大小，默认为false
		*@return 一个 Rectangle 对象，表示获取到的显示区域。
		*/
		__proto.getGraphicBounds = function (realSize) {
			(realSize === void 0) && (realSize = false);
			if (!this._graphics) return Rectangle.TEMP.setTo(0, 0, 0, 0);
			return this._graphics.getBounds(realSize);
		}

		/**
		*@private
		*获取自己坐标系的显示区域多边形顶点列表
		*@param ifRotate （可选）当前的显示对象链是否由旋转
		*@return 顶点列表。结构：[x1,y1,x2,y2,x3,y3,...]。
		*/
		__proto._getBoundPointsM = function (ifRotate) {
			(ifRotate === void 0) && (ifRotate = false);
			if (this._$P.uBounds) return this._$P.uBounds._getBoundPoints();
			if (!this._$P.temBM) this._set$P("temBM", []);
			if (this.scrollRect) {
				var rst = Utils.clearArray(this._$P.temBM);
				var rec = Rectangle.TEMP;
				rec.copyFrom(this.scrollRect);
				Utils.concatArray(rst, rec._getBoundPoints());
				return rst;
			};
			var pList = this._graphics ? this._graphics.getBoundPoints() : Utils.clearArray(this._$P.temBM);
			var child;
			var cList;
			var __childs;
			__childs = this._childs;
			for (var i = 0, n = __childs.length; i < n; i++) {
				child = __childs[i];
				if ((child instanceof laya.display.Sprite) && child.visible == true) {
					cList = child._boundPointsToParent(ifRotate);
					if (cList)
						pList = pList ? Utils.concatArray(pList, cList) : cList;
				}
			}
			return pList;
		}

		/**
		*@private
		*获取样式。
		*@return 样式 Style 。
		*/
		__proto.getStyle = function () {
			this._style === Style.EMPTY && (this._style = new Style());
			return this._style;
		}

		/**
		*@private
		*设置样式。
		*@param value 样式。
		*/
		__proto.setStyle = function (value) {
			this._style = value;
		}

		/**@private */
		__proto._adjustTransform = function () {
			'use strict';
			this._tfChanged = false;
			var style = this._style;
			var tf = style._tf;
			var sx = tf.scaleX, sy = tf.scaleY;
			var m;
			if (tf.rotate || sx !== 1 || sy !== 1 || tf.skewX || tf.skewY) {
				m = this._transform || (this._transform = Matrix.create());
				m.bTransform = true;
				var skx = (tf.rotate - tf.skewX) * 0.0174532922222222;
				var sky = (tf.rotate + tf.skewY) * 0.0174532922222222;
				var cx = Math.cos(sky);
				var ssx = Math.sin(sky);
				var cy = Math.sin(skx);
				var ssy = Math.cos(skx);
				m.a = sx * cx;
				m.b = sx * ssx;
				m.c = -sy * cy;
				m.d = sy * ssy;
				m.tx = m.ty = 0;
				return m;
			} else {
				this._transform && this._transform.destroy();
				this._transform = null;
				this._renderType &= ~ /*laya.renders.RenderSprite.TRANSFORM*/0x04;
			}
			return m;
		}

		/**
		*<p>设置坐标位置。相当于分别设置x和y属性。</p>
		*<p>因为返回值为Sprite对象本身，所以可以使用如下语法：spr.pos(...).scale(...);</p>
		*@param x X轴坐标。
		*@param y Y轴坐标。
		*@param speedMode （可选）是否极速模式，正常是调用this.x=value进行赋值，极速模式直接调用内部函数处理，如果未重写x,y属性，建议设置为急速模式性能更高。
		*@return 返回对象本身。
		*/
		__proto.pos = function (x, y, speedMode) {
			(speedMode === void 0) && (speedMode = false);
			if (this._x !== x || this._y !== y) {
				if (this.destroyed) return this;
				if (speedMode) {
					this._x = x;
					this._y = y;
					this.conchModel && this.conchModel.pos(this._x, this._y);
					var p = this._parent;
					if (p && p._repaint === 0) {
						p._repaint = 1;
						p.parentRepaint();
					}
					if (this._$P.maskParent && this._$P.maskParent._repaint === 0) {
						this._$P.maskParent._repaint = 1;
						this._$P.maskParent.parentRepaint();
					}
				} else {
					this.x = x;
					this.y = y;
				}
			}
			return this;
		}

		/**
		*<p>设置轴心点。相当于分别设置pivotX和pivotY属性。</p>
		*<p>因为返回值为Sprite对象本身，所以可以使用如下语法：spr.pivot(...).pos(...);</p>
		*@param x X轴心点。
		*@param y Y轴心点。
		*@return 返回对象本身。
		*/
		__proto.pivot = function (x, y) {
			this.pivotX = x;
			this.pivotY = y;
			return this;
		}

		/**
		*<p>设置宽高。相当于分别设置width和height属性。</p>
		*<p>因为返回值为Sprite对象本身，所以可以使用如下语法：spr.size(...).pos(...);</p>
		*@param width 宽度值。
		*@param hegiht 高度值。
		*@return 返回对象本身。
		*/
		__proto.size = function (width, height) {
			this.width = width;
			this.height = height;
			return this;
		}

		/**
		*<p>设置缩放。相当于分别设置scaleX和scaleY属性。</p>
		*<p>因为返回值为Sprite对象本身，所以可以使用如下语法：spr.scale(...).pos(...);</p>
		*@param scaleX X轴缩放比例。
		*@param scaleY Y轴缩放比例。
		*@param speedMode （可选）是否极速模式，正常是调用this.scaleX=value进行赋值，极速模式直接调用内部函数处理，如果未重写scaleX,scaleY属性，建议设置为急速模式性能更高。
		*@return 返回对象本身。
		*/
		__proto.scale = function (scaleX, scaleY, speedMode) {
			(speedMode === void 0) && (speedMode = false);
			var style = this.getStyle();
			var _tf = style._tf;
			if (_tf.scaleX != scaleX || _tf.scaleY != scaleY) {
				if (this.destroyed) return this;
				if (speedMode) {
					style.setScale(scaleX, scaleY);
					this._tfChanged = true;
					this.conchModel && this.conchModel.scale(scaleX, scaleY);
					this._renderType |=/*laya.renders.RenderSprite.TRANSFORM*/0x04;
					var p = this._parent;
					if (p && p._repaint === 0) {
						p._repaint = 1;
						p.parentRepaint();
					}
				} else {
					this.scaleX = scaleX;
					this.scaleY = scaleY;
				}
			}
			return this;
		}

		/**
		*<p>设置倾斜角度。相当于分别设置skewX和skewY属性。</p>
		*<p>因为返回值为Sprite对象本身，所以可以使用如下语法：spr.skew(...).pos(...);</p>
		*@param skewX 水平倾斜角度。
		*@param skewY 垂直倾斜角度。
		*@return 返回对象本身
		*/
		__proto.skew = function (skewX, skewY) {
			this.skewX = skewX;
			this.skewY = skewY;
			return this;
		}

		/**
		*更新、呈现显示对象。由系统调用。
		*@param context 渲染的上下文引用。
		*@param x X轴坐标。
		*@param y Y轴坐标。
		*/
		__proto.render = function (context, x, y) {
			Stat.spriteCount++;
			RenderSprite.renders[this._renderType]._fun(this, context, x + this._x, y + this._y);
			this._repaint = 0;
		}

		/**
		*<p>绘制 当前<code>Sprite</code> 到 <code>Canvas</code> 上，并返回一个HtmlCanvas。</p>
		*<p>绘制的结果可以当作图片源，再次绘制到其他Sprite里面，示例：</p>
		*
		*var htmlCanvas:HTMLCanvas=sprite.drawToCanvas(100,100,0,0);//把精灵绘制到canvas上面
		*var texture:Texture=new Texture(htmlCanvas);//使用htmlCanvas创建Texture
		*var sp:Sprite=new Sprite().pos(0,200);//创建精灵并把它放倒200位置
		*sp.graphics.drawTexture(texture);//把截图绘制到精灵上
		*Laya.stage.addChild(sp);//把精灵显示到舞台
		*
		*<p>也可以获取原始图片数据，分享到网上，从而实现截图效果，示例：</p>
		*
		*var htmlCanvas:HTMLCanvas=sprite.drawToCanvas(100,100,0,0);//把精灵绘制到canvas上面
		*
		*htmlCanvas.toBase64("image/png",0.92,function(base64){//webgl和canvas模式下为同步方法，加速器下是异步方法
			*trace(base64);//打印图片base64信息，可以发给服务器或者保存为图片
			*});
		*
		*@param canvasWidth 画布宽度。
		*@param canvasHeight 画布高度。
		*@param x 绘制的 X 轴偏移量。
		*@param y 绘制的 Y 轴偏移量。
		*@return HTMLCanvas 对象。
		*/
		__proto.drawToCanvas = function (canvasWidth, canvasHeight, offsetX, offsetY) {
			if (Render.isConchNode) {
				var canvas = HTMLCanvas.create("2D");
				var context = new RenderContext(canvasWidth, canvasHeight, canvas);
				context.ctx.setCanvasType(1);
				this.conchModel.drawToCanvas(canvas.source, offsetX, offsetY);
				return canvas;
			} else {
				return RunDriver.drawToCanvas(this, this._renderType, canvasWidth, canvasHeight, offsetX, offsetY);
			}
		}

		/**
		*<p>自定义更新、呈现显示对象。一般用来扩展渲染模式，请合理使用，可能会导致在加速器上无法渲染。</p>
		*<p><b>注意</b>不要在此函数内增加或删除树节点，否则会对树节点遍历造成影响。</p>
		*@param context 渲染的上下文引用。
		*@param x X轴坐标。
		*@param y Y轴坐标。
		*/
		__proto.customRender = function (context, x, y) {
			this._renderType |=/*laya.renders.RenderSprite.CUSTOM*/0x400;
		}

		/**
		*@private
		*应用滤镜。
		*/
		__proto._applyFilters = function () {
			if (Render.isWebGL) return;
			var _filters;
			_filters = this._$P.filters;
			if (!_filters || _filters.length < 1) return;
			for (var i = 0, n = _filters.length; i < n; i++) {
				_filters[i].action.apply(this._$P.cacheCanvas);
			}
		}

		/**
		*@private
		*查看当前原件中是否包含发光滤镜。
		*@return 一个 Boolean 值，表示当前原件中是否包含发光滤镜。
		*/
		__proto._isHaveGlowFilter = function () {
			var i = 0, len = 0;
			if (this.filters) {
				for (i = 0; i < this.filters.length; i++) {
					if (this.filters[i].type ==/*laya.filters.Filter.GLOW*/0x08) {
						return true;
					}
				}
			}
			for (i = 0, len = this._childs.length; i < len; i++) {
				if (this._childs[i]._isHaveGlowFilter()) {
					return true;
				}
			}
			return false;
		}

		/**
		*把本地坐标转换为相对stage的全局坐标。
		*@param point 本地坐标点。
		*@param createNewPoint （可选）是否创建一个新的Point对象作为返回值，默认为false，使用输入的point对象返回，减少对象创建开销。
		*@return 转换后的坐标的点。
		*/
		__proto.localToGlobal = function (point, createNewPoint) {
			(createNewPoint === void 0) && (createNewPoint = true);
			if (createNewPoint === true) {
				point = new Point(point.x, point.y);
			};
			var ele = this;
			while (ele) {
				if (ele == Laya.stage) break;
				point = ele.toParentPoint(point);
				ele = ele.parent;
			}
			return point;
		}

		/**
		*把stage的全局坐标转换为本地坐标。
		*@param point 全局坐标点。
		*@param createNewPoint （可选）是否创建一个新的Point对象作为返回值，默认为false，使用输入的point对象返回，减少对象创建开销。
		*@return 转换后的坐标的点。
		*/
		__proto.globalToLocal = function (point, createNewPoint) {
			(createNewPoint === void 0) && (createNewPoint = false);
			if (createNewPoint) {
				point = new Point(point.x, point.y);
			};
			var ele = this;
			var list = [];
			while (ele) {
				if (ele == Laya.stage) break;
				list.push(ele);
				ele = ele.parent;
			};
			var i = list.length - 1;
			while (i >= 0) {
				ele = list[i];
				point = ele.fromParentPoint(point);
				i--;
			}
			return point;
		}

		/**
		*将本地坐标系坐标转转换到父容器坐标系。
		*@param point 本地坐标点。
		*@return 转换后的点。
		*/
		__proto.toParentPoint = function (point) {
			if (!point) return point;
			point.x -= this.pivotX;
			point.y -= this.pivotY;
			if (this.transform) {
				this._transform.transformPoint(point);
			}
			point.x += this._x;
			point.y += this._y;
			var scroll = this._style.scrollRect;
			if (scroll) {
				point.x -= scroll.x;
				point.y -= scroll.y;
			}
			return point;
		}

		/**
		*将父容器坐标系坐标转换到本地坐标系。
		*@param point 父容器坐标点。
		*@return 转换后的点。
		*/
		__proto.fromParentPoint = function (point) {
			if (!point) return point;
			point.x -= this._x;
			point.y -= this._y;
			var scroll = this._style.scrollRect;
			if (scroll) {
				point.x += scroll.x;
				point.y += scroll.y;
			}
			if (this.transform) {
				this._transform.invertTransformPoint(point);
			}
			point.x += this.pivotX;
			point.y += this.pivotY;
			return point;
		}

		/**
		*<p>增加事件侦听器，以使侦听器能够接收事件通知。</p>
		*<p>如果侦听鼠标事件，则会自动设置自己和父亲节点的属性 mouseEnabled 的值为 true(如果父节点mouseEnabled=false，则停止设置父节点mouseEnabled属性)。</p>
		*@param type 事件的类型。
		*@param caller 事件侦听函数的执行域。
		*@param listener 事件侦听函数。
		*@param args （可选）事件侦听函数的回调参数。
		*@return 此 EventDispatcher 对象。
		*/
		__proto.on = function (type, caller, listener, args) {
			if (this._mouseEnableState !== 1 && this.isMouseEvent(type)) {
				this.mouseEnabled = true;
				this._setBit(/*laya.display.Node.MOUSEENABLE*/0x2, true);
				if (this._parent) {
					this._$2__onDisplay();
				}
				return this._createListener(type, caller, listener, args, false);
			}
			return _super.prototype.on.call(this, type, caller, listener, args);
		}

		/**
		*<p>增加事件侦听器，以使侦听器能够接收事件通知，此侦听事件响应一次后则自动移除侦听。</p>
		*<p>如果侦听鼠标事件，则会自动设置自己和父亲节点的属性 mouseEnabled 的值为 true(如果父节点mouseEnabled=false，则停止设置父节点mouseEnabled属性)。</p>
		*@param type 事件的类型。
		*@param caller 事件侦听函数的执行域。
		*@param listener 事件侦听函数。
		*@param args （可选）事件侦听函数的回调参数。
		*@return 此 EventDispatcher 对象。
		*/
		__proto.once = function (type, caller, listener, args) {
			if (this._mouseEnableState !== 1 && this.isMouseEvent(type)) {
				this.mouseEnabled = true;
				this._setBit(/*laya.display.Node.MOUSEENABLE*/0x2, true);
				if (this._parent) {
					this._$2__onDisplay();
				}
				return this._createListener(type, caller, listener, args, true);
			}
			return _super.prototype.once.call(this, type, caller, listener, args);
		}

		/**@private */
		__proto._$2__onDisplay = function () {
			if (this._mouseEnableState !== 1) {
				var ele = this;
				ele = ele.parent;
				while (ele && ele._mouseEnableState !== 1) {
					if (ele._getBit(/*laya.display.Node.MOUSEENABLE*/0x2)) break;
					ele.mouseEnabled = true;
					ele._setBit(/*laya.display.Node.MOUSEENABLE*/0x2, true);
					ele = ele.parent;
				}
			}
		}

		/**
		*<p>加载并显示一个图片。功能等同于graphics.loadImage方法。支持异步加载。</p>
		*<p>注意：多次调用loadImage绘制不同的图片，会同时显示。</p>
		*@param url 图片地址。
		*@param x （可选）显示图片的x位置。
		*@param y （可选）显示图片的y位置。
		*@param width （可选）显示图片的宽度，设置为0表示使用图片默认宽度。
		*@param height （可选）显示图片的高度，设置为0表示使用图片默认高度。
		*@param complete （可选）加载完成回调。
		*@return 返回精灵对象本身。
		*/
		__proto.loadImage = function (url, x, y, width, height, complete) {
			var _$this = this;
			(x === void 0) && (x = 0);
			(y === void 0) && (y = 0);
			(width === void 0) && (width = 0);
			(height === void 0) && (height = 0);
			function loaded(tex) {
				if (!_$this.destroyed) {
					_$this.size(x + (width || tex.width), y + (height || tex.height));
					_$this.repaint();
					complete && complete.runWith(tex);
				}
			}
			this.graphics.loadImage(url, x, y, width, height, loaded);
			return this;
		}

		/**cacheAs后，设置自己和父对象缓存失效。*/
		__proto.repaint = function () {
			this.conchModel && this.conchModel.repaint && this.conchModel.repaint();
			if (this._repaint === 0) {
				this._repaint = 1;
				this.parentRepaint();
			}
			if (this._$P && this._$P.maskParent) {
				this._$P.maskParent.repaint();
			}
		}

		/**
		*@private
		*获取是否重新缓存。
		*@return 如果重新缓存值为 true，否则值为 false。
		*/
		__proto._needRepaint = function () {
			return (this._repaint !== 0) && this._$P.cacheCanvas && this._$P.cacheCanvas.reCache;
		}

		/**@private */
		__proto._childChanged = function (child) {
			if (this._childs.length) this._renderType |=/*laya.renders.RenderSprite.CHILDS*/0x800;
			else this._renderType &= ~ /*laya.renders.RenderSprite.CHILDS*/0x800;
			if (child && this._get$P("hasZorder")) Laya.timer.callLater(this, this.updateZOrder);
			this.repaint();
		}

		/**cacheAs时，设置所有父对象缓存失效。 */
		__proto.parentRepaint = function () {
			var p = this._parent;
			if (p && p._repaint === 0) {
				p._repaint = 1;
				p.parentRepaint();
			}
		}

		/**
		*开始拖动此对象。
		*@param area （可选）拖动区域，此区域为当前对象注册点活动区域（不包括对象宽高），可选。
		*@param hasInertia （可选）鼠标松开后，是否还惯性滑动，默认为false，可选。
		*@param elasticDistance （可选）橡皮筋效果的距离值，0为无橡皮筋效果，默认为0，可选。
		*@param elasticBackTime （可选）橡皮筋回弹时间，单位为毫秒，默认为300毫秒，可选。
		*@param data （可选）拖动事件携带的数据，可选。
		*@param disableMouseEvent （可选）禁用其他对象的鼠标检测，默认为false，设置为true能提高性能。
		*@param ratio （可选）惯性阻尼系数，影响惯性力度和时长。
		*/
		__proto.startDrag = function (area, hasInertia, elasticDistance, elasticBackTime, data, disableMouseEvent, ratio) {
			(hasInertia === void 0) && (hasInertia = false);
			(elasticDistance === void 0) && (elasticDistance = 0);
			(elasticBackTime === void 0) && (elasticBackTime = 300);
			(disableMouseEvent === void 0) && (disableMouseEvent = false);
			(ratio === void 0) && (ratio = 0.92);
			this._$P.dragging || (this._set$P("dragging", new Dragging()));
			this._$P.dragging.start(this, area, hasInertia, elasticDistance, elasticBackTime, data, disableMouseEvent, ratio);
		}

		/**停止拖动此对象。*/
		__proto.stopDrag = function () {
			this._$P.dragging && this._$P.dragging.stop();
		}

		__proto._releaseMem = function () {
			if (!this._$P) return;
			var cc = this._$P.cacheCanvas;
			if (cc && cc.ctx) {
				Pool.recover("RenderContext", cc.ctx);
				cc.ctx.canvas.size(0, 0);
				cc.ctx = null;
			};
			var fc = this._$P._filterCache;
			if (fc) {
				fc.destroy();
				fc.recycle();
				this._set$P('_filterCache', null);
			}
			this._$P._isHaveGlowFilter && this._set$P('_isHaveGlowFilter', false);
			this._$P._isHaveGlowFilter = null;
		}

		/**@private */
		__proto._setDisplay = function (value) {
			if (!value) this._releaseMem();
			_super.prototype._setDisplay.call(this, value);
		}

		/**
		*检测某个点是否在此对象内。
		*@param x 全局x坐标。
		*@param y 全局y坐标。
		*@return 表示是否在对象内。
		*/
		__proto.hitTestPoint = function (x, y) {
			var point = this.globalToLocal(Point.TEMP.setTo(x, y));
			x = point.x;
			y = point.y;
			var rect = this._$P.hitArea ? this._$P.hitArea : (this._width > 0 && this._height > 0) ? Rectangle.TEMP.setTo(0, 0, this._width, this._height) : this.getSelfBounds();
			return rect.contains(x, y);
		}

		/**获得相对于本对象上的鼠标坐标信息。*/
		__proto.getMousePoint = function () {
			return this.globalToLocal(Point.TEMP.setTo(Laya.stage.mouseX, Laya.stage.mouseY));
		}

		/**@private */
		__proto._getWords = function () {
			return null;
		}

		/**@private */
		__proto._addChildsToLayout = function (out) {
			var words = this._getWords();
			if (words == null && this._childs.length == 0) return false;
			if (words) {
				for (var i = 0, n = words.length; i < n; i++) {
					out.push(words[i]);
				}
			}
			this._childs.forEach(function (o, index, array) {
				o._style._enableLayout() && o._addToLayout(out);
			});
			return true;
		}

		/**@private */
		__proto._addToLayout = function (out) {
			if (this._style.absolute) return;
			this._style.block ? out.push(this) : (this._addChildsToLayout(out) && (this.x = this.y = 0));
		}

		/**@private */
		__proto._isChar = function () {
			return false;
		}

		/**@private */
		__proto._getCSSStyle = function () {
			return this._style.getCSSStyle();
		}

		/**
		*@private
		*设置指定属性名的属性值。
		*@param name 属性名。
		*@param value 属性值。
		*/
		__proto._setAttributes = function (name, value) {
			switch (name) {
				case 'x':
					this.x = parseFloat(value);
					break;
				case 'y':
					this.y = parseFloat(value);
					break;
				case 'width':
					this.width = parseFloat(value);
					break;
				case 'height':
					this.height = parseFloat(value);
					break;
				default:
					this[name] = value;
			}
		}

		/**
		*@private
		*/
		__proto._layoutLater = function () {
			this.parent && (this.parent)._layoutLater();
		}

		/**
		*<p>指定是否对使用了 scrollRect 的显示对象进行优化处理。默认为false(不优化)。</p>
		*<p>当值为ture时：将对此对象使用了scrollRect 设定的显示区域以外的显示内容不进行渲染，以提高性能(如果子对象有旋转缩放或者中心点偏移，则显示筛选会不精确)。</p>
		*/
		__getset(0, __proto, 'optimizeScrollRect', function () {
			return this._optimizeScrollRect;
		}, function (b) {
			if (this._optimizeScrollRect != b) {
				this._optimizeScrollRect = b;
				this.conchModel && this.conchModel.optimizeScrollRect(b);
			}
		});

		/**
		*设置是否开启自定义渲染，只有开启自定义渲染，才能使用customRender函数渲染。
		*/
		__getset(0, __proto, 'customRenderEnable', null, function (b) {
			if (b) {
				this._renderType |=/*laya.renders.RenderSprite.CUSTOM*/0x400;
				if (Render.isConchNode) {
					Sprite.CustomList.push(this);
					var canvas = new HTMLCanvas("2d");
					canvas._setContext(/*__JS__ */new CanvasRenderingContext2D());
				/*__JS__ */this.customContext = new RenderContext(0, 0, canvas);
					canvas.context.setCanvasType && canvas.context.setCanvasType(2);
					this.conchModel.custom(canvas.context);
				}
			}
		});

		/**
		*指定显示对象是否缓存为静态图像。功能同cacheAs的normal模式。建议优先使用cacheAs代替。
		*/
		__getset(0, __proto, 'cacheAsBitmap', function () {
			return this.cacheAs !== "none";
		}, function (value) {
			this.cacheAs = value ? (this._$P["hasFilter"] ? "none" : "normal") : "none";
		});

		/**
		*<p>指定显示对象是否缓存为静态图像，cacheAs时，子对象发生变化，会自动重新缓存，同时也可以手动调用reCache方法更新缓存。</p>
		*<p>建议把不经常变化的“复杂内容”缓存为静态图像，能极大提高渲染性能。cacheAs有"none"，"normal"和"bitmap"三个值可选。
		*<li>默认为"none"，不做任何缓存。</li>
		*<li>当值为"normal"时，canvas模式下进行画布缓存，webgl模式下进行命令缓存。</li>
		*<li>当值为"bitmap"时，canvas模式下进行依然是画布缓存，webgl模式下使用renderTarget缓存。</li></p>
		*<p>webgl下renderTarget缓存模式缺点：会额外创建renderTarget对象，增加内存开销，缓存面积有最大2048限制，不断重绘时会增加CPU开销。优点：大幅减少drawcall，渲染性能最高。
		*webgl下命令缓存模式缺点：只会减少节点遍历及命令组织，不会减少drawcall数，性能中等。优点：没有额外内存开销，无需renderTarget支持。</p>
		*/
		__getset(0, __proto, 'cacheAs', function () {
			return this._$P.cacheCanvas == null ? "none" : this._$P.cacheCanvas.type;
		}, function (value) {
			var cacheCanvas = this._$P.cacheCanvas;
			if (value === (cacheCanvas ? cacheCanvas.type : "none")) return;
			if (value !== "none") {
				if (!this._getBit(/*laya.display.Node.NOTICE_DISPLAY*/0x1)) this._setUpNoticeType(/*laya.display.Node.NOTICE_DISPLAY*/0x1);
				cacheCanvas || (cacheCanvas = this._set$P("cacheCanvas", Pool.getItemByClass("cacheCanvas", Object)));
				cacheCanvas.type = value;
				cacheCanvas.reCache = true;
				this._renderType |=/*laya.renders.RenderSprite.CANVAS*/0x10;
				if (value == "bitmap") this.conchModel && this.conchModel.cacheAs(1);
				this._set$P("cacheForFilters", false);
			} else {
				if (this._$P["hasFilter"]) {
					this._set$P("cacheForFilters", true);
				} else {
					if (cacheCanvas) {
						var cc = cacheCanvas;
						if (cc && cc.ctx) {
							Pool.recover("RenderContext", cc.ctx);
							cc.ctx.canvas.size(0, 0);
							cc.ctx = null;
						}
						Pool.recover("cacheCanvas", cacheCanvas);
					}
					this._$P.cacheCanvas = null;
					this._renderType &= ~ /*laya.renders.RenderSprite.CANVAS*/0x10;
					this.conchModel && this.conchModel.cacheAs(0);
				}
			}
			this.repaint();
		});

		/**z排序，更改此值，则会按照值的大小对同一容器的所有对象重新排序。值越大，越靠上。默认为0，则根据添加顺序排序。*/
		__getset(0, __proto, 'zOrder', function () {
			return this._zOrder;
		}, function (value) {
			if (this._zOrder != value) {
				this._zOrder = value;
				this.conchModel && this.conchModel.setZOrder && this.conchModel.setZOrder(value);
				if (this._parent) {
					value && this._parent._set$P("hasZorder", true);
					Laya.timer.callLater(this._parent, this.updateZOrder);
				}
			}
		});

		/**旋转角度，默认值为0。以角度为单位。*/
		__getset(0, __proto, 'rotation', function () {
			return this._style._tf.rotate;
		}, function (value) {
			var style = this.getStyle();
			if (style._tf.rotate !== value) {
				style.setRotate(value);
				this._tfChanged = true;
				this.conchModel && this.conchModel.rotate(value);
				this._renderType |=/*laya.renders.RenderSprite.TRANSFORM*/0x04;
				var p = this._parent;
				if (p && p._repaint === 0) {
					p._repaint = 1;
					p.parentRepaint();
				}
			}
		});

		/**
		*<p>显示对象的宽度，单位为像素，默认为0。</p>
		*<p>此宽度用于鼠标碰撞检测，并不影响显示对象图像大小。需要对显示对象的图像进行缩放，请使用scale、scaleX、scaleY。</p>
		*<p>可以通过getbounds获取显示对象图像的实际宽度。</p>
		*/
		__getset(0, __proto, 'width', function () {
			if (!this.autoSize) return this._width;
			return this.getSelfBounds().width;
		}, function (value) {
			if (this._width !== value) {
				this._width = value;
				this.conchModel && this.conchModel.size(value, this._height)
				this.repaint();
			}
		});

		/**表示显示对象相对于父容器的水平方向坐标值。*/
		__getset(0, __proto, 'x', function () {
			return this._x;
		}, function (value) {
			if (this._x !== value) {
				if (this.destroyed) return;
				this._x = value;
				this.conchModel && this.conchModel.pos(value, this._y);
				var p = this._parent;
				if (p && p._repaint === 0) {
					p._repaint = 1;
					p.parentRepaint();
				}
				if (this._$P.maskParent && this._$P.maskParent._repaint === 0) {
					this._$P.maskParent._repaint = 1;
					this._$P.maskParent.parentRepaint();
				}
			}
		});

		/**
		*获得相对于stage的全局Y轴缩放值（会叠加父亲节点的缩放值）。
		*/
		__getset(0, __proto, 'globalScaleY', function () {
			var scale = 1;
			var ele = this;
			while (ele) {
				if (ele === Laya.stage) break;
				scale *= ele.scaleY;
				ele = ele.parent;
			}
			return scale;
		});

		/**
		*<p>可以设置一个Rectangle区域作为点击区域，或者设置一个<code>HitArea</code>实例作为点击区域，HitArea内可以设置可点击和不可点击区域。</p>
		*<p>如果不设置hitArea，则根据宽高形成的区域进行碰撞。</p>
		*/
		__getset(0, __proto, 'hitArea', function () {
			return this._$P.hitArea;
		}, function (value) {
			this._set$P("hitArea", value);
		});

		/**
		*是否静态缓存此对象的当前帧的最终属性。为 true 时，子对象变化时不会自动更新缓存，但是可以通过调用 reCache 方法手动刷新。
		*<b>注意：</b> 1. 设置 cacheAs 为非空和非"none"时才有效。 2. 由于渲染的时机在脚本执行之后，也就是说当前帧渲染的是对象的最终属性，所以如果在当前帧渲染之前、设置静态缓存之后改变对象属性，则最终渲染结果表现的是对象的最终属性。
		*/
		__getset(0, __proto, 'staticCache', function () {
			return this._$P.staticCache;
		}, function (value) {
			this._set$P("staticCache", value);
			if (!value) this.reCache();
		});

		/**设置一个Texture实例，并显示此图片（如果之前有其他绘制，则会被清除掉）。等同于graphics.clear();graphics.drawTexture()*/
		__getset(0, __proto, 'texture', function () {
			return this._texture;
		}, function (value) {
			if (this._texture != value) {
				this._texture = value;
				this.graphics.cleanByTexture(value, 0, 0);
			}
		});

		/**表示显示对象相对于父容器的垂直方向坐标值。*/
		__getset(0, __proto, 'y', function () {
			return this._y;
		}, function (value) {
			if (this._y !== value) {
				if (this.destroyed) return;
				this._y = value;
				this.conchModel && this.conchModel.pos(this._x, value);
				var p = this._parent;
				if (p && p._repaint === 0) {
					p._repaint = 1;
					p.parentRepaint();
				}
				if (this._$P.maskParent && this._$P.maskParent._repaint === 0) {
					this._$P.maskParent._repaint = 1;
					this._$P.maskParent.parentRepaint();
				}
			}
		});

		/**
		*<p>显示对象的高度，单位为像素，默认为0。</p>
		*<p>此高度用于鼠标碰撞检测，并不影响显示对象图像大小。需要对显示对象的图像进行缩放，请使用scale、scaleX、scaleY。</p>
		*<p>可以通过getbounds获取显示对象图像的实际高度。</p>
		*/
		__getset(0, __proto, 'height', function () {
			if (!this.autoSize) return this._height;
			return this.getSelfBounds().height;
		}, function (value) {
			if (this._height !== value) {
				this._height = value;
				this.conchModel && this.conchModel.size(this._width, value);
				this.repaint();
			}
		});

		/**指定要使用的混合模式。目前只支持"lighter"。*/
		__getset(0, __proto, 'blendMode', function () {
			return this._style.blendMode;
		}, function (value) {
			this.getStyle().blendMode = value;
			this.conchModel && this.conchModel.blendMode(value);
			if (value && value != "source-over") this._renderType |=/*laya.renders.RenderSprite.BLEND*/0x08;
			else this._renderType &= ~ /*laya.renders.RenderSprite.BLEND*/0x08;
			this.parentRepaint();
		});

		/**X轴缩放值，默认值为1。设置为负数，可以实现水平反转效果，比如scaleX=-1。*/
		__getset(0, __proto, 'scaleX', function () {
			return this._style._tf.scaleX;
		}, function (value) {
			var style = this.getStyle();
			if (style._tf.scaleX !== value) {
				style.setScaleX(value);
				this._tfChanged = true;
				this.conchModel && this.conchModel.scale(value, style._tf.scaleY);
				this._renderType |=/*laya.renders.RenderSprite.TRANSFORM*/0x04;
				var p = this._parent;
				if (p && p._repaint === 0) {
					p._repaint = 1;
					p.parentRepaint();
				}
			}
		});

		/**Y轴缩放值，默认值为1。设置为负数，可以实现垂直反转效果，比如scaleX=-1。*/
		__getset(0, __proto, 'scaleY', function () {
			return this._style._tf.scaleY;
		}, function (value) {
			var style = this.getStyle();
			if (style._tf.scaleY !== value) {
				style.setScaleY(value);
				this._tfChanged = true;
				this.conchModel && this.conchModel.scale(style._tf.scaleX, value);
				this._renderType |=/*laya.renders.RenderSprite.TRANSFORM*/0x04;
				var p = this._parent;
				if (p && p._repaint === 0) {
					p._repaint = 1;
					p.parentRepaint();
				}
			}
		});

		/**对舞台 <code>stage</code> 的引用。*/
		__getset(0, __proto, 'stage', function () {
			return this.displayedInStage?Laya.stage:null;
		});

		/**水平倾斜角度，默认值为0。以角度为单位。*/
		__getset(0, __proto, 'skewX', function () {
			return this._style._tf.skewX;
		}, function (value) {
			var style = this.getStyle();
			if (style._tf.skewX !== value) {
				style.setSkewX(value);
				this._tfChanged = true;
				this.conchModel && this.conchModel.skew(value, style._tf.skewY);
				this._renderType |=/*laya.renders.RenderSprite.TRANSFORM*/0x04;
				var p = this._parent;
				if (p && p._repaint === 0) {
					p._repaint = 1;
					p.parentRepaint();
				}
			}
		});

		/**
		*<p>显示对象的滚动矩形范围，具有裁剪效果(如果只想限制子对象渲染区域，请使用viewport)，设置optimizeScrollRect=true，可以优化裁剪区域外的内容不进行渲染。</p>
		*<p> srollRect和viewport的区别：<br/>
		*1.srollRect自带裁剪效果，viewport只影响子对象渲染是否渲染，不具有裁剪效果（性能更高）。<br/>
		*2.设置rect的x,y属性均能实现区域滚动效果，但scrollRect会保持0,0点位置不变。</p>
		*/
		__getset(0, __proto, 'scrollRect', function () {
			return this._style.scrollRect;
		}, function (value) {
			this.getStyle().scrollRect = value;
			this.repaint();
			if (value) {
				this._renderType |=/*laya.renders.RenderSprite.CLIP*/0x80;
				this.conchModel && this.conchModel.scrollRect(value.x, value.y, value.width, value.height);
			} else {
				this._renderType &= ~ /*laya.renders.RenderSprite.CLIP*/0x80;
				if (this.conchModel) {
					if (Sprite.RUNTIMEVERION < "0.9.1")
						this.conchModel.removeType(0x40);
					else
						this.conchModel.removeType(/*laya.renders.RenderSprite.CLIP*/0x80);
				}
			}
		});

		/**垂直倾斜角度，默认值为0。以角度为单位。*/
		__getset(0, __proto, 'skewY', function () {
			return this._style._tf.skewY;
		}, function (value) {
			var style = this.getStyle();
			if (style._tf.skewY !== value) {
				style.setSkewY(value);
				this._tfChanged = true;
				this.conchModel && this.conchModel.skew(style._tf.skewX, value);
				this._renderType |=/*laya.renders.RenderSprite.TRANSFORM*/0x04;
				var p = this._parent;
				if (p && p._repaint === 0) {
					p._repaint = 1;
					p.parentRepaint();
				}
			}
		});

		/**
		*<p>对象的矩阵信息。通过设置矩阵可以实现节点旋转，缩放，位移效果。</p>
		*<p>矩阵更多信息请参考 <code>Matrix</code></p>
		*/
		__getset(0, __proto, 'transform', function () {
			return this._tfChanged ? this._adjustTransform() : this._transform;
		}, function (value) {
			this._tfChanged = false;
			this._transform = value;
			if (value) {
				this._x = value.tx;
				this._y = value.ty;
				value.tx = value.ty = 0;
				this.conchModel && this.conchModel.transform(value.a, value.b, value.c, value.d, this._x, this._y);
			}
			if (value) this._renderType |=/*laya.renders.RenderSprite.TRANSFORM*/0x04;
			else {
				this._renderType &= ~ /*laya.renders.RenderSprite.TRANSFORM*/0x04;
				this.conchModel && this.conchModel.removeType(/*laya.renders.RenderSprite.TRANSFORM*/0x04);
			}
			this.parentRepaint();
		});

		/**X轴 轴心点的位置，单位为像素，默认为0。轴心点会影响对象位置，缩放中心，旋转中心。*/
		__getset(0, __proto, 'pivotX', function () {
			return this._style._tf.translateX;
		}, function (value) {
			this.getStyle().setTranslateX(value);
			this.conchModel && this.conchModel.pivot(value, this._style._tf.translateY);
			this.repaint();
		});

		/**Y轴 轴心点的位置，单位为像素，默认为0。轴心点会影响对象位置，缩放中心，旋转中心。*/
		__getset(0, __proto, 'pivotY', function () {
			return this._style._tf.translateY;
		}, function (value) {
			this.getStyle().setTranslateY(value);
			this.conchModel && this.conchModel.pivot(this._style._tf.translateX, value);
			this.repaint();
		});

		/**透明度，值为0-1，默认值为1，表示不透明。更改alpha值会影响drawcall。*/
		__getset(0, __proto, 'alpha', function () {
			return this._style.alpha;
		}, function (value) {
			if (this._style && this._style.alpha !== value) {
				value = value < 0 ? 0 : (value > 1 ? 1 : value);
				this.getStyle().alpha = value;
				this.conchModel && this.conchModel.alpha(value);
				if (value !== 1) this._renderType |=/*laya.renders.RenderSprite.ALPHA*/0x02;
				else this._renderType &= ~ /*laya.renders.RenderSprite.ALPHA*/0x02;
				this.parentRepaint();
			}
		});

		/**表示是否可见，默认为true。如果设置不可见，节点将不被渲染。*/
		__getset(0, __proto, 'visible', function () {
			return this._style.visible;
		}, function (value) {
			if (this._style && this._style.visible !== value) {
				this.getStyle().visible = value;
				this.conchModel && this.conchModel.visible(value);
				this.parentRepaint();
			}
		});

		/**绘图对象。封装了绘制位图和矢量图的接口，Sprite所有的绘图操作都通过Graphics来实现的。*/
		__getset(0, __proto, 'graphics', function () {
			return this._graphics || (this.graphics = RunDriver.createGraphics());
		}, function (value) {
			if (this._graphics) this._graphics._sp = null;
			this._graphics = value;
			if (value) {
				this._renderType &= ~ /*laya.renders.RenderSprite.IMAGE*/0x01;
				this._renderType |=/*laya.renders.RenderSprite.GRAPHICS*/0x200;
				value._sp = this;
				this.conchModel && this.conchModel.graphics(this._graphics);
			} else {
				this._renderType &= ~ /*laya.renders.RenderSprite.GRAPHICS*/0x200;
				this._renderType &= ~ /*laya.renders.RenderSprite.IMAGE*/0x01;
				if (this.conchModel) {
					if (Sprite.RUNTIMEVERION < "0.9.1")
						this.conchModel.removeType(0x100);
					else
						this.conchModel.removeType(/*laya.renders.RenderSprite.GRAPHICS*/0x200);
				}
			}
			this.repaint();
		});

		/**滤镜集合。可以设置多个滤镜组合。*/
		__getset(0, __proto, 'filters', function () {
			return this._$P.filters;
		}, function (value) {
			value && value.length === 0 && (value = null);
			if (this._$P.filters == value) return;
			this._set$P("filters", value ? value.slice() : null);
			if (Render.isConchApp) {
				if (this.conchModel) {
					if (Sprite.RUNTIMEVERION < "0.9.1")
						this.conchModel.removeType(0x10);
					else
						this.conchModel.removeType(/*laya.renders.RenderSprite.FILTERS*/0x20);
				}
				if (this._$P.filters && this._$P.filters.length == 1) {
					this._$P.filters[0].callNative(this);
				}
			}
			if (Render.isWebGL) {
				if (value && value.length) {
					this._renderType |=/*laya.renders.RenderSprite.FILTERS*/0x20;
				} else {
					this._renderType &= ~ /*laya.renders.RenderSprite.FILTERS*/0x20;
				}
			}
			if (value && value.length > 0) {
				if (!this._getBit(/*laya.display.Node.NOTICE_DISPLAY*/0x1)) this._setUpNoticeType(/*laya.display.Node.NOTICE_DISPLAY*/0x1);
				if (!(Render.isWebGL && value.length == 1 && (((value[0]) instanceof laya.filters.ColorFilter)))) {
					if (this.cacheAs != "bitmap") {
						if (!Render.isConchNode) this.cacheAs = "bitmap";
						this._set$P("cacheForFilters", true);
					}
					this._set$P("hasFilter", true);
				}
			} else {
				this._set$P("hasFilter", false);
				if (this._$P["cacheForFilters"] && this.cacheAs == "bitmap") {
					this.cacheAs = "none";
				}
			}
			this.repaint();
		});

		__getset(0, __proto, 'parent', _super.prototype._$get_parent, function (value) {
			Laya.superSet(Node, this, 'parent', value);
			if (value && this._getBit(/*laya.display.Node.MOUSEENABLE*/0x2)) {
				this._$2__onDisplay();
			}
		});

		/**
		*<p>遮罩，可以设置一个对象(支持位图和矢量图)，根据对象形状进行遮罩显示。</p>
		*<p>【注意】遮罩对象坐标系是相对遮罩对象本身的，和Flash机制不同</p>
		*/
		__getset(0, __proto, 'mask', function () {
			return this._$P._mask;
		}, function (value) {
			if (value && this.mask && this.mask._$P.maskParent) return;
			if (value) {
				this.cacheAs = "bitmap";
				this._set$P("_mask", value);
				value._set$P("maskParent", this);
			} else {
				this.cacheAs = "none";
				this.mask && this.mask._set$P("maskParent", null);
				this._set$P("_mask", value);
			}
			this.conchModel && this.conchModel.mask(value ? value.conchModel : null);
			this._renderType |=/*laya.renders.RenderSprite.MASK*/0x40;
			this.parentRepaint();
		});

		/**
		*是否接受鼠标事件。
		*默认为false，如果监听鼠标事件，则会自动设置本对象及父节点的属性 mouseEnable 的值都为 true（如果父节点手动设置为false，则不会更改）。
		**/
		__getset(0, __proto, 'mouseEnabled', function () {
			return this._mouseEnableState > 1;
		}, function (value) {
			this._mouseEnableState = value ? 2 : 1;
		});

		/**
		*获得相对于stage的全局X轴缩放值（会叠加父亲节点的缩放值）。
		*/
		__getset(0, __proto, 'globalScaleX', function () {
			var scale = 1;
			var ele = this;
			while (ele) {
				if (ele === Laya.stage) break;
				scale *= ele.scaleX;
				ele = ele.parent;
			}
			return scale;
		});

		/**
		*返回鼠标在此对象坐标系上的 X 轴坐标信息。
		*/
		__getset(0, __proto, 'mouseX', function () {
			return this.getMousePoint().x;
		});

		/**
		*返回鼠标在此对象坐标系上的 Y 轴坐标信息。
		*/
		__getset(0, __proto, 'mouseY', function () {
			return this.getMousePoint().y;
		});

		Sprite.fromImage = function (url) {
			return new Sprite().loadImage(url);
		}

		Sprite.CustomList = [];
		__static(Sprite,
			['RUNTIMEVERION', function () { return this.RUNTIMEVERION =/*__JS__ */window.conch ? conchConfig.getRuntimeVersion().substr(conchConfig.getRuntimeVersion().lastIndexOf('-') + 1) : ''; }
			]);
		return Sprite;
	})(Node)


	/**
	*@private
	*audio标签播放声音的音轨控制
	*/
	//class laya.media.h5audio.AudioSoundChannel extends laya.media.SoundChannel
	var AudioSoundChannel = (function (_super) {
		function AudioSoundChannel(audio) {
			/**
			*播放用的audio标签
			*/
			this._audio = null;
			this._onEnd = null;
			this._resumePlay = null;
			AudioSoundChannel.__super.call(this);
			this._onEnd = Utils.bind(this.__onEnd, this);
			this._resumePlay = Utils.bind(this.__resumePlay, this);
			audio.addEventListener("ended", this._onEnd);
			this._audio = audio;
		}

		__class(AudioSoundChannel, 'laya.media.h5audio.AudioSoundChannel', _super);
		var __proto = AudioSoundChannel.prototype;
		__proto.__onEnd = function () {
			if (this.loops == 1) {
				if (this.completeHandler) {
					Laya.timer.once(10, this, this.__runComplete, [this.completeHandler], false);
					this.completeHandler = null;
				}
				this.stop();
				this.event(/*laya.events.Event.COMPLETE*/"complete");
				return;
			}
			if (this.loops > 0) {
				this.loops--;
			}
			this.startTime = 0;
			this.play();
		}

		__proto.__resumePlay = function () {
			if (this._audio) this._audio.removeEventListener("canplay", this._resumePlay);
			try {
				this._audio.currentTime = this.startTime;
				Browser.container.appendChild(this._audio);
				this._audio.play();
			} catch (e) {
				this.event(/*laya.events.Event.ERROR*/"error");
			}
		}

		/**
		*播放
		*/
		__proto.play = function () {
			this.isStopped = false;
			if (!this._audio) return;
			try {
				// this._audio.playbackRate=SoundManager.playbackRate;
				this._audio.currentTime = this.startTime;
			} catch (e) {
				this._audio.addEventListener("canplay", this._resumePlay);
				return;
			}
			SoundManager.addChannel(this);
			Browser.container.appendChild(this._audio);
			if ("play" in this._audio)
				this._audio.play();
		}

		/**
		*停止播放
		*
		*/
		__proto.stop = function () {
			this.isStopped = true;
			SoundManager.removeChannel(this);
			this.completeHandler = null;
			if (!this._audio)
				return;
			if ("pause" in this._audio)
				if (Render.isConchApp) {
					this._audio.stop();
				}
			this._audio.pause();
			this._audio.removeEventListener("ended", this._onEnd);
			this._audio.removeEventListener("canplay", this._resumePlay);
			if (!Browser.onIE) {
				if (this._audio != AudioSound._musicAudio) {
					Pool.recover("audio:" + this.url, this._audio);
				}
			}
			Browser.removeElement(this._audio);
			this._audio = null;
		}

		__proto.pause = function () {
			this.isStopped = true;
			SoundManager.removeChannel(this);
			if ("pause" in this._audio)
				this._audio.pause();
		}

		__proto.resume = function () {
			if (!this._audio)
				return;
			this.isStopped = false;
			SoundManager.addChannel(this);
			if ("play" in this._audio)
				this._audio.play();
		}

		/**
		*当前播放到的位置
		*@return
		*
		*/
		__getset(0, __proto, 'position', function () {
			if (!this._audio)
				return 0;
			return this._audio.currentTime;
		});

		/**
		*获取总时间。
		*/
		__getset(0, __proto, 'duration', function () {
			if (!this._audio)
				return 0;
			return this._audio.duration;
		});

		/**
		* 设置/获取音量
		* @return
		*
		*/
		__getset(0, __proto, 'volume', function () {
			if (!this._audio) return 1;
			return this._audio.volume;
		}, function (v) {
			if (!this._audio) return;
			this._audio.volume = v;
		});
		/**
		* 设置/获取播放速率
		* @return
		*
		*/
		__getset(0, __proto, 'playbackRate', function () {
			if (!this._audio) return 1;
			return this._audio.playbackRate;
		}, function (v) {
			if (!this._audio) return;
			this._audio.playbackRate = v;
		});

		return AudioSoundChannel;
	})(SoundChannel)


	/**
	*@private
	*web audio api方式播放声音的音轨控制
	*/
	//class laya.media.webaudio.WebAudioSoundChannel extends laya.media.SoundChannel
	var WebAudioSoundChannel = (function (_super) {
		function WebAudioSoundChannel() {
			/**
			*声音原始文件数据
			*/
			this.audioBuffer = null;
			/**
			*gain节点
			*/
			this.gain = null;
			/**
			*播放用的数据
			*/
			this.bufferSource = null;
			/**
			*当前时间
			*/
			this._currentTime = 0;
			/**
			*当前音量
			*/
			this._volume = 1;
			/**
			*播放开始时的时间戳
			*/
			this._startTime = 0;
			this._pauseTime = 0;
			this._onPlayEnd = null;
			this.context = WebAudioSound.ctx;
			WebAudioSoundChannel.__super.call(this);
			this._onPlayEnd = Utils.bind(this.__onPlayEnd, this);
			if (this.context["createGain"]) {
				this.gain = this.context["createGain"]();
			} else {
				this.gain = this.context["createGainNode"]();
			}
		}

		__class(WebAudioSoundChannel, 'laya.media.webaudio.WebAudioSoundChannel', _super);
		var __proto = WebAudioSoundChannel.prototype;
		/**
		*播放声音
		*/
		__proto.play = function () {
			SoundManager.addChannel(this);
			this.isStopped = false;
			this._clearBufferSource();
			if (!this.audioBuffer) return;
			var context = this.context;
			var gain = this.gain;
			var bufferSource = context.createBufferSource();
			this.bufferSource = bufferSource;
			bufferSource.buffer = this.audioBuffer;
			bufferSource.connect(gain);
			if (gain)
				gain.disconnect();
			gain.connect(context.destination);
			bufferSource.onended = this._onPlayEnd;
			if (this.startTime >= this.duration) this.startTime = 0;
			this._startTime = Browser.now();
			this.gain.gain.value = this._volume;
			if (this.loops == 0) {
				bufferSource.loop = true;
			}
			bufferSource.playbackRate.value = this._playbackRate;
			bufferSource.start(0, this.startTime);
			this._currentTime = 0;
		}

		__proto.__onPlayEnd = function () {
			if (this.loops == 1) {
				if (this.completeHandler) {
					Laya.timer.once(10, this, this.__runComplete, [this.completeHandler], false);
					this.completeHandler = null;
				}
				this.stop();
				this.event(/*laya.events.Event.COMPLETE*/"complete");
				return;
			}
			if (this.loops > 0) {
				this.loops--;
			}
			this.startTime = 0;
			this.play();
		}

		__proto._clearBufferSource = function () {
			if (this.bufferSource) {
				var sourceNode = this.bufferSource;
				if (sourceNode.stop) {
					sourceNode.stop(0);
				} else {
					sourceNode.noteOff(0);
				}
				sourceNode.disconnect(0);
				sourceNode.onended = null;
				if (!WebAudioSoundChannel._tryCleanFailed) this._tryClearBuffer(sourceNode);
				this.bufferSource = null;
			}
		}

		__proto._tryClearBuffer = function (sourceNode) {
			if (!Browser.onMac) {
				try {
					sourceNode.buffer = null;
				} catch (e) {
					WebAudioSoundChannel._tryCleanFailed = true;
				}
				return;
			}
			try { sourceNode.buffer = WebAudioSound._miniBuffer; } catch (e) { WebAudioSoundChannel._tryCleanFailed = true; }
		}

		/**
		*停止播放
		*/
		__proto.stop = function () {
			this._clearBufferSource();
			this.audioBuffer = null;
			if (this.gain)
				this.gain.disconnect();
			this.isStopped = true;
			SoundManager.removeChannel(this);
			this.completeHandler = null;
			if (SoundManager.autoReleaseSound)
				Laya.timer.once(5000, null, SoundManager.disposeSoundIfNotUsed, [this.url], false);
		}

		__proto.pause = function () {
			if (!this.isStopped) {
				this._pauseTime = this.position;
			}
			this._clearBufferSource();
			if (this.gain)
				this.gain.disconnect();
			this.isStopped = true;
			SoundManager.removeChannel(this);
			if (SoundManager.autoReleaseSound)
				Laya.timer.once(5000, null, SoundManager.disposeSoundIfNotUsed, [this.url], false);
		}

		__proto.resume = function () {
			this.startTime = this._pauseTime;
			this.play();
		}

		/**
		*获取当前播放位置
		*/
		__getset(0, __proto, 'position', function () {
			if (this.bufferSource) {
				return (Browser.now() - this._startTime) / 1000 + this.startTime;
			}
			return 0;
		});

		__getset(0, __proto, 'duration', function () {
			if (this.audioBuffer) {
				return this.audioBuffer.duration;
			}
			return 0;
		});

		/**
		* 设置/获取音量
		*/
		__getset(0, __proto, 'volume', function () {
			return this._volume;
		}, function (v) {
			if (this.isStopped) {
				return;
			}
			this._volume = v;
			this.gain.gain.value = v;
		});

		/**
		* 设置/获取播放速率
		*/
		__getset(0, __proto, 'playbackRate', function () {
			return this._playbackRate;
		}, function (v) {
			if (this.isStopped) {
				return;
			}
			this._playbackRate = v;
		});

		WebAudioSoundChannel._tryCleanFailed = false;
		return WebAudioSoundChannel;
	})(SoundChannel)


	/**
	*@private
	*<code>Bitmap</code> 是图片资源类。
	*/
	//class laya.resource.Bitmap extends laya.resource.Resource
	var Bitmap = (function (_super) {
		function Bitmap() {
			/**@private
			*HTML Image或HTML Canvas或WebGL Texture。
			**/
			//this._source=null;
			/**@private 宽度*/
			//this._w=NaN;
			/**@private 高度*/
			//this._h=NaN;
			Bitmap.__super.call(this);
			this._w = 0;
			this._h = 0;
		}

		__class(Bitmap, 'laya.resource.Bitmap', _super);
		var __proto = Bitmap.prototype;
		/***
		*宽度。
		*/
		__getset(0, __proto, 'width', function () {
			return this._w;
		});

		/***
		*高度。
		*/
		__getset(0, __proto, 'height', function () {
			return this._h;
		});

		/***
		*HTML Image 或 HTML Canvas 或 WebGL Texture 。
		*/
		__getset(0, __proto, 'source', function () {
			return this._source;
		});

		return Bitmap;
	})(Resource)


	/**
	*<p>动画播放基类，提供了基础的动画播放控制方法和帧标签事件相关功能。</p>
	*<p>可以继承此类，但不要直接实例化此类，因为有些方法需要由子类实现。</p>
	*/
	//class laya.display.AnimationPlayerBase extends laya.display.Sprite
	var AnimationPlayerBase = (function (_super) {
		function AnimationPlayerBase() {
			/**
			*是否循环播放，调用play(...)方法时，会将此值设置为指定的参数值。
			*/
			this.loop = false;
			/**
			*<p>播放顺序类型：AnimationPlayerBase.WRAP_POSITIVE为正序播放，AnimationPlayerBase.WRAP_REVERSE为倒序播放，AnimationPlayerBase.WRAP_PINGPONG为pingpong播放(当按指定顺序播放完结尾后，如果继续播发，则会改变播放顺序)。</p>
			*<p>默认为正序播放。</p>
			*/
			this.wrapMode = 0;
			/**@private */
			this._index = 0;
			/**@private */
			this._count = 0;
			/**@private */
			this._isPlaying = false;
			/**@private */
			this._labels = null;
			/**是否是逆序播放*/
			this._isReverse = false;
			/**@private */
			this._frameRateChanged = false;
			/**@private */
			this._controlNode = null;
			/**@private */
			this._actionName = null;
			AnimationPlayerBase.__super.call(this);
			this._interval = Config.animationInterval;
			this._setUpNoticeType(/*laya.display.Node.NOTICE_DISPLAY*/0x1);
		}

		__class(AnimationPlayerBase, 'laya.display.AnimationPlayerBase', _super);
		var __proto = AnimationPlayerBase.prototype;
		/**
		*<p>开始播放动画。play(...)方法被设计为在创建实例后的任何时候都可以被调用，当相应的资源加载完毕、调用动画帧填充方法(set frames)或者将实例显示在舞台上时，会判断是否正在播放中，如果是，则进行播放。</p>
		*<p>配合wrapMode属性，可设置动画播放顺序类型。</p>
		*@param start （可选）指定动画播放开始的索引(int)或帧标签(String)。帧标签可以通过addLabel(...)和removeLabel(...)进行添加和删除。
		*@param loop （可选）是否循环播放。
		*@param name （可选）动画名称。
		*@param showWarn（可选）是否动画不存在时打印警告
		*/
		__proto.play = function (start, loop, name, showWarn) {
			(start === void 0) && (start = 0);
			(loop === void 0) && (loop = true);
			(name === void 0) && (name = "");
			(showWarn === void 0) && (showWarn = true);
			this._isPlaying = true;
			this.index = ((typeof start == 'string')) ? this._getFrameByLabel(start) : start;
			this.loop = loop;
			this._actionName = name;
			this._isReverse = this.wrapMode == 1;
			if (this.interval > 0) {
				this.timerLoop(this.interval, this, this._frameLoop, null, true, true);
			}
		}

		/**@private */
		__proto._getFrameByLabel = function (label) {
			var i = 0;
			for (i = 0; i < this._count; i++) {
				if (this._labels[i] && (this._labels[i]).indexOf(label) >= 0) return i;
			}
			return 0;
		}

		/**@private */
		__proto._frameLoop = function () {
			if (this._isReverse) {
				this._index--;
				if (this._index < 0) {
					if (this.loop) {
						if (this.wrapMode == 2) {
							this._index = this._count > 0 ? 1 : 0;
							this._isReverse = false;
						} else {
							this._index = this._count - 1;
						}
						this.event(/*laya.events.Event.COMPLETE*/"complete");
					} else {
						this._index = 0;
						this.stop();
						this.event(/*laya.events.Event.COMPLETE*/"complete");
						return;
					}
				}
			} else {
				this._index++;
				if (this._index >= this._count) {
					if (this.loop) {
						if (this.wrapMode == 2) {
							this._index = this._count - 2 >= 0 ? this._count - 2 : 0;
							this._isReverse = true;
						} else {
							this._index = 0;
						}
						this.event(/*laya.events.Event.COMPLETE*/"complete");
					} else {
						this._index--;
						this.stop();
						this.event(/*laya.events.Event.COMPLETE*/"complete");
						return;
					}
				}
			}
			this.index = this._index;
		}

		/**@private */
		__proto._setControlNode = function (node) {
			if (this._controlNode) {
				this._controlNode.off(/*laya.events.Event.DISPLAY*/"display", this, this._checkResumePlaying);
				this._controlNode.off(/*laya.events.Event.UNDISPLAY*/"undisplay", this, this._checkResumePlaying);
			}
			this._controlNode = node;
			if (node && node != this) {
				node.on(/*laya.events.Event.DISPLAY*/"display", this, this._checkResumePlaying);
				node.on(/*laya.events.Event.UNDISPLAY*/"undisplay", this, this._checkResumePlaying);
			}
		}

		/**@private */
		__proto._setDisplay = function (value) {
			_super.prototype._setDisplay.call(this, value);
			this._checkResumePlaying();
		}

		/**@private */
		__proto._checkResumePlaying = function () {
			if (this._isPlaying) {
				if (this._controlNode.displayedInStage) this.play(this._index, this.loop, this._actionName);
				else this.clearTimer(this, this._frameLoop);
			}
		}

		/**
		*停止动画播放。
		*/
		__proto.stop = function () {
			this._isPlaying = false;
			this.clearTimer(this, this._frameLoop);
		}

		/**
		*增加一个帧标签到指定索引的帧上。当动画播放到此索引的帧时会派发Event.LABEL事件，派发事件是在完成当前帧画面更新之后。
		*@param label 帧标签名称
		*@param index 帧索引
		*/
		__proto.addLabel = function (label, index) {
			if (!this._labels) this._labels = {};
			if (!this._labels[index]) this._labels[index] = [];
			this._labels[index].push(label);
		}

		/**
		*删除指定的帧标签。
		*@param label 帧标签名称。注意：如果为空，则删除所有帧标签！
		*/
		__proto.removeLabel = function (label) {
			if (!label) this._labels = null;
			else if (this._labels) {
				for (var name in this._labels) {
					this._removeLabelFromLabelList(this._labels[name], label);
				}
			}
		}

		/**@private */
		__proto._removeLabelFromLabelList = function (list, label) {
			if (!list) return;
			for (var i = list.length - 1; i >= 0; i--) {
				if (list[i] == label) {
					list.splice(i, 1);
				}
			}
		}

		/**
		*将动画切换到指定帧并停在那里。
		*@param position 帧索引或帧标签
		*/
		__proto.gotoAndStop = function (position) {
			this.index = ((typeof position == 'string')) ? this._getFrameByLabel(position) : position;
			this.stop();
		}

		/**
		*@private
		*显示到某帧
		*@param value 帧索引
		*/
		__proto._displayToIndex = function (value) { }
		/**
		*停止动画播放，并清理对象属性。之后可存入对象池，方便对象复用。
		*/
		__proto.clear = function () {
			this.stop();
			this._labels = null;
		}

		/**
		*<p>动画播放的帧间隔时间(单位：毫秒)。默认值依赖于Config.animationInterval=50，通过Config.animationInterval可以修改默认帧间隔时间。</p>
		*<p>要想为某动画设置独立的帧间隔时间，可以使用set interval，注意：如果动画正在播放，设置后会重置帧循环定时器的起始时间为当前时间，也就是说，如果频繁设置interval，会导致动画帧更新的时间间隔会比预想的要慢，甚至不更新。</p>
		*/
		__getset(0, __proto, 'interval', function () {
			return this._interval;
		}, function (value) {
			if (this._interval != value) {
				this._frameRateChanged = true;
				this._interval = value;
				if (this._isPlaying && value > 0) {
					this.timerLoop(value, this, this._frameLoop, null, true, true);
				}
			}
		});

		/**
		*是否正在播放中。
		*/
		__getset(0, __proto, 'isPlaying', function () {
			return this._isPlaying;
		});

		/**
		*动画当前帧的索引。
		*/
		__getset(0, __proto, 'index', function () {
			return this._index;
		}, function (value) {
			this._index = value;
			this._displayToIndex(value);
			if (this._labels && this._labels[value]) {
				var tArr = this._labels[value];
				for (var i = 0, len = tArr.length; i < len; i++) {
					this.event(/*laya.events.Event.LABEL*/"label", tArr[i]);
				}
			}
		});

		/**
		*当前动画中帧的总数。
		*/
		__getset(0, __proto, 'count', function () {
			return this._count;
		});

		AnimationPlayerBase.WRAP_POSITIVE = 0;
		AnimationPlayerBase.WRAP_REVERSE = 1;
		AnimationPlayerBase.WRAP_PINGPONG = 2;
		return AnimationPlayerBase;
	})(Sprite)


	/**
	*<p> <code>Text</code> 类用于创建显示对象以显示文本。</p>
	*<p>
	*注意：如果运行时系统找不到设定的字体，则用系统默认的字体渲染文字，从而导致显示异常。(通常电脑上显示正常，在一些移动端因缺少设置的字体而显示异常)。
	*</p>
	*@example
	*package
	*{
		*import laya.display.Text;
		*public class Text_Example
		*{
			*public function Text_Example()
			*{
				*Laya.init(640,800);//设置游戏画布宽高、渲染模式。
				*Laya.stage.bgColor="#efefef";//设置画布的背景颜色。
				*onInit();
				*}
			*private function onInit():void
			*{
				*var text:Text=new Text();//创建一个 Text 类的实例对象 text 。
				*text.text="这个是一个 Text 文本示例。";
				*text.color="#008fff";//设置 text 的文本颜色。
				*text.font="Arial";//设置 text 的文本字体。
				*text.bold=true;//设置 text 的文本显示为粗体。
				*text.fontSize=30;//设置 text 的字体大小。
				*text.wordWrap=true;//设置 text 的文本自动换行。
				*text.x=100;//设置 text 对象的属性 x 的值，用于控制 text 对象的显示位置。
				*text.y=100;//设置 text 对象的属性 y 的值，用于控制 text 对象的显示位置。
				*text.width=300;//设置 text 的宽度。
				*text.height=200;//设置 text 的高度。
				*text.italic=true;//设置 text 的文本显示为斜体。
				*text.borderColor="#fff000";//设置 text 的文本边框颜色。
				*Laya.stage.addChild(text);//将 text 添加到显示列表。
				*}
			*}
		*}
	*@example
	*Text_Example();
	*function Text_Example()
	*{
		*Laya.init(640,800);//设置游戏画布宽高、渲染模式。
		*Laya.stage.bgColor="#efefef";//设置画布的背景颜色。
		*onInit();
		*}
	*function onInit()
	*{
		*var text=new laya.display.Text();//创建一个 Text 类的实例对象 text 。
		*text.text="这个是一个 Text 文本示例。";
		*text.color="#008fff";//设置 text 的文本颜色。
		*text.font="Arial";//设置 text 的文本字体。
		*text.bold=true;//设置 text 的文本显示为粗体。
		*text.fontSize=30;//设置 text 的字体大小。
		*text.wordWrap=true;//设置 text 的文本自动换行。
		*text.x=100;//设置 text 对象的属性 x 的值，用于控制 text 对象的显示位置。
		*text.y=100;//设置 text 对象的属性 y 的值，用于控制 text 对象的显示位置。
		*text.width=300;//设置 text 的宽度。
		*text.height=200;//设置 text 的高度。
		*text.italic=true;//设置 text 的文本显示为斜体。
		*text.borderColor="#fff000";//设置 text 的文本边框颜色。
		*Laya.stage.addChild(text);//将 text 添加到显示列表。
		*}
	*@example
	*class Text_Example {
		*constructor(){
			*Laya.init(640,800);//设置游戏画布宽高、渲染模式。
			*Laya.stage.bgColor="#efefef";//设置画布的背景颜色。
			*this.onInit();
			*}
		*private onInit():void {
			*var text:laya.display.Text=new laya.display.Text();//创建一个 Text 类的实例对象 text 。
			*text.text="这个是一个 Text 文本示例。";
			*text.color="#008fff";//设置 text 的文本颜色。
			*text.font="Arial";//设置 text 的文本字体。
			*text.bold=true;//设置 text 的文本显示为粗体。
			*text.fontSize=30;//设置 text 的字体大小。
			*text.wordWrap=true;//设置 text 的文本自动换行。
			*text.x=100;//设置 text 对象的属性 x 的值，用于控制 text 对象的显示位置。
			*text.y=100;//设置 text 对象的属性 y 的值，用于控制 text 对象的显示位置。
			*text.width=300;//设置 text 的宽度。
			*text.height=200;//设置 text 的高度。
			*text.italic=true;//设置 text 的文本显示为斜体。
			*text.borderColor="#fff000";//设置 text 的文本边框颜色。
			*Laya.stage.addChild(text);//将 text 添加到显示列表。
			*}
		*}
	*/
	//class laya.display.Text extends laya.display.Sprite
	var Text = (function (_super) {
		function Text() {
			/**@private */
			this._clipPoint = null;
			/**当前使用的位置字体。*/
			this._currBitmapFont = null;
			/**@private 表示文本内容字符串。*/
			this._text = null;
			/**@private 表示文本内容是否发生改变。*/
			this._isChanged = false;
			/**@private 表示文本的宽度，以像素为单位。*/
			this._textWidth = 0;
			/**@private 表示文本的高度，以像素为单位。*/
			this._textHeight = 0;
			/**@private 存储文字行数信息。*/
			this._lines = [];
			/**@private 保存每行宽度*/
			this._lineWidths = [];
			/**@private 文本的内容位置 X 轴信息。*/
			this._startX = NaN;
			/**@private 文本的内容位置X轴信息。 */
			this._startY = NaN;
			/**@private 当前可视行索引。*/
			this._lastVisibleLineIndex = -1;
			/**@private 当前可视行索引。*/
			this._words = null;
			/**@private */
			this._charSize = {};
			/**
			*是否显示下划线。
			*/
			this.underline = false;
			/**
			*下划线的颜色，为null则使用字体颜色。
			*/
			this._underlineColor = null;
			Text.__super.call(this);
			this.overflow = Text.VISIBLE;
			this._style = new CSSStyle(this);
			(this._style).wordWrap = false;
		}

		__class(Text, 'laya.display.Text', _super);
		var __proto = Text.prototype;
		/**@inheritDoc */
		__proto.destroy = function (destroyChild) {
			(destroyChild === void 0) && (destroyChild = true);
			_super.prototype.destroy.call(this, destroyChild);
			this._lines = null;
			if (this._words) {
				this._words.length = 0;
				this._words = null;
			}
		}

		/**
		*@private
		*@inheritDoc
		*/
		__proto._getBoundPointsM = function (ifRotate) {
			(ifRotate === void 0) && (ifRotate = false);
			var rec = Rectangle.TEMP;
			rec.setTo(0, 0, this.width, this.height);
			return rec._getBoundPoints();
		}

		/**
		*@inheritDoc
		*/
		__proto.getGraphicBounds = function (realSize) {
			(realSize === void 0) && (realSize = false);
			var rec = Rectangle.TEMP;
			rec.setTo(0, 0, this.width, this.height);
			return rec;
		}

		/**
		*@private
		*@inheritDoc
		*/
		__proto._getCSSStyle = function () {
			return this._style;
		}

		/**
		*<p>根据指定的文本，从语言包中取当前语言的文本内容。并对此文本中的{i}文本进行替换。</p>
		*<p>设置Text.langPacks语言包后，即可使用lang获取里面的语言</p>
		*<p>例如：
		*<li>（1）text 的值为“我的名字”，先取到这个文本对应的当前语言版本里的值“My name”，将“My name”设置为当前文本的内容。</li>
		*<li>（2）text 的值为“恭喜你赢得{0}个钻石，{1}经验。”，arg1 的值为100，arg2 的值为200。
		*则先取到这个文本对应的当前语言版本里的值“Congratulations on your winning {0}diamonds,{1}experience.”，
		*然后将文本里的{0}、{1}，依据括号里的数字从0开始替换为 arg1、arg2 的值。
		*将替换处理后的文本“Congratulations on your winning 100 diamonds,200 experience.”设置为当前文本的内容。
		*</li>
		*</p>
		*@param text 文本内容。
		*@param ...args 文本替换参数。
		*/
		__proto.lang = function (text, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10) {
			text = Text.langPacks && Text.langPacks[text] ? Text.langPacks[text] : text;
			if (arguments.length < 2) {
				this._text = text;
			} else {
				for (var i = 0, n = arguments.length; i < n; i++) {
					text = text.replace("{" + i + "}", arguments[i + 1]);
				}
				this._text = text;
			}
		}

		/**
		*@private
		*/
		__proto._isPassWordMode = function () {
			var style = this._style;
			var password = style.password;
			if (("prompt" in this) && this['prompt'] == this._text)
				password = false;
			return password;
		}

		/**
		*@private
		*/
		__proto._getPassWordTxt = function (txt) {
			var len = txt.length;
			var word;
			word = "";
			for (var j = len; j > 0; j--) {
				word += "●";
			}
			return word;
		}

		/**
		*渲染文字。
		*@param begin 开始渲染的行索引。
		*@param visibleLineCount 渲染的行数。
		*/
		__proto.renderText = function (begin, visibleLineCount) {
			var graphics = this.graphics;
			graphics.clear(true);
			// debugger
			var ctxFont = (this.italic ? "italic " : "") + (this.bold ? "bold " : "") + this.fontSize + "px " + (Browser.onIPhone ? (laya.display.Text._fontFamilyMap[this.font] || this.font) : this.font);
			// alert(ctxFont)



			// ctxFont = "50px 宋体";
			// ctxFont = Font.defaultFont;
			Browser.context.font = ctxFont;
			var padding = this.padding;
			var startX = padding[3];
			var textAlgin = "left";
			var lines = this._lines;
			var lineHeight = this.leading + this._charSize.height;
			var tCurrBitmapFont = this._currBitmapFont;
			if (tCurrBitmapFont) {
				lineHeight = this.leading + tCurrBitmapFont.getMaxHeight();
			};
			var startY = padding[0];
			if ((!tCurrBitmapFont) && this._width > 0 && this._textWidth <= this._width) {
				if (this.align == "right") {
					textAlgin = "right";
					startX = this._width - padding[1];
				} else if (this.align == "center") {
					textAlgin = "center";
					startX = this._width * 0.5 + padding[3] - padding[1];
				}
			}
			if (this._height > 0) {
				var tempVAlign = (this._textHeight > this._height) ? "top" : this.valign;
				if (tempVAlign === "middle")
					startY = (this._height - visibleLineCount * lineHeight) * 0.5 + padding[0] - padding[2];
				else if (tempVAlign === "bottom")
					startY = this._height - visibleLineCount * lineHeight - padding[2];
			};
			var style = this._style;
			if (tCurrBitmapFont && tCurrBitmapFont.autoScaleSize) {
				var bitmapScale = tCurrBitmapFont.fontSize / this.fontSize;
			}
			if (this._clipPoint) {
				graphics.save();
				if (tCurrBitmapFont && tCurrBitmapFont.autoScaleSize) {
					var tClipWidth = 0;
					var tClipHeight = 0;
					this._width ? tClipWidth = (this._width - padding[3] - padding[1]) : tClipWidth = this._textWidth;
					this._height ? tClipHeight = (this._height - padding[0] - padding[2]) : tClipHeight = this._textHeight;
					tClipWidth *= bitmapScale;
					tClipHeight *= bitmapScale;
					graphics.clipRect(padding[3], padding[0], tClipWidth, tClipHeight);
				} else {
					graphics.clipRect(padding[3], padding[0], this._width ? (this._width - padding[3] - padding[1]) : this._textWidth, this._height ? (this._height - padding[0] - padding[2]) : this._textHeight);
				}
			};
			var password = style.password;
			if (("prompt" in this) && this['prompt'] == this._text)
				password = false;
			var x = 0, y = 0;
			var end = Math.min(this._lines.length, visibleLineCount + begin) || 1;
			for (var i = begin; i < end; i++) {
				var word = lines[i];
				var _word;
				if (password) {
					var len = word.length;
					word = "";
					for (var j = len; j > 0; j--) {
						word += "●";
					}
				}
				x = startX - (this._clipPoint ? this._clipPoint.x : 0);
				y = startY + lineHeight * i - (this._clipPoint ? this._clipPoint.y : 0);
				this.underline && this.drawUnderline(textAlgin, x, y, i);
				if (tCurrBitmapFont) {
					var tWidth = this.width;
					if (tCurrBitmapFont.autoScaleSize) {
						tWidth = this.width * bitmapScale;
					}
					tCurrBitmapFont.drawText(word, this, x, y, this.align, tWidth);
				} else {
					if (Render.isWebGL) {
						this._words || (this._words = []);
						_word = this._words.length > (i - begin) ? this._words[i - begin] : new WordText();
						_word.setText(word);
					} else {
						_word = word;
					}
					style.stroke ? graphics.fillBorderText(_word, x, y, ctxFont, this.color, style.strokeColor, style.stroke, textAlgin) : graphics.fillText(_word, x, y, ctxFont, this.color, textAlgin);
				}
			}
			if (tCurrBitmapFont && tCurrBitmapFont.autoScaleSize) {
				var tScale = 1 / bitmapScale;
				this.scale(tScale, tScale);
			}
			if (this._clipPoint)
				graphics.restore();
			this._startX = startX;
			this._startY = startY;
		}

		/**
		*绘制下划线
		*@param x 本行坐标
		*@param y 本行坐标
		*@param lineIndex 本行索引
		*/
		__proto.drawUnderline = function (align, x, y, lineIndex) {
			var lineWidth = this._lineWidths[lineIndex];
			switch (align) {
				case 'center':
					x -= lineWidth / 2;
					break;
				case 'right':
					x -= lineWidth;
					break;
				case 'left':
				default:
					break;
			}
			y += this._charSize.height;
			this._graphics.drawLine(x, y, x + lineWidth, y, this.underlineColor || this.color, 1);
		}

		/**
		*<p>排版文本。</p>
		*<p>进行宽高计算，渲染、重绘文本。</p>
		*/
		__proto.typeset = function () {
			this._isChanged = false;
			if (!this._text) {
				this._clipPoint = null;
				this._textWidth = this._textHeight = 0;
				this.graphics.clear(true);
				return;
			}
			Browser.context.font = this._getCSSStyle().font;
			this._lines.length = 0;
			this._lineWidths.length = 0;
			if (this._isPassWordMode()) {
				this.parseLines(this._getPassWordTxt(this._text));
			} else
				this.parseLines(this._text);
			this.evalTextSize();
			if (this.checkEnabledViewportOrNot())
				this._clipPoint || (this._clipPoint = new Point(0, 0));
			else
				this._clipPoint = null;
			var lineCount = this._lines.length;
			if (this.overflow != Text.VISIBLE) {
				var func = this.overflow == Text.HIDDEN ? Math.floor : Math.ceil;
				lineCount = Math.min(lineCount, func((this.height - this.padding[0] - this.padding[2]) / (this.leading + this._charSize.height)));
			};
			var startLine = this.scrollY / (this._charSize.height + this.leading) | 0;
			this.renderText(startLine, lineCount);
			this.repaint();
		}

		__proto.evalTextSize = function () {
			var nw = NaN, nh = NaN;
			nw = Math.max.apply(this, this._lineWidths);
			if (this._currBitmapFont)
				nh = this._lines.length * (this._currBitmapFont.getMaxHeight() + this.leading) + this.padding[0] + this.padding[2];
			else
				nh = this._lines.length * (this._charSize.height + this.leading) + this.padding[0] + this.padding[2];
			if (nw != this._textWidth || nh != this._textHeight) {
				this._textWidth = nw;
				this._textHeight = nh;
				if (!this._width || !this._height)
					this.conchModel && this.conchModel.size(this._width || this._textWidth, this._height || this._textHeight);
			}
		}

		__proto.checkEnabledViewportOrNot = function () {
			return this.overflow == Text.SCROLL && ((this._width > 0 && this._textWidth > this._width) || (this._height > 0 && this._textHeight > this._height));
		}

		/**
		*<p>快速更改显示文本。不进行排版计算，效率较高。</p>
		*<p>如果只更改文字内容，不更改文字样式，建议使用此接口，能提高效率。</p>
		*@param text 文本内容。
		*/
		__proto.changeText = function (text) {
			if (this._text !== text) {
				this.lang(text + "");
				if (this._graphics && this._graphics.replaceText(this._text)) {
				} else {
					this.typeset();
				}
			}
		}

		/**
		*@private
		*分析文本换行。
		*/
		__proto.parseLines = function (text) {
			var needWordWrapOrTruncate = this.wordWrap || this.overflow == Text.HIDDEN;
			if (needWordWrapOrTruncate) {
				var wordWrapWidth = this.getWordWrapWidth();
			}
			if (this._currBitmapFont) {
				this._charSize.width = this._currBitmapFont.getMaxWidth();
				this._charSize.height = this._currBitmapFont.getMaxHeight();
			} else {
				var measureResult = Browser.context.measureText(Text._testWord);
				this._charSize.width = measureResult.width;
				this._charSize.height = (measureResult.height || this.fontSize);
			};
			var lines = text.replace(/\r\n/g, "\n").split("\n");
			for (var i = 0, n = lines.length; i < n; i++) {
				var line = lines[i];
				if (needWordWrapOrTruncate)
					this.parseLine(line, wordWrapWidth);
				else {
					this._lineWidths.push(this.getTextWidth(line));
					this._lines.push(line);
				}
			}
		}

		/**
		*@private
		*解析行文本。
		*@param line 某行的文本。
		*@param wordWrapWidth 文本的显示宽度。
		*/
		__proto.parseLine = function (line, wordWrapWidth) {
			var ctx = Browser.context;
			var lines = this._lines;
			var maybeIndex = 0;
			var execResult;
			var charsWidth = NaN;
			var wordWidth = NaN;
			var startIndex = 0;
			charsWidth = this.getTextWidth(line);
			if (charsWidth <= wordWrapWidth) {
				lines.push(line);
				this._lineWidths.push(charsWidth);
				return;
			}
			charsWidth = this._charSize.width;
			maybeIndex = Math.floor(wordWrapWidth / charsWidth);
			(maybeIndex == 0) && (maybeIndex = 1);
			charsWidth = this.getTextWidth(line.substring(0, maybeIndex));
			wordWidth = charsWidth;
			for (var j = maybeIndex, m = line.length; j < m; j++) {
				charsWidth = this.getTextWidth(line.charAt(j));
				wordWidth += charsWidth;
				if (wordWidth > wordWrapWidth) {
					if (this.wordWrap) {
						var newLine = line.substring(startIndex, j);
						if (newLine.charCodeAt(newLine.length - 1) < 255) {
							execResult = /(?:\w|-)+$/.exec(newLine);
							if (execResult) {
								j = execResult.index + startIndex;
								if (execResult.index == 0)
									j += newLine.length;
								else
									newLine = line.substring(startIndex, j);
							}
						} else
							if (Text.RightToLeft) {
								execResult = /([\u0600-\u06FF])+$/.exec(newLine);
								if (execResult) {
									j = execResult.index + startIndex;
									if (execResult.index == 0)
										j += newLine.length;
									else
										newLine = line.substring(startIndex, j);
								}
							}
						lines.push(newLine);
						this._lineWidths.push(wordWidth - charsWidth);
						startIndex = j;
						if (j + maybeIndex < m) {
							j += maybeIndex;
							charsWidth = this.getTextWidth(line.substring(startIndex, j));
							wordWidth = charsWidth;
							j--;
						} else {
							lines.push(line.substring(startIndex, m));
							this._lineWidths.push(this.getTextWidth(lines[lines.length - 1]));
							startIndex = -1;
							break;
						}
					} else if (this.overflow == Text.HIDDEN) {
						lines.push(line.substring(0, j));
						this._lineWidths.push(this.getTextWidth(lines[lines.length - 1]));
						return;
					}
				}
			}
			if (this.wordWrap && startIndex != -1) {
				lines.push(line.substring(startIndex, m));
				this._lineWidths.push(this.getTextWidth(lines[lines.length - 1]));
			}
		}

		__proto.getTextWidth = function (text) {
			if (this._currBitmapFont)
				return this._currBitmapFont.getTextWidth(text);
			else
				return Browser.context.measureText(text).width;
		}

		/**
		*获取换行所需的宽度。
		*/
		__proto.getWordWrapWidth = function () {
			var p = this.padding;
			var w = NaN;
			if (this._currBitmapFont && this._currBitmapFont.autoScaleSize)
				w = this._width * (this._currBitmapFont.fontSize / this.fontSize);
			else
				w = this._width;
			if (w <= 0) {
				w = this.wordWrap ? 100 : Browser.width;
			}
			w <= 0 && (w = 100);
			return w - p[3] - p[1];
		}

		/**
		*返回字符在本类实例的父坐标系下的坐标。
		*@param charIndex 索引位置。
		*@param out （可选）输出的Point引用。
		*@return Point 字符在本类实例的父坐标系下的坐标。如果out参数不为空，则将结果赋值给指定的Point对象，否则创建一个新的Point对象返回。建议使用Point.TEMP作为out参数，可以省去Point对象创建和垃圾回收的开销，尤其是在需要频繁执行的逻辑中，比如帧循环和MOUSE_MOVE事件回调函数里面。
		*/
		__proto.getCharPoint = function (charIndex, out) {
			this._isChanged && Laya.timer.runCallLater(this, this.typeset);
			var len = 0, lines = this._lines, startIndex = 0;
			for (var i = 0, n = lines.length; i < n; i++) {
				len += lines[i].length;
				if (charIndex < len) {
					var line = i;
					break;
				}
				startIndex = len;
			};
			var ctxFont = (this.italic ? "italic " : "") + (this.bold ? "bold " : "") + this.fontSize + "px " + this.font;
			Browser.context.font = ctxFont;
			var width = this.getTextWidth(this._text.substring(startIndex, charIndex));
			var point = out || new Point();
			return point.setTo(this._startX + width - (this._clipPoint ? this._clipPoint.x : 0), this._startY + line * (this._charSize.height + this.leading) - (this._clipPoint ? this._clipPoint.y : 0));
		}

		/**
		*@inheritDoc
		*/
		__getset(0, __proto, 'width', function () {
			if (this._width)
				return this._width;
			return this.textWidth + this.padding[1] + this.padding[3];
		}, function (value) {
			if (value != this._width) {
				Laya.superSet(Sprite, this, 'width', value);
				this.isChanged = true;
			}
		});

		/**
		*表示文本的宽度，以像素为单位。
		*/
		__getset(0, __proto, 'textWidth', function () {
			this._isChanged && Laya.timer.runCallLater(this, this.typeset);
			return this._textWidth;
		});

		/**
		*@inheritDoc
		*/
		__getset(0, __proto, 'height', function () {
			if (this._height) return this._height;
			return this.textHeight + this.padding[0] + this.padding[2];
		}, function (value) {
			if (value != this._height) {
				Laya.superSet(Sprite, this, 'height', value);
				this.isChanged = true;
			}
		});

		/**
		*表示文本的高度，以像素为单位。
		*/
		__getset(0, __proto, 'textHeight', function () {
			this._isChanged && Laya.timer.runCallLater(this, this.typeset);
			return this._textHeight;
		});

		/**
		*<p>边距信息。</p>
		*<p>数据格式：[上边距，右边距，下边距，左边距]（边距以像素为单位）。</p>
		*/
		__getset(0, __proto, 'padding', function () {
			return this._getCSSStyle().padding;
		}, function (value) {
			this._getCSSStyle().padding = value;
			this.isChanged = true;
		});

		/**
		*<p>指定文本是否为粗体字。</p>
		*<p>默认值为 false，这意味着不使用粗体字。如果值为 true，则文本为粗体字。</p>
		*/
		__getset(0, __proto, 'bold', function () {
			return this._getCSSStyle().bold;
		}, function (value) {
			this._getCSSStyle().bold = value;
			this.isChanged = true;
		});

		/**当前文本的内容字符串。*/
		__getset(0, __proto, 'text', function () {
			return this._text || "";
		}, function (value) {
			if (this._text !== value) {
				this.lang(value + "");
				this.isChanged = true;
				this.event(/*laya.events.Event.CHANGE*/"change");
			}
		});

		/**
		*<p>表示文本的颜色值。可以通过 <code>Text.defaultColor</code> 设置默认颜色。</p>
		*<p>默认值为黑色。</p>
		*/
		__getset(0, __proto, 'color', function () {
			return this._getCSSStyle().color;
		}, function (value) {
			if (this._getCSSStyle().color != value) {
				this._getCSSStyle().color = value;
				if (!this._isChanged && this._graphics) {
					this._graphics.replaceTextColor(this.color)
				} else {
					this.isChanged = true;
				}
			}
		});

		/**
		*<p>文本的字体名称，以字符串形式表示。</p>
		*<p>默认值为："Arial"，可以通过Font.defaultFont设置默认字体。</p>
		*<p>如果运行时系统找不到设定的字体，则用系统默认的字体渲染文字，从而导致显示异常。(通常电脑上显示正常，在一些移动端因缺少设置的字体而显示异常)。</p>
		*@see laya.display.css.Font#defaultFamily
		*/
		__getset(0, __proto, 'font', function () {
			var font = this._getCSSStyle().fontFamily;
			return font == "Arial" ? Font.defaultFont : font;
		}, function (value) {
			if (this._currBitmapFont) {
				this._currBitmapFont = null;
				this.scale(1, 1);
			}
			if (Text._bitmapFonts && Text._bitmapFonts[value]) {
				this._currBitmapFont = Text._bitmapFonts[value];
			}
			this._getCSSStyle().fontFamily = value;
			this.isChanged = true;
		});

		/**
		*<p>指定文本的字体大小（以像素为单位）。</p>
		*<p>默认为20像素，可以通过 <code>Text.defaultSize</code> 设置默认大小。</p>
		*/
		__getset(0, __proto, 'fontSize', function () {
			return this._getCSSStyle().fontSize;
		}, function (value) {
			this._getCSSStyle().fontSize = value;
			this.isChanged = true;
		});

		/**
		*<p>表示使用此文本格式的文本是否为斜体。</p>
		*<p>默认值为 false，这意味着不使用斜体。如果值为 true，则文本为斜体。</p>
		*/
		__getset(0, __proto, 'italic', function () {
			return this._getCSSStyle().italic;
		}, function (value) {
			this._getCSSStyle().italic = value;
			this.isChanged = true;
		});

		/**
		*<p>表示文本的水平显示方式。</p>
		*<p><b>取值：</b>
		*<li>"left"： 居左对齐显示。</li>
		*<li>"center"： 居中对齐显示。</li>
		*<li>"right"： 居右对齐显示。</li>
		*</p>
		*/
		__getset(0, __proto, 'align', function () {
			return this._getCSSStyle().align;
		}, function (value) {
			this._getCSSStyle().align = value;
			this.isChanged = true;
		});

		/**
		*<p>表示文本的垂直显示方式。</p>
		*<p><b>取值：</b>
		*<li>"top"： 居顶部对齐显示。</li>
		*<li>"middle"： 居中对齐显示。</li>
		*<li>"bottom"： 居底部对齐显示。</li>
		*</p>
		*/
		__getset(0, __proto, 'valign', function () {
			return this._getCSSStyle().valign;
		}, function (value) {
			this._getCSSStyle().valign = value;
			this.isChanged = true;
		});

		/**
		*<p>表示文本是否自动换行，默认为false。</p>
		*<p>若值为true，则自动换行；否则不自动换行。</p>
		*/
		__getset(0, __proto, 'wordWrap', function () {
			return this._getCSSStyle().wordWrap;
		}, function (value) {
			this._getCSSStyle().wordWrap = value;
			this.isChanged = true;
		});

		/**
		*垂直行间距（以像素为单位）。
		*/
		__getset(0, __proto, 'leading', function () {
			return this._getCSSStyle().leading;
		}, function (value) {
			this._getCSSStyle().leading = value;
			this.isChanged = true;
		});

		/**
		*文本背景颜色，以字符串表示。
		*/
		__getset(0, __proto, 'bgColor', function () {
			return this._getCSSStyle().backgroundColor;
		}, function (value) {
			this._getCSSStyle().backgroundColor = value;
			this.isChanged = true;
		});

		/**
		*文本边框背景颜色，以字符串表示。
		*/
		__getset(0, __proto, 'borderColor', function () {
			return this._getCSSStyle().borderColor;
		}, function (value) {
			this._getCSSStyle().borderColor = value;
			this.isChanged = true;
		});

		/**
		*<p>描边宽度（以像素为单位）。</p>
		*<p>默认值0，表示不描边。</p>
		*/
		__getset(0, __proto, 'stroke', function () {
			return this._getCSSStyle().stroke;
		}, function (value) {
			this._getCSSStyle().stroke = value;
			this.isChanged = true;
		});

		/**
		*<p>描边颜色，以字符串表示。</p>
		*<p>默认值为 "#000000"（黑色）;</p>
		*/
		__getset(0, __proto, 'strokeColor', function () {
			return this._getCSSStyle().strokeColor;
		}, function (value) {
			this._getCSSStyle().strokeColor = value;
			this.isChanged = true;
		});

		/**
		*一个布尔值，表示文本的属性是否有改变。若为true表示有改变。
		*/
		__getset(0, __proto, 'isChanged', null, function (value) {
			if (this._isChanged !== value) {
				this._isChanged = value;
				value && Laya.timer.callLater(this, this.typeset);
			}
		});

		/**
		*<p>设置横向滚动量。</p>
		*<p>即使设置超出滚动范围的值，也会被自动限制在可能的最大值处。</p>
		*/
		/**
		*获取横向滚动量。
		*/
		__getset(0, __proto, 'scrollX', function () {
			if (!this._clipPoint)
				return 0;
			return this._clipPoint.x;
		}, function (value) {
			if (this.overflow != Text.SCROLL || (this.textWidth < this._width || !this._clipPoint))
				return;
			value = value < this.padding[3] ? this.padding[3] : value;
			var maxScrollX = this._textWidth - this._width;
			value = value > maxScrollX ? maxScrollX : value;
			var visibleLineCount = this._height / (this._charSize.height + this.leading) | 0 + 1;
			this._clipPoint.x = value;
			this.renderText(this._lastVisibleLineIndex, visibleLineCount);
		});

		/**
		*设置纵向滚动量（px)。即使设置超出滚动范围的值，也会被自动限制在可能的最大值处。
		*/
		/**
		*获取纵向滚动量。
		*/
		__getset(0, __proto, 'scrollY', function () {
			if (!this._clipPoint)
				return 0;
			return this._clipPoint.y;
		}, function (value) {
			if (this.overflow != Text.SCROLL || (this.textHeight < this._height || !this._clipPoint))
				return;
			value = value < this.padding[0] ? this.padding[0] : value;
			var maxScrollY = this._textHeight - this._height;
			value = value > maxScrollY ? maxScrollY : value;
			var startLine = value / (this._charSize.height + this.leading) | 0;
			this._lastVisibleLineIndex = startLine;
			var visibleLineCount = (this._height / (this._charSize.height + this.leading) | 0) + 1;
			this._clipPoint.y = value;
			this.renderText(startLine, visibleLineCount);
		});

		/**
		*获取横向可滚动最大值。
		*/
		__getset(0, __proto, 'maxScrollX', function () {
			return (this.textWidth < this._width) ? 0 : this._textWidth - this._width;
		});

		/**
		*获取纵向可滚动最大值。
		*/
		__getset(0, __proto, 'maxScrollY', function () {
			return (this.textHeight < this._height) ? 0 : this._textHeight - this._height;
		});

		__getset(0, __proto, 'lines', function () {
			if (this._isChanged)
				this.typeset();
			return this._lines;
		});

		__getset(0, __proto, 'underlineColor', function () {
			return this._underlineColor;
		}, function (value) {
			this._underlineColor = value;
			this._isChanged = true;
			this.typeset();
		});

		Text.registerBitmapFont = function (name, bitmapFont) {
			Text._bitmapFonts || (Text._bitmapFonts = {});
			Text._bitmapFonts[name] = bitmapFont;
		}

		Text.unregisterBitmapFont = function (name, destroy) {
			(destroy === void 0) && (destroy = true);
			if (Text._bitmapFonts && Text._bitmapFonts[name]) {
				var tBitmapFont = Text._bitmapFonts[name];
				if (destroy) {
					tBitmapFont.destroy();
				}
				delete Text._bitmapFonts[name];
			}
		}

		Text.setTextRightToLeft = function () {
			var style;
			style = Browser.canvas.source.style;
			style.display = "none";
			style.position = "absolute";
			style.direction = "rtl";
			Render._mainCanvas.source.style.direction = "rtl";
			laya.display.Text.RightToLeft = true;
			Browser.document.body.appendChild(Browser.canvas.source);
		}

		Text.supportFont = function (font) {
			Browser.context.font = "10px sans-serif";
			var defaultFontWidth = Browser.context.measureText("abcji").width;
			Browser.context.font = "10px " + font;
			var customFontWidth = Browser.context.measureText("abcji").width;
			console.log(defaultFontWidth, customFontWidth);
			if (defaultFontWidth === customFontWidth) return false;
			else return true;
		}

		Text._testWord = "游";
		Text.langPacks = null;
		Text.VISIBLE = "visible";
		Text.SCROLL = "scroll";
		Text.HIDDEN = "hidden";
		Text.CharacterCache = true;
		Text.RightToLeft = false;
		Text._bitmapFonts = null;
		__static(Text,
			['_fontFamilyMap', function () { return this._fontFamilyMap = { "报隶": "报隶-简", "黑体": "黑体-简", "楷体": "楷体-简", "兰亭黑": "兰亭黑-简", "隶变": "隶变-简", "凌慧体": "凌慧体-简", "翩翩体": "翩翩体-简", "苹方": "苹方-简", "手札体": "手札体-简", "宋体": "宋体-简", "娃娃体": "娃娃体-简", "魏碑": "魏碑-简", "行楷": "行楷-简", "雅痞": "雅痞-简", "圆体": "圆体-简" }; }
			]);
		return Text;
	})(Sprite)


	/**
	*<p> <code>Stage</code> 是舞台类，显示列表的根节点，所有显示对象都在舞台上显示。通过 Laya.stage 单例访问。</p>
	*<p>Stage提供几种适配模式，不同的适配模式会产生不同的画布大小，画布越大，渲染压力越大，所以要选择合适的适配方案。</p>
	*<p>Stage提供不同的帧率模式，帧率越高，渲染压力越大，越费电，合理使用帧率甚至动态更改帧率有利于改进手机耗电。</p>
	*/
	//class laya.display.Stage extends laya.display.Sprite
	var Stage = (function (_super) {
		function Stage() {
			/**当前焦点对象，此对象会影响当前键盘事件的派发主体。*/
			this.focus = null;
			/**设计宽度（初始化时设置的宽度Laya.init(width,height)）*/
			this.designWidth = 0;
			/**设计高度（初始化时设置的高度Laya.init(width,height)）*/
			this.designHeight = 0;
			/**画布是否发生翻转。*/
			this.canvasRotation = false;
			/**画布的旋转角度。*/
			this.canvasDegree = 0;
			/**
			*<p>设置是否渲染，设置为false，可以停止渲染，画面会停留到最后一次渲染上，减少cpu消耗，此设置不影响时钟。</p>
			*<p>比如非激活状态，可以设置renderingEnabled=true以节省消耗。</p>
			**/
			this.renderingEnabled = true;
			/**是否启用屏幕适配，可以适配后，在某个时候关闭屏幕适配，防止某些操作导致的屏幕以外改变*/
			this.screenAdaptationEnabled = true;
			/**@private */
			this._screenMode = "none";
			/**@private */
			this._scaleMode = "noscale";
			/**@private */
			this._alignV = "top";
			/**@private */
			this._alignH = "left";
			/**@private */
			this._bgColor = "black";
			/**@private */
			this._mouseMoveTime = 0;
			/**@private */
			this._renderCount = 0;
			/**@private */
			this._frameStartTime = NaN;
			/**@private */
			this._isFocused = false;
			/**@private */
			this._isVisibility = false;
			/**@private 3D场景*/
			this._scenes = null;
			/**@private */
			this._frameRate = "fast";
			Stage.__super.call(this);
			this.offset = new Point();
			this._canvasTransform = new Matrix();
			this._previousOrientation = Browser.window.orientation;
			var _$this = this;
			this.transform = Matrix.create();
			this._scenes = [];
			this.mouseEnabled = true;
			this.hitTestPrior = true;
			this.autoSize = false;
			this._displayedInStage = true;
			this._isFocused = true;
			this._isVisibility = true;
			var window = Browser.window;
			var _this = this;
			window.addEventListener("focus", function () {
				_$this._isFocused = true;
				_this.event(/*laya.events.Event.FOCUS*/"focus");
				_this.event(/*laya.events.Event.FOCUS_CHANGE*/"focuschange");
			});
			window.addEventListener("blur", function () {
				_$this._isFocused = false;
				_this.event(/*laya.events.Event.BLUR*/"blur");
				_this.event(/*laya.events.Event.FOCUS_CHANGE*/"focuschange");
				if (_this._isInputting()) Input["inputElement"].target.focus = false;
			});
			var hidden = "hidden", state = "visibilityState", visibilityChange = "visibilitychange";
			var document = window.document;
			if (typeof document.hidden !== "undefined") {
				visibilityChange = "visibilitychange";
				state = "visibilityState";
			} else if (typeof document.mozHidden !== "undefined") {
				visibilityChange = "mozvisibilitychange";
				state = "mozVisibilityState";
			} else if (typeof document.msHidden !== "undefined") {
				visibilityChange = "msvisibilitychange";
				state = "msVisibilityState";
			} else if (typeof document.webkitHidden !== "undefined") {
				visibilityChange = "webkitvisibilitychange";
				state = "webkitVisibilityState";
			}
			window.document.addEventListener(visibilityChange, visibleChangeFun);
			function visibleChangeFun() {
				if (Browser.document[state] == "hidden") {
					_this._setStageVisible(false);
				} else {
					_this._setStageVisible(true);
				}
			}
			window.document.addEventListener("qbrowserVisibilityChange", qbroserVisibleChangeFun);
			function qbroserVisibleChangeFun(e) {
				_this._setStageVisible(!e.hidden);
			}
			window.addEventListener("resize", function () {
				var orientation = Browser.window.orientation;
				if (orientation != null && orientation != _$this._previousOrientation && _this._isInputting()) {
					Input["inputElement"].target.focus = false;
				}
				_$this._previousOrientation = orientation;
				if (_this._isInputting()) return;
				_this._resetCanvas();
			});
			window.addEventListener("orientationchange", function (e) {
				_this._resetCanvas();
			});
			this.on(/*laya.events.Event.MOUSE_MOVE*/"mousemove", this, this._onmouseMove);
			if (Browser.onMobile) this.on(/*laya.events.Event.MOUSE_DOWN*/"mousedown", this, this._onmouseMove);
		}

		__class(Stage, 'laya.display.Stage', _super);
		var __proto = Stage.prototype;
		__proto._setStageVisible = function (value) {
			if (this._isVisibility == value) return;
			this._isVisibility = value;
			if (!this._isVisibility) if (this._isInputting()) Input["inputElement"].target.focus = false;
			this.event(/*laya.events.Event.VISIBILITY_CHANGE*/"visibilitychange");
		}

		/**
		*@private
		*在移动端输入时，输入法弹出期间不进行画布尺寸重置。
		*/
		__proto._isInputting = function () {
			return (Browser.onMobile && Input.isInputting);
		}

		/**@private */
		__proto._changeCanvasSize = function () {
			this.setScreenSize(Browser.clientWidth * Browser.pixelRatio, Browser.clientHeight * Browser.pixelRatio);
		}

		/**@private */
		__proto._resetCanvas = function () {
			if (!this.screenAdaptationEnabled) return;
			var canvas = Render._mainCanvas;
			var canvasStyle = canvas.source.style;
			canvas.size(1, 1);
			Laya.timer.once(100, this, this._changeCanvasSize);
		}

		/**
		*设置屏幕大小，场景会根据屏幕大小进行适配。可以动态调用此方法，来更改游戏显示的大小。
		*@param screenWidth 屏幕宽度。
		*@param screenHeight 屏幕高度。
		*/
		__proto.setScreenSize = function (screenWidth, screenHeight) {
			var rotation = false;
			if (this._screenMode !== "none") {
				var screenType = screenWidth / screenHeight < 1 ? "vertical" : "horizontal";
				rotation = screenType !== this._screenMode;
				if (rotation) {
					var temp = screenHeight;
					screenHeight = screenWidth;
					screenWidth = temp;
				}
			}
			this.canvasRotation = rotation;
			var canvas = Render._mainCanvas;
			var canvasStyle = canvas.source.style;
			var mat = this._canvasTransform.identity();
			var scaleMode = this._scaleMode;
			var scaleX = screenWidth / this.designWidth;
			var scaleY = screenHeight / this.designHeight;
			var canvasWidth = this.designWidth;
			var canvasHeight = this.designHeight;
			var realWidth = screenWidth;
			var realHeight = screenHeight;
			var pixelRatio = Browser.pixelRatio;
			this._width = this.designWidth;
			this._height = this.designHeight;
			switch (scaleMode) {
				case "noscale":
					scaleX = scaleY = 1;
					realWidth = this.designWidth;
					realHeight = this.designHeight;
					break;
				case "showall":
					scaleX = scaleY = Math.min(scaleX, scaleY);
					canvasWidth = realWidth = Math.round(this.designWidth * scaleX);
					canvasHeight = realHeight = Math.round(this.designHeight * scaleY);
					break;
				case "noborder":
					scaleX = scaleY = Math.max(scaleX, scaleY);
					realWidth = Math.round(this.designWidth * scaleX);
					realHeight = Math.round(this.designHeight * scaleY);
					break;
				case "full":
					scaleX = scaleY = 1;
					this._width = canvasWidth = screenWidth;
					this._height = canvasHeight = screenHeight;
					break;
				case "fixedwidth":
					scaleY = scaleX;
					this._height = canvasHeight = Math.round(screenHeight / scaleX);
					break;
				case "fixedheight":
					scaleX = scaleY;
					this._width = canvasWidth = Math.round(screenWidth / scaleY);
					break;
				case "fixedauto":
					if ((screenWidth / screenHeight) < (this.designWidth / this.designHeight)) {
						scaleY = scaleX;
						this._height = canvasHeight = Math.round(screenHeight / scaleX);
					} else {
						scaleX = scaleY;
						this._width = canvasWidth = Math.round(screenWidth / scaleY);
					}
					break;
			}
			if (this.conchModel) this.conchModel.size(this._width, this._height);
			scaleX *= this.scaleX;
			scaleY *= this.scaleY;
			if (scaleX === 1 && scaleY === 1) {
				this.transform.identity();
			} else {
				this.transform.a = this._formatData(scaleX / (realWidth / canvasWidth));
				this.transform.d = this._formatData(scaleY / (realHeight / canvasHeight));
				this.conchModel && this.conchModel.scale(this.transform.a, this.transform.d);
			}
			canvas.size(canvasWidth, canvasHeight);
			RunDriver.changeWebGLSize(canvasWidth, canvasHeight);
			mat.scale(realWidth / canvasWidth / pixelRatio, realHeight / canvasHeight / pixelRatio);
			if (this._alignH === "left") this.offset.x = 0;
			else if (this._alignH === "right") this.offset.x = screenWidth - realWidth;
			else this.offset.x = (screenWidth - realWidth) * 0.5 / pixelRatio;
			if (this._alignV === "top") this.offset.y = 0;
			else if (this._alignV === "bottom") this.offset.y = screenHeight - realHeight;
			else this.offset.y = (screenHeight - realHeight) * 0.5 / pixelRatio;
			this.offset.x = Math.round(this.offset.x);
			this.offset.y = Math.round(this.offset.y);
			mat.translate(this.offset.x, this.offset.y);
			this.canvasDegree = 0;
			if (rotation) {
				if (this._screenMode === "horizontal") {
					mat.rotate(Math.PI / 2);
					mat.translate(screenHeight / pixelRatio, 0);
					this.canvasDegree = 90;
				} else {
					mat.rotate(-Math.PI / 2);
					mat.translate(0, screenWidth / pixelRatio);
					this.canvasDegree = -90;
				}
			}
			mat.a = this._formatData(mat.a);
			mat.d = this._formatData(mat.d);
			mat.tx = this._formatData(mat.tx);
			mat.ty = this._formatData(mat.ty);
			canvasStyle.transformOrigin = canvasStyle.webkitTransformOrigin = canvasStyle.msTransformOrigin = canvasStyle.mozTransformOrigin = canvasStyle.oTransformOrigin = "0px 0px 0px";
			canvasStyle.transform = canvasStyle.webkitTransform = canvasStyle.msTransform = canvasStyle.mozTransform = canvasStyle.oTransform = "matrix(" + mat.toString() + ")";
			mat.translate(parseInt(canvasStyle.left) || 0, parseInt(canvasStyle.top) || 0);
			this.visible = true;
			this._repaint = 1;
			this.event(/*laya.events.Event.RESIZE*/"resize");
		}

		/**@private */
		__proto._formatData = function (value) {
			if (Math.abs(value) < 0.000001) return 0;
			if (Math.abs(1 - value) < 0.001) return value > 0 ? 1 : -1;
			return value;
		}

		/**@inheritDoc */
		__proto.getMousePoint = function () {
			return Point.TEMP.setTo(this.mouseX, this.mouseY);
		}

		/**@inheritDoc */
		__proto.repaint = function () {
			this._repaint = 1;
		}

		/**@inheritDoc */
		__proto.parentRepaint = function () { }
		/**@private */
		__proto._loop = function () {
			this.render(Render.context, 0, 0);
			return true;
		}

		/**@private */
		__proto._onmouseMove = function (e) {
			this._mouseMoveTime = Browser.now();
		}

		/**
		*<p>获得距当前帧开始后，过了多少时间，单位为毫秒。</p>
		*<p>可以用来判断函数内时间消耗，通过合理控制每帧函数处理消耗时长，避免一帧做事情太多，对复杂计算分帧处理，能有效降低帧率波动。</p>
		*/
		__proto.getTimeFromFrameStart = function () {
			return Browser.now() - this._frameStartTime;
		}

		/**@inheritDoc */
		__proto.render = function (context, x, y) {
			if (this._frameRate === "sleep" && !Render.isConchApp) {
				var now = Browser.now();
				if (now - this._frameStartTime >= 1000) this._frameStartTime = now;
				else return;
			}
			this._renderCount++;
			Render.isFlash && this.repaint();
			if (!this._style.visible) {
				if (this._renderCount % 5 === 0) {
					Stat.loopCount++;
					MouseManager.instance.runEvent();
					Laya.timer._update();
				}
				return;
			}
			this._frameStartTime = Browser.now();
			var frameMode = this._frameRate === "mouse" ? (((this._frameStartTime - this._mouseMoveTime) < 2000) ? "fast" : "slow") : this._frameRate;
			var isFastMode = (frameMode !== "slow");
			var isDoubleLoop = (this._renderCount % 2 === 0);
			Stat.renderSlow = !isFastMode;
			if (isFastMode || isDoubleLoop || Render.isConchApp) {
				Stat.loopCount++;
				MouseManager.instance.runEvent();
				Laya.timer._update();
				RunDriver.update3DLoop();
				var scene;
				var i = 0, n = 0;
				if (Render.isConchNode) {
					for (i = 0, n = this._scenes.length; i < n; i++) {
						scene = this._scenes[i];
						(scene) && (scene._updateSceneConch());
					}
				} else {
					for (i = 0, n = this._scenes.length; i < n; i++) {
						scene = this._scenes[i];
						(scene) && (scene._updateScene());
					}
				}
				if (Render.isConchNode) {
					var customList = Sprite["CustomList"];
					for (i = 0, n = customList.length; i < n; i++) {
						var customItem = customList[i];
						customItem.customRender(customItem.customContext, 0, 0);
					}
					return;
				}
			}
			if (Render.isConchNode) return;
			if (this.renderingEnabled && (isFastMode || !isDoubleLoop)) {
				if (Render.isWebGL) {
					context.clear();
					_super.prototype.render.call(this, context, x, y);
					Stat._show && Stat._sp && Stat._sp.render(context, x, y);
					RunDriver.clear(this._bgColor);
					RunDriver.beginFlush();
					context.flush();
					RunDriver.endFinish();
					VectorGraphManager.instance && VectorGraphManager.getInstance().endDispose();
				} else {
					RunDriver.clear(this._bgColor);
					_super.prototype.render.call(this, context, x, y);
					Stat._show && Stat._sp && Stat._sp.render(context, x, y);
				}
			}
		}

		/**@private */
		__proto._requestFullscreen = function () {
			var element = Browser.document.documentElement;
			if (element.requestFullscreen) {
				element.requestFullscreen();
			} else if (element.mozRequestFullScreen) {
				element.mozRequestFullScreen();
			} else if (element.webkitRequestFullscreen) {
				element.webkitRequestFullscreen();
			} else if (element.msRequestFullscreen) {
				element.msRequestFullscreen();
			}
		}

		/**@private */
		__proto._fullScreenChanged = function () {
			Laya.stage.event(/*laya.events.Event.FULL_SCREEN_CHANGE*/"fullscreenchange");
		}

		/**退出全屏模式*/
		__proto.exitFullscreen = function () {
			var document = Browser.document;
			if (document.exitFullscreen) {
				document.exitFullscreen();
			} else if (document.mozCancelFullScreen) {
				document.mozCancelFullScreen();
			} else if (document.webkitExitFullscreen) {
				document.webkitExitFullscreen();
			}
		}

		/**当前视窗由缩放模式导致的 X 轴缩放系数。*/
		__getset(0, __proto, 'clientScaleX', function () {
			return this._transform ? this._transform.getScaleX() : 1;
		});

		//[Deprecated]
		__getset(0, __proto, 'desginHeight', function () {
			console.debug("desginHeight已经弃用，请使用designHeight代替");
			return this.designHeight;
		});

		/**帧率类型，支持三种模式：fast-60帧(默认)，slow-30帧，mouse-30帧（鼠标活动后会自动加速到60，鼠标不动2秒后降低为30帧，以节省消耗），sleep-1帧。*/
		__getset(0, __proto, 'frameRate', function () {
			return this._frameRate;
		}, function (value) {
			this._frameRate = value;
			if (Render.isConchApp) {
				switch (this._frameRate) {
					case "slow":
						Browser.window.conch && Browser.window.conchConfig.setSlowFrame && Browser.window.conchConfig.setSlowFrame(true);
						break;
					case "fast":
						Browser.window.conch && Browser.window.conchConfig.setSlowFrame && Browser.window.conchConfig.setSlowFrame(false);
						break;
					case "mouse":
						Browser.window.conch && Browser.window.conchConfig.setMouseFrame && Browser.window.conchConfig.setMouseFrame(2000);
						break;
					case "sleep":
						Browser.window.conch && Browser.window.conchConfig.setLimitFPS && Browser.window.conchConfig.setLimitFPS(1);
						break;
					default:
						throw new Error("Stage:frameRate invalid.");
						break;
				}
			}
		});

		/**当前视窗由缩放模式导致的 Y 轴缩放系数。*/
		__getset(0, __proto, 'clientScaleY', function () {
			return this._transform ? this._transform.getScaleY() : 1;
		});

		__getset(0, __proto, 'width', _super.prototype._$get_width, function (value) {
			this.designWidth = value;
			Laya.superSet(Sprite, this, 'width', value);
			Laya.timer.callLater(this, this._changeCanvasSize);
		});

		/**
		*<p>水平对齐方式。默认值为"left"。</p>
		*<p><ul>取值范围：
		*<li>"left" ：居左对齐；</li>
		*<li>"center" ：居中对齐；</li>
		*<li>"right" ：居右对齐；</li>
		*</ul></p>
		*/
		__getset(0, __proto, 'alignH', function () {
			return this._alignH;
		}, function (value) {
			this._alignH = value;
			Laya.timer.callLater(this, this._changeCanvasSize);
		});

		/**
		*舞台是否获得焦点。
		*/
		__getset(0, __proto, 'isFocused', function () {
			return this._isFocused;
		});

		__getset(0, __proto, 'height', _super.prototype._$get_height, function (value) {
			this.designHeight = value;
			Laya.superSet(Sprite, this, 'height', value);
			Laya.timer.callLater(this, this._changeCanvasSize);
		});

		__getset(0, __proto, 'transform', function () {
			if (this._tfChanged) this._adjustTransform();
			return this._transform = this._transform || Matrix.create();
		}, _super.prototype._$set_transform);

		/**
		*舞台是否处于可见状态(是否进入后台)。
		*/
		__getset(0, __proto, 'isVisibility', function () {
			return this._isVisibility;
		});

		//[Deprecated]
		__getset(0, __proto, 'desginWidth', function () {
			console.debug("desginWidth已经弃用，请使用designWidth代替");
			return this.designWidth;
		});

		/**
		*<p>缩放模式。默认值为 "noscale"。</p>
		*<p><ul>取值范围：
		*<li>"noscale" ：不缩放；</li>
		*<li>"exactfit" ：全屏不等比缩放；</li>
		*<li>"showall" ：最小比例缩放；</li>
		*<li>"noborder" ：最大比例缩放；</li>
		*<li>"full" ：不缩放，stage的宽高等于屏幕宽高；</li>
		*<li>"fixedwidth" ：宽度不变，高度根据屏幕比缩放；</li>
		*<li>"fixedheight" ：高度不变，宽度根据屏幕比缩放；</li>
		*<li>"fixedauto" ：根据宽高比，自动选择使用fixedwidth或fixedheight；</li>
		*</ul></p>
		*/
		__getset(0, __proto, 'scaleMode', function () {
			return this._scaleMode;
		}, function (value) {
			this._scaleMode = value;
			Laya.timer.callLater(this, this._changeCanvasSize);
		});

		/**
		*<p>垂直对齐方式。默认值为"top"。</p>
		*<p><ul>取值范围：
		*<li>"top" ：居顶部对齐；</li>
		*<li>"middle" ：居中对齐；</li>
		*<li>"bottom" ：居底部对齐；</li>
		*</ul></p>
		*/
		__getset(0, __proto, 'alignV', function () {
			return this._alignV;
		}, function (value) {
			this._alignV = value;
			Laya.timer.callLater(this, this._changeCanvasSize);
		});

		/**舞台的背景颜色，默认为黑色，null为透明。*/
		__getset(0, __proto, 'bgColor', function () {
			return this._bgColor;
		}, function (value) {
			this._bgColor = value;
			this.conchModel && this.conchModel.bgColor(value);
			if (Render.isWebGL) {
				if (value && value !== "black" && value !== "#000000") {
					Stage._wgColor = Color.create(value)._color;
				} else {
					if (!Browser.onMiniGame) Stage._wgColor = null;
				}
			}
			if (Browser.onLimixiu) {
				Stage._wgColor = Color.create(value)._color;
			} else
				if (value) {
					Render.canvas.style.background = value;
				} else {
					Render.canvas.style.background = "none";
				}
		});

		/**鼠标在 Stage 上的 X 轴坐标。*/
		__getset(0, __proto, 'mouseX', function () {
			return Math.round(MouseManager.instance.mouseX / this.clientScaleX);
		});

		/**鼠标在 Stage 上的 Y 轴坐标。*/
		__getset(0, __proto, 'mouseY', function () {
			return Math.round(MouseManager.instance.mouseY / this.clientScaleY);
		});

		/**
		*<p>场景布局类型。</p>
		*<p><ul>取值范围：
		*<li>"none" ：不更改屏幕</li>
		*<li>"horizontal" ：自动横屏</li>
		*<li>"vertical" ：自动竖屏</li>
		*</ul></p>
		*/
		__getset(0, __proto, 'screenMode', function () {
			return this._screenMode;
		}, function (value) {
			this._screenMode = value;
		});

		__getset(0, __proto, 'visible', _super.prototype._$get_visible, function (value) {
			if (this.visible !== value) {
				Laya.superSet(Sprite, this, 'visible', value);
				var style = Render._mainCanvas.source.style;
				style.visibility = value ? "visible" : "hidden";
			}
		});

		/**
		*<p>是否开启全屏，用户点击后进入全屏。</p>
		*<p>兼容性提示：部分浏览器不允许点击进入全屏，比如Iphone等。</p>
		*/
		__getset(0, __proto, 'fullScreenEnabled', null, function (value) {
			var document = Browser.document;
			var canvas = Render.canvas;
			if (value) {
				canvas.addEventListener('mousedown', this._requestFullscreen);
				canvas.addEventListener('touchstart', this._requestFullscreen);
				document.addEventListener("fullscreenchange", this._fullScreenChanged);
				document.addEventListener("mozfullscreenchange", this._fullScreenChanged);
				document.addEventListener("webkitfullscreenchange", this._fullScreenChanged);
				document.addEventListener("msfullscreenchange", this._fullScreenChanged);
			} else {
				canvas.removeEventListener('mousedown', this._requestFullscreen);
				canvas.removeEventListener('touchstart', this._requestFullscreen);
				document.removeEventListener("fullscreenchange", this._fullScreenChanged);
				document.removeEventListener("mozfullscreenchange", this._fullScreenChanged);
				document.removeEventListener("webkitfullscreenchange", this._fullScreenChanged);
				document.removeEventListener("msfullscreenchange", this._fullScreenChanged);
			}
		});

		Stage.SCALE_NOSCALE = "noscale";
		Stage.SCALE_EXACTFIT = "exactfit";
		Stage.SCALE_SHOWALL = "showall";
		Stage.SCALE_NOBORDER = "noborder";
		Stage.SCALE_FULL = "full";
		Stage.SCALE_FIXED_WIDTH = "fixedwidth";
		Stage.SCALE_FIXED_HEIGHT = "fixedheight";
		Stage.SCALE_FIXED_AUTO = "fixedauto";
		Stage.ALIGN_LEFT = "left";
		Stage.ALIGN_RIGHT = "right";
		Stage.ALIGN_CENTER = "center";
		Stage.ALIGN_TOP = "top";
		Stage.ALIGN_MIDDLE = "middle";
		Stage.ALIGN_BOTTOM = "bottom";
		Stage.SCREEN_NONE = "none";
		Stage.SCREEN_HORIZONTAL = "horizontal";
		Stage.SCREEN_VERTICAL = "vertical";
		Stage.FRAME_FAST = "fast";
		Stage.FRAME_SLOW = "slow";
		Stage.FRAME_MOUSE = "mouse";
		Stage.FRAME_SLEEP = "sleep";
		Stage._wgColor = null;
		Stage.FRAME_MOUSE_THREDHOLD = 2000;
		return Stage;
	})(Sprite)


	/**
	*@private
	*/
	//class laya.media.SoundNode extends laya.display.Sprite
	var SoundNode = (function (_super) {
		function SoundNode() {
			this.url = null;
			this._channel = null;
			this._tar = null;
			this._playEvents = null;
			this._stopEvents = null;
			SoundNode.__super.call(this);
			this.visible = false;
			this.on(/*laya.events.Event.ADDED*/"added", this, this._onParentChange);
			this.on(/*laya.events.Event.REMOVED*/"removed", this, this._onParentChange);
		}

		__class(SoundNode, 'laya.media.SoundNode', _super);
		var __proto = SoundNode.prototype;
		/**@private */
		__proto._onParentChange = function () {
			this.target = this.parent;
		}

		/**
		*播放
		*@param loops 循环次数
		*@param complete 完成回调
		*
		*/
		__proto.play = function (loops, complete) {
			(loops === void 0) && (loops = 1);
			if (isNaN(loops)) {
				loops = 1;
			}
			if (!this.url) return;
			this.stop();
			this._channel = SoundManager.playSound(this.url, loops, complete);
		}

		/**
		*停止播放
		*
		*/
		__proto.stop = function () {
			if (this._channel && !this._channel.isStopped) {
				this._channel.stop();
			}
			this._channel = null;
		}

		/**@private */
		__proto._setPlayAction = function (tar, event, action, add) {
			(add === void 0) && (add = true);
			if (!this[action]) return;
			if (!tar) return;
			if (add) {
				tar.on(event, this, this[action]);
			} else {
				tar.off(event, this, this[action]);
			}
		}

		/**@private */
		__proto._setPlayActions = function (tar, events, action, add) {
			(add === void 0) && (add = true);
			if (!tar) return;
			if (!events) return;
			var eventArr = events.split(",");
			var i = 0, len = 0;
			len = eventArr.length;
			for (i = 0; i < len; i++) {
				this._setPlayAction(tar, eventArr[i], action, add);
			}
		}

		/**
		*设置触发播放的事件
		*@param events
		*
		*/
		__getset(0, __proto, 'playEvent', null, function (events) {
			this._playEvents = events;
			if (!events) return;
			if (this._tar) {
				this._setPlayActions(this._tar, events, "play");
			}
		});

		/**
		*设置控制播放的对象
		*@param tar
		*
		*/
		__getset(0, __proto, 'target', null, function (tar) {
			if (this._tar) {
				this._setPlayActions(this._tar, this._playEvents, "play", false);
				this._setPlayActions(this._tar, this._stopEvents, "stop", false);
			}
			this._tar = tar;
			if (this._tar) {
				this._setPlayActions(this._tar, this._playEvents, "play", true);
				this._setPlayActions(this._tar, this._stopEvents, "stop", true);
			}
		});

		/**
		*设置触发停止的事件
		*@param events
		*
		*/
		__getset(0, __proto, 'stopEvent', null, function (events) {
			this._stopEvents = events;
			if (!events) return;
			if (this._tar) {
				this._setPlayActions(this._tar, events, "stop");
			}
		});

		return SoundNode;
	})(Sprite)


	/**
	*@private
	*<code>FileBitmap</code> 是图片文件资源类。
	*/
	//class laya.resource.FileBitmap extends laya.resource.Bitmap
	var FileBitmap = (function (_super) {
		function FileBitmap() {
			/**@private 文件路径全名。*/
			this._src = null;
			/**@private onload触发函数*/
			this._onload = null;
			/**@private onerror触发函数*/
			this._onerror = null;
			FileBitmap.__super.call(this);
		}

		__class(FileBitmap, 'laya.resource.FileBitmap', _super);
		var __proto = FileBitmap.prototype;
		/**
		*文件路径全名。
		*/
		__getset(0, __proto, 'src', function () {
			return this._src;
		}, function (value) {
			this._src = value;
		});

		/**
		*载入完成处理函数。
		*/
		__getset(0, __proto, 'onload', null, function (value) {
		});

		/**
		*错误处理函数。
		*/
		__getset(0, __proto, 'onerror', null, function (value) {
		});

		return FileBitmap;
	})(Bitmap)


	/**
	*<code>HTMLCanvas</code> 是 Html Canvas 的代理类，封装了 Canvas 的属性和方法。。请不要直接使用 new HTMLCanvas！
	*/
	//class laya.resource.HTMLCanvas extends laya.resource.Bitmap
	var HTMLCanvas = (function (_super) {
		function HTMLCanvas(type, canvas) {
			//this._ctx=null;
			this._is2D = false;
			HTMLCanvas.__super.call(this);
			var _$this = this;
			this._source = this;
			if (type === "2D" || (type === "AUTO" && !Render.isWebGL)) {
				this._is2D = true;
				this._source = canvas || Browser.createElement("canvas");
				this._w = this._source.width;
				this._h = this._source.height;
				var o = this;
				o.getContext = function (contextID, other) {
					if (_$this._ctx) return _$this._ctx;
					var ctx = _$this._ctx = _$this._source.getContext(contextID, other);
					if (ctx) {
						ctx._canvas = o;
						if (!Render.isFlash && !Browser.onLimixiu) ctx.size = function (w, h) {
						};
					}
					return ctx;
				}
			}
			this.lock = true;
		}

		__class(HTMLCanvas, 'laya.resource.HTMLCanvas', _super);
		var __proto = HTMLCanvas.prototype;
		/**
		*清空画布内容。
		*/
		__proto.clear = function () {
			this._ctx && this._ctx.clear();
		}

		/**
		*销毁。
		*/
		__proto.destroy = function () {
			this._ctx && this._ctx.destroy();
			this._ctx = null;
			laya.resource.Resource.prototype.destroy.call(this);
		}

		/**
		*释放。
		*/
		__proto.release = function () { }
		/**
		*@private
		*设置 Canvas 渲染上下文。
		*@param context Canvas 渲染上下文。
		*/
		__proto._setContext = function (context) {
			this._ctx = context;
		}

		/**
		*获取 Canvas 渲染上下文。
		*@param contextID 上下文ID.
		*@param other
		*@return Canvas 渲染上下文 Context 对象。
		*/
		__proto.getContext = function (contextID, other) {
			return this._ctx ? this._ctx : (this._ctx = HTMLCanvas._createContext(this));
		}

		/**
		*获取内存大小。
		*@return 内存大小。
		*/
		__proto.getMemSize = function () {
			return 0;
		}

		/**
		*设置宽高。
		*@param w 宽度。
		*@param h 高度。
		*/
		__proto.size = function (w, h) {
			if (this._w != w || this._h != h || (this._source && (this._source.width != w || this._source.height != h))) {
				this._w = w;
				this._h = h;
				this.memorySize = this._w * this._h * 4;
				this._ctx && this._ctx.size(w, h);
				this._source && (this._source.height = h, this._source.width = w);
			}
		}

		__proto.getCanvas = function () {
			return this._source;
		}

		__proto.toBase64 = function (type, encoderOptions, callBack) {
			if (this._source) {
				if (Render.isConchApp && this._source.toBase64) {
					this._source.toBase64(type, encoderOptions, callBack);
				}
				else {
					var base64Data = this._source.toDataURL(type, encoderOptions);
					callBack.call(this, base64Data);
				}
			}
		}

		/**
		*Canvas 渲染上下文。
		*/
		__getset(0, __proto, 'context', function () {
			return this._ctx;
		});

		/**
		*是否当作 Bitmap 对象。
		*/
		__getset(0, __proto, 'asBitmap', null, function (value) {
		});

		HTMLCanvas.create = function (type, canvas) {
			return new HTMLCanvas(type, canvas);
		}

		HTMLCanvas.TYPE2D = "2D";
		HTMLCanvas.TYPE3D = "3D";
		HTMLCanvas.TYPEAUTO = "AUTO";
		HTMLCanvas._createContext = null;
		return HTMLCanvas;
	})(Bitmap)


	/**
	*@private
	*/
	//class laya.resource.HTMLSubImage extends laya.resource.Bitmap
	var HTMLSubImage = (function (_super) {
		//请不要直接使用new HTMLSubImage
		function HTMLSubImage(canvas, offsetX, offsetY, width, height, atlasImage, src, allowMerageInAtlas) {
			HTMLSubImage.__super.call(this);
			throw new Error("不允许new！");
		}

		__class(HTMLSubImage, 'laya.resource.HTMLSubImage', _super);
		HTMLSubImage.create = function (canvas, offsetX, offsetY, width, height, atlasImage, src, allowMerageInAtlas) {
			(allowMerageInAtlas === void 0) && (allowMerageInAtlas = false);
			return new HTMLSubImage(canvas, offsetX, offsetY, width, height, atlasImage, src, allowMerageInAtlas);
		}

		return HTMLSubImage;
	})(Bitmap)


	/**
	*<p> <code>Animation</code> 是Graphics动画类。实现了基于Graphics的动画创建、播放、控制接口。</p>
	*<p>本类使用了动画模版缓存池，它以一定的内存开销来节省CPU开销，当相同的动画模版被多次使用时，相比于每次都创建新的动画模版，使用动画模版缓存池，只需创建一次，缓存之后多次复用，从而节省了动画模版创建的开销。</p>
	*<p>动画模版缓存池，以key-value键值对存储，key可以自定义，也可以从指定的配置文件中读取，value为对应的动画模版，是一个Graphics对象数组，每个Graphics对象对应一个帧图像，动画的播放实质就是定时切换Graphics对象。</p>
	*<p>使用set source、loadImages(...)、loadAtlas(...)、loadAnimation(...)方法可以创建动画模版。使用play(...)可以播放指定动画。</p>
	*@example <caption>以下示例代码，创建了一个 <code>Text</code> 实例。</caption>
	*package
	*{
		*import laya.display.Animation;
		*import laya.net.Loader;
		*import laya.utils.Handler;
		*public class Animation_Example
		*{
			*public function Animation_Example()
			*{
				*Laya.init(640,800);//设置游戏画布宽高、渲染模式。
				*Laya.stage.bgColor="#efefef";//设置画布的背景颜色。
				*init();//初始化
				*}
			*private function init():void
			*{
				*var animation:Animation=new Animation();//创建一个 Animation 类的实例对象 animation 。
				*animation.loadAtlas("resource/ani/fighter.json");//加载图集并播放
				*animation.x=200;//设置 animation 对象的属性 x 的值，用于控制 animation 对象的显示位置。
				*animation.y=200;//设置 animation 对象的属性 x 的值，用于控制 animation 对象的显示位置。
				*animation.interval=50;//设置 animation 对象的动画播放间隔时间，单位：毫秒。
				*animation.play();//播放动画。
				*Laya.stage.addChild(animation);//将 animation 对象添加到显示列表。
				*}
			*}
		*}
	*
	*@example
	*Animation_Example();
	*function Animation_Example(){
		*Laya.init(640,800);//设置游戏画布宽高、渲染模式。
		*Laya.stage.bgColor="#efefef";//设置画布的背景颜色。
		*init();//初始化
		*}
	*function init()
	*{
		*var animation=new Laya.Animation();//创建一个 Animation 类的实例对象 animation 。
		*animation.loadAtlas("resource/ani/fighter.json");//加载图集并播放
		*animation.x=200;//设置 animation 对象的属性 x 的值，用于控制 animation 对象的显示位置。
		*animation.y=200;//设置 animation 对象的属性 x 的值，用于控制 animation 对象的显示位置。
		*animation.interval=50;//设置 animation 对象的动画播放间隔时间，单位：毫秒。
		*animation.play();//播放动画。
		*Laya.stage.addChild(animation);//将 animation 对象添加到显示列表。
		*}
	*
	*@example
	*import Animation=laya.display.Animation;
	*class Animation_Example {
		*constructor(){
			*Laya.init(640,800);//设置游戏画布宽高、渲染模式。
			*Laya.stage.bgColor="#efefef";//设置画布的背景颜色。
			*this.init();
			*}
		*private init():void {
			*var animation:Animation=new Laya.Animation();//创建一个 Animation 类的实例对象 animation 。
			*animation.loadAtlas("resource/ani/fighter.json");//加载图集并播放
			*animation.x=200;//设置 animation 对象的属性 x 的值，用于控制 animation 对象的显示位置。
			*animation.y=200;//设置 animation 对象的属性 x 的值，用于控制 animation 对象的显示位置。
			*animation.interval=50;//设置 animation 对象的动画播放间隔时间，单位：毫秒。
			*animation.play();//播放动画。
			*Laya.stage.addChild(animation);//将 animation 对象添加到显示列表。
			*}
		*}
	*new Animation_Example();
	*/
	//class laya.display.Animation extends laya.display.AnimationPlayerBase
	var Animation = (function (_super) {
		function Animation() {
			/**@private */
			this._frames = null;
			/**@private */
			this._url = null;
			Animation.__super.call(this);
			this._setControlNode(this);
		}

		__class(Animation, 'laya.display.Animation', _super);
		var __proto = Animation.prototype;
		/**@inheritDoc */
		__proto.destroy = function (destroyChild) {
			(destroyChild === void 0) && (destroyChild = true);
			this.stop();
			laya.display.Sprite.prototype.destroy.call(this, destroyChild);
			this._frames = null;
			this._labels = null;
		}

		/**
		*<p>开始播放动画。会在动画模版缓存池中查找key值为name的动画模版，存在则用此动画模版初始化当前序列帧， 如果不存在，则使用当前序列帧。</p>
		*<p>play(...)方法被设计为在创建实例后的任何时候都可以被调用，调用后就处于播放状态，当相应的资源加载完毕、调用动画帧填充方法(set frames)或者将实例显示在舞台上时，会判断是否处于播放状态，如果是，则开始播放。</p>
		*<p>配合wrapMode属性，可设置动画播放顺序类型。</p>
		*@param start （可选）指定动画播放开始的索引(int)或帧标签(String)。帧标签可以通过addLabel(...)和removeLabel(...)进行添加和删除。
		*@param loop （可选）是否循环播放。
		*@param name （可选）动画模板在动画模版缓存池中的key，也可认为是动画名称。如果name为空，则播放当前动画序列帧；如果不为空，则在动画模版缓存池中寻找key值为name的动画模版，如果存在则用此动画模版初始化当前序列帧并播放，如果不存在，则仍然播放当前动画序列帧；如果没有当前动画的帧数据，则不播放，但该实例仍然处于播放状态。
		*@param showWarn（可选）是否动画不存在时打印警告
		*/
		__proto.play = function (start, loop, name, showWarn) {
			(start === void 0) && (start = 0);
			(loop === void 0) && (loop = true);
			(name === void 0) && (name = "");
			(showWarn === void 0) && (showWarn = true);
			if (name) this._setFramesFromCache(name, showWarn);
			this._isPlaying = true;
			this.index = ((typeof start == 'string')) ? this._getFrameByLabel(start) : start;
			this.loop = loop;
			this._actionName = name;
			this._isReverse = this.wrapMode == 1;
			if (this._frames && this.interval > 0) {
				this.timerLoop(this.interval, this, this._frameLoop, null, true, true);
			}
		}

		/**@private */
		__proto._setFramesFromCache = function (name, showWarn) {
			(showWarn === void 0) && (showWarn = false);
			if (this._url) name = this._url + "#" + name;
			if (name && Animation.framesMap[name]) {
				var tAniO;
				tAniO = Animation.framesMap[name];
				if ((tAniO instanceof Array)) {
					this._frames = Animation.framesMap[name];
					this._count = this._frames.length;
				} else {
					if (tAniO.nodeRoot) {
						Animation.framesMap[name] = this._parseGraphicAnimationByData(tAniO);
						tAniO = Animation.framesMap[name];
					}
					this._frames = tAniO.frames;
					this._count = this._frames.length;
					if (!this._frameRateChanged) this._interval = tAniO.interval;
					this._labels = this._copyLabels(tAniO.labels);
				}
				return true;
			} else {
				if (showWarn) console.log("ani not found:", name);
			}
			return false;
		}

		/**@private */
		__proto._copyLabels = function (labels) {
			if (!labels) return null;
			var rst;
			rst = {};
			var key;
			for (key in labels) {
				rst[key] = Utils.copyArray([], labels[key]);
			}
			return rst;
		}

		/**@private */
		__proto._frameLoop = function () {
			if (this._style.visible && this._style.alpha > 0.01) {
				_super.prototype._frameLoop.call(this);
			}
		}

		/**@private */
		__proto._displayToIndex = function (value) {
			if (this._frames) this.graphics = this._frames[value];
		}

		/**
		*停止动画播放，并清理对象属性。之后可存入对象池，方便对象复用。
		*/
		__proto.clear = function () {
			this.stop();
			this.graphics = null;
			this._frames = null;
			this._labels = null;
		}

		/**
		*<p>根据指定的动画模版初始化当前动画序列帧。选择动画模版的过程如下：1. 动画模版缓存池中key为cacheName的动画模版；2. 如果不存在，则加载指定的图片集合并创建动画模版。注意：只有指定不为空的cacheName，才能将创建好的动画模版以此为key缓存到动画模版缓存池，否则不进行缓存。</p>
		*<p>动画模版缓存池是以一定的内存开销来节省CPU开销，当相同的动画模版被多次使用时，相比于每次都创建新的动画模版，使用动画模版缓存池，只需创建一次，缓存之后多次复用，从而节省了动画模版创建的开销。</p>
		*<p>因为返回值为Animation对象本身，所以可以使用如下语法：ani.loadImages(...).loadImages(...).play(...);。</p>
		*@param urls 图片路径集合。需要创建动画模版时，会以此为数据源。参数形如：[url1,url2,url3,...]。
		*@param cacheName （可选）动画模板在动画模版缓存池中的key。如果此参数不为空，表示使用动画模版缓存池。如果动画模版缓存池中存在key为cacheName的动画模版，则使用此模版。否则，创建新的动画模版，如果cacheName不为空，则以cacheName为key缓存到动画模版缓存池中，如果cacheName为空，不进行缓存。
		*@return 返回Animation对象本身。
		*/
		__proto.loadImages = function (urls, cacheName) {
			(cacheName === void 0) && (cacheName = "");
			this._url = "";
			if (!this._setFramesFromCache(cacheName)) {
				this.frames = Animation.framesMap[cacheName] ? Animation.framesMap[cacheName] : Animation.createFrames(urls, cacheName);
			}
			return this;
		}

		/**
		*<p>根据指定的动画模版初始化当前动画序列帧。选择动画模版的过程如下：1. 动画模版缓存池中key为cacheName的动画模版；2. 如果不存在，则加载指定的图集并创建动画模版。</p>
		*<p>注意：只有指定不为空的cacheName，才能将创建好的动画模版以此为key缓存到动画模版缓存池，否则不进行缓存。</p>
		*<p>动画模版缓存池是以一定的内存开销来节省CPU开销，当相同的动画模版被多次使用时，相比于每次都创建新的动画模版，使用动画模版缓存池，只需创建一次，缓存之后多次复用，从而节省了动画模版创建的开销。</p>
		*<p>因为返回值为Animation对象本身，所以可以使用如下语法：ani.loadAtlas(...).loadAtlas(...).play(...);。</p>
		*@param url 图集路径。需要创建动画模版时，会以此为数据源。
		*@param loaded （可选）使用指定图集初始化动画完毕的回调。
		*@param cacheName （可选）动画模板在动画模版缓存池中的key。如果此参数不为空，表示使用动画模版缓存池。如果动画模版缓存池中存在key为cacheName的动画模版，则使用此模版。否则，创建新的动画模版，如果cacheName不为空，则以cacheName为key缓存到动画模版缓存池中，如果cacheName为空，不进行缓存。
		*@return 返回动画本身。
		*/
		__proto.loadAtlas = function (url, loaded, cacheName) {
			(cacheName === void 0) && (cacheName = "");
			this._url = "";
			var _this_ = this;
			function onLoaded(loadUrl) {
				if (url === loadUrl) {
					_this_.frames = Animation.framesMap[cacheName] ? Animation.framesMap[cacheName] : Animation.createFrames(url, cacheName);
					if (loaded) loaded.run();
				}
			}
			if (!_this_._setFramesFromCache(cacheName)) {
				if (Loader.getAtlas(url)) onLoaded(url);
				else Laya.loader.load(url, Handler.create(null, onLoaded, [url]), null,/*laya.net.Loader.ATLAS*/"atlas");
			}
			return this;
		}

		/**
		*<p>加载并解析由The3Air IDE制作的动画文件，此文件中可能包含多个动画。默认帧率为在IDE中设计的帧率，如果调用过set interval，则使用此帧间隔对应的帧率。加载后创建动画模版，并缓存到动画模版缓存池，key "url#动画名称" 对应相应动画名称的动画模板，key "url#" 对应动画模版集合的默认动画模版。</p>
		*<p>注意：如果调用本方法前，还没有预加载动画使用的图集，请将atlas参数指定为对应的图集路径，否则会导致动画创建失败。</p>
		*<p>动画模版缓存池是以一定的内存开销来节省CPU开销，当相同的动画模版被多次使用时，相比于每次都创建新的动画模版，使用动画模版缓存池，只需创建一次，缓存之后多次复用，从而节省了动画模版创建的开销。</p>
		*<p>因为返回值为Animation对象本身，所以可以使用如下语法：ani.loadAnimation(...).loadAnimation(...).play(...);。</p>
		*@param url 动画文件路径。可由The3Air IDE创建并发布。
		*@param loaded （可选）使用指定动画资源初始化动画完毕的回调。
		*@param atlas （可选）动画用到的图集地址（可选）。
		*@return 返回动画本身。
		*/
		__proto.loadAnimation = function (url, loaded, atlas) {
			this._url = url;
			var _this_ = this;
			if (!this._actionName) this._actionName = "";
			if (!_this_._setFramesFromCache("")) {
				if (!atlas || Loader.getAtlas(atlas)) {
					this._loadAnimationData(url, loaded, atlas);
				} else {
					Laya.loader.load(atlas, Handler.create(this, this._loadAnimationData, [url, loaded, atlas]), null,/*laya.net.Loader.ATLAS*/"atlas")
				}
			} else {
				_this_._setFramesFromCache(this._actionName, true);
				this.index = 0;
				if (loaded) loaded.run();
			}
			return this;
		}

		/**@private */
		__proto._loadAnimationData = function (url, loaded, atlas) {
			var _$this = this;
			if (atlas && !Loader.getAtlas(atlas)) {
				console.warn("atlas load fail:" + atlas);
				return;
			};
			var _this_ = this;
			function onLoaded(loadUrl) {
				if (!Loader.getRes(loadUrl)) return;
				if (url === loadUrl) {
					var tAniO;
					if (!Animation.framesMap[url + "#"]) {
						var aniData = _this_._parseGraphicAnimation(Loader.getRes(url));
						if (!aniData) return;
						var aniList = aniData.animationList;
						var i = 0, len = aniList.length;
						var defaultO;
						for (i = 0; i < len; i++) {
							tAniO = aniList[i];
							Animation.framesMap[url + "#" + tAniO.name] = tAniO;
							if (!defaultO) defaultO = tAniO;
						}
						if (defaultO) {
							Animation.framesMap[url + "#"] = defaultO;
							_this_._setFramesFromCache(_$this._actionName, true);
							_$this.index = 0;
						}
						_$this._checkResumePlaying();
					} else {
						_this_._setFramesFromCache(_$this._actionName, true);
						_$this.index = 0;
						_$this._checkResumePlaying();
					}
					if (loaded) loaded.run();
				}
			}
			if (Loader.getRes(url)) onLoaded(url);
			else Laya.loader.load(url, Handler.create(null, onLoaded, [url]), null,/*laya.net.Loader.JSON*/"json");
			Loader.clearRes(url);
		}

		/**@private */
		__proto._parseGraphicAnimation = function (animationData) {
			return GraphicAnimation.parseAnimationData(animationData);
		}

		/**@private */
		__proto._parseGraphicAnimationByData = function (animationObject) {
			return GraphicAnimation.parseAnimationByData(animationObject);
		}

		/**
		*当前动画的帧图像数组。本类中，每个帧图像是一个Graphics对象，而动画播放就是定时切换Graphics对象的过程。
		*/
		__getset(0, __proto, 'frames', function () {
			return this._frames;
		}, function (value) {
			this._frames = value;
			if (value) {
				this._count = value.length;
				if (this._isPlaying) this.play(this._index, this.loop, this._actionName);
				else this.index = this._index;
			}
		});

		/**
		*是否自动播放，默认为false。如果设置为true，则动画被创建并添加到舞台后自动播放。
		*/
		__getset(0, __proto, 'autoPlay', null, function (value) {
			if (value) this.play();
			else this.stop();
		});

		/**
		*<p>动画数据源。</p>
		*<p>类型如下：<br/>
		*1. The3Air IDE动画文件路径：使用此类型需要预加载所需的图集资源，否则会创建失败，如果不想预加载或者需要创建完毕的回调，请使用loadAnimation(...)方法；<br/>
		*2. 图集路径：使用此类型创建的动画模版不会被缓存到动画模版缓存池中，如果需要缓存或者创建完毕的回调，请使用loadAtlas(...)方法；<br/>
		*3. 图片路径集合：使用此类型创建的动画模版不会被缓存到动画模版缓存池中，如果需要缓存，请使用loadImages(...)方法。</p>
		*@param value 数据源。比如：图集："xx/a1.atlas"；图片集合："a1.png,a2.png,a3.png"；The3Air IDE动画"xx/a1.ani"。
		*/
		__getset(0, __proto, 'source', null, function (value) {
			if (value.indexOf(".ani") > -1) this.loadAnimation(value);
			else if (value.indexOf(".json") > -1 || value.indexOf("als") > -1 || value.indexOf("atlas") > -1) this.loadAtlas(value);
			else this.loadImages(value.split(","));
		});

		/**
		*设置自动播放的动画名称，在The3Air IDE中可以创建的多个动画组成的动画集合，选择其中一个动画名称进行播放。
		*/
		__getset(0, __proto, 'autoAnimation', null, function (value) {
			this.play(0, true, value, false);
		});

		Animation.createFrames = function (url, name) {
			var arr, i = 0, n = 0, g;
			if ((typeof url == 'string')) {
				var atlas = Loader.getAtlas(url);
				if (atlas && atlas.length) {
					arr = [];
					for (i = 0, n = atlas.length; i < n; i++) {
						g = new RunDriver.createGraphics();
						g.drawTexture(Loader.getRes(atlas[i]), 0, 0);
						arr.push(g);
					}
				}
			} else if ((url instanceof Array)) {
				arr = [];
				for (i = 0, n = url.length; i < n; i++) {
					g = new RunDriver.createGraphics();
					g.loadImage(url[i], 0, 0);
					arr.push(g);
				}
			}
			if (name) Animation.framesMap[name] = arr;
			return arr;
		}

		Animation.clearCache = function (key) {
			var cache = Animation.framesMap;
			var val;
			var key2 = key + "#";
			for (val in cache) {
				if (val === key || val.indexOf(key2) == 0) {
					delete Animation.framesMap[val];
				}
			}
		}

		Animation.framesMap = {};
		return Animation;
	})(AnimationPlayerBase)


	/**
	*关键帧动画播放类。
	*/
	//class laya.display.FrameAnimation extends laya.display.AnimationPlayerBase
	var FrameAnimation = (function (_super) {
		function FrameAnimation() {
			/**
			*@private
			*id对象表
			*/
			this._targetDic = null;
			/**
			*@private
			*动画数据
			*/
			this._animationData = null;
			/**@private */
			this._animationNewFrames = null;
			FrameAnimation.__super.call(this);
			if (FrameAnimation._sortIndexFun == null) {
				FrameAnimation._sortIndexFun = MathUtil.sortByKey("index", false, true);
			}
		}

		__class(FrameAnimation, 'laya.display.FrameAnimation', _super);
		var __proto = FrameAnimation.prototype;
		/**
		*@private
		*初始化动画数据
		*@param targetDic 对象表
		*@param animationData 动画数据
		*
		*/
		__proto._setUp = function (targetDic, animationData) {
			this._labels = null;
			this._animationNewFrames = null;
			this._targetDic = targetDic;
			this._animationData = animationData;
			this.interval = 1000 / animationData.frameRate;
			if (animationData.parsed) {
				this._count = animationData.count;
				this._labels = animationData.labels;
				this._animationNewFrames = animationData.animationNewFrames;
			} else {
				this._animationNewFrames = [];
				this._calculateDatas();
			}
			animationData.parsed = true;
			animationData.labels = this._labels;
			animationData.count = this._count;
			animationData.animationNewFrames = this._animationNewFrames;
		}

		/**@inheritDoc */
		__proto.clear = function () {
			_super.prototype.clear.call(this);
			this._targetDic = null;
			this._animationData = null;
		}

		/**@inheritDoc */
		__proto._displayToIndex = function (value) {
			if (!this._animationData) return;
			if (value < 0) value = 0;
			if (value > this._count) value = this._count;
			var nodes = this._animationData.nodes, i = 0, len = nodes.length;
			for (i = 0; i < len; i++) {
				this._displayNodeToFrame(nodes[i], value);
			}
		}

		/**
		*@private
		*将节点设置到某一帧的状态
		*@param node 节点ID
		*@param frame
		*@param targetDic 节点表
		*
		*/
		__proto._displayNodeToFrame = function (node, frame, targetDic) {
			if (!targetDic) targetDic = this._targetDic;
			var target = targetDic[node.target];
			if (!target) {
				return;
			};
			var frames = node.frames, key, propFrames, value;
			var keys = node.keys, i = 0, len = keys.length;
			for (i = 0; i < len; i++) {
				key = keys[i];
				propFrames = frames[key];
				if (propFrames.length > frame) {
					value = propFrames[frame];
				} else {
					value = propFrames[propFrames.length - 1];
				}
				target[key] = value;
			}
		}

		/**
		*@private
		*计算帧数据
		*
		*/
		__proto._calculateDatas = function () {
			if (!this._animationData) return;
			var nodes = this._animationData.nodes, i = 0, len = nodes.length, tNode;
			this._count = 0;
			for (i = 0; i < len; i++) {
				tNode = nodes[i];
				this._calculateNodeKeyFrames(tNode);
			}
			this._count += 1;
		}

		/**
		*@private
		*计算某个节点的帧数据
		*@param node
		*
		*/
		__proto._calculateNodeKeyFrames = function (node) {
			var keyFrames = node.keyframes, key, tKeyFrames, target = node.target;
			if (!node.frames) {
				node.frames = {};
			}
			if (!node.keys) {
				node.keys = [];
			} else {
				node.keys.length = 0;
			}
			if (!node.initValues) {
				node.initValues = {};
			}
			for (key in keyFrames) {
				tKeyFrames = keyFrames[key];
				if (!node.frames[key]) {
					node.frames[key] = [];
				}
				if (this._targetDic && this._targetDic[target]) {
					node.initValues[key] = this._targetDic[target][key];
				}
				tKeyFrames.sort(FrameAnimation._sortIndexFun);
				node.keys.push(key);
				this._calculateNodePropFrames(tKeyFrames, node.frames[key], key, target);
			}
		}

		/**
		*将动画控制对象还原到动画控制之前的状态
		*/
		__proto.resetToInitState = function () {
			if (!this._targetDic) return;
			if (!this._animationData) return;
			var nodes = this._animationData.nodes, i = 0, len = nodes.length;
			var tNode;
			var initValues;
			for (i = 0; i < len; i++) {
				tNode = nodes[i];
				initValues = tNode.initValues;
				if (!initValues) continue;
				var target = this._targetDic[tNode.target];
				if (!target) continue;
				var key;
				for (key in initValues) {
					target[key] = initValues[key];
				}
			}
		}

		/**
		*@private
		*计算节点某个属性的帧数据
		*@param keyframes
		*@param frames
		*@param key
		*@param target
		*
		*/
		__proto._calculateNodePropFrames = function (keyframes, frames, key, target) {
			var i = 0, len = keyframes.length - 1;
			frames.length = keyframes[len].index + 1;
			for (i = 0; i < len; i++) {
				this._dealKeyFrame(keyframes[i]);
				this._calculateFrameValues(keyframes[i], keyframes[i + 1], frames);
			}
			if (len == 0) {
				frames[0] = keyframes[0].value;
				if (this._animationNewFrames)
					this._animationNewFrames[keyframes[0].index] = true;
			}
			this._dealKeyFrame(keyframes[i]);
		}

		/**
		*@private
		*
		*/
		__proto._dealKeyFrame = function (keyFrame) {
			if (keyFrame.label && keyFrame.label != "") this.addLabel(keyFrame.label, keyFrame.index);
		}

		/**
		*@private
		*计算两个关键帧直接的帧数据
		*@param startFrame
		*@param endFrame
		*@param result
		*
		*/
		__proto._calculateFrameValues = function (startFrame, endFrame, result) {
			var i = 0, easeFun;
			var start = startFrame.index, end = endFrame.index;
			var startValue = startFrame.value;
			var dValue = endFrame.value - startFrame.value;
			var dLen = end - start;
			if (end > this._count) this._count = end;
			if (startFrame.tween) {
				easeFun = Ease[startFrame.tweenMethod];
				if (easeFun == null) {
					easeFun = Ease.linearNone;
				}
				for (i = start; i < end; i++) {
					result[i] = easeFun(i - start, startValue, dValue, dLen);
					if (this._animationNewFrames) {
						this._animationNewFrames[i] = true;
					}
				}
			} else {
				for (i = start; i < end; i++) {
					result[i] = startValue;
				}
			}
			if (this._animationNewFrames) {
				this._animationNewFrames[startFrame.index] = true;
				this._animationNewFrames[endFrame.index] = true;
			}
			result[endFrame.index] = endFrame.value;
		}

		FrameAnimation._sortIndexFun = null;
		return FrameAnimation;
	})(AnimationPlayerBase)


	/**
	*<p><code>Input</code> 类用于创建显示对象以显示和输入文本。</p>
	*<p>Input 类封装了原生的文本输入框，由于不同浏览器的差异，会导致此对象的默认文本的位置与用户点击输入时的文本的位置有少许的偏差。</p>
	*/
	//class laya.display.Input extends laya.display.Text
	var Input = (function (_super) {
		function Input() {
			/**@private */
			this._focus = false;
			/**@private */
			this._multiline = false;
			/**@private */
			this._editable = true;
			/**@private */
			this._restrictPattern = null;
			this._type = "text";
			/**输入提示符。*/
			this._prompt = '';
			/**输入提示符颜色。*/
			this._promptColor = "#A9A9A9";
			this._originColor = "#000000";
			this._content = '';
			Input.__super.call(this);
			this._maxChars = 1E5;
			this._width = 100;
			this._height = 20;
			this.multiline = false;
			this.overflow = Text.SCROLL;
			this.on(/*laya.events.Event.MOUSE_DOWN*/"mousedown", this, this._onMouseDown);
			this.on(/*laya.events.Event.UNDISPLAY*/"undisplay", this, this._onUnDisplay);
		}

		__class(Input, 'laya.display.Input', _super);
		var __proto = Input.prototype;
		/**
		*设置光标位置和选取字符。
		*@param startIndex 光标起始位置。
		*@param endIndex 光标结束位置。
		*/
		__proto.setSelection = function (startIndex, endIndex) {
			this.focus = true;
			laya.display.Input.inputElement.selectionStart = startIndex;
			laya.display.Input.inputElement.selectionEnd = endIndex;
		}

		__proto._onUnDisplay = function (e) {
			this.focus = false;
		}

		__proto._onMouseDown = function (e) {
			this.focus = true;
		}

		/**
		*在输入期间，如果 Input 实例的位置改变，调用_syncInputTransform同步输入框的位置。
		*/
		__proto._syncInputTransform = function () {
			var inputElement = this.nativeInput;
			var transform = Utils.getTransformRelativeToWindow(this, this.padding[3], this.padding[0]);
			var inputWid = this._width - this.padding[1] - this.padding[3];
			var inputHei = this._height - this.padding[0] - this.padding[2];
			if (Render.isConchApp) {
				inputElement.setScale(transform.scaleX, transform.scaleY);
				inputElement.setSize(inputWid, inputHei);
				inputElement.setPos(transform.x, transform.y);
			} else {
				Input.inputContainer.style.transform = Input.inputContainer.style.webkitTransform = "scale(" + transform.scaleX + "," + transform.scaleY + ") rotate(" + (Laya.stage.canvasDegree) + "deg)";
				inputElement.style.width = inputWid + 'px';
				inputElement.style.height = inputHei + 'px';
				Input.inputContainer.style.left = transform.x + 'px';
				Input.inputContainer.style.top = transform.y + 'px';
			}
		}

		/**选中当前实例的所有文本。*/
		__proto.select = function () {
			this.nativeInput.select();
		}

		__proto._setInputMethod = function () {
			Input.input.parentElement && (Input.inputContainer.removeChild(Input.input));
			Input.area.parentElement && (Input.inputContainer.removeChild(Input.area));
			Input.inputElement = (this._multiline ? Input.area : Input.input);
			Input.inputContainer.appendChild(Input.inputElement);
			if (Text.RightToLeft) {
				Input.inputElement.style.direction = "rtl";
			}
		}

		__proto._focusIn = function () {
			laya.display.Input.isInputting = true;
			var input = this.nativeInput;
			this._focus = true;
			var cssStyle = input.style;
			cssStyle.whiteSpace = (this.wordWrap ? "pre-wrap" : "nowrap");
			this._setPromptColor();
			input.readOnly = !this._editable;
			if (Render.isConchApp) {
				input.setType(this._type);
				input.setForbidEdit(!this._editable);
			}
			input.maxLength = this._maxChars;
			var padding = this.padding;
			input.type = this._type;
			input.value = this._content;
			input.placeholder = this._prompt;
			Laya.stage.off(/*laya.events.Event.KEY_DOWN*/"keydown", this, this._onKeyDown);
			Laya.stage.on(/*laya.events.Event.KEY_DOWN*/"keydown", this, this._onKeyDown);
			Laya.stage.focus = this;
			this.event(/*laya.events.Event.FOCUS*/"focus");
			if (Browser.onPC) input.focus();
			if (!Browser.onMiniGame) {
				var temp = this._text;
				this._text = null;
			}
			this.typeset();
			input.setColor(this._originColor);
			input.setFontSize(this.fontSize);
			input.setFontFace(Browser.onIPhone ? (Text._fontFamilyMap[this.font] || this.font) : this.font);
			if (Render.isConchApp) {
				input.setMultiAble && input.setMultiAble(this._multiline);
			}
			cssStyle.lineHeight = (this.leading + this.fontSize) + "px";
			cssStyle.fontStyle = (this.italic ? "italic" : "normal");
			cssStyle.fontWeight = (this.bold ? "bold" : "normal");
			cssStyle.textAlign = this.align;
			cssStyle.padding = "0 0";
			this._syncInputTransform();
			if (!Render.isConchApp && Browser.onPC)
				Laya.timer.frameLoop(1, this, this._syncInputTransform);
		}

		// 设置DOM输入框提示符颜色。
		__proto._setPromptColor = function () {
			Input.promptStyleDOM = Browser.getElementById("promptStyle");
			if (!Input.promptStyleDOM) {
				Input.promptStyleDOM = Browser.createElement("style");
				Input.promptStyleDOM.setAttribute("id", "promptStyle");
				Browser.document.head.appendChild(Input.promptStyleDOM);
			}
			Input.promptStyleDOM.innerText = "input::-webkit-input-placeholder, textarea::-webkit-input-placeholder {" + "color:" + this._promptColor + "}" + "input:-moz-placeholder, textarea:-moz-placeholder {" + "color:" + this._promptColor + "}" + "input::-moz-placeholder, textarea::-moz-placeholder {" + "color:" + this._promptColor + "}" + "input:-ms-input-placeholder, textarea:-ms-input-placeholder {" + "color:" + this._promptColor + "}";
		}

		/**@private */
		__proto._focusOut = function () {
			laya.display.Input.isInputting = false;
			this._focus = false;
			this._text = null;
			this._content = this.nativeInput.value;
			if (!this._content) {
				Laya.superSet(Text, this, 'text', this._prompt);
				Laya.superSet(Text, this, 'color', this._promptColor);
			} else {
				Laya.superSet(Text, this, 'text', this._content);
				Laya.superSet(Text, this, 'color', this._originColor);
			}
			Laya.stage.off(/*laya.events.Event.KEY_DOWN*/"keydown", this, this._onKeyDown);
			Laya.stage.focus = null;
			this.event(/*laya.events.Event.BLUR*/"blur");
			if (Render.isConchApp) this.nativeInput.blur();
			Browser.onPC && Laya.timer.clear(this, this._syncInputTransform);
		}

		/**@private */
		__proto._onKeyDown = function (e) {
			if (e.keyCode === 13) {
				if (Browser.onMobile && !this._multiline)
					this.focus = false;
				this.event(/*laya.events.Event.ENTER*/"enter");
			}
		}

		__proto.changeText = function (text) {
			this._content = text;
			if (this._focus) {
				this.nativeInput.value = text || '';
				this.event(/*laya.events.Event.CHANGE*/"change");
			} else
				_super.prototype.changeText.call(this, text);
		}

		/**@inheritDoc */
		__getset(0, __proto, 'color', _super.prototype._$get_color, function (value) {
			if (this._focus)
				this.nativeInput.setColor(value);
			Laya.superSet(Text, this, 'color', this._content ? value : this._promptColor);
			this._originColor = value;
		});

		//[Deprecated]
		__getset(0, __proto, 'inputElementYAdjuster', function () {
			console.warn("deprecated: 由于即使设置了该值，在各平台和浏览器之间也不一定一致，inputElementYAdjuster已弃用。");
			return 0;
		}, function (value) {
			console.warn("deprecated: 由于即使设置了该值，在各平台和浏览器之间也不一定一致，inputElementYAdjuster已弃用。");
		});

		/**表示是否是多行输入框。*/
		__getset(0, __proto, 'multiline', function () {
			return this._multiline;
		}, function (value) {
			this._multiline = value;
			this.valign = value ? "top" : "middle";
		});

		/**
		*<p>字符数量限制，默认为10000。</p>
		*<p>设置字符数量限制时，小于等于0的值将会限制字符数量为10000。</p>
		*/
		__getset(0, __proto, 'maxChars', function () {
			return this._maxChars;
		}, function (value) {
			if (value <= 0)
				value = 1E5;
			this._maxChars = value;
		});

		/**@inheritDoc */
		__getset(0, __proto, 'text', function () {
			if (this._focus)
				return this.nativeInput.value;
			else
				return this._content || "";
		}, function (value) {
			Laya.superSet(Text, this, 'color', this._originColor);
			value += '';
			if (this._focus) {
				this.nativeInput.value = value || '';
				this.event(/*laya.events.Event.CHANGE*/"change");
			} else {
				if (!this._multiline)
					value = value.replace(/\r?\n/g, '');
				this._content = value;
				if (value)
					Laya.superSet(Text, this, 'text', value);
				else {
					Laya.superSet(Text, this, 'text', this._prompt);
					Laya.superSet(Text, this, 'color', this.promptColor);
				}
			}
		});

		/**
		*获取对输入框的引用实例。
		*/
		__getset(0, __proto, 'nativeInput', function () {
			return this._multiline ? Input.area : Input.input;
		});

		/**
		*设置输入提示符。
		*/
		__getset(0, __proto, 'prompt', function () {
			return this._prompt;
		}, function (value) {
			if (!this._text && value)
				Laya.superSet(Text, this, 'color', this._promptColor);
			this.promptColor = this._promptColor;
			if (this._text)
				Laya.superSet(Text, this, 'text', (this._text == this._prompt) ? value : this._text);
			else
				Laya.superSet(Text, this, 'text', value);
			this._prompt = Text.langPacks && Text.langPacks[value] ? Text.langPacks[value] : value;
		});

		// 因此 调用focus接口是无法都在移动平台立刻弹出键盘的
		/**
		*表示焦点是否在此实例上。
		*/
		__getset(0, __proto, 'focus', function () {
			return this._focus;
		}, function (value) {
			var input = this.nativeInput;
			if (this._focus !== value) {
				if (value) {
					if (input.target) {
						input.target._focusOut();
					} else {
						this._setInputMethod();
					}
					input.target = this;
					this._focusIn();
				} else {
					input.target = null;
					this._focusOut();
					Browser.document.body.scrollTop = 0;
					input.blur();
					if (Render.isConchApp) {
						input.setPos(-10000, -10000);
					} else if (Input.inputContainer.contains(input))
						Input.inputContainer.removeChild(input);
				}
			}
		});

		/**限制输入的字符。*/
		__getset(0, __proto, 'restrict', function () {
			if (this._restrictPattern) {
				return this._restrictPattern.source;
			}
			return "";
		}, function (pattern) {
			if (pattern) {
				pattern = "[^" + pattern + "]";
				if (pattern.indexOf("^^") > -1)
					pattern = pattern.replace("^^", "");
				this._restrictPattern = new RegExp(pattern, "g");
			} else
				this._restrictPattern = null;
		});

		/**
		*是否可编辑。
		*/
		__getset(0, __proto, 'editable', function () {
			return this._editable;
		}, function (value) {
			this._editable = value;
			if (Render.isConchApp) {
				Input.input.setForbidEdit(!value);
			}
		});

		/**
		*设置输入提示符颜色。
		*/
		__getset(0, __proto, 'promptColor', function () {
			return this._promptColor;
		}, function (value) {
			this._promptColor = value;
			if (!this._content) Laya.superSet(Text, this, 'color', value);
		});

		/**
		*<p>输入框类型为Input静态常量之一。</p>
		*<ul>
		*<li>TYPE_TEXT</li>
		*<li>TYPE_PASSWORD</li>
		*<li>TYPE_EMAIL</li>
		*<li>TYPE_URL</li>
		*<li>TYPE_NUMBER</li>
		*<li>TYPE_RANGE</li>
		*<li>TYPE_DATE</li>
		*<li>TYPE_MONTH</li>
		*<li>TYPE_WEEK</li>
		*<li>TYPE_TIME</li>
		*<li>TYPE_DATE_TIME</li>
		*<li>TYPE_DATE_TIME_LOCAL</li>
		*</ul>
		*<p>平台兼容性参见http://www.w3school.com.cn/html5/html_5_form_input_types.asp。</p>
		*/
		__getset(0, __proto, 'type', function () {
			return this._type;
		}, function (value) {
			if (value == "password")
				this._getCSSStyle().password = true;
			else
				this._getCSSStyle().password = false;
			this._type = value;
			if (Render.isConchApp) {
				this.nativeInput.setType(value);
			}
		});

		/**
		*<p>原生输入框 X 轴调整值，用来调整输入框坐标。</p>
		*<p>由于即使设置了该值，在各平台和浏览器之间也不一定一致，inputElementXAdjuster已弃用。</p>
		*@deprecated
		*/
		__getset(0, __proto, 'inputElementXAdjuster', function () {
			console.warn("deprecated: 由于即使设置了该值，在各平台和浏览器之间也不一定一致，inputElementXAdjuster已弃用。");
			return 0;
		}, function (value) {
			console.warn("deprecated: 由于即使设置了该值，在各平台和浏览器之间也不一定一致，inputElementXAdjuster已弃用。");
		});

		//[Deprecated(replacement="Input.type")]
		__getset(0, __proto, 'asPassword', function () {
			return this._getCSSStyle().password;
		}, function (value) {
			this._getCSSStyle().password = value;
			this._type =/*CLASS CONST:laya.display.Input.TYPE_PASSWORD*/"password";
			console.warn("deprecated: 使用type=\"password\"替代设置asPassword, asPassword将在下次重大更新时删去");
			this.isChanged = true;
		});

		Input.__init__ = function () {
			Input._createInputElement();
			if (Browser.onMobile)
				Render.canvas.addEventListener(Input.IOS_IFRAME ? (Browser.onMiniGame ? "touchend" : "click") : "touchend", Input._popupInputMethod);
		}

		Input._popupInputMethod = function (e) {
			if (!laya.display.Input.isInputting) return;
			var input = laya.display.Input.inputElement;
			input.focus();
		}

		Input._createInputElement = function () {
			Input._initInput(Input.area = Browser.createElement("textarea"));
			Input._initInput(Input.input = Browser.createElement("input"));
			Input.inputContainer = Browser.createElement("div");
			Input.inputContainer.style.position = "absolute";
			Input.inputContainer.style.zIndex = 1E5;
			Browser.container.appendChild(Input.inputContainer);
			Input.inputContainer.setPos = function (x, y) { Input.inputContainer.style.left = x + 'px'; Input.inputContainer.style.top = y + 'px'; };
		}

		Input._initInput = function (input) {
			var style = input.style;
			style.cssText = "position:absolute;overflow:hidden;resize:none;transform-origin:0 0;-webkit-transform-origin:0 0;-moz-transform-origin:0 0;-o-transform-origin:0 0;";
			style.resize = 'none';
			style.backgroundColor = 'transparent';
			style.border = 'none';
			style.outline = 'none';
			style.zIndex = 1;
			input.addEventListener('input', Input._processInputting);
			input.addEventListener('mousemove', Input._stopEvent);
			input.addEventListener('mousedown', Input._stopEvent);
			input.addEventListener('touchmove', Input._stopEvent);
			input.setFontFace = function (fontFace) { input.style.fontFamily = fontFace; };
			if (!Render.isConchApp) {
				input.setColor = function (color) { input.style.color = color; };
				input.setFontSize = function (fontSize) { input.style.fontSize = fontSize + 'px'; };
			}
		}

		Input._processInputting = function (e) {
			var input = laya.display.Input.inputElement.target;
			if (!input) return;
			var value = laya.display.Input.inputElement.value;
			if (input._restrictPattern) {
				value = value.replace(/\u2006|\x27/g, "");
				if (input._restrictPattern.test(value)) {
					value = value.replace(input._restrictPattern, "");
					laya.display.Input.inputElement.value = value;
				}
			}
			input._text = value;
			input.event(/*laya.events.Event.INPUT*/"input");
		}

		Input._stopEvent = function (e) {
			if (e.type == 'touchmove')
				e.preventDefault();
			e.stopPropagation && e.stopPropagation();
		}

		Input.TYPE_TEXT = "text";
		Input.TYPE_PASSWORD = "password";
		Input.TYPE_EMAIL = "email";
		Input.TYPE_URL = "url";
		Input.TYPE_NUMBER = "number";
		Input.TYPE_RANGE = "range";
		Input.TYPE_DATE = "date";
		Input.TYPE_MONTH = "month";
		Input.TYPE_WEEK = "week";
		Input.TYPE_TIME = "time";
		Input.TYPE_DATE_TIME = "datetime";
		Input.TYPE_DATE_TIME_LOCAL = "datetime-local";
		Input.TYPE_SEARCH = "search";
		Input.input = null;
		Input.area = null;
		Input.inputElement = null;
		Input.inputContainer = null;
		Input.confirmButton = null;
		Input.promptStyleDOM = null;
		Input.inputHeight = 45;
		Input.isInputting = false;
		Input.stageMatrix = null;
		__static(Input,
			['IOS_IFRAME', function () { return this.IOS_IFRAME = (Browser.onIOS && Browser.window.top != Browser.window.self); }
			]);
		return Input;
	})(Text)


	/**
	*@private
	*<p> <code>HTMLImage</code> 用于创建 HTML Image 元素。</p>
	*<p>请使用 <code>HTMLImage.create()<code>获取新实例，不要直接使用 <code>new HTMLImage<code> 。</p>
	*/
	//class laya.resource.HTMLImage extends laya.resource.FileBitmap
	var HTMLImage = (function (_super) {
		function HTMLImage(src, def) {
			/**异步加载锁*/
			this._recreateLock = false;
			/**异步加载完成后是否需要释放（有可能在恢复过程中,再次被释放，用此变量做标记）*/
			this._needReleaseAgain = false;
			this._enableMerageInAtlas = true;
			HTMLImage.__super.call(this);
			this._init_(src, def);
		}

		__class(HTMLImage, 'laya.resource.HTMLImage', _super);
		var __proto = HTMLImage.prototype;
		__proto._init_ = function (src, def) {
			this._src = src;
			this._source = new Browser.window.Image();
			if (def) {
				def.onload && (this.onload = def.onload);
				def.onerror && (this.onerror = def.onerror);
				def.onCreate && def.onCreate(this);
			}
			if (src.indexOf("data:image") != 0) this._source.crossOrigin = "";
			(src) && (this._source.src = src);
		}

		/**
		*@inheritDoc
		*/
		__proto.recreateResource = function () {
			var _$this = this;
			if (this._src === "")
				throw new Error("src no null！");
			this._needReleaseAgain = false;
			if (!this._source) {
				this._recreateLock = true;
				var _this = this;
				this._source = new Browser.window.Image();
				this._source.crossOrigin = "";
				this._source.onload = function () {
					if (_this._needReleaseAgain) {
						_this._needReleaseAgain = false;
						_this._source.onload = null;
						_this._source = null;
						return;
					}
					_this._source.onload = null;
					_this.memorySize = _$this._w * _$this._h * 4;
					_this._recreateLock = false;
					_this.completeCreate();
				};
				this._source.src = this._src;
			} else {
				if (this._recreateLock)
					return;
				this.memorySize = this._w * this._h * 4;
				this._recreateLock = false;
				this.completeCreate();
			}
		}

		/**
		*@inheritDoc
		*/
		__proto.disposeResource = function () {
			if (this._recreateLock)
				this._needReleaseAgain = true;
			(this._source) && (this._source = null, this.memorySize = 0);
		}

		/***调整尺寸。*/
		__proto.onresize = function () {
			this._w = this._source.width;
			this._h = this._source.height;
		}

		/**
		*@inheritDoc
		*/
		__getset(0, __proto, 'onload', null, function (value) {
			var _$this = this;
			this._onload = value;
			this._source && (this._source.onload = this._onload != null ? (function () {
				_$this.onresize();
				_$this._onload();
			}) : null);
		});

		/**
		*@inheritDoc
		*/
		__getset(0, __proto, 'onerror', null, function (value) {
			var _$this = this;
			this._onerror = value;
			this._source && (this._source.onerror = this._onerror != null ? (function () {
				_$this._onerror()
			}) : null);
		});

		__getset(0, __proto, 'enableMerageInAtlas', function () {
			return this._enableMerageInAtlas;
		}, function (value) {
			this._enableMerageInAtlas = value;
			if (Render.isConchApp) {
				if (this._source) this._source.enableMerageInAtlas = value;
			}
		});

		HTMLImage.create = function (src, def) {
			return new HTMLImage(src, def);
		}

		return HTMLImage;
	})(FileBitmap)


	/**
	*<p> 动效模板。用于为指定目标对象添加动画效果。每个动效有唯一的目标对象，而同一个对象可以添加多个动效。 当一个动效开始播放时，其他动效会自动停止播放。</p>
	*<p> 可以通过The3Air IDE创建。 </p>
	*/
	//class laya.display.EffectAnimation extends laya.display.FrameAnimation
	var EffectAnimation = (function (_super) {
		function EffectAnimation() {
			/**@private */
			this._target = null;
			/**@private */
			this._playEvents = null;
			/**@private */
			this._initData = {};
			/**@private */
			this._aniKeys = null;
			/**@private */
			this._effectClass = null;
			EffectAnimation.__super.call(this);
		}

		__class(EffectAnimation, 'laya.display.EffectAnimation', _super);
		var __proto = EffectAnimation.prototype;
		/**@private */
		__proto._onOtherBegin = function (effect) {
			if (effect == this)
				return;
			this.stop();
		}

		/**@private */
		__proto.addEvent = function () {
			if (!this._target || !this._playEvents)
				return;
			this._setControlNode(this._target);
			this._target.on(this._playEvents, this, this._onPlayAction);
		}

		/**@private */
		__proto._onPlayAction = function () {
			this.play(0, false);
		}

		__proto.play = function (start, loop, name, showWarn) {
			(start === void 0) && (start = 0);
			(loop === void 0) && (loop = true);
			(name === void 0) && (name = "");
			(showWarn === void 0) && (showWarn = true);
			if (!this._target)
				return;
			this._target.event("effectanimationbegin", [this]);
			this._recordInitData();
			laya.display.AnimationPlayerBase.prototype.play.call(this, start, loop, name, showWarn);
		}

		/**@private */
		__proto._recordInitData = function () {
			if (!this._aniKeys)
				return;
			var i = 0, len = 0;
			len = this._aniKeys.length;
			var key;
			for (i = 0; i < len; i++) {
				key = this._aniKeys[i];
				this._initData[key] = this._target[key];
			}
		}

		/**@private */
		__proto._displayToIndex = function (value) {
			if (!this._animationData)
				return;
			if (value < 0)
				value = 0;
			if (value > this._count)
				value = this._count;
			var nodes = this._animationData.nodes, i = 0, len = nodes.length;
			len = len > 1 ? 1 : len;
			for (i = 0; i < len; i++) {
				this._displayNodeToFrame(nodes[i], value);
			}
		}

		/**@private */
		__proto._displayNodeToFrame = function (node, frame, targetDic) {
			if (!this._target)
				return;
			var target;
			target = this._target;
			var frames = node.frames, key, propFrames, value;
			var keys = node.keys, i = 0, len = keys.length;
			var secondFrames;
			secondFrames = node.secondFrames;
			var tSecondFrame = 0;
			var easeFun;
			var tKeyFrames;
			var startFrame;
			var endFrame;
			for (i = 0; i < len; i++) {
				key = keys[i];
				propFrames = frames[key];
				tSecondFrame = secondFrames[key];
				if (tSecondFrame == -1) {
					value = this._initData[key];
				} else {
					if (frame < tSecondFrame) {
						tKeyFrames = node.keyframes[key];
						startFrame = tKeyFrames[0];
						if (startFrame.tween) {
							easeFun = Ease[startFrame.tweenMethod];
							if (easeFun == null) {
								easeFun = Ease.linearNone;
							}
							endFrame = tKeyFrames[1];
							value = easeFun(frame, this._initData[key], endFrame.value - this._initData[key], endFrame.index);
						} else {
							value = this._initData[key];
						}
					} else {
						if (propFrames.length > frame) {
							value = propFrames[frame];
						} else {
							value = propFrames[propFrames.length - 1];
						}
					}
				}
				target[key] = value;
			}
		}

		/**@private */
		__proto._calculateNodeKeyFrames = function (node) {
			_super.prototype._calculateNodeKeyFrames.call(this, node);
			var keyFrames = node.keyframes, key, tKeyFrames, target = node.target;
			var secondFrames;
			secondFrames = {};
			node.secondFrames = secondFrames;
			for (key in keyFrames) {
				tKeyFrames = keyFrames[key];
				if (tKeyFrames.length <= 1) {
					secondFrames[key] = -1;
				} else {
					secondFrames[key] = tKeyFrames[1].index;
				}
			}
		}

		/**
		*本实例的目标对象。通过本实例控制目标对象的属性变化。
		*@param v 指定的目标对象。
		*/
		__getset(0, __proto, 'target', function () {
			return this._target;
		}, function (v) {
			if (this._target) {
				this._target.off("effectanimationbegin", this, this._onOtherBegin);
			}
			this._target = v;
			if (this._target) {
				this._target.on("effectanimationbegin", this, this._onOtherBegin);
			}
			this.addEvent();
		});

		/**
		*设置开始播放的事件。本实例会侦听目标对象的指定事件，触发后播放相应动画效果。
		*@param event
		*/
		__getset(0, __proto, 'playEvent', null, function (event) {
			this._playEvents = event;
			if (!event)
				return;
			this.addEvent();
		});

		/**
		*设置动画数据。
		*@param uiData
		*/
		__getset(0, __proto, 'effectData', null, function (uiData) {
			if (uiData) {
				var aniData;
				aniData = uiData["animations"];
				if (aniData && aniData[0]) {
					this._setUp({}, aniData[0]);
					if (aniData[0].nodes && aniData[0].nodes[0]) {
						this._aniKeys = aniData[0].nodes[0].keys;
					}
				}
			}
		});

		/**
		*设置提供数据的类。
		*@param classStr 类路径
		*/
		__getset(0, __proto, 'effectClass', null, function (classStr) {
			this._effectClass = ClassUtils.getClass(classStr);
			if (this._effectClass) {
				var uiData;
				uiData = this._effectClass["uiView"];
				if (uiData) {
					var aniData;
					aniData = uiData["animations"];
					if (aniData && aniData[0]) {
						this._setUp({}, aniData[0]);
						if (aniData[0].nodes && aniData[0].nodes[0]) {
							this._aniKeys = aniData[0].nodes[0].keys;
						}
					}
				}
			}
		});

		EffectAnimation.EffectAnimationBegin = "effectanimationbegin";
		return EffectAnimation;
	})(FrameAnimation)


	/**
	*@private
	*/
	//class laya.utils.GraphicAnimation extends laya.display.FrameAnimation
	var GraphicAnimation = (function (_super) {
		var GraphicNode;
		function GraphicAnimation() {
			/**
			*@private
			*/
			this.animationList = null;
			/**
			*@private
			*/
			this.animationDic = null;
			/**
			*@private
			*/
			this._nodeList = null;
			/**
			*@private
			*/
			this._nodeDefaultProps = null;
			/**
			*@private
			*/
			this._gList = null;
			/**
			*@private
			*/
			this._nodeIDAniDic = {};
			this._rootNode = null;
			this._nodeGDic = null;
			GraphicAnimation.__super.call(this);
		}

		__class(GraphicAnimation, 'laya.utils.GraphicAnimation', _super);
		var __proto = GraphicAnimation.prototype;
		/**
		*@private
		*/
		__proto._parseNodeList = function (uiView) {
			if (!this._nodeList) {
				this._nodeList = [];
			}
			this._nodeDefaultProps[uiView.compId] = uiView.props;
			if (uiView.compId)
				this._nodeList.push(uiView.compId);
			var childs = uiView.child;
			if (childs) {
				var i = 0, len = childs.length;
				for (i = 0; i < len; i++) {
					this._parseNodeList(childs[i]);
				}
			}
		}

		/**
		*@private
		*/
		__proto._calGraphicData = function (aniData) {
			this._setUp(null, aniData);
			this._createGraphicData();
			if (this._nodeIDAniDic) {
				var key;
				for (key in this._nodeIDAniDic) {
					this._nodeIDAniDic[key] = null;
				}
			}
		}

		/**
		*@private
		*/
		__proto._createGraphicData = function () {
			var gList = [];
			var i = 0, len = this.count;
			var animationDataNew = this._animationNewFrames;
			if (!animationDataNew) animationDataNew = [];
			var preGraphic;
			for (i = 0; i < len; i++) {
				if (animationDataNew[i] || !preGraphic) {
					preGraphic = this._createFrameGraphic(i);
				}
				gList.push(preGraphic);
			}
			this._gList = gList;
		}

		/**
		*@private
		*/
		__proto._createFrameGraphic = function (frame) {
			var g = RunDriver.createGraphics();
			if (!GraphicAnimation._rootMatrix)
				GraphicAnimation._rootMatrix = new Matrix();
			this._updateNodeGraphic(this._rootNode, frame, GraphicAnimation._rootMatrix, g);
			return g;
		}

		__proto._updateNodeGraphic = function (node, frame, parentTransfrom, g, alpha) {
			(alpha === void 0) && (alpha = 1);
			var tNodeG;
			tNodeG = this._nodeGDic[node.compId] = this._getNodeGraphicData(node.compId, frame, this._nodeGDic[node.compId]);
			var tGraphicAlpha = tNodeG.alpha * alpha;
			if (tGraphicAlpha < 0.01) return;
			if (!tNodeG.resultTransform) {
				tNodeG.resultTransform = Matrix.create();
			};
			var tResultTransform;
			tResultTransform = tNodeG.resultTransform;
			Matrix.mul(tNodeG.transform, parentTransfrom, tResultTransform);
			var tTex;
			if (tNodeG.skin) {
				tTex = this._getTextureByUrl(tNodeG.skin);
				if (tTex) {
					if (tResultTransform._checkTransform()) {
						g.drawTexture(tTex, 0, 0, tNodeG.width, tNodeG.height, tResultTransform, tGraphicAlpha);
						tNodeG.resultTransform = null;
					} else {
						g.drawTexture(tTex, tResultTransform.tx, tResultTransform.ty, tNodeG.width, tNodeG.height, null, tGraphicAlpha);
					}
				}
			};
			var childs;
			childs = node.child;
			if (!childs)
				return;
			var i = 0, len = 0;
			len = childs.length;
			for (i = 0; i < len; i++) {
				this._updateNodeGraphic(childs[i], frame, tResultTransform, g, tGraphicAlpha);
			}
		}

		__proto._updateNoChilds = function (tNodeG, g) {
			if (!tNodeG.skin)
				return;
			var tTex = this._getTextureByUrl(tNodeG.skin);
			if (!tTex)
				return;
			var tTransform = tNodeG.transform;
			tTransform._checkTransform();
			var onlyTranslate = false;
			onlyTranslate = !tTransform.bTransform;
			if (!onlyTranslate) {
				g.drawTexture(tTex, 0, 0, tNodeG.width, tNodeG.height, tTransform.clone(), tNodeG.alpha);
			} else {
				g.drawTexture(tTex, tTransform.tx, tTransform.ty, tNodeG.width, tNodeG.height, null, tNodeG.alpha);
			}
		}

		__proto._updateNodeGraphic2 = function (node, frame, g) {
			var tNodeG;
			tNodeG = this._nodeGDic[node.compId] = this._getNodeGraphicData(node.compId, frame, this._nodeGDic[node.compId]);
			if (!node.child) {
				this._updateNoChilds(tNodeG, g);
				return;
			};
			var tTransform = tNodeG.transform;
			tTransform._checkTransform();
			var onlyTranslate = false;
			onlyTranslate = !tTransform.bTransform;
			var hasTrans = false;
			hasTrans = onlyTranslate && (tTransform.tx != 0 || tTransform.ty != 0);
			var ifSave = false;
			ifSave = (tTransform.bTransform) || tNodeG.alpha != 1;
			if (ifSave) {
				g.save();
			}
			if (tNodeG.alpha != 1) {
				g.alpha(tNodeG.alpha);
			}
			if (!onlyTranslate) {
				g.transform(tTransform.clone());
			} else if (hasTrans) {
				g.translate(tTransform.tx, tTransform.ty);
			};
			var childs;
			childs = node.child;
			var tTex;
			if (tNodeG.skin) {
				tTex = this._getTextureByUrl(tNodeG.skin);
				if (tTex) {
					g.drawTexture(tTex, 0, 0, tNodeG.width, tNodeG.height);
				}
			}
			if (childs) {
				var i = 0, len = 0;
				len = childs.length;
				for (i = 0; i < len; i++) {
					this._updateNodeGraphic2(childs[i], frame, g);
				}
			}
			if (ifSave) {
				g.restore();
			} else {
				if (!onlyTranslate) {
					g.transform(tTransform.clone().invert());
				} else if (hasTrans) {
					g.translate(-tTransform.tx, -tTransform.ty);
				}
			}
		}

		/**
		*@private
		*/
		__proto._calculateNodeKeyFrames = function (node) {
			_super.prototype._calculateNodeKeyFrames.call(this, node);
			this._nodeIDAniDic[node.target] = node;
		}

		/**
		*@private
		*/
		__proto.getNodeDataByID = function (nodeID) {
			return this._nodeIDAniDic[nodeID];
		}

		/**
		*@private
		*/
		__proto._getParams = function (obj, params, frame, obj2) {
			var rst = GraphicAnimation._temParam;
			rst.length = params.length;
			var i = 0, len = params.length;
			for (i = 0; i < len; i++) {
				rst[i] = this._getObjVar(obj, params[i][0], frame, params[i][1], obj2);
			}
			return rst;
		}

		/**
		*@private
		*/
		__proto._getObjVar = function (obj, key, frame, noValue, obj2) {
			if (obj.hasOwnProperty(key)) {
				var vArr = obj[key];
				if (frame >= vArr.length)
					frame = vArr.length - 1;
				return obj[key][frame];
			}
			if (obj2.hasOwnProperty(key)) {
				return obj2[key];
			}
			return noValue;
		}

		__proto._getNodeGraphicData = function (nodeID, frame, rst) {
			if (!rst)
				rst = GraphicNode.create();
			if (!rst.transform) {
				rst.transform = Matrix.create();
			} else {
				rst.transform.identity();
			};
			var node = this.getNodeDataByID(nodeID);
			if (!node)
				return rst;
			var frameData = node.frames;
			var params = this._getParams(frameData, GraphicAnimation._drawTextureCmd, frame, this._nodeDefaultProps[nodeID]);
			var url = params[0];
			var width = NaN, height = NaN;
			var px = params[5], py = params[6];
			var aX = params[13], aY = params[14];
			var sx = params[7], sy = params[8];
			var rotate = params[9];
			var skewX = params[11], skewY = params[12]
			width = params[3];
			height = params[4];
			if (width == 0 || height == 0) url = null;
			if (width == -1) width = 0;
			if (height == -1) height = 0;
			var tex;
			rst.skin = url;
			rst.width = width;
			rst.height = height;
			if (url) {
				tex = this._getTextureByUrl(url);
				if (tex) {
					if (!width)
						width = tex.sourceWidth;
					if (!height)
						height = tex.sourceHeight;
				} else {
					console.warn("lost skin:", url, ",you may load pics first");
				}
			}
			rst.alpha = params[10];
			var m;
			m = rst.transform;
			if (aX != 0) {
				px = aX * width;
			}
			if (aY != 0) {
				py = aY * height;
			}
			if (px != 0 || py != 0) {
				m.translate(-px, -py);
			};
			var tm = null;
			if (rotate || sx !== 1 || sy !== 1 || skewX || skewY) {
				tm = GraphicAnimation._tempMt;
				tm.identity();
				tm.bTransform = true;
				var skx = (rotate - skewX) * 0.0174532922222222;
				var sky = (rotate + skewY) * 0.0174532922222222;
				var cx = Math.cos(sky);
				var ssx = Math.sin(sky);
				var cy = Math.sin(skx);
				var ssy = Math.cos(skx);
				tm.a = sx * cx;
				tm.b = sx * ssx;
				tm.c = -sy * cy;
				tm.d = sy * ssy;
				tm.tx = tm.ty = 0;
			}
			if (tm) {
				m = Matrix.mul(m, tm, m);
			}
			m.translate(params[1], params[2]);
			return rst;
		}

		/**
		*@private
		*/
		__proto._getTextureByUrl = function (url) {
			return Loader.getRes(url);
		}

		/**
		*@private
		*/
		__proto.setAniData = function (uiView, aniName) {
			if (uiView.animations) {
				this._nodeDefaultProps = {};
				this._nodeGDic = {};
				if (this._nodeList)
					this._nodeList.length = 0;
				this._rootNode = uiView;
				this._parseNodeList(uiView);
				var aniDic = {};
				var anilist = [];
				var animations = uiView.animations;
				var i = 0, len = animations.length;
				var tAniO;
				for (i = 0; i < len; i++) {
					tAniO = animations[i];
					this._labels = null;
					if (aniName && aniName != tAniO.name) {
						continue;
					}
					if (!tAniO)
						continue;
					try {
						this._calGraphicData(tAniO);
					} catch (e) {
						console.warn("parse animation fail:" + tAniO.name + ",empty animation created");
						this._gList = [];
					};
					var frameO = {};
					frameO.interval = 1000 / tAniO["frameRate"];
					frameO.frames = this._gList;
					frameO.labels = this._labels;
					frameO.name = tAniO.name;
					anilist.push(frameO);
					aniDic[tAniO.name] = frameO;
				}
				this.animationList = anilist;
				this.animationDic = aniDic;
			}
			GraphicAnimation._temParam.length = 0;
		}

		__proto.parseByData = function (aniData) {
			var rootNode, aniO;
			rootNode = aniData.nodeRoot;
			aniO = aniData.aniO;
			delete aniData.nodeRoot;
			delete aniData.aniO;
			this._nodeDefaultProps = {};
			this._nodeGDic = {};
			if (this._nodeList)
				this._nodeList.length = 0;
			this._rootNode = rootNode;
			this._parseNodeList(rootNode);
			this._labels = null;
			try {
				this._calGraphicData(aniO);
			} catch (e) {
				console.warn("parse animation fail:" + aniO.name + ",empty animation created");
				this._gList = [];
			};
			var frameO = aniData;
			frameO.interval = 1000 / aniO["frameRate"];
			frameO.frames = this._gList;
			frameO.labels = this._labels;
			frameO.name = aniO.name;
			return frameO;
		}

		/**
		*@private
		*/
		__proto.setUpAniData = function (uiView) {
			if (uiView.animations) {
				var aniDic = {};
				var anilist = [];
				var animations = uiView.animations;
				var i = 0, len = animations.length;
				var tAniO;
				for (i = 0; i < len; i++) {
					tAniO = animations[i];
					if (!tAniO)
						continue;
					var frameO = {};
					frameO.name = tAniO.name;
					frameO.aniO = tAniO;
					frameO.nodeRoot = uiView;
					anilist.push(frameO);
					aniDic[tAniO.name] = frameO;
				}
				this.animationList = anilist;
				this.animationDic = aniDic;
			}
		}

		/**
		*@private
		*/
		__proto._clear = function () {
			this.animationList = null;
			this.animationDic = null;
			this._gList = null;
			if (this._nodeGDic) {
				var key;
				var tGNode;
				for (key in this._nodeGDic) {
					tGNode = this._nodeGDic[key];
					if (tGNode) tGNode.recover();
				}
			}
			this._nodeGDic = null;
		}

		GraphicAnimation.parseAnimationByData = function (animationObject) {
			if (!GraphicAnimation._I)
				GraphicAnimation._I = new GraphicAnimation();
			var rst;
			rst = GraphicAnimation._I.parseByData(animationObject);
			GraphicAnimation._I._clear();
			return rst;
		}

		GraphicAnimation.parseAnimationData = function (aniData) {
			if (!GraphicAnimation._I)
				GraphicAnimation._I = new GraphicAnimation();
			GraphicAnimation._I.setUpAniData(aniData);
			var rst;
			rst = {};
			rst.animationList = GraphicAnimation._I.animationList;
			rst.animationDic = GraphicAnimation._I.animationDic;
			GraphicAnimation._I._clear();
			return rst;
		}

		GraphicAnimation._drawTextureCmd = [["skin", null], ["x", 0], ["y", 0], ["width", -1], ["height", -1], ["pivotX", 0], ["pivotY", 0], ["scaleX", 1], ["scaleY", 1], ["rotation", 0], ["alpha", 1], ["skewX", 0], ["skewY", 0], ["anchorX", 0], ["anchorY", 0]];
		GraphicAnimation._temParam = [];
		GraphicAnimation._I = null;
		GraphicAnimation._rootMatrix = null;
		__static(GraphicAnimation,
			['_tempMt', function () { return this._tempMt = new Matrix(); }
			]);
		GraphicAnimation.__init$ = function () {
			//class GraphicNode
			GraphicNode = (function () {
				function GraphicNode() {
					this.skin = null;
					this.transform = null;
					this.resultTransform = null;
					this.width = NaN;
					this.height = NaN;
					this.alpha = 1;
				}
				__class(GraphicNode, '');
				var __proto = GraphicNode.prototype;
				__proto.recover = function () {
					this.skin = null;
					this.width = 0;
					this.height = 0;
					this.alpha = 1;
					if (this.transform) {
						this.transform.destroy();
						this.transform = null;
					}
					if (this.resultTransform) {
						this.resultTransform.destroy();
						this.resultTransform = null;
					}
					Pool.recover("GraphicNode", this);
				}
				GraphicNode.create = function () {
					return Pool.getItemByClass("GraphicNode", GraphicNode);
				}
				return GraphicNode;
			})()
		}

		return GraphicAnimation;
	})(FrameAnimation)


	Laya.__init([EventDispatcher, LoaderManager, Render, Browser, Timer, LocalStorage, TimeLine, GraphicAnimation]);
})(window, document, Laya);

(function (window, document, Laya) {
	var __un = Laya.un, __uns = Laya.uns, __static = Laya.static, __class = Laya.class, __getset = Laya.getset, __newvec = Laya.__newvec;
	//class The3Main
	var The3Main = (function () {
		/*[COMPILER OPTIONS:normal]*/
		function The3Main() { }
		__class(The3Main, 'The3Main');
		return The3Main;
	})()



	/**The3GameStart**/
	new The3Main();

})(window, document, Laya);

if (typeof define === 'function' && define.amd) {
	define('laya.core', ['require', "exports"], function (require, exports) {
		'use strict';
		Object.defineProperty(exports, '__esModule', { value: true });
		for (var i in Laya) {
			var o = Laya[i];
			o && o.__isclass && (exports[i] = o);
		}
	});
}


(function (window, document, Laya) {
	var __un = Laya.un, __uns = Laya.uns, __static = Laya.static, __class = Laya.class, __getset = Laya.getset, __newvec = Laya.__newvec;

	var Arith = laya.maths.Arith, Bezier = laya.maths.Bezier, Bitmap = laya.resource.Bitmap, Browser = laya.utils.Browser;
	var Byte = laya.utils.Byte, Color = laya.utils.Color, ColorFilter = laya.filters.ColorFilter, Config = Laya.Config, Context = laya.resource.Context;
	var Event = laya.events.Event, Filter = laya.filters.Filter, Graphics = laya.display.Graphics, HTMLCanvas = laya.resource.HTMLCanvas;
	var HTMLChar = laya.utils.HTMLChar, HTMLImage = laya.resource.HTMLImage, HTMLSubImage = laya.resource.HTMLSubImage;
	var Handler = laya.utils.Handler, Loader = laya.net.Loader, Matrix = laya.maths.Matrix, Point = laya.maths.Point, Rectangle = laya.maths.Rectangle;
	var Render = laya.renders.Render, RenderContext = laya.renders.RenderContext, RenderSprite = laya.renders.RenderSprite;
	var Resource = laya.resource.Resource, ResourceManager = laya.resource.ResourceManager, RunDriver = laya.utils.RunDriver;
	var Sprite = laya.display.Sprite, Stage = laya.display.Stage, Stat = laya.utils.Stat, StringKey = laya.utils.StringKey;
	var Style = laya.display.css.Style, System = laya.system.System, Text = laya.display.Text, Texture = laya.resource.Texture;
	var TransformInfo = laya.display.css.TransformInfo, URL = laya.net.URL, Utils = laya.utils.Utils, VectorGraphManager = laya.utils.VectorGraphManager;
	var WordText = laya.utils.WordText;
	Laya.interface('laya.webgl.shapes.IShape');
	Laya.interface('laya.webgl.submit.ISubmit');
	Laya.interface('laya.webgl.text.ICharSegment');
	Laya.interface('laya.webgl.canvas.save.ISaveData');
	Laya.interface('laya.webgl.resource.IMergeAtlasBitmap');
	Laya.interface('laya.filters.IFilterActionGL', 'laya.filters.IFilterAction');
	//class laya.filters.webgl.FilterActionGL
	var FilterActionGL = (function () {
		function FilterActionGL() { }
		__class(FilterActionGL, 'laya.filters.webgl.FilterActionGL');
		var __proto = FilterActionGL.prototype;
		Laya.imps(__proto, { "laya.filters.IFilterActionGL": true })
		__proto.setValue = function (shader) { }
		__proto.setValueMix = function (shader) { }
		__proto.apply3d = function (scope, sprite, context, x, y) { return null; }
		__proto.apply = function (srcCanvas) { return null; }
		__getset(0, __proto, 'typeMix', function () {
			return 0;
		});

		return FilterActionGL;
	})()


	//class laya.webgl.shader.ShaderValue
	var ShaderValue = (function () {
		function ShaderValue() { }
		__class(ShaderValue, 'laya.webgl.shader.ShaderValue');
		return ShaderValue;
	})()


	//class laya.webgl.atlas.AtlasGrid
	var AtlasGrid = (function () {
		var TexRowInfo, TexMergeTexSize;
		function AtlasGrid(width, height, atlasID) {
			this._atlasID = 0;
			this._width = 0;
			this._height = 0;
			this._texCount = 0;
			this._rowInfo = null;
			this._cells = null;
			this._failSize = new TexMergeTexSize();
			(width === void 0) && (width = 0);
			(height === void 0) && (height = 0);
			(atlasID === void 0) && (atlasID = 0);
			this._cells = null;
			this._rowInfo = null;
			this._init(width, height);
			this._atlasID = atlasID;
		}

		__class(AtlasGrid, 'laya.webgl.atlas.AtlasGrid');
		var __proto = AtlasGrid.prototype;
		//------------------------------------------------------------------------------
		__proto.getAltasID = function () {
			return this._atlasID;
		}

		//------------------------------------------------------------------------------
		__proto.setAltasID = function (atlasID) {
			if (atlasID >= 0) {
				this._atlasID = atlasID;
			}
		}

		//------------------------------------------------------------------
		__proto.addTex = function (type, width, height) {
			var result = this._get(width, height);
			if (result.ret == false) {
				return result;
			}
			this._fill(result.x, result.y, width, height, type);
			this._texCount++;
			return result;
		}

		//------------------------------------------------------------------------------
		__proto._release = function () {
			if (this._cells != null) {
				this._cells.length = 0;
				this._cells = null;
			}
			if (this._rowInfo) {
				this._rowInfo.length = 0;
				this._rowInfo = null;
			}
		}

		//------------------------------------------------------------------------------
		__proto._init = function (width, height) {
			this._width = width;
			this._height = height;
			this._release();
			if (this._width == 0) return false;
			this._cells = new Uint8Array(this._width * this._height * 3);
			this._rowInfo = __newvec(this._height);
			for (var i = 0; i < this._height; i++) {
				this._rowInfo[i] = new TexRowInfo();
			}
			this._clear();
			return true;
		}

		//------------------------------------------------------------------
		__proto._get = function (width, height) {
			var pFillInfo = new MergeFillInfo();
			if (width >= this._failSize.width && height >= this._failSize.height) {
				return pFillInfo;
			};
			var rx = -1;
			var ry = -1;
			var nWidth = this._width;
			var nHeight = this._height;
			var pCellBox = this._cells;
			for (var y = 0; y < nHeight; y++) {
				if (this._rowInfo[y].spaceCount < width) continue;
				for (var x = 0; x < nWidth;) {
					var tm = (y * nWidth + x) * 3;
					if (pCellBox[tm] != 0 || pCellBox[tm + 1] < width || pCellBox[tm + 2] < height) {
						x += pCellBox[tm + 1];
						continue;
					}
					rx = x;
					ry = y;
					for (var xx = 0; xx < width; xx++) {
						if (pCellBox[3 * xx + tm + 2] < height) {
							rx = -1;
							break;
						}
					}
					if (rx < 0) {
						x += pCellBox[tm + 1];
						continue;
					}
					pFillInfo.ret = true;
					pFillInfo.x = rx;
					pFillInfo.y = ry;
					return pFillInfo;
				}
			}
			return pFillInfo;
		}

		//------------------------------------------------------------------
		__proto._fill = function (x, y, w, h, type) {
			var nWidth = this._width;
			var nHeghit = this._height;
			this._check((x + w) <= nWidth && (y + h) <= nHeghit);
			for (var yy = y; yy < (h + y); ++yy) {
				this._check(this._rowInfo[yy].spaceCount >= w);
				this._rowInfo[yy].spaceCount -= w;
				for (var xx = 0; xx < w; xx++) {
					var tm = (x + yy * nWidth + xx) * 3;
					this._check(this._cells[tm] == 0);
					this._cells[tm] = type;
					this._cells[tm + 1] = w;
					this._cells[tm + 2] = h;
				}
			}
			if (x > 0) {
				for (yy = 0; yy < h; ++yy) {
					var s = 0;
					for (xx = x - 1; xx >= 0; --xx, ++s) {
						if (this._cells[((y + yy) * nWidth + xx) * 3] != 0) break;
					}
					for (xx = s; xx > 0; --xx) {
						this._cells[((y + yy) * nWidth + x - xx) * 3 + 1] = xx;
						this._check(xx > 0);
					}
				}
			}
			if (y > 0) {
				for (xx = x; xx < (x + w); ++xx) {
					s = 0;
					for (yy = y - 1; yy >= 0; --yy, s++) {
						if (this._cells[(xx + yy * nWidth) * 3] != 0) break;
					}
					for (yy = s; yy > 0; --yy) {
						this._cells[(xx + (y - yy) * nWidth) * 3 + 2] = yy;
						this._check(yy > 0);
					}
				}
			}
		}

		__proto._check = function (ret) {
			if (ret == false) {
				console.log("xtexMerger 错误啦");
			}
		}

		//------------------------------------------------------------------
		__proto._clear = function () {
			this._texCount = 0;
			for (var y = 0; y < this._height; y++) {
				this._rowInfo[y].spaceCount = this._width;
			}
			for (var i = 0; i < this._height; i++) {
				for (var j = 0; j < this._width; j++) {
					var tm = (i * this._width + j) * 3;
					this._cells[tm] = 0;
					this._cells[tm + 1] = this._width - j;
					this._cells[tm + 2] = this._width - i;
				}
			}
			this._failSize.width = this._width + 1;
			this._failSize.height = this._height + 1;
		}

		AtlasGrid.__init$ = function () {
			//------------------------------------------------------------------------------
			//class TexRowInfo
			TexRowInfo = (function () {
				function TexRowInfo() {
					this.spaceCount = 0;
				}
				__class(TexRowInfo, '');
				return TexRowInfo;
			})()
			//------------------------------------------------------------------------------
			//class TexMergeTexSize
			TexMergeTexSize = (function () {
				function TexMergeTexSize() {
					this.width = 0;
					this.height = 0;
				}
				__class(TexMergeTexSize, '');
				return TexMergeTexSize;
			})()
		}

		return AtlasGrid;
	})()


	//class laya.webgl.atlas.AtlasResourceManager
	var AtlasResourceManager = (function () {
		function AtlasResourceManager(width, height, gridSize, maxTexNum) {
			this._currentAtlasCount = 0;
			this._maxAtlaserCount = 0;
			this._width = 0;
			this._height = 0;
			this._gridSize = 0;
			this._gridNumX = 0;
			this._gridNumY = 0;
			this._init = false;
			this._curAtlasIndex = 0;
			this._setAtlasParam = false;
			this._atlaserArray = null;
			this._needGC = false;
			this._setAtlasParam = true;
			this._width = width;
			this._height = height;
			this._gridSize = gridSize;
			this._maxAtlaserCount = maxTexNum;
			this._gridNumX = width / gridSize;
			this._gridNumY = height / gridSize;
			this._curAtlasIndex = 0;
			this._atlaserArray = [];
		}

		__class(AtlasResourceManager, 'laya.webgl.atlas.AtlasResourceManager');
		var __proto = AtlasResourceManager.prototype;
		__proto.setAtlasParam = function (width, height, gridSize, maxTexNum) {
			if (this._setAtlasParam == true) {
				AtlasResourceManager._sid_ = 0;
				this._width = width;
				this._height = height;
				this._gridSize = gridSize;
				this._maxAtlaserCount = maxTexNum;
				this._gridNumX = width / gridSize;
				this._gridNumY = height / gridSize;
				this._curAtlasIndex = 0;
				this.freeAll();
				return true;
			} else {
				console.log("设置大图合集参数错误，只能在开始页面设置各种参数");
				throw -1;
				return false;
			}
			return false;
		}

		//添加 图片到大图集
		__proto.pushData = function (texture) {
			var bitmap = texture.bitmap;
			var nWebGLImageIndex = -1;
			var curAtlas = null;
			var i = 0, n = 0, altasIndex = 0;
			for (i = 0, n = this._atlaserArray.length; i < n; i++) {
				altasIndex = (this._curAtlasIndex + i) % n;
				curAtlas = this._atlaserArray[altasIndex];
				nWebGLImageIndex = curAtlas.findBitmapIsExist(bitmap);
				if (nWebGLImageIndex != -1) {
					break;
				}
			}
			if (nWebGLImageIndex != -1) {
				var offset = curAtlas.InAtlasWebGLImagesOffsetValue[nWebGLImageIndex];
				offsetX = offset[0];
				offsetY = offset[1];
				curAtlas.addToAtlas(texture, offsetX, offsetY);
				return true;
			} else {
				var tex = texture;
				this._setAtlasParam = false;
				var bFound = false;
				var nImageGridX = (Math.ceil((texture.bitmap.width + 2) / this._gridSize));
				var nImageGridY = (Math.ceil((texture.bitmap.height + 2) / this._gridSize));
				var bSuccess = false;
				for (var k = 0; k < 2; k++) {
					var maxAtlaserCount = this._maxAtlaserCount;
					for (i = 0; i < maxAtlaserCount; i++) {
						altasIndex = (this._curAtlasIndex + i) % maxAtlaserCount;
						(this._atlaserArray.length - 1 >= altasIndex) || (this._atlaserArray.push(new Atlaser(this._gridNumX, this._gridNumY, this._width, this._height, AtlasResourceManager._sid_++)));
						var atlas = this._atlaserArray[altasIndex];
						var offsetX = 0, offsetY = 0;
						var fillInfo = atlas.addTex(1, nImageGridX, nImageGridY);
						if (fillInfo.ret) {
							offsetX = fillInfo.x * this._gridSize + 1;
							offsetY = fillInfo.y * this._gridSize + 1;
							bitmap.lock = true;
							atlas.addToAtlasTexture((bitmap), offsetX, offsetY);
							atlas.addToAtlas(texture, offsetX, offsetY);
							bSuccess = true;
							this._curAtlasIndex = altasIndex;
							break;
						}
					}
					if (bSuccess)
						break;
					this._atlaserArray.push(new Atlaser(this._gridNumX, this._gridNumY, this._width, this._height, AtlasResourceManager._sid_++));
					this._needGC = true;
					this.garbageCollection();
					this._curAtlasIndex = this._atlaserArray.length - 1;
				}
				if (!bSuccess) {
					console.log(">>>AtlasManager pushData error");
				}
				return bSuccess;
			}
		}

		__proto.addToAtlas = function (tex) {
			laya.webgl.atlas.AtlasResourceManager.instance.pushData(tex);
		}

		/**
		*回收大图合集,不建议手动调用
		*@return
		*/
		__proto.garbageCollection = function () {
			if (this._needGC === true) {
				var n = this._atlaserArray.length - this._maxAtlaserCount;
				for (var i = 0; i < n; i++) {
					this._atlaserArray[i].dispose();
					console.log("AtlasResourceManager:Dispose the inner Atlas。");
				}
				console.log(">>>>altas garbageCollection =" + n);
				this._atlaserArray.splice(0, n);
				this._needGC = false;
			}
			return true;
		}

		__proto.freeAll = function () {
			for (var i = 0, n = this._atlaserArray.length; i < n; i++) {
				this._atlaserArray[i].dispose();
			}
			this._atlaserArray.length = 0;
			this._curAtlasIndex = 0;
		}

		__proto.getAtlaserCount = function () {
			return this._atlaserArray.length;
		}

		__proto.getAtlaserByIndex = function (index) {
			return this._atlaserArray[index];
		}

		__getset(1, AtlasResourceManager, 'instance', function () {
			if (!AtlasResourceManager._Instance) {
				AtlasResourceManager._Instance = new AtlasResourceManager(laya.webgl.atlas.AtlasResourceManager.atlasTextureWidth, laya.webgl.atlas.AtlasResourceManager.atlasTextureHeight,/*CLASS CONST:laya.webgl.atlas.AtlasResourceManager.gridSize*/16, laya.webgl.atlas.AtlasResourceManager.maxTextureCount);
			}
			return AtlasResourceManager._Instance;
		});

		__getset(1, AtlasResourceManager, 'enabled', function () {
			return Config.atlasEnable;
		});

		__getset(1, AtlasResourceManager, 'atlasLimitWidth', function () {
			return AtlasResourceManager._atlasLimitWidth;
		}, function (value) {
			AtlasResourceManager._atlasLimitWidth = value;
		});

		__getset(1, AtlasResourceManager, 'atlasLimitHeight', function () {
			return AtlasResourceManager._atlasLimitHeight;
		}, function (value) {
			AtlasResourceManager._atlasLimitHeight = value;
		});

		AtlasResourceManager._enable = function () {
			Config.atlasEnable = true;
		}

		AtlasResourceManager._disable = function () {
			Config.atlasEnable = false;
		}

		AtlasResourceManager.__init__ = function () {
			AtlasResourceManager.atlasTextureWidth = 2048;
			AtlasResourceManager.atlasTextureHeight = 2048;
			AtlasResourceManager.maxTextureCount = 6;
			AtlasResourceManager.atlasLimitWidth = 512;
			AtlasResourceManager.atlasLimitHeight = 512;
		}

		AtlasResourceManager._atlasLimitWidth = 0;
		AtlasResourceManager._atlasLimitHeight = 0;
		AtlasResourceManager.gridSize = 16;
		AtlasResourceManager.atlasTextureWidth = 0;
		AtlasResourceManager.atlasTextureHeight = 0;
		AtlasResourceManager.maxTextureCount = 0;
		AtlasResourceManager._atlasRestore = 0;
		AtlasResourceManager.BOARDER_TYPE_NO = 0;
		AtlasResourceManager.BOARDER_TYPE_RIGHT = 1;
		AtlasResourceManager.BOARDER_TYPE_LEFT = 2;
		AtlasResourceManager.BOARDER_TYPE_BOTTOM = 4;
		AtlasResourceManager.BOARDER_TYPE_TOP = 8;
		AtlasResourceManager.BOARDER_TYPE_ALL = 15;
		AtlasResourceManager._sid_ = 0;
		AtlasResourceManager._Instance = null;
		return AtlasResourceManager;
	})()


	//class laya.webgl.atlas.MergeFillInfo
	var MergeFillInfo = (function () {
		function MergeFillInfo() {
			this.x = 0;
			this.y = 0;
			this.ret = false;
			this.ret = false;
			this.x = 0;
			this.y = 0;
		}

		__class(MergeFillInfo, 'laya.webgl.atlas.MergeFillInfo');
		return MergeFillInfo;
	})()


		;
	//class laya.webgl.canvas.BlendMode
	var BlendMode = (function () {
		function BlendMode() { }
		__class(BlendMode, 'laya.webgl.canvas.BlendMode');
		BlendMode._init_ = function (gl) {
			BlendMode.fns = [BlendMode.BlendNormal, BlendMode.BlendAdd, BlendMode.BlendMultiply, BlendMode.BlendScreen, BlendMode.BlendOverlay, BlendMode.BlendLight, BlendMode.BlendMask, BlendMode.BlendDestinationOut];
			BlendMode.targetFns = [BlendMode.BlendNormalTarget, BlendMode.BlendAddTarget, BlendMode.BlendMultiplyTarget, BlendMode.BlendScreenTarget, BlendMode.BlendOverlayTarget, BlendMode.BlendLightTarget, BlendMode.BlendMask, BlendMode.BlendDestinationOut];
		}

		BlendMode.BlendNormal = function (gl) {
			// 修改之前
			// gl.blendFunc(/*laya.webgl.WebGLContext.ONE*/1,/*laya.webgl.WebGLContext.ONE_MINUS_SRC_ALPHA*/0x0303);
			// 修改之后
			gl.blendFuncSeparate(/*laya.webgl.WebGLContext.SRC_ALPHA*/0x0302,/*laya.webgl.WebGLContext.ONE_MINUS_SRC_ALPHA*/0x0303,/*laya.webgl.WebGLContext.ONE*/0x0302,/*laya.webgl.WebGLContext.ONE*/0x0303);
			// gl.blendFunc(/*laya.webgl.WebGLContext.ONE*/0x0302,/*laya.webgl.WebGLContext.ONE_MINUS_SRC_ALPHA*/0x0303);
		}

		BlendMode.BlendAdd = function (gl) {
			// debugger
			// 修改之前
			// gl.blendFunc(/*laya.webgl.WebGLContext.ONE*/1,/*laya.webgl.WebGLContext.DST_ALPHA*/0x0304);
			// 修改之后
			gl.blendFunc(/*laya.webgl.WebGLContext.ONE*/0x0302,/*laya.webgl.WebGLContext.DST_ALPHA*/0x0304);
		}

		BlendMode.BlendMultiply = function (gl) {
			gl.blendFunc(/*laya.webgl.WebGLContext.DST_COLOR*/0x0306,/*laya.webgl.WebGLContext.ONE_MINUS_SRC_ALPHA*/0x0303);
		}

		BlendMode.BlendScreen = function (gl) {
			gl.blendFunc(/*laya.webgl.WebGLContext.ONE*/1,/*laya.webgl.WebGLContext.ONE*/1);
		}

		BlendMode.BlendOverlay = function (gl) {
			gl.blendFunc(/*laya.webgl.WebGLContext.ONE*/1,/*laya.webgl.WebGLContext.ONE_MINUS_SRC_COLOR*/0x0301);
		}

		BlendMode.BlendLight = function (gl) {
			gl.blendFunc(/*laya.webgl.WebGLContext.ONE*/1,/*laya.webgl.WebGLContext.ONE*/1);
		}

		BlendMode.BlendNormalTarget = function (gl) {
			gl.blendFunc(/*laya.webgl.WebGLContext.ONE*/1,/*laya.webgl.WebGLContext.ONE_MINUS_SRC_ALPHA*/0x0303);
		}

		BlendMode.BlendAddTarget = function (gl) {
			gl.blendFunc(/*laya.webgl.WebGLContext.ONE*/1,/*laya.webgl.WebGLContext.DST_ALPHA*/0x0304);
		}

		BlendMode.BlendMultiplyTarget = function (gl) {
			gl.blendFunc(/*laya.webgl.WebGLContext.DST_COLOR*/0x0306,/*laya.webgl.WebGLContext.ONE_MINUS_SRC_ALPHA*/0x0303);
		}

		BlendMode.BlendScreenTarget = function (gl) {
			gl.blendFunc(/*laya.webgl.WebGLContext.ONE*/1,/*laya.webgl.WebGLContext.ONE*/1);
		}

		BlendMode.BlendOverlayTarget = function (gl) {
			gl.blendFunc(/*laya.webgl.WebGLContext.ONE*/1,/*laya.webgl.WebGLContext.ONE_MINUS_SRC_COLOR*/0x0301);
		}

		BlendMode.BlendLightTarget = function (gl) {
			gl.blendFunc(/*laya.webgl.WebGLContext.ONE*/1,/*laya.webgl.WebGLContext.ONE*/1);
		}

		BlendMode.BlendMask = function (gl) {
			gl.blendFunc(/*laya.webgl.WebGLContext.ZERO*/0,/*laya.webgl.WebGLContext.SRC_ALPHA*/0x0302);
		}

		BlendMode.BlendDestinationOut = function (gl) {
			gl.blendFunc(/*laya.webgl.WebGLContext.ZERO*/0,/*laya.webgl.WebGLContext.ZERO*/0);
		}

		BlendMode.activeBlendFunction = null;
		BlendMode.NAMES = ["normal", "add", "multiply", "screen", "overlay", "light", "mask", "destination-out"];
		BlendMode.TOINT = { "normal": 0, "add": 1, "multiply": 2, "screen": 3, "lighter": 1, "overlay": 4, "light": 5, "mask": 6, "destination-out": 7 };
		BlendMode.NORMAL = "normal";
		BlendMode.ADD = "add";
		BlendMode.MULTIPLY = "multiply";
		BlendMode.SCREEN = "screen";
		BlendMode.LIGHT = "light";
		BlendMode.OVERLAY = "overlay";
		BlendMode.DESTINATIONOUT = "destination-out";
		BlendMode.fns = [];
		BlendMode.targetFns = [];
		return BlendMode;
	})()


	//class laya.webgl.canvas.DrawStyle
	var DrawStyle = (function () {
		function DrawStyle(value) {
			this._color = Color.create("black");
			this.setValue(value);
		}

		__class(DrawStyle, 'laya.webgl.canvas.DrawStyle');
		var __proto = DrawStyle.prototype;
		__proto.setValue = function (value) {
			if (value) {
				if ((typeof value == 'string')) {
					this._color = Color.create(value);
					return;
				}
				if ((value instanceof laya.utils.Color)) {
					this._color = value;
					return;
				}
			}
		}

		__proto.reset = function () {
			this._color = Color.create("black");
		}

		__proto.equal = function (value) {
			if ((typeof value == 'string')) return this._color.strColor === value;
			if ((value instanceof laya.utils.Color)) return this._color.numColor === (value).numColor;
			return false;
		}

		__proto.toColorStr = function () {
			return this._color.strColor;
		}

		DrawStyle.create = function (value) {
			if (value) {
				var color;
				if ((typeof value == 'string')) color = Color.create(value);
				else if ((value instanceof laya.utils.Color)) color = value;
				if (color) {
					return color._drawStyle || (color._drawStyle = new DrawStyle(value));
				}
			}
			return laya.webgl.canvas.DrawStyle.DEFAULT;
		}

		__static(DrawStyle,
			['DEFAULT', function () { return this.DEFAULT = new DrawStyle("#000000"); }
			]);
		return DrawStyle;
	})()


	//class laya.webgl.canvas.Path
	var Path = (function () {
		function Path() {
			this._x = 0;
			this._y = 0;
			//this._rect=null;
			//this.ib=null;
			//this.vb=null;
			this.dirty = false;
			//this.geomatrys=null;
			//this._curGeomatry=null;
			this.offset = 0;
			this.count = 0;
			this.geoStart = 0;
			this.tempArray = [];
			this.closePath = false;
			this.geomatrys = [];
			var gl = WebGL.mainContext;
			this.ib = IndexBuffer2D.create(/*laya.webgl.WebGLContext.DYNAMIC_DRAW*/0x88E8);
			this.vb = VertexBuffer2D.create(5);
		}

		__class(Path, 'laya.webgl.canvas.Path');
		var __proto = Path.prototype;
		__proto.addPoint = function (pointX, pointY) {
			this.tempArray.push(pointX, pointY);
		}

		__proto.getEndPointX = function () {
			return this.tempArray[this.tempArray.length - 2];
		}

		__proto.getEndPointY = function () {
			return this.tempArray[this.tempArray.length - 1];
		}

		__proto.polygon = function (x, y, points, color, borderWidth, borderColor) {
			var geo;
			this.geomatrys.push(this._curGeomatry = geo = new Polygon(x, y, points, color, borderWidth, borderColor));
			if (!color) geo.fill = false;
			if (borderColor == undefined) geo.borderWidth = 0;
			return geo;
		}

		__proto.setGeomtry = function (shape) {
			this.geomatrys.push(this._curGeomatry = shape);
		}

		__proto.drawLine = function (x, y, points, width, color) {
			var geo;
			if (this.closePath) {
				this.geomatrys.push(this._curGeomatry = geo = new LoopLine(x, y, points, width, color));
			} else {
				this.geomatrys.push(this._curGeomatry = geo = new Line(x, y, points, width, color));
			}
			geo.fill = false;
			return geo;
		}

		__proto.update = function () {
			var si = this.ib._byteLength;
			var len = this.geomatrys.length;
			this.offset = si;
			for (var i = this.geoStart; i < len; i++) {
				this.geomatrys[i].getData(this.ib, this.vb, this.vb._byteLength / 20);
			}
			this.geoStart = len;
			this.count = (this.ib._byteLength - si) / CONST3D2D.BYTES_PIDX;
		}

		__proto.reset = function () {
			this.vb.clear();
			this.ib.clear();
			this.offset = this.count = this.geoStart = 0;
			this.geomatrys.length = 0;
		}

		__proto.recover = function () {
			this._curGeomatry = null;
			this.vb.destory();
			this.vb = null;
			this.ib.destory();
			this.ib = null;
		}

		return Path;
	})()


	//class laya.webgl.canvas.save.SaveBase
	var SaveBase = (function () {
		function SaveBase() {
			//this._valueName=null;
			//this._value=null;
			//this._dataObj=null;
			//this._newSubmit=false;
		}

		__class(SaveBase, 'laya.webgl.canvas.save.SaveBase');
		var __proto = SaveBase.prototype;
		Laya.imps(__proto, { "laya.webgl.canvas.save.ISaveData": true })
		__proto.isSaveMark = function () { return false; }
		__proto.restore = function (context) {
			this._dataObj[this._valueName] = this._value;
			SaveBase._cache[SaveBase._cache._length++] = this;
			this._newSubmit && (context._curSubmit = Submit.RENDERBASE, context._renderKey = 0);
		}

		SaveBase._createArray = function () {
			var value = [];
			value._length = 0;
			return value;
		}

		SaveBase._init = function () {
			var namemap = SaveBase._namemap = {};
			namemap[0x1] = "ALPHA";
			namemap[0x2] = "fillStyle";
			namemap[0x8] = "font";
			namemap[0x100] = "lineWidth";
			namemap[0x200] = "strokeStyle";
			namemap[0x2000] = "_mergeID";
			namemap[0x400] = namemap[0x800] = namemap[0x1000] = [];
			namemap[0x4000] = "textBaseline";
			namemap[0x8000] = "textAlign";
			namemap[0x10000] = "_nBlendType";
			namemap[0x100000] = "shader";
			namemap[0x200000] = "filters";
			return namemap;
		}

		SaveBase.save = function (context, type, dataObj, newSubmit) {
			if ((context._saveMark._saveuse & type) !== type) {
				context._saveMark._saveuse |= type;
				var cache = SaveBase._cache;
				var o = cache._length > 0 ? cache[--cache._length] : (new SaveBase());
				o._value = dataObj[o._valueName = SaveBase._namemap[type]];
				o._dataObj = dataObj;
				o._newSubmit = newSubmit;
				var _save = context._save;
				_save[_save._length++] = o;
			}
		}

		SaveBase._cache = laya.webgl.canvas.save.SaveBase._createArray();
		SaveBase._namemap = SaveBase._init();
		return SaveBase;
	})()


	//class laya.webgl.canvas.save.SaveClipRect
	var SaveClipRect = (function () {
		function SaveClipRect() {
			//this._clipSaveRect=null;
			//this._submitScissor=null;
			this._clipRect = new Rectangle();
		}

		__class(SaveClipRect, 'laya.webgl.canvas.save.SaveClipRect');
		var __proto = SaveClipRect.prototype;
		Laya.imps(__proto, { "laya.webgl.canvas.save.ISaveData": true })
		__proto.isSaveMark = function () { return false; }
		__proto.restore = function (context) {
			context._clipRect = this._clipSaveRect;
			SaveClipRect._cache[SaveClipRect._cache._length++] = this;
			this._submitScissor.submitLength = context._submits._length - this._submitScissor.submitIndex;
			context._curSubmit = Submit.RENDERBASE;
			context._renderKey = 0;
		}

		SaveClipRect.save = function (context, submitScissor) {
			if ((context._saveMark._saveuse & /*laya.webgl.canvas.save.SaveBase.TYPE_CLIPRECT*/0x20000) ==/*laya.webgl.canvas.save.SaveBase.TYPE_CLIPRECT*/0x20000) return;
			context._saveMark._saveuse |=/*laya.webgl.canvas.save.SaveBase.TYPE_CLIPRECT*/0x20000;
			var cache = SaveClipRect._cache;
			var o = cache._length > 0 ? cache[--cache._length] : (new SaveClipRect());
			o._clipSaveRect = context._clipRect;
			context._clipRect = o._clipRect.copyFrom(context._clipRect);
			o._submitScissor = submitScissor;
			var _save = context._save;
			_save[_save._length++] = o;
		}

		__static(SaveClipRect,
			['_cache', function () { return this._cache = SaveBase._createArray(); }
			]);
		return SaveClipRect;
	})()


	//class laya.webgl.canvas.save.SaveClipRectStencil
	var SaveClipRectStencil = (function () {
		function SaveClipRectStencil() {
			//this._clipSaveRect=null;
			//this._saveMatrix=null;
			this._contextX = 0;
			this._contextY = 0;
			//this._submitStencil=null;
			this._clipRect = new Rectangle();
			this._rect = new Rectangle();
			this._matrix = new Matrix();
		}

		__class(SaveClipRectStencil, 'laya.webgl.canvas.save.SaveClipRectStencil');
		var __proto = SaveClipRectStencil.prototype;
		Laya.imps(__proto, { "laya.webgl.canvas.save.ISaveData": true })
		__proto.isSaveMark = function () { return false; }
		__proto.restore = function (context) {
			SubmitStencil.restore(context, this._rect, this._saveMatrix, this._contextX, this._contextY);
			context._clipRect = this._clipSaveRect;
			context._curMat = this._saveMatrix;
			context._x = this._contextX;
			context._y = this._contextY;
			SaveClipRectStencil._cache[SaveClipRectStencil._cache._length++] = this;
			context._curSubmit = Submit.RENDERBASE;
		}

		SaveClipRectStencil.save = function (context, submitStencil, x, y, width, height, clipX, clipY, clipWidth, clipHeight) {
			if ((context._saveMark._saveuse & /*laya.webgl.canvas.save.SaveBase.TYPE_CLIPRECT_STENCIL*/0x40000) ==/*laya.webgl.canvas.save.SaveBase.TYPE_CLIPRECT_STENCIL*/0x40000) return;
			context._saveMark._saveuse |=/*laya.webgl.canvas.save.SaveBase.TYPE_CLIPRECT_STENCIL*/0x40000;
			var cache = SaveClipRectStencil._cache;
			var o = cache._length > 0 ? cache[--cache._length] : (new SaveClipRectStencil());
			o._clipSaveRect = context._clipRect;
			o._clipRect.setTo(clipX, clipY, clipWidth, clipHeight);
			context._clipRect = o._clipRect;
			o._rect.x = x;
			o._rect.y = y;
			o._rect.width = width;
			o._rect.height = height;
			o._contextX = context._x;
			o._contextY = context._y;
			o._saveMatrix = context._curMat;
			context._curMat.copyTo(o._matrix);
			context._curMat = o._matrix;
			o._submitStencil = submitStencil;
			var _save = context._save;
			_save[_save._length++] = o;
		}

		__static(SaveClipRectStencil,
			['_cache', function () { return this._cache = SaveBase._createArray(); }
			]);
		return SaveClipRectStencil;
	})()


	//class laya.webgl.canvas.save.SaveMark
	var SaveMark = (function () {
		function SaveMark() {
			this._saveuse = 0;
			//this._preSaveMark=null;
			;
		}

		__class(SaveMark, 'laya.webgl.canvas.save.SaveMark');
		var __proto = SaveMark.prototype;
		Laya.imps(__proto, { "laya.webgl.canvas.save.ISaveData": true })
		__proto.isSaveMark = function () {
			return true;
		}

		__proto.restore = function (context) {
			context._saveMark = this._preSaveMark;
			SaveMark._no[SaveMark._no._length++] = this;
		}

		SaveMark.Create = function (context) {
			var no = SaveMark._no;
			var o = no._length > 0 ? no[--no._length] : (new SaveMark());
			o._saveuse = 0;
			o._preSaveMark = context._saveMark;
			context._saveMark = o;
			return o;
		}

		__static(SaveMark,
			['_no', function () { return this._no = SaveBase._createArray(); }
			]);
		return SaveMark;
	})()


	//class laya.webgl.canvas.save.SaveTransform
	var SaveTransform = (function () {
		function SaveTransform() {
			//this._savematrix=null;
			this._matrix = new Matrix();
		}

		__class(SaveTransform, 'laya.webgl.canvas.save.SaveTransform');
		var __proto = SaveTransform.prototype;
		Laya.imps(__proto, { "laya.webgl.canvas.save.ISaveData": true })
		__proto.isSaveMark = function () { return false; }
		__proto.restore = function (context) {
			context._curMat = this._savematrix;
			SaveTransform._no[SaveTransform._no._length++] = this;
		}

		SaveTransform.save = function (context) {
			var _saveMark = context._saveMark;
			if ((_saveMark._saveuse & /*laya.webgl.canvas.save.SaveBase.TYPE_TRANSFORM*/0x800) ===/*laya.webgl.canvas.save.SaveBase.TYPE_TRANSFORM*/0x800) return;
			_saveMark._saveuse |=/*laya.webgl.canvas.save.SaveBase.TYPE_TRANSFORM*/0x800;
			var no = SaveTransform._no;
			var o = no._length > 0 ? no[--no._length] : (new SaveTransform());
			o._savematrix = context._curMat;
			context._curMat = context._curMat.copyTo(o._matrix);
			var _save = context._save;
			_save[_save._length++] = o;
		}

		__static(SaveTransform,
			['_no', function () { return this._no = SaveBase._createArray(); }
			]);
		return SaveTransform;
	})()


	//class laya.webgl.canvas.save.SaveTranslate
	var SaveTranslate = (function () {
		function SaveTranslate() {
			//this._x=NaN;
			//this._y=NaN;
		}

		__class(SaveTranslate, 'laya.webgl.canvas.save.SaveTranslate');
		var __proto = SaveTranslate.prototype;
		Laya.imps(__proto, { "laya.webgl.canvas.save.ISaveData": true })
		__proto.isSaveMark = function () { return false; }
		__proto.restore = function (context) {
			var mat = context._curMat;
			context._x = this._x;
			context._y = this._y;
			SaveTranslate._no[SaveTranslate._no._length++] = this;
		}

		SaveTranslate.save = function (context) {
			var no = SaveTranslate._no;
			var o = no._length > 0 ? no[--no._length] : (new SaveTranslate());
			o._x = context._x;
			o._y = context._y;
			var _save = context._save;
			_save[_save._length++] = o;
		}

		__static(SaveTranslate,
			['_no', function () { return this._no = SaveBase._createArray(); }
			]);
		return SaveTranslate;
	})()


	//class laya.webgl.resource.RenderTargetMAX
	var RenderTargetMAX = (function () {
		function RenderTargetMAX() {
			//public var targets:Vector.<OneTarget>;//没用到
			this.target = null;
			this.repaint = false;
			this._width = NaN;
			this._height = NaN;
			this._sp = null;
			this._clipRect = new Rectangle();
		}

		__class(RenderTargetMAX, 'laya.webgl.resource.RenderTargetMAX');
		var __proto = RenderTargetMAX.prototype;
		__proto.setSP = function (sp) {
			this._sp = sp;
		}

		__proto.size = function (w, h) {
			var _$this = this;
			if (this._width === w && this._height === h) {
				this.target.size(w, h);
				return;
			}
			this.repaint = true;
			this._width = w;
			this._height = h;
			if (!this.target)
				this.target = RenderTarget2D.create(w, h);
			else
				this.target.size(w, h);
			if (!this.target.hasListener(/*laya.events.Event.RECOVERED*/"recovered")) {
				this.target.on(/*laya.events.Event.RECOVERED*/"recovered", this, function (e) {
					Laya.timer.callLater(_$this._sp, _$this._sp.repaint);
				});
			}
		}

		__proto._flushToTarget = function (context, target) {
			if (target._destroy) return;
			var worldScissorTest = RenderState2D.worldScissorTest;
			var preworldClipRect = RenderState2D.worldClipRect;
			RenderState2D.worldClipRect = this._clipRect;
			this._clipRect.x = this._clipRect.y = 0;
			this._clipRect.width = this._width;
			this._clipRect.height = this._height;
			RenderState2D.worldScissorTest = false;
			WebGL.mainContext.disable(/*laya.webgl.WebGLContext.SCISSOR_TEST*/0x0C11);
			var preAlpha = RenderState2D.worldAlpha;
			var preMatrix4 = RenderState2D.worldMatrix4;
			var preMatrix = RenderState2D.worldMatrix;
			var preFilters = RenderState2D.worldFilters;
			var preShaderDefines = RenderState2D.worldShaderDefines;
			RenderState2D.worldMatrix = Matrix.EMPTY;
			RenderState2D.restoreTempArray();
			RenderState2D.worldMatrix4 = RenderState2D.TEMPMAT4_ARRAY;
			RenderState2D.worldAlpha = 1;
			RenderState2D.worldFilters = null;
			RenderState2D.worldShaderDefines = null;
			BaseShader.activeShader = null;
			target.start();
			Config.showCanvasMark ? target.clear(0, 1, 0, 0.3) : target.clear(0, 0, 0, 0);
			context.flush();
			target.end();
			BaseShader.activeShader = null;
			RenderState2D.worldAlpha = preAlpha;
			RenderState2D.worldMatrix4 = preMatrix4;
			RenderState2D.worldMatrix = preMatrix;
			RenderState2D.worldFilters = preFilters;
			RenderState2D.worldShaderDefines = preShaderDefines;
			RenderState2D.worldScissorTest = worldScissorTest
			if (worldScissorTest) {
				var y = RenderState2D.height - preworldClipRect.y - preworldClipRect.height;
				WebGL.mainContext.scissor(preworldClipRect.x, y, preworldClipRect.width, preworldClipRect.height);
				WebGL.mainContext.enable(/*laya.webgl.WebGLContext.SCISSOR_TEST*/0x0C11);
			}
			RenderState2D.worldClipRect = preworldClipRect;
		}

		__proto.flush = function (context) {
			if (this.repaint) {
				this._flushToTarget(context, this.target);
				this.repaint = false;
			}
		}

		__proto.drawTo = function (context, x, y, width, height) {
			context.drawTexture(this.target.getTexture(), x, y, width, height, 0, 0);
		}

		__proto.destroy = function () {
			if (this.target) {
				this.target.destroy();
				this.target = null;
				this._sp = null;
			}
		}

		return RenderTargetMAX;
	})()


	//class laya.webgl.shader.d2.Shader2D
	var Shader2D = (function () {
		function Shader2D() {
			this.ALPHA = 1;
			//this.glTexture=null;
			//this.shader=null;
			//this.filters=null;
			this.shaderType = 0;
			//this.colorAdd=null;
			//this.strokeStyle=null;
			//this.fillStyle=null;
			this.defines = new ShaderDefines2D();
		}

		__class(Shader2D, 'laya.webgl.shader.d2.Shader2D');
		var __proto = Shader2D.prototype;
		__proto.destroy = function () {
			this.defines = null;
			this.filters = null;
			this.glTexture = null;
			this.strokeStyle = null;
			this.fillStyle = null;
		}

		Shader2D.__init__ = function () {
			Shader.addInclude("parts/ColorFilter_ps_uniform.glsl", "uniform vec4 colorAlpha;\nuniform mat4 colorMat;");
			Shader.addInclude("parts/ColorFilter_ps_logic.glsl", "mat4 alphaMat =colorMat;\n\nalphaMat[0][3] *= gl_FragColor.a;\nalphaMat[1][3] *= gl_FragColor.a;\nalphaMat[2][3] *= gl_FragColor.a;\n\ngl_FragColor = gl_FragColor * alphaMat;\ngl_FragColor += colorAlpha/255.0*gl_FragColor.a;\n");
			Shader.addInclude("parts/GlowFilter_ps_uniform.glsl", "uniform vec4 u_color;\nuniform float u_strength;\nuniform float u_blurX;\nuniform float u_blurY;\nuniform float u_offsetX;\nuniform float u_offsetY;\nuniform float u_textW;\nuniform float u_textH;");
			Shader.addInclude("parts/GlowFilter_ps_logic.glsl", "const float c_IterationTime = 10.0;\nfloat floatIterationTotalTime = c_IterationTime * c_IterationTime;\nvec4 vec4Color = vec4(0.0,0.0,0.0,0.0);\nvec2 vec2FilterDir = vec2(-(u_offsetX)/u_textW,-(u_offsetY)/u_textH);\nvec2 vec2FilterOff = vec2(u_blurX/u_textW/c_IterationTime * 2.0,u_blurY/u_textH/c_IterationTime * 2.0);\nfloat maxNum = u_blurX * u_blurY;\nvec2 vec2Off = vec2(0.0,0.0);\nfloat floatOff = c_IterationTime/2.0;\nfor(float i = 0.0;i<=c_IterationTime; ++i){\n	for(float j = 0.0;j<=c_IterationTime; ++j){\n		vec2Off = vec2(vec2FilterOff.x * (i - floatOff),vec2FilterOff.y * (j - floatOff));\n		vec4Color += texture2D(texture, v_texcoord + vec2FilterDir + vec2Off)/floatIterationTotalTime;\n	}\n}\ngl_FragColor = vec4(u_color.rgb,vec4Color.a * u_strength);\ngl_FragColor.rgb *= gl_FragColor.a;");
			Shader.addInclude("parts/BlurFilter_ps_logic.glsl", "gl_FragColor =   blur();\ngl_FragColor.w*=alpha;");
			Shader.addInclude("parts/BlurFilter_ps_uniform.glsl", "uniform vec4 strength_sig2_2sig2_gauss1;\nuniform vec2 blurInfo;\n\n#define PI 3.141593\n\n//float sigma=strength/3.0;//3σ以外影响很小。即当σ=1的时候，半径为3\n//float sig2 = sigma*sigma;\n//float _2sig2 = 2.0*sig2;\n//return 1.0/(2*PI*sig2)*exp(-(x*x+y*y)/_2sig2)\n//float gauss1 = 1.0/(2.0*PI*sig2);\n\nfloat getGaussian(float x, float y){\n    return strength_sig2_2sig2_gauss1.w*exp(-(x*x+y*y)/strength_sig2_2sig2_gauss1.z);\n}\n\nvec4 blur(){\n    const float blurw = 9.0;\n    vec4 vec4Color = vec4(0.0,0.0,0.0,0.0);\n    vec2 halfsz=vec2(blurw,blurw)/2.0/blurInfo;    \n    vec2 startpos=v_texcoord-halfsz;\n    vec2 ctexcoord = startpos;\n    vec2 step = 1.0/blurInfo;  //每个像素      \n    \n    for(float y = 0.0;y<=blurw; ++y){\n        ctexcoord.x=startpos.x;\n        for(float x = 0.0;x<=blurw; ++x){\n            //TODO 纹理坐标的固定偏移应该在vs中处理\n            vec4Color += texture2D(texture, ctexcoord)*getGaussian(x-blurw/2.0,y-blurw/2.0);\n            ctexcoord.x+=step.x;\n        }\n        ctexcoord.y+=step.y;\n    }\n    return vec4Color;\n}");
			Shader.addInclude("parts/ColorAdd_ps_uniform.glsl", "uniform vec4 colorAdd;\n");
			Shader.addInclude("parts/ColorAdd_ps_logic.glsl", "gl_FragColor = vec4(colorAdd.rgb,colorAdd.a*gl_FragColor.a);\ngl_FragColor.xyz *= colorAdd.a;");
			var vs, ps;
			vs = "attribute vec4 position;\nattribute vec2 texcoord;\nuniform vec2 size;\n\n#ifdef WORLDMAT\nuniform mat4 mmat;\n#endif\nvarying vec2 v_texcoord;\nvoid main() {\n  #ifdef WORLDMAT\n  vec4 pos=mmat*position;\n  gl_Position =vec4((pos.x/size.x-0.5)*2.0,(0.5-pos.y/size.y)*2.0,pos.z,1.0);\n  #else\n  gl_Position =vec4((position.x/size.x-0.5)*2.0,(0.5-position.y/size.y)*2.0,position.z,1.0);\n  #endif\n  \n  v_texcoord = texcoord;\n}";
			ps = "precision mediump float;\n//precision highp float;\nvarying vec2 v_texcoord;\nuniform sampler2D texture;\nuniform float alpha;\n#include?BLUR_FILTER  \"parts/BlurFilter_ps_uniform.glsl\";\n#include?COLOR_FILTER \"parts/ColorFilter_ps_uniform.glsl\";\n#include?GLOW_FILTER \"parts/GlowFilter_ps_uniform.glsl\";\n#include?COLOR_ADD \"parts/ColorAdd_ps_uniform.glsl\";\n\nvoid main() {\n   vec4 color= texture2D(texture, v_texcoord);\nif(color.a<1.0)color.rgb*=1.0/color.a;\n   color.a*=alpha;\n   \n   gl_FragColor=color;\n   #include?COLOR_ADD \"parts/ColorAdd_ps_logic.glsl\";   \n   #include?BLUR_FILTER  \"parts/BlurFilter_ps_logic.glsl\";\n   #include?COLOR_FILTER \"parts/ColorFilter_ps_logic.glsl\";\n   #include?GLOW_FILTER \"parts/GlowFilter_ps_logic.glsl\";\n}";

			Shader.preCompile2D(0,/*laya.webgl.shader.d2.ShaderDefines2D.TEXTURE2D*/0x01, vs, ps, null);
			vs = "attribute vec4 position;\nuniform vec2 size;\nuniform mat4 mmat;\nvoid main() {\n  vec4 pos=mmat*position;\n  gl_Position =vec4((pos.x/size.x-0.5)*2.0,(0.5-pos.y/size.y)*2.0,pos.z,1.0);\n}";
			ps = "precision mediump float;\nuniform vec4 color;\nuniform float alpha;\n#include?COLOR_FILTER \"parts/ColorFilter_ps_uniform.glsl\";\nvoid main() {\n	vec4 a = vec4(color.r, color.g, color.b, color.a);\n	a.w = alpha;\n	a.xyz *= alpha;\n	gl_FragColor = a;\n	#include?COLOR_FILTER \"parts/ColorFilter_ps_logic.glsl\";\n}";
			Shader.preCompile2D(0,/*laya.webgl.shader.d2.ShaderDefines2D.COLOR2D*/0x02, vs, ps, null);
			vs = "attribute vec4 position;\nattribute vec3 a_color;\nuniform mat4 mmat;\nuniform mat4 u_mmat2;\nuniform vec2 u_pos;\nuniform vec2 size;\nvarying vec3 color;\nvoid main(){\n  vec4 tPos = vec4(position.x + u_pos.x,position.y + u_pos.y,position.z,position.w);\n  vec4 pos=mmat*u_mmat2*tPos;\n  gl_Position =vec4((pos.x/size.x-0.5)*2.0,(0.5-pos.y/size.y)*2.0,pos.z,1.0);\n  color=a_color;\n}";
			ps = "precision mediump float;\n//precision mediump float;\nvarying vec3 color;\nuniform float alpha;\nvoid main(){\n	//vec4 a=vec4(color.r, color.g, color.b, 1);\n	//a.a*=alpha;\n    gl_FragColor=vec4(color.r, color.g, color.b, alpha);\n	gl_FragColor.rgb*=alpha;\n}";
			Shader.preCompile2D(0,/*laya.webgl.shader.d2.ShaderDefines2D.PRIMITIVE*/0x04, vs, ps, null);
			vs = "attribute vec4 position;\nattribute vec2 texcoord;\nuniform vec2 size;\n\n#ifdef WORLDMAT\nuniform mat4 mmat;\n#endif\nvarying vec2 v_texcoord;\nvoid main() {\n  #ifdef WORLDMAT\n  vec4 pos=mmat*position;\n  gl_Position =vec4((pos.x/size.x-0.5)*2.0,(0.5-pos.y/size.y)*2.0,pos.z,1.0);\n  #else\n  gl_Position =vec4((position.x/size.x-0.5)*2.0,(0.5-position.y/size.y)*2.0,position.z,1.0);\n  #endif\n  \n  v_texcoord = texcoord;\n}";
			ps = "#ifdef FSHIGHPRECISION\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n//precision highp float;\nvarying vec2 v_texcoord;\nuniform sampler2D texture;\nuniform float alpha;\nuniform vec4 u_TexRange;\nuniform vec2 u_offset;\n#include?BLUR_FILTER  \"parts/BlurFilter_ps_uniform.glsl\";\n#include?COLOR_FILTER \"parts/ColorFilter_ps_uniform.glsl\";\n#include?GLOW_FILTER \"parts/GlowFilter_ps_uniform.glsl\";\n#include?COLOR_ADD \"parts/ColorAdd_ps_uniform.glsl\";\n\nvoid main() {\n   vec2 newTexCoord;\n   newTexCoord.x = mod(u_offset.x + v_texcoord.x,u_TexRange.y) + u_TexRange.x;\n   newTexCoord.y = mod(u_offset.y + v_texcoord.y,u_TexRange.w) + u_TexRange.z;\n   vec4 color= texture2D(texture, newTexCoord);\n if(color.a<1.0)color.rgb*=1.0/color.a;  color.a*=alpha;\n   gl_FragColor=color;\n   #include?COLOR_ADD \"parts/ColorAdd_ps_logic.glsl\";   \n   #include?BLUR_FILTER  \"parts/BlurFilter_ps_logic.glsl\";\n   #include?COLOR_FILTER \"parts/ColorFilter_ps_logic.glsl\";\n   #include?GLOW_FILTER \"parts/GlowFilter_ps_logic.glsl\";\n}";
			Shader.preCompile2D(0,/*laya.webgl.shader.d2.ShaderDefines2D.FILLTEXTURE*/0x100, vs, ps, null);
			vs = "attribute vec2 position;\nattribute vec2 texcoord;\nattribute vec4 color;\nuniform vec2 size;\nuniform float offsetX;\nuniform float offsetY;\nuniform mat4 mmat;\nuniform mat4 u_mmat2;\nvarying vec2 v_texcoord;\nvarying vec4 v_color;\nvoid main() {\n  vec4 pos=mmat*u_mmat2*vec4(offsetX+position.x,offsetY+position.y,0,1 );\n  gl_Position = vec4((pos.x/size.x-0.5)*2.0,(0.5-pos.y/size.y)*2.0,pos.z,1.0);\n  v_color = color;\n  v_color.rgb *= v_color.a;\n  v_texcoord = texcoord;  \n}";
			ps = "precision mediump float;\nvarying vec2 v_texcoord;\nvarying vec4 v_color;\nuniform sampler2D texture;\nuniform float alpha;\nvoid main() {\n	vec4 t_color = texture2D(texture, v_texcoord);\n	gl_FragColor = t_color.rgba * v_color;\n	gl_FragColor *= alpha;\n}";
			Shader.preCompile2D(0,/*laya.webgl.shader.d2.ShaderDefines2D.SKINMESH*/0x200, vs, ps, null);
		}

		return Shader2D;
	})()


	//class laya.webgl.shader.ShaderDefines
	var ShaderDefines = (function () {
		function ShaderDefines(name2int, int2name, int2nameMap) {
			this._value = 0;
			//this._name2int=null;
			//this._int2name=null;
			//this._int2nameMap=null;
			this._name2int = name2int;
			this._int2name = int2name;
			this._int2nameMap = int2nameMap;
		}

		__class(ShaderDefines, 'laya.webgl.shader.ShaderDefines');
		var __proto = ShaderDefines.prototype;
		__proto.add = function (value) {
			if ((typeof value == 'string')) value = this._name2int[value];
			this._value |= value;
			return this._value;
		}

		__proto.addInt = function (value) {
			this._value |= value;
			return this._value;
		}

		__proto.remove = function (value) {
			if ((typeof value == 'string')) value = this._name2int[value];
			this._value &= (~value);
			return this._value;
		}

		__proto.isDefine = function (def) {
			return (this._value & def) === def;
		}

		__proto.getValue = function () {
			return this._value;
		}

		__proto.setValue = function (value) {
			this._value = value;
		}

		__proto.toNameDic = function () {
			var r = this._int2nameMap[this._value];
			return r ? r : ShaderDefines._toText(this._value, this._int2name, this._int2nameMap);
		}

		ShaderDefines._reg = function (name, value, _name2int, _int2name) {
			_name2int[name] = value;
			_int2name[value] = name;
		}

		ShaderDefines._toText = function (value, _int2name, _int2nameMap) {
			var r = _int2nameMap[value];
			if (r) return r;
			var o = {};
			var d = 1;
			for (var i = 0; i < 32; i++) {
				d = 1 << i;
				if (d > value) break;
				if (value & d) {
					var name = _int2name[d];
					name && (o[name] = "");
				}
			}
			_int2nameMap[value] = o;
			return o;
		}

		ShaderDefines._toInt = function (names, _name2int) {
			var words = names.split('.');
			var num = 0;
			for (var i = 0, n = words.length; i < n; i++) {
				var value = _name2int[words[i]];
				if (!value) throw new Error("Defines to int err:" + names + "/" + words[i]);
				num |= value;
			}
			return num;
		}

		return ShaderDefines;
	})()


	/**
	*这里销毁的问题，后面待确认
	*/
	//class laya.webgl.shader.d2.skinAnishader.SkinMesh
	var SkinMesh = (function () {
		function SkinMesh() {
			this.mVBBuffer = null;
			this.mIBBuffer = null;
			this.mVBData = null;
			this.mIBData = null;
			this.mEleNum = 0;
			this.mTexture = null;
			this.transform = null;
			this._vs = null;
			this._ps = null;
			this._indexStart = -1;
			this._verticles = null;
			this._uvs = null;
			this._tempMatrix = new Matrix();
		}

		__class(SkinMesh, 'laya.webgl.shader.d2.skinAnishader.SkinMesh');
		var __proto = SkinMesh.prototype;
		__proto.init = function (texture, vs, ps) {
			if (vs) {
				this._vs = vs;
			} else {
				this._vs = [];
				var tWidth = texture.width;
				var tHeight = texture.height;
				var tRed = 1;
				var tGreed = 1;
				var tBlue = 1;
				var tAlpha = 1;
				this._vs.push(0, 0, 0, 0, tRed, tGreed, tBlue, tAlpha);
				this._vs.push(tWidth, 0, 1, 0, tRed, tGreed, tBlue, tAlpha);
				this._vs.push(tWidth, tHeight, 1, 1, tRed, tGreed, tBlue, tAlpha);
				this._vs.push(0, tHeight, 0, 1, tRed, tGreed, tBlue, tAlpha);
			}
			if (ps) {
				this._ps = ps;
			} else {
				if (!SkinMesh._defaultPS) {
					SkinMesh._defaultPS = [];
					SkinMesh._defaultPS.push(0, 1, 3, 3, 1, 2);
				}
				this._ps = SkinMesh._defaultPS;
			}
			this.mVBData = new Float32Array(this._vs);
			this.mIBData = new Uint16Array(this._ps.length);
			this.mIBData["start"] = -1;
			this.mEleNum = this._ps.length;
			this.mTexture = texture;
		}

		__proto.init2 = function (texture, vs, ps, verticles, uvs) {
			if (this.transform) this.transform = null;
			if (ps) {
				this._ps = ps;
			} else {
				this._ps = [];
				this._ps.push(0, 1, 3, 3, 1, 2);
			}
			this._verticles = verticles;
			this._uvs = uvs;
			this.mEleNum = this._ps.length;
			this.mTexture = texture;
			if (Render.isConchNode || Render.isConchApp) {
				this._initMyData();
				this.mVBData = new Float32Array(this._vs);
			}
		}

		__proto._initMyData = function () {
			var vsI = 0;
			var vI = 0;
			var vLen = this._verticles.length;
			var tempVLen = vLen * 4;
			this._vs = SkinMesh._tempVS;
			var insertNew = false;
			if (Render.isConchNode || Render.isConchApp) {
				this._vs.length = tempVLen;
				insertNew = true;
			} else {
				if (this._vs.length < tempVLen) {
					this._vs.length = tempVLen;
					insertNew = true;
				}
			}
			SkinMesh._tVSLen = tempVLen;
			if (insertNew) {
				while (vsI < tempVLen) {
					this._vs[vsI] = this._verticles[vI];
					this._vs[vsI + 1] = this._verticles[vI + 1];
					this._vs[vsI + 2] = this._uvs[vI];
					this._vs[vsI + 3] = this._uvs[vI + 1];
					this._vs[vsI + 4] = 1;
					this._vs[vsI + 5] = 1;
					this._vs[vsI + 6] = 1;
					this._vs[vsI + 7] = 1;
					vsI += 8;
					vI += 2;
				}
			} else {
				while (vsI < tempVLen) {
					this._vs[vsI] = this._verticles[vI];
					this._vs[vsI + 1] = this._verticles[vI + 1];
					this._vs[vsI + 2] = this._uvs[vI];
					this._vs[vsI + 3] = this._uvs[vI + 1];
					vsI += 8;
					vI += 2;
				}
			}
		}

		__proto.getData2 = function (vb, ib, start) {
			this.mVBBuffer = vb;
			this.mIBBuffer = ib;
			this._initMyData();
			vb.appendEx2(this._vs, Float32Array, SkinMesh._tVSLen, 4);
			this._indexStart = ib._byteLength;
			var tIB;
			tIB = SkinMesh._tempIB;
			if (tIB.length < this._ps.length) {
				tIB.length = this._ps.length;
			}
			for (var i = 0, n = this._ps.length; i < n; i++) {
				tIB[i] = this._ps[i] + start;
			}
			ib.appendEx2(tIB, Uint16Array, this._ps.length, 2);
		}

		__proto.getData = function (vb, ib, start) {
			this.mVBBuffer = vb;
			this.mIBBuffer = ib;
			vb.append(this.mVBData);
			this._indexStart = ib._byteLength;
			if (this.mIBData["start"] != start) {
				for (var i = 0, n = this._ps.length; i < n; i++) {
					this.mIBData[i] = this._ps[i] + start;
				}
				this.mIBData["start"] = start;
			}
			ib.append(this.mIBData);
		}

		__proto.render = function (context, x, y) {
			if (Render.isWebGL && this.mTexture) {
				context._renderKey = 0;
				context._shader2D.glTexture = null;
				SkinMeshBuffer.getInstance().addSkinMesh(this);
				var tempSubmit = Submit.createShape(context, this.mIBBuffer, this.mVBBuffer, this.mEleNum, this._indexStart, Value2D.create(/*laya.webgl.shader.d2.ShaderDefines2D.SKINMESH*/0x200, 0));
				this.transform || (this.transform = Matrix.EMPTY);
				this.transform.translate(x, y);
				Matrix.mul(this.transform, context._curMat, this._tempMatrix);
				this.transform.translate(-x, -y);
				var tShaderValue = tempSubmit.shaderValue;
				var tArray = tShaderValue.u_mmat2 || RenderState2D.getMatrArray();
				RenderState2D.mat2MatArray(this._tempMatrix, tArray);
				tShaderValue.textureHost = this.mTexture;
				tShaderValue.offsetX = 0;
				tShaderValue.offsetY = 0;
				tShaderValue.u_mmat2 = tArray;
				tShaderValue.ALPHA = context._shader2D.ALPHA;
				context._submits[context._submits._length++] = tempSubmit;
			}
			else if (Render.isConchApp && this.mTexture) {
				this.transform || (this.transform = Matrix.EMPTY);
				context.setSkinMesh && context.setSkinMesh(x, y, this._ps, this.mVBData, this.mEleNum, 0, this.mTexture, this.transform);
			}
		}

		SkinMesh._tempVS = [];
		SkinMesh._tempIB = [];
		SkinMesh._defaultPS = null;
		SkinMesh._tVSLen = 0;
		return SkinMesh;
	})()


	//class laya.webgl.shader.d2.skinAnishader.SkinMeshBuffer
	var SkinMeshBuffer = (function () {
		function SkinMeshBuffer() {
			this.ib = null;
			this.vb = null;
			var gl = WebGL.mainContext;
			this.ib = IndexBuffer2D.create(/*laya.webgl.WebGLContext.DYNAMIC_DRAW*/0x88E8);
			this.vb = VertexBuffer2D.create(8);
		}

		__class(SkinMeshBuffer, 'laya.webgl.shader.d2.skinAnishader.SkinMeshBuffer');
		var __proto = SkinMeshBuffer.prototype;
		__proto.addSkinMesh = function (skinMesh) {
			skinMesh.getData2(this.vb, this.ib, this.vb._byteLength / 32);
		}

		__proto.reset = function () {
			this.vb.clear();
			this.ib.clear();
		}

		SkinMeshBuffer.getInstance = function () {
			return SkinMeshBuffer.instance = SkinMeshBuffer.instance || new SkinMeshBuffer();
		}

		SkinMeshBuffer.instance = null;
		return SkinMeshBuffer;
	})()


	//此类可以减少代码
	//class laya.webgl.shapes.BasePoly
	var BasePoly = (function () {
		function BasePoly(x, y, width, height, edges, color, borderWidth, borderColor, round) {
			//this.x=NaN;
			//this.y=NaN;
			//this.r=NaN;
			//this.width=NaN;
			//this.height=NaN;
			//this.edges=NaN;
			this.r0 = 0
			//this.color=0;
			//this.borderColor=NaN;
			//this.borderWidth=NaN;
			//this.round=0;
			this.fill = true;
			//this.mUint16Array=null;
			//this.mFloat32Array=null;
			this.r1 = Math.PI / 2;
			(round === void 0) && (round = 0);
			this.x = x;
			this.y = y;
			this.width = width;
			this.height = height;
			this.edges = edges;
			this.color = color;
			this.borderWidth = borderWidth;
			this.borderColor = borderColor;
		}

		__class(BasePoly, 'laya.webgl.shapes.BasePoly');
		var __proto = BasePoly.prototype;
		Laya.imps(__proto, { "laya.webgl.shapes.IShape": true })
		__proto.getData = function (ib, vb, start) { }
		__proto.rebuild = function (points) { }
		__proto.setMatrix = function (mat) { }
		__proto.needUpdate = function (mat) {
			return true;
		}

		__proto.sector = function (outVert, outIndex, start) {
			var x = this.x, y = this.y, edges = this.edges, seg = (this.r1 - this.r0) / edges;
			var w = this.width, h = this.height, color = this.color;
			var r = ((color >> 16) & 0x0000ff) / 255, g = ((color >> 8) & 0xff) / 255, b = (color & 0x0000ff) / 255;
			outVert.push(x, y, r, g, b);
			for (var i = 0; i < edges + 1; i++) {
				outVert.push(x + Math.sin(seg * i + this.r0) * w, y + Math.cos(seg * i + this.r0) * h);
				outVert.push(r, g, b);
			}
			for (i = 0; i < edges; i++) {
				outIndex.push(start, start + i + 1, start + i + 2);
			}
		}

		//用于画线
		__proto.createLine2 = function (p, indices, lineWidth, len, outVertex, indexCount) {
			var points = p.concat();
			var result = outVertex;
			var color = this.borderColor;
			var r = ((color >> 16) & 0x0000ff) / 255, g = ((color >> 8) & 0xff) / 255, b = (color & 0x0000ff) / 255;
			var length = points.length / 2;
			var iStart = len, w = lineWidth / 2;
			var px, py, p1x, p1y, p2x, p2y, p3x, p3y;
			var perpx, perpy, perp2x, perp2y, perp3x, perp3y;
			var a1, b1, c1, a2, b2, c2;
			var denom, pdist, dist;
			p1x = points[0];
			p1y = points[1];
			p2x = points[2];
			p2y = points[3];
			perpx = -(p1y - p2y);
			perpy = p1x - p2x;
			dist = Math.sqrt(perpx * perpx + perpy * perpy);
			perpx = perpx / dist * w;
			perpy = perpy / dist * w;
			result.push(p1x - perpx + this.x, p1y - perpy + this.y, r, g, b, p1x + perpx + this.x, p1y + perpy + this.y, r, g, b);
			for (var i = 1; i < length - 1; i++) {
				p1x = points[(i - 1) * 2];
				p1y = points[(i - 1) * 2 + 1];
				p2x = points[(i) * 2];
				p2y = points[(i) * 2 + 1];
				p3x = points[(i + 1) * 2];
				p3y = points[(i + 1) * 2 + 1];
				perpx = -(p1y - p2y);
				perpy = p1x - p2x;
				dist = Math.sqrt(perpx * perpx + perpy * perpy);
				perpx = perpx / dist * w;
				perpy = perpy / dist * w;
				perp2x = -(p2y - p3y);
				perp2y = p2x - p3x;
				dist = Math.sqrt(perp2x * perp2x + perp2y * perp2y);
				perp2x = perp2x / dist * w;
				perp2y = perp2y / dist * w;
				a1 = (-perpy + p1y) - (-perpy + p2y);
				b1 = (-perpx + p2x) - (-perpx + p1x);
				c1 = (-perpx + p1x) * (-perpy + p2y) - (-perpx + p2x) * (-perpy + p1y);
				a2 = (-perp2y + p3y) - (-perp2y + p2y);
				b2 = (-perp2x + p2x) - (-perp2x + p3x);
				c2 = (-perp2x + p3x) * (-perp2y + p2y) - (-perp2x + p2x) * (-perp2y + p3y);
				denom = a1 * b2 - a2 * b1;
				if (Math.abs(denom) < 0.1) {
					denom += 10.1;
					result.push(p2x - perpx + this.x, p2y - perpy + this.y, r, g, b, p2x + perpx + this.x, p2y + perpy + this.y, r, g, b);
					continue;
				}
				px = (b1 * c2 - b2 * c1) / denom;
				py = (a2 * c1 - a1 * c2) / denom;
				pdist = (px - p2x) * (px - p2x) + (py - p2y) + (py - p2y);
				result.push(px + this.x, py + this.y, r, g, b, p2x - (px - p2x) + this.x, p2y - (py - p2y) + this.y, r, g, b);
			}
			p1x = points[points.length - 4];
			p1y = points[points.length - 3];
			p2x = points[points.length - 2];
			p2y = points[points.length - 1];
			perpx = -(p1y - p2y);
			perpy = p1x - p2x;
			dist = Math.sqrt(perpx * perpx + perpy * perpy);
			perpx = perpx / dist * w;
			perpy = perpy / dist * w;
			result.push(p2x - perpx + this.x, p2y - perpy + this.y, r, g, b, p2x + perpx + this.x, p2y + perpy + this.y, r, g, b);
			var groupLen = indexCount;
			for (i = 1; i < groupLen; i++) {
				indices.push(iStart + (i - 1) * 2, iStart + (i - 1) * 2 + 1, iStart + i * 2 + 1, iStart + i * 2 + 1, iStart + i * 2, iStart + (i - 1) * 2);
			}
			return result;
		}

		// /*,outVertex:Array,outIndex:Array*/
		__proto.createLine = function (p, indices, lineWidth, len) {
			var points = p.concat();
			var result = p;
			var color = this.borderColor;
			var r = ((color >> 16) & 0x0000ff) / 255, g = ((color >> 8) & 0xff) / 255, b = (color & 0x0000ff) / 255;
			points.splice(0, 5);
			var length = points.length / 5;
			var iStart = len, w = lineWidth / 2;
			var px, py, p1x, p1y, p2x, p2y, p3x, p3y;
			var perpx, perpy, perp2x, perp2y, perp3x, perp3y;
			var a1, b1, c1, a2, b2, c2;
			var denom, pdist, dist;
			p1x = points[0];
			p1y = points[1];
			p2x = points[5];
			p2y = points[6];
			perpx = -(p1y - p2y);
			perpy = p1x - p2x;
			dist = Math.sqrt(perpx * perpx + perpy * perpy);
			perpx = perpx / dist * w;
			perpy = perpy / dist * w;
			result.push(p1x - perpx, p1y - perpy, r, g, b, p1x + perpx, p1y + perpy, r, g, b);
			for (var i = 1; i < length - 1; i++) {
				p1x = points[(i - 1) * 5];
				p1y = points[(i - 1) * 5 + 1];
				p2x = points[(i) * 5];
				p2y = points[(i) * 5 + 1];
				p3x = points[(i + 1) * 5];
				p3y = points[(i + 1) * 5 + 1];
				perpx = -(p1y - p2y);
				perpy = p1x - p2x;
				dist = Math.sqrt(perpx * perpx + perpy * perpy);
				perpx = perpx / dist * w;
				perpy = perpy / dist * w;
				perp2x = -(p2y - p3y);
				perp2y = p2x - p3x;
				dist = Math.sqrt(perp2x * perp2x + perp2y * perp2y);
				perp2x = perp2x / dist * w;
				perp2y = perp2y / dist * w;
				a1 = (-perpy + p1y) - (-perpy + p2y);
				b1 = (-perpx + p2x) - (-perpx + p1x);
				c1 = (-perpx + p1x) * (-perpy + p2y) - (-perpx + p2x) * (-perpy + p1y);
				a2 = (-perp2y + p3y) - (-perp2y + p2y);
				b2 = (-perp2x + p2x) - (-perp2x + p3x);
				c2 = (-perp2x + p3x) * (-perp2y + p2y) - (-perp2x + p2x) * (-perp2y + p3y);
				denom = a1 * b2 - a2 * b1;
				if (Math.abs(denom) < 0.1) {
					denom += 10.1;
					result.push(p2x - perpx, p2y - perpy, r, g, b, p2x + perpx, p2y + perpy, r, g, b);
					continue;
				}
				px = (b1 * c2 - b2 * c1) / denom;
				py = (a2 * c1 - a1 * c2) / denom;
				pdist = (px - p2x) * (px - p2x) + (py - p2y) + (py - p2y);
				result.push(px, py, r, g, b, p2x - (px - p2x), p2y - (py - p2y), r, g, b);
			}
			p1x = points[points.length - 10];
			p1y = points[points.length - 9];
			p2x = points[points.length - 5];
			p2y = points[points.length - 4];
			perpx = -(p1y - p2y);
			perpy = p1x - p2x;
			dist = Math.sqrt(perpx * perpx + perpy * perpy);
			perpx = perpx / dist * w;
			perpy = perpy / dist * w;
			result.push(p2x - perpx, p2y - perpy, r, g, b, p2x + perpx, p2y + perpy, r, g, b);
			var groupLen = this.edges + 1;
			for (i = 1; i < groupLen; i++) {
				indices.push(iStart + (i - 1) * 2, iStart + (i - 1) * 2 + 1, iStart + i * 2 + 1, iStart + i * 2 + 1, iStart + i * 2, iStart + (i - 1) * 2);
			}
			return result;
		}

		//闭合路径
		__proto.createLoopLine = function (p, indices, lineWidth, len, outVertex, outIndex) {
			var points = p.concat();
			var result = outVertex ? outVertex : p;
			var color = this.borderColor;
			var r = ((color >> 16) & 0x0000ff) / 255, g = ((color >> 8) & 0xff) / 255, b = (color & 0x0000ff) / 255;
			points.splice(0, 5);
			var firstPoint = [points[0], points[1]];
			var lastPoint = [points[points.length - 5], points[points.length - 4]];
			var midPointX = lastPoint[0] + (firstPoint[0] - lastPoint[0]) * 0.5;
			var midPointY = lastPoint[1] + (firstPoint[1] - lastPoint[1]) * 0.5;
			points.unshift(midPointX, midPointY, 0, 0, 0);
			points.push(midPointX, midPointY, 0, 0, 0);
			var length = points.length / 5;
			var iStart = len, w = lineWidth / 2;
			var px, py, p1x, p1y, p2x, p2y, p3x, p3y;
			var perpx, perpy, perp2x, perp2y, perp3x, perp3y;
			var a1, b1, c1, a2, b2, c2;
			var denom, pdist, dist;
			p1x = points[0];
			p1y = points[1];
			p2x = points[5];
			p2y = points[6];
			perpx = -(p1y - p2y);
			perpy = p1x - p2x;
			dist = Math.sqrt(perpx * perpx + perpy * perpy);
			perpx = perpx / dist * w;
			perpy = perpy / dist * w;
			result.push(p1x - perpx, p1y - perpy, r, g, b, p1x + perpx, p1y + perpy, r, g, b);
			for (var i = 1; i < length - 1; i++) {
				p1x = points[(i - 1) * 5];
				p1y = points[(i - 1) * 5 + 1];
				p2x = points[(i) * 5];
				p2y = points[(i) * 5 + 1];
				p3x = points[(i + 1) * 5];
				p3y = points[(i + 1) * 5 + 1];
				perpx = -(p1y - p2y);
				perpy = p1x - p2x;
				dist = Math.sqrt(perpx * perpx + perpy * perpy);
				perpx = perpx / dist * w;
				perpy = perpy / dist * w;
				perp2x = -(p2y - p3y);
				perp2y = p2x - p3x;
				dist = Math.sqrt(perp2x * perp2x + perp2y * perp2y);
				perp2x = perp2x / dist * w;
				perp2y = perp2y / dist * w;
				a1 = (-perpy + p1y) - (-perpy + p2y);
				b1 = (-perpx + p2x) - (-perpx + p1x);
				c1 = (-perpx + p1x) * (-perpy + p2y) - (-perpx + p2x) * (-perpy + p1y);
				a2 = (-perp2y + p3y) - (-perp2y + p2y);
				b2 = (-perp2x + p2x) - (-perp2x + p3x);
				c2 = (-perp2x + p3x) * (-perp2y + p2y) - (-perp2x + p2x) * (-perp2y + p3y);
				denom = a1 * b2 - a2 * b1;
				if (Math.abs(denom) < 0.1) {
					denom += 10.1;
					result.push(p2x - perpx, p2y - perpy, r, g, b, p2x + perpx, p2y + perpy, r, g, b);
					continue;
				}
				px = (b1 * c2 - b2 * c1) / denom;
				py = (a2 * c1 - a1 * c2) / denom;
				pdist = (px - p2x) * (px - p2x) + (py - p2y) + (py - p2y);
				result.push(px, py, r, g, b, p2x - (px - p2x), p2y - (py - p2y), r, g, b);
			}
			if (outIndex) {
				indices = outIndex;
			};
			var groupLen = this.edges + 1;
			for (i = 1; i < groupLen; i++) {
				indices.push(iStart + (i - 1) * 2, iStart + (i - 1) * 2 + 1, iStart + i * 2 + 1, iStart + i * 2 + 1, iStart + i * 2, iStart + (i - 1) * 2);
			}
			indices.push(iStart + (i - 1) * 2, iStart + (i - 1) * 2 + 1, iStart + 1, iStart + 1, iStart, iStart + (i - 1) * 2);
			return result;
		}

		return BasePoly;
	})()


	//class laya.webgl.shapes.Earcut
	var Earcut = (function () {
		function Earcut() { }
		__class(Earcut, 'laya.webgl.shapes.Earcut');
		Earcut.earcut = function (data, holeIndices, dim) {
			dim = dim || 2;
			var hasHoles = holeIndices && holeIndices.length,
				outerLen = hasHoles ? holeIndices[0] * dim : data.length,
				outerNode = Earcut.linkedList(data, 0, outerLen, dim, true),
				triangles = [];
			if (!outerNode) return triangles;
			var minX, minY, maxX, maxY, x, y, invSize;
			if (hasHoles) outerNode = Earcut.eliminateHoles(data, holeIndices, outerNode, dim);
			if (data.length > 80 * dim) {
				minX = maxX = data[0];
				minY = maxY = data[1];
				for (var i = dim; i < outerLen; i += dim) {
					x = data[i];
					y = data[i + 1];
					if (x < minX) minX = x;
					if (y < minY) minY = y;
					if (x > maxX) maxX = x;
					if (y > maxY) maxY = y;
				}
				invSize = Math.max(maxX - minX, maxY - minY);
				invSize = invSize !== 0 ? 1 / invSize : 0;
			}
			Earcut.earcutLinked(outerNode, triangles, dim, minX, minY, invSize);
			return triangles;
		}

		Earcut.linkedList = function (data, start, end, dim, clockwise) {
			var i, last;
			if (clockwise === (Earcut.signedArea(data, start, end, dim) > 0)) {
				for (i = start; i < end; i += dim)last = Earcut.insertNode(i, data[i], data[i + 1], last);
			} else {
				for (i = end - dim; i >= start; i -= dim)last = Earcut.insertNode(i, data[i], data[i + 1], last);
			}
			if (last && Earcut.equals(last, last.next)) {
				Earcut.removeNode(last);
				last = last.next;
			}
			return last;
		}

		Earcut.filterPoints = function (start, end) {
			if (!start) return start;
			if (!end) end = start;
			var p = start,
				again;
			do {
				again = false;
				if (!p.steiner && (Earcut.equals(p, p.next) || Earcut.area(p.prev, p, p.next) === 0)) {
					Earcut.removeNode(p);
					p = end = p.prev;
					if (p === p.next) break;
					again = true;
				} else {
					p = p.next;
				}
			} while (again || p !== end);
			return end;
		}

		Earcut.earcutLinked = function (ear, triangles, dim, minX, minY, invSize, pass) {
			if (!ear) return;
			if (!pass && invSize) Earcut.indexCurve(ear, minX, minY, invSize);
			var stop = ear,
				prev, next;
			while (ear.prev !== ear.next) {
				prev = ear.prev;
				next = ear.next;
				if (invSize ? Earcut.isEarHashed(ear, minX, minY, invSize) : Earcut.isEar(ear)) {
					triangles.push(prev.i / dim);
					triangles.push(ear.i / dim);
					triangles.push(next.i / dim);
					Earcut.removeNode(ear);
					ear = next.next;
					stop = next.next;
					continue;
				}
				ear = next;
				if (ear === stop) {
					if (!pass) {
						Earcut.earcutLinked(Earcut.filterPoints(ear, null), triangles, dim, minX, minY, invSize, 1);
					} else if (pass === 1) {
						ear = Earcut.cureLocalIntersections(ear, triangles, dim);
						Earcut.earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
					} else if (pass === 2) {
						Earcut.splitEarcut(ear, triangles, dim, minX, minY, invSize);
					}
					break;
				}
			}
		}

		Earcut.isEar = function (ear) {
			var a = ear.prev,
				b = ear,
				c = ear.next;
			if (Earcut.area(a, b, c) >= 0) return false;
			var p = ear.next.next;
			while (p !== ear.prev) {
				if (Earcut.pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
					Earcut.area(p.prev, p, p.next) >= 0) return false;
				p = p.next;
			}
			return true;
		}

		Earcut.isEarHashed = function (ear, minX, minY, invSize) {
			var a = ear.prev,
				b = ear,
				c = ear.next;
			if (Earcut.area(a, b, c) >= 0) return false;
			var minTX = a.x < b.x ? (a.x < c.x ? a.x : c.x) : (b.x < c.x ? b.x : c.x),
				minTY = a.y < b.y ? (a.y < c.y ? a.y : c.y) : (b.y < c.y ? b.y : c.y),
				maxTX = a.x > b.x ? (a.x > c.x ? a.x : c.x) : (b.x > c.x ? b.x : c.x),
				maxTY = a.y > b.y ? (a.y > c.y ? a.y : c.y) : (b.y > c.y ? b.y : c.y);
			var minZ = Earcut.zOrder(minTX, minTY, minX, minY, invSize),
				maxZ = Earcut.zOrder(maxTX, maxTY, minX, minY, invSize);
			var p = ear.nextZ;
			while (p && p.z <= maxZ) {
				if (p !== ear.prev && p !== ear.next &&
					Earcut.pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
					Earcut.area(p.prev, p, p.next) >= 0) return false;
				p = p.nextZ;
			}
			p = ear.prevZ;
			while (p && p.z >= minZ) {
				if (p !== ear.prev && p !== ear.next &&
					Earcut.pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
					Earcut.area(p.prev, p, p.next) >= 0) return false;
				p = p.prevZ;
			}
			return true;
		}

		Earcut.cureLocalIntersections = function (start, triangles, dim) {
			var p = start;
			do {
				var a = p.prev,
					b = p.next.next;
				if (!Earcut.equals(a, b) && Earcut.intersects(a, p, p.next, b) && Earcut.locallyInside(a, b) && Earcut.locallyInside(b, a)) {
					triangles.push(a.i / dim);
					triangles.push(p.i / dim);
					triangles.push(b.i / dim);
					Earcut.removeNode(p);
					Earcut.removeNode(p.next);
					p = start = b;
				}
				p = p.next;
			} while (p !== start);
			return p;
		}

		Earcut.splitEarcut = function (start, triangles, dim, minX, minY, invSize) {
			var a = start;
			do {
				var b = a.next.next;
				while (b !== a.prev) {
					if (a.i !== b.i && Earcut.isValidDiagonal(a, b)) {
						var c = Earcut.splitPolygon(a, b);
						a = Earcut.filterPoints(a, a.next);
						c = Earcut.filterPoints(c, c.next);
						Earcut.earcutLinked(a, triangles, dim, minX, minY, invSize);
						Earcut.earcutLinked(c, triangles, dim, minX, minY, invSize);
						return;
					}
					b = b.next;
				}
				a = a.next;
			} while (a !== start);
		}

		Earcut.eliminateHoles = function (data, holeIndices, outerNode, dim) {
			var queue = [],
				i, len, start, end, list;
			for (i = 0, len = holeIndices.length; i < len; i++) {
				start = holeIndices[i] * dim;
				end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
				list = Earcut.linkedList(data, start, end, dim, false);
				if (list === list.next) list.steiner = true;
				queue.push(Earcut.getLeftmost(list));
			}
			queue.sort(Earcut.compareX);
			for (i = 0; i < queue.length; i++) {
				Earcut.eliminateHole(queue[i], outerNode);
				outerNode = Earcut.filterPoints(outerNode, outerNode.next);
			}
			return outerNode;
		}

		Earcut.compareX = function (a, b) {
			return a.x - b.x;
		}

		Earcut.eliminateHole = function (hole, outerNode) {
			outerNode = Earcut.findHoleBridge(hole, outerNode);
			if (outerNode) {
				var b = Earcut.splitPolygon(outerNode, hole);
				Earcut.filterPoints(b, b.next);
			}
		}

		Earcut.findHoleBridge = function (hole, outerNode) {
			var p = outerNode,
				hx = hole.x,
				hy = hole.y,
				qx = -Infinity,
				m;
			do {
				if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
					var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
					if (x <= hx && x > qx) {
						qx = x;
						if (x === hx) {
							if (hy === p.y) return p;
							if (hy === p.next.y) return p.next;
						}
						m = p.x < p.next.x ? p : p.next;
					}
				}
				p = p.next;
			} while (p !== outerNode);
			if (!m) return null;
			if (hx === qx) return m.prev;
			var stop = m,
				mx = m.x,
				my = m.y,
				tanMin = Infinity,
				tan;
			p = m.next;
			while (p !== stop) {
				if (hx >= p.x && p.x >= mx && hx !== p.x &&
					Earcut.pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
					tan = Math.abs(hy - p.y) / (hx - p.x);
					if ((tan < tanMin || (tan === tanMin && p.x > m.x)) && Earcut.locallyInside(p, hole)) {
						m = p;
						tanMin = tan;
					}
				}
				p = p.next;
			}
			return m;
		}

		Earcut.indexCurve = function (start, minX, minY, invSize) {
			var p = start;
			do {
				if (p.z === null) p.z = Earcut.zOrder(p.x, p.y, minX, minY, invSize);
				p.prevZ = p.prev;
				p.nextZ = p.next;
				p = p.next;
			} while (p !== start);
			p.prevZ.nextZ = null;
			p.prevZ = null;
			Earcut.sortLinked(p);
		}

		Earcut.sortLinked = function (list) {
			var i, p, q, e, tail, numMerges, pSize, qSize,
				inSize = 1;
			do {
				p = list;
				list = null;
				tail = null;
				numMerges = 0;
				while (p) {
					numMerges++;
					q = p;
					pSize = 0;
					for (i = 0; i < inSize; i++) {
						pSize++;
						q = q.nextZ;
						if (!q) break;
					}
					qSize = inSize;
					while (pSize > 0 || (qSize > 0 && q)) {
						if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
							e = p;
							p = p.nextZ;
							pSize--;
						} else {
							e = q;
							q = q.nextZ;
							qSize--;
						}
						if (tail) tail.nextZ = e;
						else list = e;
						e.prevZ = tail;
						tail = e;
					}
					p = q;
				}
				tail.nextZ = null;
				inSize *= 2;
			} while (numMerges > 1);
			return list;
		}

		Earcut.zOrder = function (x, y, minX, minY, invSize) {
			x = 32767 * (x - minX) * invSize;
			y = 32767 * (y - minY) * invSize;
			x = (x | (x << 8)) & 0x00FF00FF;
			x = (x | (x << 4)) & 0x0F0F0F0F;
			x = (x | (x << 2)) & 0x33333333;
			x = (x | (x << 1)) & 0x55555555;
			y = (y | (y << 8)) & 0x00FF00FF;
			y = (y | (y << 4)) & 0x0F0F0F0F;
			y = (y | (y << 2)) & 0x33333333;
			y = (y | (y << 1)) & 0x55555555;
			return x | (y << 1);
		}

		Earcut.getLeftmost = function (start) {
			var p = start,
				leftmost = start;
			do {
				if (p.x < leftmost.x) leftmost = p;
				p = p.next;
			} while (p !== start);
			return leftmost;
		}

		Earcut.pointInTriangle = function (ax, ay, bx, by, cx, cy, px, py) {
			return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 &&
				(ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 &&
				(bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
		}

		Earcut.isValidDiagonal = function (a, b) {
			return a.next.i !== b.i && a.prev.i !== b.i && !Earcut.intersectsPolygon(a, b) &&
				Earcut.locallyInside(a, b) && Earcut.locallyInside(b, a) && Earcut.middleInside(a, b);
		}

		Earcut.area = function (p, q, r) {
			return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
		}

		Earcut.equals = function (p1, p2) {
			return p1.x === p2.x && p1.y === p2.y;
		}

		Earcut.intersects = function (p1, q1, p2, q2) {
			if ((Earcut.equals(p1, q1) && Earcut.equals(p2, q2)) ||
				(Earcut.equals(p1, q2) && Earcut.equals(p2, q1))) return true;
			return Earcut.area(p1, q1, p2) > 0 !== Earcut.area(p1, q1, q2) > 0 &&
				Earcut.area(p2, q2, p1) > 0 !== Earcut.area(p2, q2, q1) > 0;
		}

		Earcut.intersectsPolygon = function (a, b) {
			var p = a;
			do {
				if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
					Earcut.intersects(p, p.next, a, b)) return true;
				p = p.next;
			} while (p !== a);
			return false;
		}

		Earcut.locallyInside = function (a, b) {
			return Earcut.area(a.prev, a, a.next) < 0 ?
				Earcut.area(a, b, a.next) >= 0 && Earcut.area(a, a.prev, b) >= 0 :
				Earcut.area(a, b, a.prev) < 0 || Earcut.area(a, a.next, b) < 0;
		}

		Earcut.middleInside = function (a, b) {
			var p = a,
				inside = false,
				px = (a.x + b.x) / 2,
				py = (a.y + b.y) / 2;
			do {
				if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&
					(px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))
					inside = !inside;
				p = p.next;
			} while (p !== a);
			return inside;
		}

		Earcut.splitPolygon = function (a, b) {
			var a2 = new EarcutNode(a.i, a.x, a.y),
				b2 = new EarcutNode(b.i, b.x, b.y),
				an = a.next,
				bp = b.prev;
			a.next = b;
			b.prev = a;
			a2.next = an;
			an.prev = a2;
			b2.next = a2;
			a2.prev = b2;
			bp.next = b2;
			b2.prev = bp;
			return b2;
		}

		Earcut.insertNode = function (i, x, y, last) {
			var p = new EarcutNode(i, x, y);
			if (!last) {
				p.prev = p;
				p.next = p;
			} else {
				p.next = last.next;
				p.prev = last;
				last.next.prev = p;
				last.next = p;
			}
			return p;
		}

		Earcut.removeNode = function (p) {
			p.next.prev = p.prev;
			p.prev.next = p.next;
			if (p.prevZ) p.prevZ.nextZ = p.nextZ;
			if (p.nextZ) p.nextZ.prevZ = p.prevZ;
		}

		Earcut.signedArea = function (data, start, end, dim) {
			var sum = 0;
			for (var i = start, j = end - dim; i < end; i += dim) {
				sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
				j = i;
			}
			return sum;
		}

		return Earcut;
	})()


	//class laya.webgl.shapes.EarcutNode
	var EarcutNode = (function () {
		function EarcutNode(i, x, y) {
			this.i = null;
			this.x = null;
			this.y = null;
			this.prev = null;
			this.next = null;
			this.z = null;
			this.prevZ = null;
			this.nextZ = null;
			this.steiner = null;
			this.i = i;
			this.x = x;
			this.y = y;
			this.prev = null;
			this.next = null;
			this.z = null;
			this.prevZ = null;
			this.nextZ = null;
			this.steiner = false;
		}

		__class(EarcutNode, 'laya.webgl.shapes.EarcutNode');
		return EarcutNode;
	})()


	//class laya.webgl.shapes.GeometryData
	var GeometryData = (function () {
		function GeometryData(lineWidth, lineColor, lineAlpha, fillColor, fillAlpha, fill, shape) {
			//this.lineWidth=NaN;
			//this.lineColor=NaN;
			//this.lineAlpha=NaN;
			//this.fillColor=NaN;
			//this.fillAlpha=NaN;
			//this.shape=null;
			//this.fill=false;
			this.lineWidth = lineWidth;
			this.lineColor = lineColor;
			this.lineAlpha = lineAlpha;
			this.fillColor = fillColor;
			this.fillAlpha = fillAlpha;
			this.shape = shape;
			this.fill = fill;
		}

		__class(GeometryData, 'laya.webgl.shapes.GeometryData');
		var __proto = GeometryData.prototype;
		__proto.clone = function () {
			return new GeometryData(this.lineWidth, this.lineColor, this.lineAlpha, this.fillColor, this.fillAlpha, this.fill, this.shape);
		}

		__proto.getIndexData = function () {
			return null;
		}

		__proto.getVertexData = function () {
			return null;
		}

		__proto.destroy = function () {
			this.shape = null;
		}

		return GeometryData;
	})()


	//class laya.webgl.shapes.Vertex
	var Vertex = (function () {
		function Vertex(p) {
			//this.points=null;
			if ((p instanceof Float32Array))
				this.points = p;
			else if ((p instanceof Array)) {
				var len = p.length;
				this.points = new Float32Array(p);
			}
		}

		__class(Vertex, 'laya.webgl.shapes.Vertex');
		var __proto = Vertex.prototype;
		Laya.imps(__proto, { "laya.webgl.shapes.IShape": true })
		__proto.getData = function (ib, vb, start) { }
		__proto.needUpdate = function (mat) {
			return false;
		}

		__proto.rebuild = function (points) { }
		// TODO Auto Generated method stub
		__proto.setMatrix = function (mat) { }
		return Vertex;
	})()


	//class laya.webgl.submit.Submit
	var Submit = (function () {
		function Submit(renderType) {
			//this._selfVb=null;
			//this._ib=null;
			//this._blendFn=null;
			//this._renderType=0;
			//this._vb=null;
			// 从VB中什么地方开始画，画到哪
			//this._startIdx=0;
			//this._numEle=0;
			//this.shaderValue=null;
			(renderType === void 0) && (renderType = 10000);
			this._renderType = renderType;
		}

		__class(Submit, 'laya.webgl.submit.Submit');
		var __proto = Submit.prototype;
		Laya.imps(__proto, { "laya.webgl.submit.ISubmit": true })
		__proto.releaseRender = function () {
			var cache = Submit._cache;
			cache[cache._length++] = this;
			this.shaderValue.release();
			this._vb = null;
		}

		__proto.getRenderType = function () {
			return this._renderType;
		}

		__proto.renderSubmit = function () {
			if (this._numEle === 0) return 1;
			var _tex = this.shaderValue.textureHost;
			if (_tex) {
				var source = _tex.source;
				if (!_tex.bitmap || !source)
					return 1;
				this.shaderValue.texture = source;
			}
			this._vb.bind_upload(this._ib);
			var gl = WebGL.mainContext;
			this.shaderValue.upload();
			if (BlendMode.activeBlendFunction !== this._blendFn) {
				gl.enable(/*laya.webgl.WebGLContext.BLEND*/0x0BE2);
				this._blendFn(gl);
				BlendMode.activeBlendFunction = this._blendFn;
			}
			Stat.drawCall++;
			Stat.trianglesFaces += this._numEle / 3;
			gl.drawElements(/*laya.webgl.WebGLContext.TRIANGLES*/0x0004, this._numEle,/*laya.webgl.WebGLContext.UNSIGNED_SHORT*/0x1403, this._startIdx);
			return 1;
		}

		Submit.__init__ = function () {
			var s = Submit.RENDERBASE = new Submit(-1);
			s.shaderValue = new Value2D(0, 0);
			s.shaderValue.ALPHA = -1234;
		}

		Submit.createSubmit = function (context, ib, vb, pos, sv) {
			var o = Submit._cache._length ? Submit._cache[--Submit._cache._length] : new Submit();
			if (vb == null) {
				vb = o._selfVb || (o._selfVb = VertexBuffer2D.create(-1));
				vb.clear();
				pos = 0;
			}
			o._ib = ib;
			o._vb = vb;
			o._startIdx = pos * CONST3D2D.BYTES_PIDX;
			o._numEle = 0;
			var blendType = context._nBlendType;
			o._blendFn = context._targets ? BlendMode.targetFns[blendType] : BlendMode.fns[blendType];
			o.shaderValue = sv;
			o.shaderValue.setValue(context._shader2D);
			var filters = context._shader2D.filters;
			filters && o.shaderValue.setFilters(filters);
			return o;
		}

		Submit.createShape = function (ctx, ib, vb, numEle, offset, sv) {
			var o = (!Submit._cache._length) ? (new Submit()) : Submit._cache[--Submit._cache._length];
			o._ib = ib;
			o._vb = vb;
			o._numEle = numEle;
			o._startIdx = offset;
			o.shaderValue = sv;
			o.shaderValue.setValue(ctx._shader2D);
			var blendType = ctx._nBlendType;
			o._blendFn = ctx._targets ? BlendMode.targetFns[blendType] : BlendMode.fns[blendType];
			return o;
		}

		Submit.TYPE_2D = 10000;
		Submit.TYPE_CANVAS = 10003;
		Submit.TYPE_CMDSETRT = 10004;
		Submit.TYPE_CUSTOM = 10005;
		Submit.TYPE_BLURRT = 10006;
		Submit.TYPE_CMDDESTORYPRERT = 10007;
		Submit.TYPE_DISABLESTENCIL = 10008;
		Submit.TYPE_OTHERIBVB = 10009;
		Submit.TYPE_PRIMITIVE = 10010;
		Submit.TYPE_RT = 10011;
		Submit.TYPE_BLUR_RT = 10012;
		Submit.TYPE_TARGET = 10013;
		Submit.TYPE_CHANGE_VALUE = 10014;
		Submit.TYPE_SHAPE = 10015;
		Submit.TYPE_TEXTURE = 10016;
		Submit.TYPE_FILLTEXTURE = 10017;
		Submit.RENDERBASE = null;
		Submit._cache = (Submit._cache = [], Submit._cache._length = 0, Submit._cache);
		return Submit;
	})()


	//class laya.webgl.submit.SubmitCMD
	var SubmitCMD = (function () {
		function SubmitCMD() {
			this.fun = null;
			this.args = null;
		}

		__class(SubmitCMD, 'laya.webgl.submit.SubmitCMD');
		var __proto = SubmitCMD.prototype;
		Laya.imps(__proto, { "laya.webgl.submit.ISubmit": true })
		__proto.renderSubmit = function () {
			this.fun.apply(null, this.args);
			return 1;
		}

		__proto.getRenderType = function () {
			return 0;
		}

		__proto.releaseRender = function () {
			var cache = SubmitCMD._cache;
			cache[cache._length++] = this;
		}

		SubmitCMD.create = function (args, fun) {
			var o = SubmitCMD._cache._length ? SubmitCMD._cache[--SubmitCMD._cache._length] : new SubmitCMD();
			o.fun = fun;
			o.args = args;
			return o;
		}

		SubmitCMD._cache = (SubmitCMD._cache = [], SubmitCMD._cache._length = 0, SubmitCMD._cache);
		return SubmitCMD;
	})()


	//class laya.webgl.submit.SubmitCMDScope
	var SubmitCMDScope = (function () {
		function SubmitCMDScope() {
			this.variables = {};
		}

		__class(SubmitCMDScope, 'laya.webgl.submit.SubmitCMDScope');
		var __proto = SubmitCMDScope.prototype;
		__proto.getValue = function (name) {
			return this.variables[name];
		}

		__proto.addValue = function (name, value) {
			return this.variables[name] = value;
		}

		__proto.setValue = function (name, value) {
			if (this.variables.hasOwnProperty(name)) {
				return this.variables[name] = value;
			}
			return null;
		}

		__proto.clear = function () {
			for (var key in this.variables) {
				delete this.variables[key];
			}
		}

		__proto.recycle = function () {
			this.clear();
			SubmitCMDScope.POOL.push(this);
		}

		SubmitCMDScope.create = function () {
			var scope = SubmitCMDScope.POOL.pop();
			scope || (scope = new SubmitCMDScope());
			return scope;
		}

		SubmitCMDScope.POOL = [];
		return SubmitCMDScope;
	})()


	//class laya.webgl.submit.SubmitOtherIBVB
	var SubmitOtherIBVB = (function () {
		function SubmitOtherIBVB() {
			this.offset = 0;
			//this._vb=null;
			//this._ib=null;
			//this._blendFn=null;
			//this._mat=null;
			//this._shader=null;
			//this._shaderValue=null;
			//this._numEle=0;
			this.startIndex = 0;
			;
			this._mat = Matrix.create();
		}

		__class(SubmitOtherIBVB, 'laya.webgl.submit.SubmitOtherIBVB');
		var __proto = SubmitOtherIBVB.prototype;
		Laya.imps(__proto, { "laya.webgl.submit.ISubmit": true })
		__proto.releaseRender = function () {
			var cache = SubmitOtherIBVB._cache;
			cache[cache._length++] = this;
		}

		__proto.getRenderType = function () {
			return /*laya.webgl.submit.Submit.TYPE_OTHERIBVB*/10009;
		}

		__proto.renderSubmit = function () {
			var _tex = this._shaderValue.textureHost;
			if (_tex) {
				var source = _tex.source;
				if (!_tex.bitmap || !source)
					return 1;
				this._shaderValue.texture = source;
			}
			this._vb.bind_upload(this._ib);
			var w = RenderState2D.worldMatrix4;
			var wmat = Matrix.TEMP;
			Matrix.mulPre(this._mat, w[0], w[1], w[4], w[5], w[12], w[13], wmat);
			var tmp = RenderState2D.worldMatrix4 = SubmitOtherIBVB.tempMatrix4;
			tmp[0] = wmat.a;
			tmp[1] = wmat.b;
			tmp[4] = wmat.c;
			tmp[5] = wmat.d;
			tmp[12] = wmat.tx;
			tmp[13] = wmat.ty;
			this._shader._offset = this.offset;
			this._shaderValue.refresh();
			this._shader.upload(this._shaderValue);
			this._shader._offset = 0;
			var gl = WebGL.mainContext;
			if (BlendMode.activeBlendFunction !== this._blendFn) {
				gl.enable(/*laya.webgl.WebGLContext.BLEND*/0x0BE2);
				this._blendFn(gl);
				BlendMode.activeBlendFunction = this._blendFn;
			}
			Stat.drawCall++;
			Stat.trianglesFaces += this._numEle / 3;
			gl.drawElements(/*laya.webgl.WebGLContext.TRIANGLES*/0x0004, this._numEle,/*laya.webgl.WebGLContext.UNSIGNED_SHORT*/0x1403, this.startIndex);
			RenderState2D.worldMatrix4 = w;
			BaseShader.activeShader = null;
			return 1;
		}

		SubmitOtherIBVB.create = function (context, vb, ib, numElement, shader, shaderValue, startIndex, offset, type) {
			(type === void 0) && (type = 0);
			var o = (!SubmitOtherIBVB._cache._length) ? (new SubmitOtherIBVB()) : SubmitOtherIBVB._cache[--SubmitOtherIBVB._cache._length];
			o._ib = ib;
			o._vb = vb;
			o._numEle = numElement;
			o._shader = shader;
			o._shaderValue = shaderValue;
			var blendType = context._nBlendType;
			o._blendFn = context._targets ? BlendMode.targetFns[blendType] : BlendMode.fns[blendType];
			switch (type) {
				case 0:
					o.offset = 0;
					o.startIndex = offset / (CONST3D2D.BYTES_PE * vb.vertexStride) * 1.5;
					o.startIndex *= CONST3D2D.BYTES_PIDX;
					break;
				case 1:
					o.startIndex = startIndex;
					o.offset = offset;
					break;
			}
			return o;
		}

		SubmitOtherIBVB._cache = (SubmitOtherIBVB._cache = [], SubmitOtherIBVB._cache._length = 0, SubmitOtherIBVB._cache);
		SubmitOtherIBVB.tempMatrix4 = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1,];
		return SubmitOtherIBVB;
	})()


	//class laya.webgl.submit.SubmitScissor
	var SubmitScissor = (function () {
		function SubmitScissor() {
			this.submitIndex = 0;
			this.submitLength = 0;
			this.context = null;
			this.clipRect = new Rectangle();
			this.screenRect = new Rectangle();
		}

		__class(SubmitScissor, 'laya.webgl.submit.SubmitScissor');
		var __proto = SubmitScissor.prototype;
		Laya.imps(__proto, { "laya.webgl.submit.ISubmit": true })
		__proto._scissor = function (x, y, w, h) {
			var m = RenderState2D.worldMatrix4;
			var a = m[0], d = m[5], tx = m[12], ty = m[13];
			x = x * a + tx;
			y = y * d + ty;
			w *= a;
			h *= d;
			if (w < 1 || h < 1) {
				return false;
			};
			var r = x + w;
			var b = y + h;
			x < 0 && (x = 0, w = r - x);
			y < 0 && (y = 0, h = b - y);
			var screen = RenderState2D.worldClipRect;
			x = Math.max(x, screen.x);
			y = Math.max(y, screen.y);
			w = Math.min(r, screen.right) - x;
			h = Math.min(b, screen.bottom) - y;
			if (w < 1 || h < 1) {
				return false;
			};
			var worldScissorTest = RenderState2D.worldScissorTest;
			this.screenRect.copyFrom(screen);
			screen.x = x;
			screen.y = y;
			screen.width = w;
			screen.height = h;
			RenderState2D.worldScissorTest = true;
			y = RenderState2D.height - y - h;
			WebGL.mainContext.scissor(x, y, w, h);
			WebGL.mainContext.enable(/*laya.webgl.WebGLContext.SCISSOR_TEST*/0x0C11);
			this.context.submitElement(this.submitIndex, this.submitIndex + this.submitLength);
			if (worldScissorTest) {
				y = RenderState2D.height - this.screenRect.y - this.screenRect.height;
				WebGL.mainContext.scissor(this.screenRect.x, y, this.screenRect.width, this.screenRect.height);
				WebGL.mainContext.enable(/*laya.webgl.WebGLContext.SCISSOR_TEST*/0x0C11);
			}
			else {
				WebGL.mainContext.disable(/*laya.webgl.WebGLContext.SCISSOR_TEST*/0x0C11);
				RenderState2D.worldScissorTest = false;
			}
			screen.copyFrom(this.screenRect);
			return true;
		}

		__proto._scissorWithTagart = function (x, y, w, h) {
			if (w < 1 || h < 1) {
				return false;
			};
			var r = x + w;
			var b = y + h;
			x < 0 && (x = 0, w = r - x);
			y < 0 && (y = 0, h = b - y);
			var screen = RenderState2D.worldClipRect;
			x = Math.max(x, screen.x);
			y = Math.max(y, screen.y);
			w = Math.min(r, screen.right) - x;
			h = Math.min(b, screen.bottom) - y;
			if (w < 1 || h < 1) {
				return false;
			};
			var worldScissorTest = RenderState2D.worldScissorTest;
			this.screenRect.copyFrom(screen);
			RenderState2D.worldScissorTest = true;
			screen.x = x;
			screen.y = y;
			screen.width = w;
			screen.height = h;
			y = RenderState2D.height - y - h;
			WebGL.mainContext.scissor(x, y, w, h);
			WebGL.mainContext.enable(/*laya.webgl.WebGLContext.SCISSOR_TEST*/0x0C11);
			this.context.submitElement(this.submitIndex, this.submitIndex + this.submitLength);
			if (worldScissorTest) {
				y = RenderState2D.height - this.screenRect.y - this.screenRect.height;
				WebGL.mainContext.scissor(this.screenRect.x, y, this.screenRect.width, this.screenRect.height);
				WebGL.mainContext.enable(/*laya.webgl.WebGLContext.SCISSOR_TEST*/0x0C11);
			}
			else {
				WebGL.mainContext.disable(/*laya.webgl.WebGLContext.SCISSOR_TEST*/0x0C11);
				RenderState2D.worldScissorTest = false;
			}
			screen.copyFrom(this.screenRect);
			return true;
		}

		__proto.renderSubmit = function () {
			this.submitLength = Math.min(this.context._submits._length - 1, this.submitLength);
			if (this.submitLength < 1 || this.clipRect.width < 1 || this.clipRect.height < 1)
				return this.submitLength + 1;
			if (this.context._targets)
				this._scissorWithTagart(this.clipRect.x, this.clipRect.y, this.clipRect.width, this.clipRect.height);
			else this._scissor(this.clipRect.x, this.clipRect.y, this.clipRect.width, this.clipRect.height);
			return this.submitLength + 1;
		}

		__proto.getRenderType = function () {
			return 0;
		}

		__proto.releaseRender = function () {
			var cache = SubmitScissor._cache;
			cache[cache._length++] = this;
			this.context = null;
		}

		SubmitScissor.create = function (context) {
			var o = SubmitScissor._cache._length ? SubmitScissor._cache[--SubmitScissor._cache._length] : new SubmitScissor();
			o.context = context;
			return o;
		}

		SubmitScissor._cache = (SubmitScissor._cache = [], SubmitScissor._cache._length = 0, SubmitScissor._cache);
		return SubmitScissor;
	})()


	//class laya.webgl.submit.SubmitStencil
	var SubmitStencil = (function () {
		function SubmitStencil() {
			this.step = 0;
			this.blendMode = null;
			this.level = 0;
		}

		__class(SubmitStencil, 'laya.webgl.submit.SubmitStencil');
		var __proto = SubmitStencil.prototype;
		Laya.imps(__proto, { "laya.webgl.submit.ISubmit": true })
		__proto.renderSubmit = function () {
			switch (this.step) {
				case 1:
					this.do1();
					break;
				case 2:
					this.do2();
					break;
				case 3:
					this.do3();
					break;
				case 4:
					this.do4();
					break;
				case 5:
					this.do5();
					break;
				case 6:
					this.do6();
					break;
				case 7:
					this.do7();
					break;
				case 8:
					this.do8();
					break;
			}
			return 1;
		}

		__proto.getRenderType = function () {
			return 0;
		}

		__proto.releaseRender = function () {
			var cache = SubmitStencil._cache;
			cache[cache._length++] = this;
		}

		__proto.do1 = function () {
			var gl = WebGL.mainContext;
			gl.enable(/*laya.webgl.WebGLContext.STENCIL_TEST*/0x0B90);
			gl.clear(/*laya.webgl.WebGLContext.STENCIL_BUFFER_BIT*/0x00000400);
			gl.colorMask(false, false, false, false);
			gl.stencilFunc(/*laya.webgl.WebGLContext.EQUAL*/0x0202, this.level, 0xFF);
			gl.stencilOp(/*laya.webgl.WebGLContext.KEEP*/0x1E00,/*laya.webgl.WebGLContext.KEEP*/0x1E00,/*laya.webgl.WebGLContext.INCR*/0x1E02);
		}

		//gl.stencilOp(WebGLContext.KEEP,WebGLContext.KEEP,WebGLContext.INVERT);//测试通过给模版缓冲 写入值 一开始是0 现在是 0xFF (模版缓冲中不知道是多少位的数据)
		__proto.do2 = function () {
			var gl = WebGL.mainContext;
			gl.stencilFunc(/*laya.webgl.WebGLContext.EQUAL*/0x0202, this.level + 1, 0xFF);
			gl.colorMask(true, true, true, true);
			gl.stencilOp(/*laya.webgl.WebGLContext.KEEP*/0x1E00,/*laya.webgl.WebGLContext.KEEP*/0x1E00,/*laya.webgl.WebGLContext.KEEP*/0x1E00);
		}

		__proto.do3 = function () {
			var gl = WebGL.mainContext;
			gl.colorMask(true, true, true, true);
			gl.stencilOp(/*laya.webgl.WebGLContext.KEEP*/0x1E00,/*laya.webgl.WebGLContext.KEEP*/0x1E00,/*laya.webgl.WebGLContext.KEEP*/0x1E00);
			gl.clear(/*laya.webgl.WebGLContext.STENCIL_BUFFER_BIT*/0x00000400);
			gl.disable(/*laya.webgl.WebGLContext.STENCIL_TEST*/0x0B90);
		}

		__proto.do4 = function () {
			var gl = WebGL.mainContext;
			if (this.level == 0) {
				gl.enable(/*laya.webgl.WebGLContext.STENCIL_TEST*/0x0B90);
				gl.clear(/*laya.webgl.WebGLContext.STENCIL_BUFFER_BIT*/0x00000400);
			}
			gl.colorMask(false, false, false, false);
			gl.stencilFunc(/*laya.webgl.WebGLContext.ALWAYS*/0x0207, 0, 0xFF);
			gl.stencilOp(/*laya.webgl.WebGLContext.KEEP*/0x1E00,/*laya.webgl.WebGLContext.KEEP*/0x1E00,/*laya.webgl.WebGLContext.INCR*/0x1E02);
		}

		__proto.do5 = function () {
			var gl = WebGL.mainContext;
			gl.stencilFunc(/*laya.webgl.WebGLContext.EQUAL*/0x0202, this.level, 0xFF);
			gl.colorMask(true, true, true, true);
			gl.stencilOp(/*laya.webgl.WebGLContext.KEEP*/0x1E00,/*laya.webgl.WebGLContext.KEEP*/0x1E00,/*laya.webgl.WebGLContext.KEEP*/0x1E00);
		}

		__proto.do6 = function () {
			var gl = WebGL.mainContext;
			BlendMode.targetFns[BlendMode.TOINT[this.blendMode]](gl);
		}

		__proto.do7 = function () {
			var gl = WebGL.mainContext;
			gl.colorMask(false, false, false, false);
			gl.stencilOp(/*laya.webgl.WebGLContext.KEEP*/0x1E00,/*laya.webgl.WebGLContext.KEEP*/0x1E00,/*laya.webgl.WebGLContext.DECR*/0x1E03);
		}

		__proto.do8 = function () {
			var gl = WebGL.mainContext;
			gl.colorMask(true, true, true, true);
			gl.stencilFunc(/*laya.webgl.WebGLContext.EQUAL*/0x0202, this.level, 0xFF);
			gl.stencilOp(/*laya.webgl.WebGLContext.KEEP*/0x1E00,/*laya.webgl.WebGLContext.KEEP*/0x1E00,/*laya.webgl.WebGLContext.KEEP*/0x1E00);
		}

		SubmitStencil.restore = function (context, clip, m, _x, _y) {
			var submitStencil;
			context._renderKey = 0;
			if (SubmitStencil._mask > 0) {
				SubmitStencil._mask--;
			}
			if (SubmitStencil._mask == 0) {
				submitStencil = laya.webgl.submit.SubmitStencil.create(3);
				context.addRenderObject(submitStencil);
				context._curSubmit = Submit.RENDERBASE;
			}
			else {
				submitStencil = laya.webgl.submit.SubmitStencil.create(7);
				context.addRenderObject(submitStencil);
				var vb = context._vb;
				var nPos = (vb._byteLength >> 2);
				if (GlUtils.fillRectImgVb(vb, null, clip.x, clip.y, clip.width, clip.height, Texture.DEF_UV, m, _x, _y, 0, 0)) {
					var shader = context._shader2D;
					shader.glTexture = null;
					var submit = context._curSubmit = Submit.createSubmit(context, context._ib, vb, ((vb._byteLength -/*laya.webgl.canvas.WebGLContext2D._RECTVBSIZE*/16 */*laya.webgl.utils.Buffer2D.FLOAT32*/4) / 32) * 3, Value2D.create(/*laya.webgl.shader.d2.ShaderDefines2D.COLOR2D*/0x02, 0));
					submit.shaderValue.ALPHA = 1.0;
					context._submits[context._submits._length++] = submit;
					context._curSubmit._numEle += 6;
					context._curSubmit = Submit.RENDERBASE;
				} else {
					alert("clipRect calc stencil rect error");
				}
				submitStencil = laya.webgl.submit.SubmitStencil.create(8);
				context.addRenderObject(submitStencil);
			}
		}

		SubmitStencil.restore2 = function (context, submit) {
			var submitStencil;
			context._renderKey = 0;
			if (SubmitStencil._mask > 0) {
				SubmitStencil._mask--;
			}
			if (SubmitStencil._mask == 0) {
				submitStencil = laya.webgl.submit.SubmitStencil.create(3);
				context.addRenderObject(submitStencil);
				context._curSubmit = Submit.RENDERBASE;
			}
			else {
				submitStencil = laya.webgl.submit.SubmitStencil.create(7);
				context.addRenderObject(submitStencil);
				context._submits[context._submits._length++] = submit;
				submitStencil = laya.webgl.submit.SubmitStencil.create(8);
				context.addRenderObject(submitStencil);
			}
		}

		SubmitStencil.create = function (step) {
			var o = SubmitStencil._cache._length ? SubmitStencil._cache[--SubmitStencil._cache._length] : new SubmitStencil();
			o.step = step;
			if (step == 5)
				++SubmitStencil._mask;
			o.level = SubmitStencil._mask;
			return o;
		}

		SubmitStencil._cache = (SubmitStencil._cache = [], SubmitStencil._cache._length = 0, SubmitStencil._cache);
		SubmitStencil._mask = 0;
		return SubmitStencil;
	})()


	//class laya.webgl.submit.SubmitTarget
	var SubmitTarget = (function () {
		function SubmitTarget() {
			this._renderType = 0;
			this._vb = null;
			this._ib = null;
			this._startIdx = 0;
			this._numEle = 0;
			this.shaderValue = null;
			this.blendType = 0;
			this.proName = null;
			this.scope = null;
		}

		__class(SubmitTarget, 'laya.webgl.submit.SubmitTarget');
		var __proto = SubmitTarget.prototype;
		Laya.imps(__proto, { "laya.webgl.submit.ISubmit": true })
		__proto.renderSubmit = function () {
			this._vb.bind_upload(this._ib);
			var target = this.scope.getValue(this.proName);
			if (target) {
				this.shaderValue.texture = target.source;
				if (this.shaderValue["strength"] && !this.shaderValue["blurInfo"]) {
					this.shaderValue["blurInfo"] = [target.width, target.height];
				}
				this.shaderValue.upload();
				this.blend();
				Stat.drawCall++;
				Stat.trianglesFaces += this._numEle / 3;
				WebGL.mainContext.drawElements(/*laya.webgl.WebGLContext.TRIANGLES*/0x0004, this._numEle,/*laya.webgl.WebGLContext.UNSIGNED_SHORT*/0x1403, this._startIdx);
			}
			return 1;
		}

		__proto.blend = function () {
			if (BlendMode.activeBlendFunction !== BlendMode.fns[this.blendType]) {
				var gl = WebGL.mainContext;
				gl.enable(/*laya.webgl.WebGLContext.BLEND*/0x0BE2);
				BlendMode.fns[this.blendType](gl);
				BlendMode.activeBlendFunction = BlendMode.fns[this.blendType];
			}
		}

		__proto.getRenderType = function () {
			return 0;
		}

		__proto.releaseRender = function () {
			var cache = SubmitTarget._cache;
			cache[cache._length++] = this;
		}

		SubmitTarget.create = function (context, ib, vb, pos, sv, proName) {
			var o = SubmitTarget._cache._length ? SubmitTarget._cache[--SubmitTarget._cache._length] : new SubmitTarget();
			o._ib = ib;
			o._vb = vb;
			o.proName = proName;
			o._startIdx = pos * CONST3D2D.BYTES_PIDX;
			o._numEle = 0;
			o.blendType = context._nBlendType;
			o.shaderValue = sv;
			o.shaderValue.setValue(context._shader2D);
			return o;
		}

		SubmitTarget._cache = (SubmitTarget._cache = [], SubmitTarget._cache._length = 0, SubmitTarget._cache);
		return SubmitTarget;
	})()


	/**
	*...特殊的字符，如泰文，必须重新实现这个类
	*/
	//class laya.webgl.text.CharSegment
	var CharSegment = (function () {
		function CharSegment() {
			this._sourceStr = null;
		}

		__class(CharSegment, 'laya.webgl.text.CharSegment');
		var __proto = CharSegment.prototype;
		Laya.imps(__proto, { "laya.webgl.text.ICharSegment": true })
		__proto.textToSpit = function (str) {
			this._sourceStr = str;
		}

		__proto.getChar = function (i) {
			return this._sourceStr.charAt(i);
		}

		__proto.getCharCode = function (i) {
			return this._sourceStr.charCodeAt(i);
		}

		__proto.length = function () {
			return this._sourceStr.length;
		}

		return CharSegment;
	})()


	//class laya.webgl.text.DrawText
	var DrawText = (function () {
		var CharValue;
		function DrawText() { }
		__class(DrawText, 'laya.webgl.text.DrawText');
		DrawText.__init__ = function () {
			DrawText._charsTemp = new Array;
			DrawText._drawValue = new CharValue();
			DrawText._charSeg = new CharSegment();
		}

		DrawText.customCharSeg = function (charseg) {
			DrawText._charSeg = charseg;
		}

		DrawText.getChar = function (char, id, drawValue) {
			var result = WebGLCharImage.createOneChar(char, drawValue);
			if (id != -1)
				DrawText._charsCache[id] = result;
			return result;
		}

		DrawText._drawSlow = function (save, ctx, txt, words, curMat, font, textAlign, fillColor, borderColor, lineWidth, x, y, sx, sy, underLine) {
			var drawValue = DrawText._drawValue.value(font, fillColor, borderColor, lineWidth, sx, sy, underLine);
			var i = 0, n = 0;
			var chars = DrawText._charsTemp;
			var width = 0, oneChar, htmlWord, id = NaN;
			if (words) {
				chars.length = words.length;
				for (i = 0, n = words.length; i < n; i++) {
					htmlWord = words[i];
					id = htmlWord.charNum + drawValue.txtID;
					chars[i] = oneChar = DrawText._charsCache[id] || DrawText.getChar(htmlWord.char, id, drawValue);
					oneChar.active();
				}
			} else {
				var text = ((txt instanceof laya.utils.WordText)) ? txt.toString() : txt;
				if (Text.CharacterCache) {
					DrawText._charSeg.textToSpit(text);
					var len =/*if err,please use iflash.method.xmlLength()*/DrawText._charSeg.length();
					chars.length = len;
					for (i = 0, n = len; i < n; i++) {
						id = DrawText._charSeg.getCharCode(i) + drawValue.txtID;
						chars[i] = oneChar = DrawText._charsCache[id] || DrawText.getChar(DrawText._charSeg.getChar(i), id, drawValue);
						oneChar.active();
						width += oneChar.cw;
					}
				}
				else {
					chars.length = 0;
					oneChar = DrawText.getChar(text, -1, drawValue);
					oneChar.active();
					width += oneChar.cw;
					chars[0] = oneChar;
				}
			};
			var dx = 0;
			if (textAlign !== null && textAlign !== "left")
				dx = -(textAlign == "center" ? (width / 2) : width);
			var uv, bdSz = NaN, texture, value, saveLength = 0;
			if (words) {
				for (i = 0, n = chars.length; i < n; i++) {
					oneChar = chars[i];
					if (!oneChar.isSpace) {
						htmlWord = words[i];
						bdSz = oneChar.borderSize;
						texture = oneChar.texture;
						ctx._drawText(texture, x + dx + htmlWord.x * sx - bdSz, y + htmlWord.y * sy - bdSz, texture.width, texture.height, curMat, 0, 0, 0, 0);
					}
				}
			} else {
				for (i = 0, n = chars.length; i < n; i++) {
					oneChar = chars[i];
					if (!oneChar.isSpace) {
						bdSz = oneChar.borderSize;
						texture = oneChar.texture;
						ctx._drawText(texture, x + dx - bdSz, y - bdSz, texture.width, texture.height, curMat, 0, 0, 0, 0);
						save && (value = save[saveLength++], value || (value = save[saveLength - 1] = []), value[0] = texture, value[1] = dx - bdSz, value[2] = -bdSz);
					}
					dx += oneChar.cw;
				}
				save && (save.length = saveLength);
			}
		}

		DrawText._drawFast = function (save, ctx, curMat, x, y) {
			var texture, value;
			for (var i = 0, n = save.length; i < n; i++) {
				value = save[i];
				texture = value[0];
				texture.active();
				ctx._drawText(texture, x + value[1], y + value[2], texture.width, texture.height, curMat, 0, 0, 0, 0);
			}
		}

		DrawText.drawText = function (ctx, txt, words, curMat, font, textAlign, fillColor, borderColor, lineWidth, x, y, underLine) {
			(underLine === void 0) && (underLine = 0);
			if ((txt && txt.length === 0) || (words && words.length === 0))
				return;
			var sx = curMat.a, sy = curMat.d;
			(curMat.b !== 0 || curMat.c !== 0) && (sx = sy = 1);
			var scale = sx !== 1 || sy !== 1;
			if (scale && Laya.stage.transform) {
				var t = Laya.stage.transform;
				scale = t.a === sx && t.d === sy;
			} else scale = false;
			if (scale) {
				curMat = curMat.copyTo(WebGLContext2D._tmpMatrix);
				var tempTx = curMat.tx;
				var tempTy = curMat.ty;
				curMat.scale(1 / sx, 1 / sy);
				curMat._checkTransform();
				x *= sx;
				y *= sy;
				x += tempTx - curMat.tx;
				y += tempTy - curMat.ty;
			} else sx = sy = 1;
			if (words) {
				DrawText._drawSlow(null, ctx, txt, words, curMat, font, textAlign, fillColor, borderColor, lineWidth, x, y, sx, sy, underLine);
			} else {
				if (txt.toUpperCase === null) {
					var idNum = sx + sy * 100000;
					var myCache = txt;
					if (!myCache.changed && myCache.id === idNum) {
						DrawText._drawFast(myCache.save, ctx, curMat, x, y);
					} else {
						myCache.id = idNum;
						myCache.changed = false;
						DrawText._drawSlow(myCache.save, ctx, txt, words, curMat, font, textAlign, fillColor, borderColor, lineWidth, x, y, sx, sy, underLine);
					}
					return;
				};
				var id = txt + font.toString() + fillColor + borderColor + lineWidth + sx + sy + textAlign;
				var cache = DrawText._textsCache[id];
				if (Text.CharacterCache) {
					if (cache) {
						DrawText._drawFast(cache, ctx, curMat, x, y);
					} else {
						DrawText._textsCache.__length || (DrawText._textsCache.__length = 0);
						if (DrawText._textsCache.__length > Config.WebGLTextCacheCount) {
							DrawText._textsCache = {};
							DrawText._textsCache.__length = 0;
							DrawText._curPoolIndex = 0;
						}
						DrawText._textCachesPool[DrawText._curPoolIndex] ? (cache = DrawText._textsCache[id] = DrawText._textCachesPool[DrawText._curPoolIndex], cache.length = 0) : (DrawText._textCachesPool[DrawText._curPoolIndex] = cache = DrawText._textsCache[id] = []);
						DrawText._textsCache.__length++
						DrawText._curPoolIndex++;
						DrawText._drawSlow(cache, ctx, txt, words, curMat, font, textAlign, fillColor, borderColor, lineWidth, x, y, sx, sy, underLine);
					}
				}
				else {
					DrawText._drawSlow(cache, ctx, txt, words, curMat, font, textAlign, fillColor, borderColor, lineWidth, x, y, sx, sy, underLine);
				}
			}
		}

		DrawText._charsTemp = null;
		DrawText._textCachesPool = [];
		DrawText._curPoolIndex = 0;
		DrawText._charsCache = {};
		DrawText._textsCache = {};
		DrawText._drawValue = null;
		DrawText.d = [];
		DrawText._charSeg = null;
		DrawText.__init$ = function () {
			//class CharValue
			CharValue = (function () {
				function CharValue() {
					//this.txtID=NaN;
					//this.font=null;
					//this.fillColor=null;
					//this.borderColor=null;
					//this.lineWidth=0;
					//this.scaleX=NaN;
					//this.scaleY=NaN;
					//this.underLine=0;
				}
				__class(CharValue, '');
				var __proto = CharValue.prototype;
				__proto.value = function (font, fillColor, borderColor, lineWidth, scaleX, scaleY, underLine) {
					this.font = font;
					this.fillColor = fillColor;
					this.borderColor = borderColor;
					this.lineWidth = lineWidth;
					this.scaleX = scaleX;
					this.scaleY = scaleY;
					this.underLine = underLine;
					var key = font.toString() + scaleX + scaleY + lineWidth + fillColor + borderColor + underLine;
					this.txtID = CharValue._keymap[key];
					if (!this.txtID) {
						this.txtID = (++CharValue._keymapCount) * 0.0000001;
						CharValue._keymap[key] = this.txtID;
					}
					return this;
				}
				CharValue.clear = function () {
					CharValue._keymap = {};
					CharValue._keymapCount = 1;
				}
				CharValue._keymap = {};
				CharValue._keymapCount = 1;
				return CharValue;
			})()
		}

		return DrawText;
	})()


	//class laya.webgl.text.FontInContext
	var FontInContext = (function () {
		function FontInContext(font) {
			//this._text=null;
			//this._words=null;
			this._index = 0;
			this._size = 14;
			this._italic = -2;
			FontInContext._cache2 = FontInContext._cache2 || [];
			this.setFont(font || "14px Arial");
		}

		__class(FontInContext, 'laya.webgl.text.FontInContext');
		var __proto = FontInContext.prototype;
		__proto.setFont = function (value) {
			var arr = FontInContext._cache2[value];
			if (!arr) {
				this._words = value.split(' ');
				for (var i = 0, n = this._words.length; i < n; i++) {
					if (this._words[i].indexOf('px') > 0) {
						this._index = i;
						break;
					}
				}
				this._size = parseInt(this._words[this._index]);
				FontInContext._cache2[value] = [this._words, this._size];
			} else {
				this._words = arr[0];
				this._size = arr[1];
			}
			this._text = null;
			this._italic = -2;
		}

		__proto.getItalic = function () {
			this._italic === -2 && (this._italic = this.hasType("italic"));
			return this._italic;
		}

		__proto.hasType = function (name) {
			for (var i = 0, n = this._words.length; i < n; i++)
				if (this._words[i] === name) return i;
			return -1;
		}

		__proto.removeType = function (name) {
			for (var i = 0, n = this._words.length; i < n; i++)
				if (this._words[i] === name) {
					this._words.splice(i, 1);
					if (this._index > i) this._index--;
					break;
				}
			this._text = null;
			this._italic = -2;
		}

		__proto.copyTo = function (dec) {
			dec._text = this._text;
			dec._size = this._size;
			dec._index = this._index;
			dec._words = this._words.slice();
			dec._italic = -2;
			return dec;
		}

		__proto.toString = function () {
			return this._text ? this._text : (this._text = this._words.join(' '));
		}

		__getset(0, __proto, 'size', function () {
			return this._size;
		}, function (value) {
			this._size = value;
			this._words[this._index] = value + "px";
			this._text = null;
		});

		FontInContext.create = function (font) {
			var r = FontInContext._cache[font];
			if (r) return r;
			r = FontInContext._cache[font] = new FontInContext(font);
			return r;
		}

		FontInContext.EMPTY = new FontInContext();
		FontInContext._cache = {};
		FontInContext._cache2 = null;
		return FontInContext;
	})()


	//class laya.webgl.utils.CONST3D2D
	var CONST3D2D = (function () {
		function CONST3D2D() { }
		__class(CONST3D2D, 'laya.webgl.utils.CONST3D2D');
		CONST3D2D.defaultMatrix4 = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
		CONST3D2D.defaultMinusYMatrix4 = [1, 0, 0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
		CONST3D2D.uniformMatrix3 = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0];
		CONST3D2D._TMPARRAY = [];
		CONST3D2D._OFFSETX = 0;
		CONST3D2D._OFFSETY = 0;
		__static(CONST3D2D,
			['BYTES_PE', function () { return this.BYTES_PE =/*__JS__ */Float32Array.BYTES_PER_ELEMENT; }, 'BYTES_PIDX', function () { return this.BYTES_PIDX =/*__JS__ */Uint16Array.BYTES_PER_ELEMENT; }
			]);
		return CONST3D2D;
	})()


	//class laya.webgl.utils.GlUtils
	var GlUtils = (function () {
		function GlUtils() { }
		__class(GlUtils, 'laya.webgl.utils.GlUtils');
		GlUtils.make2DProjection = function (width, height, depth) {
			return [2.0 / width, 0, 0, 0, 0, -2.0 / height, 0, 0, 0, 0, 2.0 / depth, 0, -1, 1, 0, 1,];
		}

		GlUtils.fillIBQuadrangle = function (buffer, count) {
			if (count > 65535 / 4) {
				throw Error("IBQuadrangle count:" + count + " must<:" + Math.floor(65535 / 4));
				return false;
			}
			count = Math.floor(count);
			buffer._resizeBuffer((count + 1) * 6 */*laya.webgl.utils.Buffer2D.SHORT*/2, false);
			buffer.byteLength = buffer.bufferLength;
			var bufferData = buffer.getUint16Array();
			var idx = 0;
			for (var i = 0; i < count; i++) {
				bufferData[idx++] = i * 4;
				bufferData[idx++] = i * 4 + 2;
				bufferData[idx++] = i * 4 + 1;
				bufferData[idx++] = i * 4;
				bufferData[idx++] = i * 4 + 3;
				bufferData[idx++] = i * 4 + 2;
			}
			buffer.setNeedUpload();
			return true;
		}

		GlUtils.expandIBQuadrangle = function (buffer, count) {
			buffer.bufferLength >= (count * 6 */*laya.webgl.utils.Buffer2D.SHORT*/2) || GlUtils.fillIBQuadrangle(buffer, count);
		}

		GlUtils.mathCeilPowerOfTwo = function (value) {
			value--;
			value |= value >> 1;
			value |= value >> 2;
			value |= value >> 4;
			value |= value >> 8;
			value |= value >> 16;
			value++;
			return value;
		}

		GlUtils.fillQuadrangleImgVb = function (vb, x, y, point4, uv, m, _x, _y) {
			'use strict';
			var vpos = (vb._byteLength >> 2) +/*laya.webgl.canvas.WebGLContext2D._RECTVBSIZE*/16;
			vb.byteLength = (vpos << 2);
			var vbdata = vb.getFloat32Array();
			vpos -=/*laya.webgl.canvas.WebGLContext2D._RECTVBSIZE*/16;
			vbdata[vpos + 2] = uv[0];
			vbdata[vpos + 3] = uv[1];
			vbdata[vpos + 6] = uv[2];
			vbdata[vpos + 7] = uv[3];
			vbdata[vpos + 10] = uv[4];
			vbdata[vpos + 11] = uv[5];
			vbdata[vpos + 14] = uv[6];
			vbdata[vpos + 15] = uv[7];
			var a = m.a, b = m.b, c = m.c, d = m.d;
			if (a !== 1 || b !== 0 || c !== 0 || d !== 1) {
				m.bTransform = true;
				var tx = m.tx + _x, ty = m.ty + _y;
				vbdata[vpos] = (point4[0] + x) * a + (point4[1] + y) * c + tx;
				vbdata[vpos + 1] = (point4[0] + x) * b + (point4[1] + y) * d + ty;
				vbdata[vpos + 4] = (point4[2] + x) * a + (point4[3] + y) * c + tx;
				vbdata[vpos + 5] = (point4[2] + x) * b + (point4[3] + y) * d + ty;
				vbdata[vpos + 8] = (point4[4] + x) * a + (point4[5] + y) * c + tx;
				vbdata[vpos + 9] = (point4[4] + x) * b + (point4[5] + y) * d + ty;
				vbdata[vpos + 12] = (point4[6] + x) * a + (point4[7] + y) * c + tx;
				vbdata[vpos + 13] = (point4[6] + x) * b + (point4[7] + y) * d + ty;
			} else {
				m.bTransform = false;
				x += m.tx + _x;
				y += m.ty + _y;
				vbdata[vpos] = x + point4[0];
				vbdata[vpos + 1] = y + point4[1];
				vbdata[vpos + 4] = x + point4[2];
				vbdata[vpos + 5] = y + point4[3];
				vbdata[vpos + 8] = x + point4[4];
				vbdata[vpos + 9] = y + point4[5];
				vbdata[vpos + 12] = x + point4[6];
				vbdata[vpos + 13] = y + point4[7];
			}
			vb._upload = true;
			return true;
		}

		GlUtils.fillTranglesVB = function (vb, x, y, points, m, _x, _y) {
			var vpos = (vb._byteLength >> 2) + points.length;
			vb.byteLength = (vpos << 2);
			var vbdata = vb.getFloat32Array();
			vpos -= points.length;
			var len = points.length;
			var a = m.a, b = m.b, c = m.c, d = m.d;
			for (var i = 0; i < len; i += 4) {
				vbdata[vpos + i + 2] = points[i + 2];
				vbdata[vpos + i + 3] = points[i + 3];
				if (a !== 1 || b !== 0 || c !== 0 || d !== 1) {
					m.bTransform = true;
					var tx = m.tx + _x, ty = m.ty + _y;
					vbdata[vpos + i] = (points[i] + x) * a + (points[i + 1] + y) * c + tx;
					vbdata[vpos + i + 1] = (points[i] + x) * b + (points[i + 1] + y) * d + ty;
				} else {
					m.bTransform = false;
					x += m.tx + _x;
					y += m.ty + _y;
					vbdata[vpos + i] = x + points[i];
					vbdata[vpos + i + 1] = y + points[i + 1];
				}
			}
			vb._upload = true;
			return true;
		}

		GlUtils.copyPreImgVb = function (vb, dx, dy) {
			var vpos = (vb._byteLength >> 2);
			vb.byteLength = ((vpos +/*laya.webgl.canvas.WebGLContext2D._RECTVBSIZE*/16) << 2);
			var vbdata = vb.getFloat32Array();
			for (var i = 0, ci = vpos - 16; i < 4; i++) {
				vbdata[vpos] = vbdata[ci] + dx;
				++vpos;
				++ci;
				vbdata[vpos] = vbdata[ci] + dy;
				++vpos;
				++ci;
				vbdata[vpos] = vbdata[ci];
				++vpos;
				++ci;
				vbdata[vpos] = vbdata[ci];
				++vpos;
				++ci;
			}
			vb._upload = true;
		}

		GlUtils.fillRectImgVb = function (vb, clip, x, y, width, height, uv, m, _x, _y, dx, dy, round) {
			(round === void 0) && (round = false);
			var mType = 1;
			var toBx, toBy, toEx, toEy;
			var cBx, cBy, cEx, cEy;
			var w0, h0, tx, ty;
			var finalX, finalY, offsetX, offsetY;
			var a = m.a, b = m.b, c = m.c, d = m.d;
			var useClip = clip && clip.width < /*laya.webgl.canvas.WebGLContext2D._MAXSIZE*/99999999;
			if (a !== 1 || b !== 0 || c !== 0 || d !== 1) {
				m.bTransform = true;
				if (b === 0 && c === 0) {
					mType = 23;
					w0 = width + x, h0 = height + y;
					tx = m.tx + _x, ty = m.ty + _y;
					toBx = a * x + tx;
					toEx = a * w0 + tx;
					toBy = d * y + ty;
					toEy = d * h0 + ty;
				}
			} else {
				mType = 23;
				m.bTransform = false;
				toBx = x + m.tx + _x;
				toEx = toBx + width;
				toBy = y + m.ty + _y;
				toEy = toBy + height;
			}
			if (useClip) {
				cBx = clip.x, cBy = clip.y, cEx = clip.width + cBx, cEy = clip.height + cBy;
			}
			if (mType !== 1) {
				if (Math.min(toBx, toEx) >= cEx) return false;
				if (Math.min(toBy, toEy) >= cEy) return false;
				if (Math.max(toEx, toBx) <= cBx) return false;
				if (Math.max(toEy, toBy) <= cBy) return false;
			};
			var vpos = (vb._byteLength >> 2);
			vb.byteLength = ((vpos +/*laya.webgl.canvas.WebGLContext2D._RECTVBSIZE*/16) << 2);
			var vbdata = vb.getFloat32Array();
			vbdata[vpos + 2] = uv[0];
			vbdata[vpos + 3] = uv[1];
			vbdata[vpos + 6] = uv[2];
			vbdata[vpos + 7] = uv[3];
			vbdata[vpos + 10] = uv[4];
			vbdata[vpos + 11] = uv[5];
			vbdata[vpos + 14] = uv[6];
			vbdata[vpos + 15] = uv[7];
			switch (mType) {
				case 1:
					tx = m.tx + _x, ty = m.ty + _y;
					w0 = width + x, h0 = height + y;
					var w1 = x, h1 = y;
					var aw1 = a * w1, ch1 = c * h1, dh1 = d * h1, bw1 = b * w1;
					var aw0 = a * w0, ch0 = c * h0, dh0 = d * h0, bw0 = b * w0;
					if (round) {
						finalX = aw1 + ch1 + tx;
						offsetX = Math.round(finalX) - finalX;
						finalY = dh1 + bw1 + ty;
						offsetY = Math.round(finalY) - finalY;
						vbdata[vpos] = finalX + offsetX;
						vbdata[vpos + 1] = finalY + offsetY;
						vbdata[vpos + 4] = aw0 + ch1 + tx + offsetX;
						vbdata[vpos + 5] = dh1 + bw0 + ty + offsetY;
						vbdata[vpos + 8] = aw0 + ch0 + tx + offsetX;
						vbdata[vpos + 9] = dh0 + bw0 + ty + offsetY;
						vbdata[vpos + 12] = aw1 + ch0 + tx + offsetX;
						vbdata[vpos + 13] = dh0 + bw1 + ty + offsetY;
					} else {
						vbdata[vpos] = aw1 + ch1 + tx;
						vbdata[vpos + 1] = dh1 + bw1 + ty;
						vbdata[vpos + 4] = aw0 + ch1 + tx;
						vbdata[vpos + 5] = dh1 + bw0 + ty;
						vbdata[vpos + 8] = aw0 + ch0 + tx;
						vbdata[vpos + 9] = dh0 + bw0 + ty;
						vbdata[vpos + 12] = aw1 + ch0 + tx;
						vbdata[vpos + 13] = dh0 + bw1 + ty;
					}
					break;
				case 23:
					if (round) {
						finalX = toBx + dx;
						offsetX = Math.round(finalX) - finalX;
						finalY = toBy;
						offsetY = Math.round(finalY) - finalY;
						vbdata[vpos] = finalX + offsetX;
						vbdata[vpos + 1] = finalY + offsetY;
						vbdata[vpos + 4] = toEx + dx + offsetX;
						vbdata[vpos + 5] = toBy + offsetY;
						vbdata[vpos + 8] = toEx + offsetX;
						vbdata[vpos + 9] = toEy + offsetY;
						vbdata[vpos + 12] = toBx + offsetX;
						vbdata[vpos + 13] = toEy + offsetY;
					} else {
						vbdata[vpos] = toBx + dx;
						vbdata[vpos + 1] = toBy;
						vbdata[vpos + 4] = toEx + dx;
						vbdata[vpos + 5] = toBy;
						vbdata[vpos + 8] = toEx;
						vbdata[vpos + 9] = toEy;
						vbdata[vpos + 12] = toBx;
						vbdata[vpos + 13] = toEy;
					}
					break;
			}
			vb._upload = true;
			return true;
		}

		GlUtils.fillLineVb = function (vb, clip, fx, fy, tx, ty, width, mat) {
			'use strict';
			var linew = width * .5;
			var data = GlUtils._fillLineArray;
			var perpx = -(fy - ty), perpy = fx - tx;
			var dist = Math.sqrt(perpx * perpx + perpy * perpy);
			perpx /= dist, perpy /= dist, perpx *= linew, perpy *= linew;
			data[0] = fx - perpx, data[1] = fy - perpy, data[4] = fx + perpx, data[5] = fy + perpy, data[8] = tx + perpx, data[9] = ty + perpy, data[12] = tx - perpx, data[13] = ty - perpy;
			mat && mat.transformPointArray(data, data);
			var vpos = (vb._byteLength >> 2) +/*laya.webgl.canvas.WebGLContext2D._RECTVBSIZE*/16;
			vb.byteLength = (vpos << 2);
			vb.insertData(data, vpos -/*laya.webgl.canvas.WebGLContext2D._RECTVBSIZE*/16);
			return true;
		}

		GlUtils._fillLineArray = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
		return GlUtils;
	})()


	//class laya.webgl.utils.MatirxArray
	var MatirxArray = (function () {
		function MatirxArray() { }
		__class(MatirxArray, 'laya.webgl.utils.MatirxArray');
		MatirxArray.ArrayMul = function (a, b, o) {
			if (!a) {
				MatirxArray.copyArray(b, o);
				return;
			}
			if (!b) {
				MatirxArray.copyArray(a, o);
				return;
			};
			var ai0 = NaN, ai1 = NaN, ai2 = NaN, ai3 = NaN;
			for (var i = 0; i < 4; i++) {
				ai0 = a[i];
				ai1 = a[i + 4];
				ai2 = a[i + 8];
				ai3 = a[i + 12];
				o[i] = ai0 * b[0] + ai1 * b[1] + ai2 * b[2] + ai3 * b[3];
				o[i + 4] = ai0 * b[4] + ai1 * b[5] + ai2 * b[6] + ai3 * b[7];
				o[i + 8] = ai0 * b[8] + ai1 * b[9] + ai2 * b[10] + ai3 * b[11];
				o[i + 12] = ai0 * b[12] + ai1 * b[13] + ai2 * b[14] + ai3 * b[15];
			}
		}

		MatirxArray.copyArray = function (f, t) {
			if (!f) return;
			if (!t) return;
			for (var i = 0; i < f.length; i++) {
				t[i] = f[i];
			}
		}

		return MatirxArray;
	})()


	/**
	*Mesh2d只是保存数据。描述attribute用的。本身不具有渲染功能。
	*/
	//class laya.webgl.utils.Mesh2D
	var Mesh2D = (function () {
		function Mesh2D(stride, vballoc, iballoc) {
			this._stride = 0;
			//顶点结构大小。每个mesh的顶点结构是固定的。
			this.vertNum = 0;
			//当前的顶点的个数
			this.indexNum = 0;
			//实际index 个数。例如一个三角形是3个。由于ib本身可能超过实际使用的数量，所以需要一个indexNum
			this._applied = false;
			//是否已经设置给webgl了
			this._vb = null;
			//vb和ib都可能需要在外部修改，所以public
			this._ib = null;
			this._vao = null;
			this._attribInfo = null;
			//保存起来的属性定义数组。
			this._quadNum = 0;
			//public static var meshlist:Array=[];//活着的mesh对象列表。
			this.canReuse = false;
			this._stride = stride;
			this._vb = new VertexBuffer2D(stride,/*laya.webgl.WebGLContext.DYNAMIC_DRAW*/0x88E8);
			if (vballoc) {
				this._vb._resizeBuffer(vballoc, false);
			} else { }
			this._ib = new IndexBuffer2D();
			if (iballoc) {
				this._ib._resizeBuffer(iballoc, false);
			}
		}

		__class(Mesh2D, 'laya.webgl.utils.Mesh2D');
		var __proto = Mesh2D.prototype;
		/**
		*重新创建一个mesh。复用这个对象的vertex结构，ib对象和attribinfo对象
		*/
		__proto.cloneWithNewVB = function () {
			var mesh = new Mesh2D(this._stride, 0, 0);
			mesh._ib = this._ib;
			mesh._quadNum = this._quadNum;
			mesh._attribInfo = this._attribInfo;
			return mesh;
		}

		/**
		*创建一个mesh，使用当前对象的vertex结构。vb和ib自己提供。
		*@return
		*/
		__proto.cloneWithNewVBIB = function () {
			var mesh = new Mesh2D(this._stride, 0, 0);
			mesh._attribInfo = this._attribInfo;
			return mesh;
		}

		/**
		*获得一个可以写的vb对象
		*/
		__proto.getVBW = function () {
			this._vb.setNeedUpload();
			return this._vb;
		}

		/**
		*获得一个只读vb
		*/
		__proto.getVBR = function () {
			return this._vb;
		}

		__proto.getIBR = function () {
			return this._ib;
		}

		/**
		*获得一个可写的ib
		*/
		__proto.getIBW = function () {
			this._ib.setNeedUpload();
			return this._ib;
		}

		/**
		*直接创建一个固定的ib。按照固定四边形的索引。
		*@param var QuadNum
		*/
		__proto.createQuadIB = function (QuadNum) {
			this._quadNum = QuadNum;
			this._ib._resizeBuffer(QuadNum * 6 * 2, false);
			this._ib.byteLength = this._ib.bufferLength;
			var bd = this._ib.getUint16Array();
			var idx = 0;
			var curvert = 0;
			for (var i = 0; i < QuadNum; i++) {
				bd[idx++] = curvert;
				bd[idx++] = curvert + 2;
				bd[idx++] = curvert + 1;
				bd[idx++] = curvert;
				bd[idx++] = curvert + 3;
				bd[idx++] = curvert + 2;
				curvert += 4;
			}
			this._ib.setNeedUpload();
		}

		/**
		*设置mesh的属性。每3个一组，对应的location分别是0,1,2...
		*含义是：type,size,offset
		*不允许多流。因此stride是固定的，offset只是在一个vertex之内。
		*@param attribs
		*/
		__proto.setAttributes = function (attribs) {
			this._attribInfo = attribs;
			if (this._attribInfo.length % 3 != 0) {
				throw 'Mesh2D setAttributes error!';
			}
		}

		__proto.getEleNum = function () {
			return this._ib.getBuffer().byteLength / 2;
		}

		/**
		*子类实现。用来把自己放到对应的回收池中，以便复用。
		*/
		__proto.releaseMesh = function () { }
		/**
		*释放资源。
		*/
		__proto.destroy = function () { }
		/**
		*清理vb数据
		*/
		__proto.clearVB = function () {
			this._vb.clear();
		}

		Mesh2D._gvaoid = 0;
		return Mesh2D;
	})()


	//class laya.webgl.utils.RenderState2D
	var RenderState2D = (function () {
		function RenderState2D() { }
		__class(RenderState2D, 'laya.webgl.utils.RenderState2D');
		RenderState2D.getMatrArray = function () {
			return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
		}

		RenderState2D.mat2MatArray = function (mat, matArray) {
			var m = mat;
			var m4 = matArray;
			m4[0] = m.a;
			m4[1] = m.b;
			m4[2] = RenderState2D.EMPTYMAT4_ARRAY[2];
			m4[3] = RenderState2D.EMPTYMAT4_ARRAY[3];
			m4[4] = m.c;
			m4[5] = m.d;
			m4[6] = RenderState2D.EMPTYMAT4_ARRAY[6];
			m4[7] = RenderState2D.EMPTYMAT4_ARRAY[7];
			m4[8] = RenderState2D.EMPTYMAT4_ARRAY[8];
			m4[9] = RenderState2D.EMPTYMAT4_ARRAY[9];
			m4[10] = RenderState2D.EMPTYMAT4_ARRAY[10];
			m4[11] = RenderState2D.EMPTYMAT4_ARRAY[11];
			m4[12] = m.tx;
			m4[13] = m.ty;
			m4[14] = RenderState2D.EMPTYMAT4_ARRAY[14];
			m4[15] = RenderState2D.EMPTYMAT4_ARRAY[15];
			return matArray;
		}

		RenderState2D.restoreTempArray = function () {
			RenderState2D.TEMPMAT4_ARRAY[0] = 1;
			RenderState2D.TEMPMAT4_ARRAY[1] = 0;
			RenderState2D.TEMPMAT4_ARRAY[4] = 0;
			RenderState2D.TEMPMAT4_ARRAY[5] = 1;
			RenderState2D.TEMPMAT4_ARRAY[12] = 0;
			RenderState2D.TEMPMAT4_ARRAY[13] = 0;
		}

		RenderState2D.clear = function () {
			RenderState2D.worldScissorTest = false;
			RenderState2D.worldShaderDefines = null;
			RenderState2D.worldFilters = null;
			RenderState2D.worldAlpha = 1;
			RenderState2D.worldClipRect.x = RenderState2D.worldClipRect.y = 0;
			RenderState2D.worldClipRect.width = RenderState2D.width;
			RenderState2D.worldClipRect.height = RenderState2D.height;
			RenderState2D.curRenderTarget = null;
		}

		RenderState2D._MAXSIZE = 99999999;
		RenderState2D.EMPTYMAT4_ARRAY = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
		RenderState2D.TEMPMAT4_ARRAY = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
		RenderState2D.worldMatrix4 = RenderState2D.TEMPMAT4_ARRAY;
		RenderState2D.worldAlpha = 1.0;
		RenderState2D.worldScissorTest = false;
		RenderState2D.worldFilters = null;
		RenderState2D.worldShaderDefines = null;
		RenderState2D.curRenderTarget = null;
		RenderState2D.width = 0;
		RenderState2D.height = 0;
		__static(RenderState2D,
			['worldMatrix', function () { return this.worldMatrix = new Matrix(); }, 'worldClipRect', function () { return this.worldClipRect = new Rectangle(0, 0, 99999999, 99999999); }
			]);
		return RenderState2D;
	})()


	/**
	*@private
	*<code>ShaderCompile</code> 类用于实现Shader编译。
	*/
	//class laya.webgl.utils.ShaderCompile
	var ShaderCompile = (function () {
		var ShaderNode, InlcudeFile;
		function ShaderCompile(name, vs, ps, nameMap, defs) {
			//this._nameMap=null;
			//this._VS=null;
			//this._PS=null;
			var _$this = this;
			function _compile(script) {
				var includefiles = [];
				var top = new ShaderNode(includefiles);
				_$this._compileToTree(top, script.split('\n'), 0, includefiles, defs);
				return top;
			};
			var startTime = Browser.now();
			this._VS = _compile(vs);
			this._PS = _compile(ps);
			this._nameMap = nameMap;
			if ((Browser.now() - startTime) > 2)
				console.log("ShaderCompile use time:" + (Browser.now() - startTime) + "  size:" + vs.length + "/" + ps.length);
		}

		__class(ShaderCompile, 'laya.webgl.utils.ShaderCompile');
		var __proto = ShaderCompile.prototype;
		__proto._compileToTree = function (parent, lines, start, includefiles, defs) {
			var node, preNode;
			var text, name, fname;
			var ofs = 0, words, noUseNode;
			var i = 0, n = 0, j = 0;
			for (i = start; i < lines.length; i++) {
				text = lines[i];
				if (text.length < 1) continue;
				ofs = text.indexOf("//");
				if (ofs === 0) continue;
				if (ofs >= 0) text = text.substr(0, ofs);
				node = noUseNode || new ShaderNode(includefiles);
				noUseNode = null;
				node.text = text;
				node.noCompile = true;
				if ((ofs = text.indexOf("#")) >= 0) {
					name = "#";
					for (j = ofs + 1, n = text.length; j < n; j++) {
						var c = text.charAt(j);
						if (c === ' ' || c === '\t' || c === '?') break;
						name += c;
					}
					node.name = name;
					switch (name) {
						case "#ifdef":
						case "#ifndef":
							node.src = text;
							node.noCompile = text.match(/[!&|()=<>]/) != null;
							if (!node.noCompile) {
								words = text.replace(/^\s*/, '').split(/\s+/);
								node.setCondition(words[1], name === "#ifdef" ? 1 : 2);
								node.text = "//" + node.text;
							} else {
								console.log("function():Boolean{return " + text.substr(ofs + node.name.length) + "}");
							}
							node.setParent(parent);
							parent = node;
							if (defs) {
								words = text.substr(j).split(ShaderCompile._splitToWordExps3);
								for (j = 0; j < words.length; j++) {
									text = words[j];
									text.length && (defs[text] = true);
								}
							}
							continue;
						case "#if":
							node.src = text;
							node.noCompile = true;
							node.setParent(parent);
							parent = node;
							if (defs) {
								words = text.substr(j).split(ShaderCompile._splitToWordExps3);
								for (j = 0; j < words.length; j++) {
									text = words[j];
									text.length && text != "defined" && (defs[text] = true);
								}
							}
							continue;
						case "#else":
							node.src = text;
							parent = parent.parent;
							preNode = parent.childs[parent.childs.length - 1];
							node.noCompile = preNode.noCompile
							if (!(node.noCompile)) {
								node.condition = preNode.condition;
								node.conditionType = preNode.conditionType == 1 ? 2 : 1;
								node.text = "//" + node.text + " " + preNode.text + " " + node.conditionType;
							}
							node.setParent(parent);
							parent = node;
							continue;
						case "#endif":
							parent = parent.parent;
							preNode = parent.childs[parent.childs.length - 1];
							node.noCompile = preNode.noCompile;
							if (!(node.noCompile)) {
								node.text = "//" + node.text;
							}
							node.setParent(parent);
							continue;
						case "#include":
							words = ShaderCompile.splitToWords(text, null);
							var inlcudeFile = ShaderCompile.includes[words[1]];
							if (!inlcudeFile) {
								throw "ShaderCompile error no this include file:" + words[1];
								return;
							}
							if ((ofs = words[0].indexOf("?")) < 0) {
								node.setParent(parent);
								text = inlcudeFile.getWith(words[2] == 'with' ? words[3] : null);
								this._compileToTree(node, text.split('\n'), 0, includefiles, defs);
								node.text = "";
								continue;
							}
							node.setCondition(words[0].substr(ofs + 1), 1);
							node.text = inlcudeFile.getWith(words[2] == 'with' ? words[3] : null);
							break;
						case "#import":
							words = ShaderCompile.splitToWords(text, null);
							fname = words[1];
							includefiles.push({ node: node, file: ShaderCompile.includes[fname], ofs: node.text.length });
							continue;
					}
				} else {
					preNode = parent.childs[parent.childs.length - 1];
					if (preNode && !preNode.name) {
						includefiles.length > 0 && ShaderCompile.splitToWords(text, preNode);
						noUseNode = node;
						preNode.text += "\n" + text;
						continue;
					}
					includefiles.length > 0 && ShaderCompile.splitToWords(text, node);
				}
				node.setParent(parent);
			}
		}

		__proto.createShader = function (define, shaderName, createShader) {
			var defMap = {};
			var defineStr = "";
			if (define) {
				for (var i in define) {
					defineStr += "#define " + i + "\n";
					defMap[i] = true;
				}
			};
			var vs = this._VS.toscript(defMap, []);
			var ps = this._PS.toscript(defMap, []);
			return (createShader || Shader.create)(defineStr + vs.join('\n'), defineStr + ps.join('\n'), shaderName, this._nameMap);
		}

		ShaderCompile._parseOne = function (attributes, uniforms, words, i, word, b) {
			var one = { type: ShaderCompile.shaderParamsMap[words[i + 1]], name: words[i + 2], size: isNaN(parseInt(words[i + 3])) ? 1 : parseInt(words[i + 3]) };
			if (b) {
				if (word == "attribute") {
					attributes.push(one);
				} else {
					uniforms.push(one);
				}
			}
			if (words[i + 3] == ':') {
				one.type = words[i + 4];
				i += 2;
			}
			i += 2;
			return i;
		}

		ShaderCompile.addInclude = function (fileName, txt) {
			if (!txt || txt.length === 0)
				throw new Error("add shader include file err:" + fileName);
			if (ShaderCompile.includes[fileName])
				throw new Error("add shader include file err, has add:" + fileName);
			ShaderCompile.includes[fileName] = new InlcudeFile(txt);
		}

		ShaderCompile.preGetParams = function (vs, ps) {
			var text = [vs, ps];
			var result = {};
			var attributes = [];
			var uniforms = [];
			var definesInfo = {};
			var definesName = [];
			result.attributes = attributes;
			result.uniforms = uniforms;
			result.defines = definesInfo;
			var i = 0, n = 0, one;
			for (var s = 0; s < 2; s++) {
				text[s] = text[s].replace(ShaderCompile._removeAnnotation, "");
				var words = text[s].match(ShaderCompile._reg);
				var tempelse;
				for (i = 0, n = words.length; i < n; i++) {
					var word = words[i];
					if (word != "attribute" && word != "uniform") {
						if (word == "#define") {
							word = words[++i];
							definesName[word] = 1;
							continue;
						} else if (word == "#ifdef") {
							tempelse = words[++i];
							var def = definesInfo[tempelse] = definesInfo[tempelse] || [];
							for (i++; i < n; i++) {
								word = words[i];
								if (word != "attribute" && word != "uniform") {
									if (word == "#else") {
										for (i++; i < n; i++) {
											word = words[i];
											if (word != "attribute" && word != "uniform") {
												if (word == "#endif") {
													break;
												}
												continue;
											}
											i = ShaderCompile._parseOne(attributes, uniforms, words, i, word, !definesName[tempelse]);
										}
									}
									continue;
								}
								i = ShaderCompile._parseOne(attributes, uniforms, words, i, word, definesName[tempelse]);
							}
						}
						continue;
					}
					i = ShaderCompile._parseOne(attributes, uniforms, words, i, word, true);
				}
			}
			return result;
		}

		ShaderCompile.splitToWords = function (str, block) {
			var out = [];
			var c;
			var ofs = -1;
			var word;
			for (var i = 0, n = str.length; i < n; i++) {
				c = str.charAt(i);
				if (" \t=+-*/&%!<>()'\",;".indexOf(c) >= 0) {
					if (ofs >= 0 && (i - ofs) > 1) {
						word = str.substr(ofs, i - ofs);
						out.push(word);
					}
					if (c == '"' || c == "'") {
						var ofs2 = str.indexOf(c, i + 1);
						if (ofs2 < 0) {
							throw "Sharder err:" + str;
						}
						out.push(str.substr(i + 1, ofs2 - i - 1));
						i = ofs2;
						ofs = -1;
						continue;
					}
					if (c == '(' && block && out.length > 0) {
						word = out[out.length - 1] + ";";
						if ("vec4;main;".indexOf(word) < 0)
							block.useFuns += word;
					}
					ofs = -1;
					continue;
				}
				if (ofs < 0) ofs = i;
			}
			if (ofs < n && (n - ofs) > 1) {
				word = str.substr(ofs, n - ofs);
				out.push(word);
			}
			return out;
		}

		ShaderCompile.IFDEF_NO = 0;
		ShaderCompile.IFDEF_YES = 1;
		ShaderCompile.IFDEF_ELSE = 2;
		ShaderCompile.IFDEF_PARENT = 3;
		ShaderCompile._removeAnnotation = new RegExp("(/\\*([^*]|[\\r\\\n]|(\\*+([^*/]|[\\r\\n])))*\\*+/)|(//.*)", "g");
		ShaderCompile._reg = new RegExp("(\".*\")|('.*')|([#\\w\\*-\\.+/()=<>{}\\\\]+)|([,;:\\\\])", "g");
		ShaderCompile._splitToWordExps = new RegExp("[(\".*\")]+|[('.*')]+|([ \\t=\\+\\-*/&%!<>!%\(\),;])", "g");
		ShaderCompile.includes = {};
		__static(ShaderCompile,
			['shaderParamsMap', function () { return this.shaderParamsMap = { "float":/*laya.webgl.WebGLContext.FLOAT*/0x1406, "int":/*laya.webgl.WebGLContext.INT*/0x1404, "bool":/*laya.webgl.WebGLContext.BOOL*/0x8B56, "vec2":/*laya.webgl.WebGLContext.FLOAT_VEC2*/0x8B50, "vec3":/*laya.webgl.WebGLContext.FLOAT_VEC3*/0x8B51, "vec4":/*laya.webgl.WebGLContext.FLOAT_VEC4*/0x8B52, "ivec2":/*laya.webgl.WebGLContext.INT_VEC2*/0x8B53, "ivec3":/*laya.webgl.WebGLContext.INT_VEC3*/0x8B54, "ivec4":/*laya.webgl.WebGLContext.INT_VEC4*/0x8B55, "bvec2":/*laya.webgl.WebGLContext.BOOL_VEC2*/0x8B57, "bvec3":/*laya.webgl.WebGLContext.BOOL_VEC3*/0x8B58, "bvec4":/*laya.webgl.WebGLContext.BOOL_VEC4*/0x8B59, "mat2":/*laya.webgl.WebGLContext.FLOAT_MAT2*/0x8B5A, "mat3":/*laya.webgl.WebGLContext.FLOAT_MAT3*/0x8B5B, "mat4":/*laya.webgl.WebGLContext.FLOAT_MAT4*/0x8B5C, "sampler2D":/*laya.webgl.WebGLContext.SAMPLER_2D*/0x8B5E, "samplerCube":/*laya.webgl.WebGLContext.SAMPLER_CUBE*/0x8B60 }; }, '_splitToWordExps3', function () { return this._splitToWordExps3 = new RegExp("[ \\t=\\+\\-*/&%!<>!%\(\),;\\|]", "g"); }
			]);
		ShaderCompile.__init$ = function () {
			//class ShaderNode
			ShaderNode = (function () {
				function ShaderNode(includefiles) {
					this.childs = [];
					this.text = "";
					this.parent = null;
					this.name = null;
					this.noCompile = false;
					this.includefiles = null;
					this.condition = null;
					this.conditionType = 0;
					this.useFuns = "";
					this.z = 0;
					this.src = null;
					this.includefiles = includefiles;
				}
				__class(ShaderNode, '');
				var __proto = ShaderNode.prototype;
				__proto.setParent = function (parent) {
					parent.childs.push(this);
					this.z = parent.z + 1;
					this.parent = parent;
				}
				__proto.setCondition = function (condition, type) {
					if (condition) {
						this.conditionType = type;
						condition = condition.replace(/(\s*$)/g, "");
						this.condition = function () {
							return this[condition];
						}
						this.condition.__condition = condition;
					}
				}
				__proto.toscript = function (def, out) {
					return this._toscript(def, out, ++ShaderNode.__id);
				}
				__proto._toscript = function (def, out, id) {
					if (this.childs.length < 1 && !this.text) return out;
					var outIndex = out.length;
					if (this.condition) {
						var ifdef = !!this.condition.call(def);
						this.conditionType ===/*laya.webgl.utils.ShaderCompile.IFDEF_ELSE*/2 && (ifdef = !ifdef);
						if (!ifdef) return out;
					}
					this.text && out.push(this.text);
					this.childs.length > 0 && this.childs.forEach(function (o, index, arr) {
						o._toscript(def, out, id);
					});
					if (this.includefiles.length > 0 && this.useFuns.length > 0) {
						var funsCode;
						for (var i = 0, n = this.includefiles.length; i < n; i++) {
							if (this.includefiles[i].curUseID == id) {
								continue;
							}
							funsCode = this.includefiles[i].file.getFunsScript(this.useFuns);
							if (funsCode.length > 0) {
								this.includefiles[i].curUseID = id;
								out[0] = funsCode + out[0];
							}
						}
					}
					return out;
				}
				ShaderNode.__id = 1;
				return ShaderNode;
			})()
			//class InlcudeFile
			InlcudeFile = (function () {
				function InlcudeFile(txt) {
					this.script = null;
					this.codes = {};
					this.funs = {};
					this.curUseID = -1;
					this.funnames = "";
					this.script = txt;
					var begin = 0, ofs = 0, end = 0;
					while (true) {
						begin = txt.indexOf("#begin", begin);
						if (begin < 0) break;
						end = begin + 5;
						while (true) {
							end = txt.indexOf("#end", end);
							if (end < 0) break;
							if (txt.charAt(end + 4) === 'i')
								end += 5;
							else break;
						}
						if (end < 0) {
							throw "add include err,no #end:" + txt;
							return;
						}
						ofs = txt.indexOf('\n', begin);
						var words = ShaderCompile.splitToWords(txt.substr(begin, ofs - begin), null);
						if (words[1] == 'code') {
							this.codes[words[2]] = txt.substr(ofs + 1, end - ofs - 1);
						} else if (words[1] == 'function') {
							ofs = txt.indexOf("function", begin);
							ofs += "function".length;
							this.funs[words[3]] = txt.substr(ofs + 1, end - ofs - 1);
							this.funnames += words[3] + ";";
						}
						begin = end + 1;
					}
				}
				__class(InlcudeFile, '');
				var __proto = InlcudeFile.prototype;
				__proto.getWith = function (name) {
					var r = name ? this.codes[name] : this.script;
					if (!r) {
						throw "get with error:" + name;
					}
					return r;
				}
				__proto.getFunsScript = function (funsdef) {
					var r = "";
					for (var i in this.funs) {
						if (funsdef.indexOf(i + ";") >= 0) {
							r += this.funs[i];
						}
					}
					return r;
				}
				return InlcudeFile;
			})()
		}

		return ShaderCompile;
	})()


	/**
	*@private
	*/
	//class laya.webgl.WebGL
	var WebGL = (function () {
		function WebGL() { }
		__class(WebGL, 'laya.webgl.WebGL');
		WebGL._uint8ArraySlice = function () {
			var _this =/*__JS__ */this;
			var sz = _this.length;
			var dec = new Uint8Array(_this.length);
			for (var i = 0; i < sz; i++)dec[i] = _this[i];
			return dec;
		}

		WebGL._float32ArraySlice = function () {
			var _this =/*__JS__ */this;
			var sz = _this.length;
			var dec = new Float32Array(_this.length);
			for (var i = 0; i < sz; i++)dec[i] = _this[i];
			return dec;
		}

		WebGL._uint16ArraySlice = function (__arg) {
			var arg = arguments;
			var _this =/*__JS__ */this;
			var sz = 0;
			var dec;
			var i = 0;
			if (arg.length === 0) {
				sz = _this.length;
				dec = new Uint16Array(sz);
				for (i = 0; i < sz; i++)
					dec[i] = _this[i];
			} else if (arg.length === 2) {
				var start = arg[0];
				var end = arg[1];
				if (end > start) {
					sz = end - start;
					dec = new Uint16Array(sz);
					for (i = start; i < end; i++)
						dec[i - start] = _this[i];
				} else {
					dec = new Uint16Array(0);
				}
			}
			return dec;
		}

		WebGL.expandContext = function () {
			var from = Context.prototype;
			var to =/*__JS__ */CanvasRenderingContext2D.prototype;
			to.fillTrangles = from.fillTrangles;
			Buffer2D.__int__(null);
			to.setIBVB = function (x, y, ib, vb, numElement, mat, shader, shaderValues, startIndex, offset) {
				(startIndex === void 0) && (startIndex = 0);
				(offset === void 0) && (offset = 0);
				if (ib === null) {
					this._ib = this._ib || IndexBuffer2D.QuadrangleIB;
					ib = this._ib;
					GlUtils.expandIBQuadrangle(ib, (vb._byteLength / (4 * 16) + 8));
				}
				this._setIBVB(x, y, ib, vb, numElement, mat, shader, shaderValues, startIndex, offset);
			};
			to.fillTrangles = function (tex, x, y, points, m) {
				this._curMat = this._curMat || Matrix.create();
				this._vb = this._vb || VertexBuffer2D.create();
				if (!this._ib) {
					this._ib = IndexBuffer2D.create();
					GlUtils.fillIBQuadrangle(this._ib, length / 4);
				};
				var vb = this._vb;
				var length = points.length >> 4;
				GlUtils.fillTranglesVB(vb, x, y, points, m || this._curMat, 0, 0);
				GlUtils.expandIBQuadrangle(this._ib, (vb._byteLength / (4 * 16) + 8));
				var shaderValues = new Value2D(0x01, 0);
				shaderValues.textureHost = tex;
				var sd = new Shader2X("attribute vec2 position; attribute vec2 texcoord; uniform vec2 size; uniform mat4 mmat; varying vec2 v_texcoord; void main() { vec4 p=vec4(position.xy,0.0,1.0);vec4 pos=mmat*p; gl_Position =vec4((pos.x/size.x-0.5)*2.0,(0.5-pos.y/size.y)*2.0,pos.z,1.0); v_texcoord = texcoord; }", "precision mediump float; varying vec2 v_texcoord; uniform sampler2D texture; void main() {vec4 color= texture2D(texture, v_texcoord); color.a*=1.0; gl_FragColor= color;}");
			/*__JS__ */vb._vertType = 3;
				this._setIBVB(x, y, this._ib, vb, length * 6, m, sd, shaderValues, 0, 0);
			}
		}

		WebGL.enable = function () {
			Browser.__init__();
			if (Render.isConchApp) {
				if (!Render.isConchWebGL) {
					RunDriver.skinAniSprite = function () {
						var tSkinSprite = new SkinMesh()
						return tSkinSprite;
					}
					WebGL.expandContext();
					return false;
				}
			}
			RunDriver.getWebGLContext = function getWebGLContext(canvas) {
				var gl;
				var names = ["webgl", "experimental-webgl", "webkit-3d", "moz-webgl"];
				for (var i = 0; i < names.length; i++) {
					try {
						gl = canvas.getContext(names[i], { stencil: Config.isStencil, alpha: Config.isAlpha, antialias: Config.isAntialias, premultipliedAlpha: Config.premultipliedAlpha, preserveDrawingBuffer: Config.preserveDrawingBuffer });
					} catch (e) { }
					if (gl)
						return gl;
				}
				return null;
			}
			WebGL.mainContext = RunDriver.getWebGLContext(Render._mainCanvas);
			if (WebGL.mainContext == null)
				return false;
			if (Render.isWebGL) return true;
			HTMLImage.create = function (src, def) {
				return new WebGLImage(src, def);
			}
			HTMLSubImage.create = function (canvas, offsetX, offsetY, width, height, atlasImage, src) {
				return new WebGLSubImage(canvas, offsetX, offsetY, width, height, atlasImage, src);
			}
			Render.WebGL = WebGL;
			Render.isWebGL = true;
			DrawText.__init__();
			RunDriver.createRenderSprite = function (type, next) {
				return new RenderSprite3D(type, next);
			}
			RunDriver.createWebGLContext2D = function (c) {
				return new WebGLContext2D(c);
			}
			RunDriver.changeWebGLSize = function (width, height) {
				laya.webgl.WebGL.onStageResize(width, height);
			}
			RunDriver.createGraphics = function () {
				return new GraphicsGL();
			};
			var action = RunDriver.createFilterAction;
			RunDriver.createFilterAction = action ? action : function (type) {
				return new ColorFilterActionGL()
			}
			RunDriver.clear = function (color) {
				RenderState2D.worldScissorTest && laya.webgl.WebGL.mainContext.disable(/*laya.webgl.WebGLContext.SCISSOR_TEST*/0x0C11);
				var ctx = Render.context.ctx;
				var c = (ctx._submits._length == 0 || Config.preserveDrawingBuffer) ? Color.create(color)._color : Stage._wgColor;
				if (c) ctx.clearBG(c[0], c[1], c[2], c[3]);
				RenderState2D.clear();
			}
			RunDriver.addToAtlas = function (texture, force) {
				(force === void 0) && (force = false);
				var bitmap = texture.bitmap;
				if (!Render.optimizeTextureMemory(texture.url, texture)) {
					(bitmap).enableMerageInAtlas = false;
					return;
				}
				if ((Laya.__typeof(bitmap, 'laya.webgl.resource.IMergeAtlasBitmap')) && ((bitmap).allowMerageInAtlas)) {
					bitmap.on(/*laya.events.Event.RECOVERED*/"recovered", texture, texture.addTextureToAtlas);
				}
			}
			RunDriver.isAtlas = function (bitmap) {
				return (bitmap instanceof laya.webgl.atlas.AtlasWebGLCanvas);
			}
			AtlasResourceManager._enable();
			RunDriver.beginFlush = function () {
				var atlasResourceManager = AtlasResourceManager.instance;
				var count = atlasResourceManager.getAtlaserCount();
				for (var i = 0; i < count; i++) {
					var atlerCanvas = atlasResourceManager.getAtlaserByIndex(i).texture;
					(atlerCanvas._flashCacheImageNeedFlush) && (RunDriver.flashFlushImage(atlerCanvas));
				}
			}
			RunDriver.drawToCanvas = function (sprite, _renderType, canvasWidth, canvasHeight, offsetX, offsetY) {

				if (canvasWidth <= 0 || canvasHeight <= 0) {
					console.log("[error] canvasWidth and canvasHeight should greater than zero");
				}
				offsetX -= sprite.x;
				offsetY -= sprite.y;
				var renderTarget = RenderTarget2D.create(canvasWidth, canvasHeight,/*laya.webgl.WebGLContext.RGBA*/0x1908,/*laya.webgl.WebGLContext.UNSIGNED_BYTE*/0x1401, 0, false);
				renderTarget.start();
				renderTarget.clear(0, 0, 0, 0);
				Render.context.clear();
				RenderSprite.renders[_renderType]._fun(sprite, Render.context, offsetX, RenderState2D.height - canvasHeight + offsetY);
				Render.context.flush();
				renderTarget.end();

				var pixels = renderTarget.getData(0, 0, renderTarget.width, renderTarget.height);
				renderTarget.recycle();


				var htmlCanvas = new WebGLCanvas();

				htmlCanvas._canvas = Browser.createElement("canvas");
				htmlCanvas.size(canvasWidth, canvasHeight);
				var context = htmlCanvas._canvas.getContext('2d');
				Browser.canvas.size(canvasWidth, canvasHeight);
				var tempContext = Browser.context;
				var imgData = tempContext.createImageData(canvasWidth, canvasHeight);
				imgData.data.set(/*__JS__ */new Uint8ClampedArray(pixels.buffer));

				// alert(tempContext)	

				htmlCanvas._imgData = imgData;


				tempContext.putImageData(imgData, 0, 0);

				context.save();
				context.translate(0, canvasHeight);
				context.scale(1, -1);
				context.drawImage(Browser.canvas.source, 0, 0);
				context.restore();
				return htmlCanvas;
			}
			RunDriver.createFilterAction = function (type) {
				var action;
				switch (type) {
					case /*laya.filters.Filter.COLOR*/0x20:
						action = new ColorFilterActionGL();
						break;
				}
				return action;
			}
			RunDriver.addTextureToAtlas = function (texture) {
				texture._uvID++;
				AtlasResourceManager._atlasRestore++;
				((texture.bitmap).enableMerageInAtlas) && (AtlasResourceManager.instance.addToAtlas(texture));
			}
			RunDriver.getTexturePixels = function (value, x, y, width, height) {
				(Render.context.ctx).clear();
				var tSprite = new Sprite();
				tSprite.graphics.drawTexture(value, -x, -y);
				var tRenderTarget = RenderTarget2D.create(width, height);
				tRenderTarget.start();
				tRenderTarget.clear(0, 0, 0, 0);
				tSprite.render(Render.context, 0, 0);
				(Render.context.ctx).flush();
				tRenderTarget.end();
				var tUint8Array = tRenderTarget.getData(0, 0, width, height);
				var tArray = [];
				var tIndex = 0;
				for (var i = height - 1; i >= 0; i--) {
					for (var j = 0; j < width; j++) {
						tIndex = (i * width + j) * 4;
						tArray.push(tUint8Array[tIndex]);
						tArray.push(tUint8Array[tIndex + 1]);
						tArray.push(tUint8Array[tIndex + 2]);
						tArray.push(tUint8Array[tIndex + 3]);
					}
				}
				return tArray;
			}
			RunDriver.skinAniSprite = function () {
				var tSkinSprite = new SkinMesh()
				return tSkinSprite;
			}
			HTMLCanvas.create = function (type, canvas) {
				var ret = new WebGLCanvas();
				ret._imgData = canvas;
				ret.flipY = false;
				return ret;
			}
			Filter._filterStart = function (scope, sprite, context, x, y) {
				var b = scope.getValue("bounds");
				var source = RenderTarget2D.create(b.width, b.height);
				source.start();
				source.clear(0, 0, 0, 0);
				scope.addValue("src", source);
				scope.addValue("ScissorTest", RenderState2D.worldScissorTest);
				if (RenderState2D.worldScissorTest) {
					var tClilpRect = new Rectangle();
					tClilpRect.copyFrom((context.ctx)._clipRect)
					scope.addValue("clipRect", tClilpRect);
					RenderState2D.worldScissorTest = false;
					laya.webgl.WebGL.mainContext.disable(/*laya.webgl.WebGLContext.SCISSOR_TEST*/0x0C11);
				}
			}
			Filter._filterEnd = function (scope, sprite, context, x, y) {
				var b = scope.getValue("bounds");
				var source = scope.getValue("src");
				source.end();
				var out = RenderTarget2D.create(b.width, b.height);
				out.start();
				out.clear(0, 0, 0, 0);
				scope.addValue("out", out);
				sprite._set$P('_filterCache', out);
				sprite._set$P('_isHaveGlowFilter', scope.getValue("_isHaveGlowFilter"));
			}
			Filter._EndTarget = function (scope, context) {
				var source = scope.getValue("src");
				source.recycle();
				var out = scope.getValue("out");
				out.end();
				var b = scope.getValue("ScissorTest");
				if (b) {
					RenderState2D.worldScissorTest = true;
					laya.webgl.WebGL.mainContext.enable(/*laya.webgl.WebGLContext.SCISSOR_TEST*/0x0C11);
					context.ctx.save();
					var tClipRect = scope.getValue("clipRect");
					(context.ctx).clipRect(tClipRect.x, tClipRect.y, tClipRect.width, tClipRect.height);
				}
			}
			Filter._useSrc = function (scope) {
				var source = scope.getValue("out");
				source.end();
				source = scope.getValue("src");
				source.start();
				source.clear(0, 0, 0, 0);
			}
			Filter._endSrc = function (scope) {
				var source = scope.getValue("src");
				source.end();
			}
			Filter._useOut = function (scope) {
				var source = scope.getValue("src");
				source.end();
				source = scope.getValue("out");
				source.start();
				source.clear(0, 0, 0, 0);
			}
			Filter._endOut = function (scope) {
				var source = scope.getValue("out");
				source.end();
			}
			Filter._recycleScope = function (scope) {
				scope.recycle();
			}
			Filter._filter = function (sprite, context, x, y) {
				var next = this._next;
				if (next) {
					var filters = sprite.filters, len = filters.length;
					if (len == 1 && (filters[0].type ==/*laya.filters.Filter.COLOR*/0x20)) {
						context.ctx.save();
						context.ctx.setFilters([filters[0]]);
						next._fun.call(next, sprite, context, x, y);
						context.ctx.restore();
						return;
					};
					var shaderValue;
					var b;
					var scope = SubmitCMDScope.create();
					var p = Point.TEMP;
					var tMatrix = context.ctx._getTransformMatrix();
					var mat = Matrix.create();
					tMatrix.copyTo(mat);
					var tPadding = 0;
					var tHalfPadding = 0;
					var tIsHaveGlowFilter = false;
					var out = sprite._$P._filterCache ? sprite._$P._filterCache : null;
					if (!out || sprite._repaint) {
						tIsHaveGlowFilter = sprite._isHaveGlowFilter();
						scope.addValue("_isHaveGlowFilter", tIsHaveGlowFilter);
						if (tIsHaveGlowFilter) {
							tPadding = 50;
							tHalfPadding = 25;
						}
						b = new Rectangle();
						b.copyFrom((sprite).getSelfBounds());
						b.x += (sprite).x;
						b.y += (sprite).y;
						b.x -= (sprite).pivotX + 4;
						b.y -= (sprite).pivotY + 4;
						var tSX = b.x;
						var tSY = b.y;
						b.width += (tPadding + 8);
						b.height += (tPadding + 8);
						p.x = b.x * mat.a + b.y * mat.c;
						p.y = b.y * mat.d + b.x * mat.b;
						b.x = p.x;
						b.y = p.y;
						p.x = b.width * mat.a + b.height * mat.c;
						p.y = b.height * mat.d + b.width * mat.b;
						b.width = p.x;
						b.height = p.y;
						if (b.width <= 0 || b.height <= 0) {
							return;
						}
						out && out.recycle();
						scope.addValue("bounds", b);
						var submit = SubmitCMD.create([scope, sprite, context, 0, 0], Filter._filterStart);
						context.addRenderObject(submit);
						(context.ctx)._renderKey = 0;
						(context.ctx)._shader2D.glTexture = null;
						var tX = sprite.x - tSX + tHalfPadding;
						var tY = sprite.y - tSY + tHalfPadding;
						next._fun.call(next, sprite, context, tX, tY);
						submit = SubmitCMD.create([scope, sprite, context, 0, 0], Filter._filterEnd);
						context.addRenderObject(submit);
						for (var i = 0; i < len; i++) {
							if (i != 0) {
								submit = SubmitCMD.create([scope], Filter._useSrc);
								context.addRenderObject(submit);
								shaderValue = Value2D.create(/*laya.webgl.shader.d2.ShaderDefines2D.TEXTURE2D*/0x01, 0);
								Matrix.TEMP.identity();
								context.ctx.drawTarget(scope, 0, 0, b.width, b.height, Matrix.TEMP, "out", shaderValue, null, BlendMode.TOINT.overlay);
								submit = SubmitCMD.create([scope], Filter._useOut);
								context.addRenderObject(submit);
							};
							var fil = filters[i];
							fil.action.apply3d(scope, sprite, context, 0, 0);
						}
						submit = SubmitCMD.create([scope, context], Filter._EndTarget);
						context.addRenderObject(submit);
					} else {
						tIsHaveGlowFilter = sprite._$P._isHaveGlowFilter ? sprite._$P._isHaveGlowFilter : false;
						if (tIsHaveGlowFilter) {
							tPadding = 50;
							tHalfPadding = 25;
						}
						b = sprite.getBounds();
						if (b.width <= 0 || b.height <= 0) {
							return;
						}
						b.width += tPadding;
						b.height += tPadding;
						p.x = b.x * mat.a + b.y * mat.c;
						p.y = b.y * mat.d + b.x * mat.b;
						b.x = p.x;
						b.y = p.y;
						p.x = b.width * mat.a + b.height * mat.c;
						p.y = b.height * mat.d + b.width * mat.b;
						b.width = p.x;
						b.height = p.y;
						scope.addValue("out", out);
					}
					x = x - tHalfPadding - sprite.x;
					y = y - tHalfPadding - sprite.y;
					p.setTo(x, y);
					mat.transformPoint(p);
					x = p.x + b.x;
					y = p.y + b.y;
					shaderValue = Value2D.create(/*laya.webgl.shader.d2.ShaderDefines2D.TEXTURE2D*/0x01, 0);
					Matrix.TEMP.identity();
					(context.ctx).drawTarget(scope, x, y, b.width, b.height, Matrix.TEMP, "out", shaderValue, null, BlendMode.TOINT.overlay);
					submit = SubmitCMD.create([scope], Filter._recycleScope);
					context.addRenderObject(submit);
					mat.destroy();
				}
			}
			Float32Array.prototype.slice || (Float32Array.prototype.slice = WebGL._float32ArraySlice);
			Uint16Array.prototype.slice || (Uint16Array.prototype.slice = WebGL._uint16ArraySlice);
			Uint8Array.prototype.slice || (Uint8Array.prototype.slice = WebGL._uint8ArraySlice);
			return true;
		}

		WebGL.onStageResize = function (width, height) {
			if (WebGL.mainContext == null) return;
			WebGL.mainContext.viewport(0, 0, width, height);
			RenderState2D.width = width;
			RenderState2D.height = height;
		}

		WebGL.onInvalidGLRes = function () {
			AtlasResourceManager.instance.freeAll();
			ResourceManager.releaseContentManagers(true);
			WebGL.doNodeRepaint(Laya.stage);
			WebGL.mainContext.viewport(0, 0, RenderState2D.width, RenderState2D.height);
			Laya.stage.event(/*laya.events.Event.DEVICE_LOST*/"devicelost");
		}

		WebGL.doNodeRepaint = function (sprite) {
			(sprite.numChildren == 0) && (sprite.repaint());
			for (var i = 0; i < sprite.numChildren; i++)
				WebGL.doNodeRepaint(sprite.getChildAt(i));
		}

		WebGL.init = function (canvas, width, height) {
			WebGL.mainCanvas = canvas;
			HTMLCanvas._createContext = function (canvas) {
				return new WebGLContext2D(canvas);
			}
			WebGLCanvas._createContext = function (canvas) {
				return new WebGLContext2D(canvas);
			};
			var gl = laya.webgl.WebGL.mainContext;
			if (gl.getShaderPrecisionFormat != null) {
				var vertexPrecisionFormat = gl.getShaderPrecisionFormat(/*laya.webgl.WebGLContext.VERTEX_SHADER*/0x8B31,/*laya.webgl.WebGLContext.HIGH_FLOAT*/0x8DF2);
				var framePrecisionFormat = gl.getShaderPrecisionFormat(/*laya.webgl.WebGLContext.FRAGMENT_SHADER*/0x8B30,/*laya.webgl.WebGLContext.HIGH_FLOAT*/0x8DF2);
				WebGL.shaderHighPrecision = (vertexPrecisionFormat.precision && framePrecisionFormat.precision) ? true : false;
			} else {
				WebGL.shaderHighPrecision = false;
			}
			WebGL.compressAstc = gl.getExtension("WEBGL_compressed_texture_astc");
			WebGL.compressAtc = gl.getExtension("WEBGL_compressed_texture_atc");
			WebGL.compressEtc = gl.getExtension("WEBGL_compressed_texture_etc");
			WebGL.compressEtc1 = gl.getExtension("WEBGL_compressed_texture_etc1");
			WebGL.compressPvrtc = gl.getExtension("WEBGL_compressed_texture_pvrtc");
			WebGL.compressS3tc = gl.getExtension("WEBGL_compressed_texture_s3tc");
			WebGL.compressS3tc_srgb = gl.getExtension("WEBGL_compressed_texture_s3tc_srgb");
			gl.deleteTexture1 = gl.deleteTexture;
			gl.deleteTexture = function (t) {
				if (t == WebGLContext.curBindTexValue) {
					WebGLContext.curBindTexValue = null;
				}
				gl.deleteTexture1(t);
			}
			WebGL.onStageResize(width, height);
			if (WebGL.mainContext == null)
				throw new Error("webGL getContext err!");
			System.__init__();
			AtlasResourceManager.__init__();
			ShaderDefines2D.__init__();
			Submit.__init__();
			WebGLContext2D.__init__();
			Value2D.__init__();
			Shader2D.__init__();
			Buffer2D.__int__(gl);
			BlendMode._init_(gl);
			if (Render.isConchApp) {
			/*__JS__ */conch.setOnInvalidGLRes(WebGL.onInvalidGLRes);
			}
		}

		WebGL.compressAstc = null;
		WebGL.compressAtc = null;
		WebGL.compressEtc = null;
		WebGL.compressEtc1 = null;
		WebGL.compressPvrtc = null;
		WebGL.compressS3tc = null;
		WebGL.compressS3tc_srgb = null;
		WebGL.mainCanvas = null;
		WebGL.mainContext = null;
		WebGL.antialias = true;
		WebGL.shaderHighPrecision = false;
		WebGL._bg_null = [0, 0, 0, 0];
		return WebGL;
	})()


	//class laya.webgl.WebGLContext
	var WebGLContext = (function () {
		function WebGLContext() { }
		__class(WebGLContext, 'laya.webgl.WebGLContext');
		WebGLContext.UseProgram = function (program) {
			if (WebGLContext._useProgram === program) return false;
			WebGL.mainContext.useProgram(program);
			WebGLContext._useProgram = program;
			return true;
		}

		WebGLContext.setDepthTest = function (gl, value) {
			value !== WebGLContext._depthTest && (WebGLContext._depthTest = value, value ? gl.enable(/*CLASS CONST:laya.webgl.WebGLContext.DEPTH_TEST*/0x0B71) : gl.disable(/*CLASS CONST:laya.webgl.WebGLContext.DEPTH_TEST*/0x0B71));
		}

		WebGLContext.setDepthMask = function (gl, value) {
			value !== WebGLContext._depthMask && (WebGLContext._depthMask = value, gl.depthMask(value));
		}

		WebGLContext.setDepthFunc = function (gl, value) {
			value !== WebGLContext._depthFunc && (WebGLContext._depthFunc = value, gl.depthFunc(value));
		}

		WebGLContext.setBlend = function (gl, value) {
			value !== WebGLContext._blend && (WebGLContext._blend = value, value ? gl.enable(/*CLASS CONST:laya.webgl.WebGLContext.BLEND*/0x0BE2) : gl.disable(/*CLASS CONST:laya.webgl.WebGLContext.BLEND*/0x0BE2));
		}

		WebGLContext.setBlendFunc = function (gl, sFactor, dFactor) {
			(sFactor !== WebGLContext._sFactor || dFactor !== WebGLContext._dFactor) && (WebGLContext._sFactor = sFactor, WebGLContext._dFactor = dFactor, gl.blendFunc(sFactor, dFactor));
		}

		WebGLContext.setCullFace = function (gl, value) {
			value !== WebGLContext._cullFace && (WebGLContext._cullFace = value, value ? gl.enable(/*CLASS CONST:laya.webgl.WebGLContext.CULL_FACE*/0x0B44) : gl.disable(/*CLASS CONST:laya.webgl.WebGLContext.CULL_FACE*/0x0B44));
		}

		WebGLContext.setFrontFace = function (gl, value) {
			value !== WebGLContext._frontFace && (WebGLContext._frontFace = value, gl.frontFace(value));
		}

		WebGLContext.bindTexture = function (gl, target, texture) {
			gl.bindTexture(target, texture);
			WebGLContext.curBindTexTarget = target;
			WebGLContext.curBindTexValue = texture;
		}

		WebGLContext.DEPTH_BUFFER_BIT = 0x00000100;
		WebGLContext.STENCIL_BUFFER_BIT = 0x00000400;
		WebGLContext.COLOR_BUFFER_BIT = 0x00004000;
		WebGLContext.POINTS = 0x0000;
		WebGLContext.LINES = 0x0001;
		WebGLContext.LINE_LOOP = 0x0002;
		WebGLContext.LINE_STRIP = 0x0003;
		WebGLContext.TRIANGLES = 0x0004;
		WebGLContext.TRIANGLE_STRIP = 0x0005;
		WebGLContext.TRIANGLE_FAN = 0x0006;
		WebGLContext.ZERO = 0;
		WebGLContext.ONE = 1;
		WebGLContext.SRC_COLOR = 0x0300;
		WebGLContext.ONE_MINUS_SRC_COLOR = 0x0301;
		WebGLContext.SRC_ALPHA = 0x0302;
		WebGLContext.ONE_MINUS_SRC_ALPHA = 0x0303;
		WebGLContext.DST_ALPHA = 0x0304;
		WebGLContext.ONE_MINUS_DST_ALPHA = 0x0305;
		WebGLContext.DST_COLOR = 0x0306;
		WebGLContext.ONE_MINUS_DST_COLOR = 0x0307;
		WebGLContext.SRC_ALPHA_SATURATE = 0x0308;
		WebGLContext.FUNC_ADD = 0x8006;
		WebGLContext.BLEND_EQUATION = 0x8009;
		WebGLContext.BLEND_EQUATION_RGB = 0x8009;
		WebGLContext.BLEND_EQUATION_ALPHA = 0x883D;
		WebGLContext.FUNC_SUBTRACT = 0x800A;
		WebGLContext.FUNC_REVERSE_SUBTRACT = 0x800B;
		WebGLContext.BLEND_DST_RGB = 0x80C8;
		WebGLContext.BLEND_SRC_RGB = 0x80C9;
		WebGLContext.BLEND_DST_ALPHA = 0x80CA;
		WebGLContext.BLEND_SRC_ALPHA = 0x80CB;
		WebGLContext.CONSTANT_COLOR = 0x8001;
		WebGLContext.ONE_MINUS_CONSTANT_COLOR = 0x8002;
		WebGLContext.CONSTANT_ALPHA = 0x8003;
		WebGLContext.ONE_MINUS_CONSTANT_ALPHA = 0x8004;
		WebGLContext.BLEND_COLOR = 0x8005;
		WebGLContext.ARRAY_BUFFER = 0x8892;
		WebGLContext.ELEMENT_ARRAY_BUFFER = 0x8893;
		WebGLContext.ARRAY_BUFFER_BINDING = 0x8894;
		WebGLContext.ELEMENT_ARRAY_BUFFER_BINDING = 0x8895;
		WebGLContext.STREAM_DRAW = 0x88E0;
		WebGLContext.STATIC_DRAW = 0x88E4;
		WebGLContext.DYNAMIC_DRAW = 0x88E8;
		WebGLContext.BUFFER_SIZE = 0x8764;
		WebGLContext.BUFFER_USAGE = 0x8765;
		WebGLContext.CURRENT_VERTEX_ATTRIB = 0x8626;
		WebGLContext.FRONT = 0x0404;
		WebGLContext.BACK = 0x0405;
		WebGLContext.CULL_FACE = 0x0B44;
		WebGLContext.FRONT_AND_BACK = 0x0408;
		WebGLContext.BLEND = 0x0BE2;
		WebGLContext.DITHER = 0x0BD0;
		WebGLContext.STENCIL_TEST = 0x0B90;
		WebGLContext.DEPTH_TEST = 0x0B71;
		WebGLContext.SCISSOR_TEST = 0x0C11;
		WebGLContext.POLYGON_OFFSET_FILL = 0x8037;
		WebGLContext.SAMPLE_ALPHA_TO_COVERAGE = 0x809E;
		WebGLContext.SAMPLE_COVERAGE = 0x80A0;
		WebGLContext.NO_ERROR = 0;
		WebGLContext.INVALID_ENUM = 0x0500;
		WebGLContext.INVALID_VALUE = 0x0501;
		WebGLContext.INVALID_OPERATION = 0x0502;
		WebGLContext.OUT_OF_MEMORY = 0x0505;
		WebGLContext.CW = 0x0900;
		WebGLContext.CCW = 0x0901;
		WebGLContext.LINE_WIDTH = 0x0B21;
		WebGLContext.ALIASED_POINT_SIZE_RANGE = 0x846D;
		WebGLContext.ALIASED_LINE_WIDTH_RANGE = 0x846E;
		WebGLContext.CULL_FACE_MODE = 0x0B45;
		WebGLContext.FRONT_FACE = 0x0B46;
		WebGLContext.DEPTH_RANGE = 0x0B70;
		WebGLContext.DEPTH_WRITEMASK = 0x0B72;
		WebGLContext.DEPTH_CLEAR_VALUE = 0x0B73;
		WebGLContext.DEPTH_FUNC = 0x0B74;
		WebGLContext.STENCIL_CLEAR_VALUE = 0x0B91;
		WebGLContext.STENCIL_FUNC = 0x0B92;
		WebGLContext.STENCIL_FAIL = 0x0B94;
		WebGLContext.STENCIL_PASS_DEPTH_FAIL = 0x0B95;
		WebGLContext.STENCIL_PASS_DEPTH_PASS = 0x0B96;
		WebGLContext.STENCIL_REF = 0x0B97;
		WebGLContext.STENCIL_VALUE_MASK = 0x0B93;
		WebGLContext.STENCIL_WRITEMASK = 0x0B98;
		WebGLContext.STENCIL_BACK_FUNC = 0x8800;
		WebGLContext.STENCIL_BACK_FAIL = 0x8801;
		WebGLContext.STENCIL_BACK_PASS_DEPTH_FAIL = 0x8802;
		WebGLContext.STENCIL_BACK_PASS_DEPTH_PASS = 0x8803;
		WebGLContext.STENCIL_BACK_REF = 0x8CA3;
		WebGLContext.STENCIL_BACK_VALUE_MASK = 0x8CA4;
		WebGLContext.STENCIL_BACK_WRITEMASK = 0x8CA5;
		WebGLContext.VIEWPORT = 0x0BA2;
		WebGLContext.SCISSOR_BOX = 0x0C10;
		WebGLContext.COLOR_CLEAR_VALUE = 0x0C22;
		WebGLContext.COLOR_WRITEMASK = 0x0C23;
		WebGLContext.UNPACK_ALIGNMENT = 0x0CF5;
		WebGLContext.PACK_ALIGNMENT = 0x0D05;
		WebGLContext.MAX_TEXTURE_SIZE = 0x0D33;
		WebGLContext.MAX_VIEWPORT_DIMS = 0x0D3A;
		WebGLContext.SUBPIXEL_BITS = 0x0D50;
		WebGLContext.RED_BITS = 0x0D52;
		WebGLContext.GREEN_BITS = 0x0D53;
		WebGLContext.BLUE_BITS = 0x0D54;
		WebGLContext.ALPHA_BITS = 0x0D55;
		WebGLContext.DEPTH_BITS = 0x0D56;
		WebGLContext.STENCIL_BITS = 0x0D57;
		WebGLContext.POLYGON_OFFSET_UNITS = 0x2A00;
		WebGLContext.POLYGON_OFFSET_FACTOR = 0x8038;
		WebGLContext.TEXTURE_BINDING_2D = 0x8069;
		WebGLContext.SAMPLE_BUFFERS = 0x80A8;
		WebGLContext.SAMPLES = 0x80A9;
		WebGLContext.SAMPLE_COVERAGE_VALUE = 0x80AA;
		WebGLContext.SAMPLE_COVERAGE_INVERT = 0x80AB;
		WebGLContext.NUM_COMPRESSED_TEXTURE_FORMATS = 0x86A2;
		WebGLContext.COMPRESSED_TEXTURE_FORMATS = 0x86A3;
		WebGLContext.DONT_CARE = 0x1100;
		WebGLContext.FASTEST = 0x1101;
		WebGLContext.NICEST = 0x1102;
		WebGLContext.GENERATE_MIPMAP_HINT = 0x8192;
		WebGLContext.BYTE = 0x1400;
		WebGLContext.UNSIGNED_BYTE = 0x1401;
		WebGLContext.SHORT = 0x1402;
		WebGLContext.UNSIGNED_SHORT = 0x1403;
		WebGLContext.INT = 0x1404;
		WebGLContext.UNSIGNED_INT = 0x1405;
		WebGLContext.FLOAT = 0x1406;
		WebGLContext.DEPTH_COMPONENT = 0x1902;
		WebGLContext.ALPHA = 0x1906;
		WebGLContext.RGB = 0x1907;
		WebGLContext.RGBA = 0x1908;
		WebGLContext.LUMINANCE = 0x1909;
		WebGLContext.LUMINANCE_ALPHA = 0x190A;
		WebGLContext.UNSIGNED_SHORT_4_4_4_4 = 0x8033;
		WebGLContext.UNSIGNED_SHORT_5_5_5_1 = 0x8034;
		WebGLContext.UNSIGNED_SHORT_5_6_5 = 0x8363;
		WebGLContext.FRAGMENT_SHADER = 0x8B30;
		WebGLContext.VERTEX_SHADER = 0x8B31;
		WebGLContext.MAX_VERTEX_ATTRIBS = 0x8869;
		WebGLContext.MAX_VERTEX_UNIFORM_VECTORS = 0x8DFB;
		WebGLContext.MAX_VARYING_VECTORS = 0x8DFC;
		WebGLContext.MAX_COMBINED_TEXTURE_IMAGE_UNITS = 0x8B4D;
		WebGLContext.MAX_VERTEX_TEXTURE_IMAGE_UNITS = 0x8B4C;
		WebGLContext.MAX_TEXTURE_IMAGE_UNITS = 0x8872;
		WebGLContext.MAX_FRAGMENT_UNIFORM_VECTORS = 0x8DFD;
		WebGLContext.SHADER_TYPE = 0x8B4F;
		WebGLContext.DELETE_STATUS = 0x8B80;
		WebGLContext.LINK_STATUS = 0x8B82;
		WebGLContext.VALIDATE_STATUS = 0x8B83;
		WebGLContext.ATTACHED_SHADERS = 0x8B85;
		WebGLContext.ACTIVE_UNIFORMS = 0x8B86;
		WebGLContext.ACTIVE_ATTRIBUTES = 0x8B89;
		WebGLContext.SHADING_LANGUAGE_VERSION = 0x8B8C;
		WebGLContext.CURRENT_PROGRAM = 0x8B8D;
		WebGLContext.NEVER = 0x0200;
		WebGLContext.LESS = 0x0201;
		WebGLContext.EQUAL = 0x0202;
		WebGLContext.LEQUAL = 0x0203;
		WebGLContext.GREATER = 0x0204;
		WebGLContext.NOTEQUAL = 0x0205;
		WebGLContext.GEQUAL = 0x0206;
		WebGLContext.ALWAYS = 0x0207;
		WebGLContext.KEEP = 0x1E00;
		WebGLContext.REPLACE = 0x1E01;
		WebGLContext.INCR = 0x1E02;
		WebGLContext.DECR = 0x1E03;
		WebGLContext.INVERT = 0x150A;
		WebGLContext.INCR_WRAP = 0x8507;
		WebGLContext.DECR_WRAP = 0x8508;
		WebGLContext.VENDOR = 0x1F00;
		WebGLContext.RENDERER = 0x1F01;
		WebGLContext.VERSION = 0x1F02;
		WebGLContext.NEAREST = 0x2600;
		WebGLContext.LINEAR = 0x2601;
		WebGLContext.NEAREST_MIPMAP_NEAREST = 0x2700;
		WebGLContext.LINEAR_MIPMAP_NEAREST = 0x2701;
		WebGLContext.NEAREST_MIPMAP_LINEAR = 0x2702;
		WebGLContext.LINEAR_MIPMAP_LINEAR = 0x2703;
		WebGLContext.TEXTURE_MAG_FILTER = 0x2800;
		WebGLContext.TEXTURE_MIN_FILTER = 0x2801;
		WebGLContext.TEXTURE_WRAP_S = 0x2802;
		WebGLContext.TEXTURE_WRAP_T = 0x2803;
		WebGLContext.TEXTURE_2D = 0x0DE1;
		WebGLContext.TEXTURE = 0x1702;
		WebGLContext.TEXTURE_CUBE_MAP = 0x8513;
		WebGLContext.TEXTURE_BINDING_CUBE_MAP = 0x8514;
		WebGLContext.TEXTURE_CUBE_MAP_POSITIVE_X = 0x8515;
		WebGLContext.TEXTURE_CUBE_MAP_NEGATIVE_X = 0x8516;
		WebGLContext.TEXTURE_CUBE_MAP_POSITIVE_Y = 0x8517;
		WebGLContext.TEXTURE_CUBE_MAP_NEGATIVE_Y = 0x8518;
		WebGLContext.TEXTURE_CUBE_MAP_POSITIVE_Z = 0x8519;
		WebGLContext.TEXTURE_CUBE_MAP_NEGATIVE_Z = 0x851A;
		WebGLContext.MAX_CUBE_MAP_TEXTURE_SIZE = 0x851C;
		WebGLContext.TEXTURE0 = 0x84C0;
		WebGLContext.TEXTURE1 = 0x84C1;
		WebGLContext.TEXTURE2 = 0x84C2;
		WebGLContext.TEXTURE3 = 0x84C3;
		WebGLContext.TEXTURE4 = 0x84C4;
		WebGLContext.TEXTURE5 = 0x84C5;
		WebGLContext.TEXTURE6 = 0x84C6;
		WebGLContext.TEXTURE7 = 0x84C7;
		WebGLContext.TEXTURE8 = 0x84C8;
		WebGLContext.TEXTURE9 = 0x84C9;
		WebGLContext.TEXTURE10 = 0x84CA;
		WebGLContext.TEXTURE11 = 0x84CB;
		WebGLContext.TEXTURE12 = 0x84CC;
		WebGLContext.TEXTURE13 = 0x84CD;
		WebGLContext.TEXTURE14 = 0x84CE;
		WebGLContext.TEXTURE15 = 0x84CF;
		WebGLContext.TEXTURE16 = 0x84D0;
		WebGLContext.TEXTURE17 = 0x84D1;
		WebGLContext.TEXTURE18 = 0x84D2;
		WebGLContext.TEXTURE19 = 0x84D3;
		WebGLContext.TEXTURE20 = 0x84D4;
		WebGLContext.TEXTURE21 = 0x84D5;
		WebGLContext.TEXTURE22 = 0x84D6;
		WebGLContext.TEXTURE23 = 0x84D7;
		WebGLContext.TEXTURE24 = 0x84D8;
		WebGLContext.TEXTURE25 = 0x84D9;
		WebGLContext.TEXTURE26 = 0x84DA;
		WebGLContext.TEXTURE27 = 0x84DB;
		WebGLContext.TEXTURE28 = 0x84DC;
		WebGLContext.TEXTURE29 = 0x84DD;
		WebGLContext.TEXTURE30 = 0x84DE;
		WebGLContext.TEXTURE31 = 0x84DF;
		WebGLContext.ACTIVE_TEXTURE = 0x84E0;
		WebGLContext.REPEAT = 0x2901;
		WebGLContext.CLAMP_TO_EDGE = 0x812F;
		WebGLContext.MIRRORED_REPEAT = 0x8370;
		WebGLContext.FLOAT_VEC2 = 0x8B50;
		WebGLContext.FLOAT_VEC3 = 0x8B51;
		WebGLContext.FLOAT_VEC4 = 0x8B52;
		WebGLContext.INT_VEC2 = 0x8B53;
		WebGLContext.INT_VEC3 = 0x8B54;
		WebGLContext.INT_VEC4 = 0x8B55;
		WebGLContext.BOOL = 0x8B56;
		WebGLContext.BOOL_VEC2 = 0x8B57;
		WebGLContext.BOOL_VEC3 = 0x8B58;
		WebGLContext.BOOL_VEC4 = 0x8B59;
		WebGLContext.FLOAT_MAT2 = 0x8B5A;
		WebGLContext.FLOAT_MAT3 = 0x8B5B;
		WebGLContext.FLOAT_MAT4 = 0x8B5C;
		WebGLContext.SAMPLER_2D = 0x8B5E;
		WebGLContext.SAMPLER_CUBE = 0x8B60;
		WebGLContext.VERTEX_ATTRIB_ARRAY_ENABLED = 0x8622;
		WebGLContext.VERTEX_ATTRIB_ARRAY_SIZE = 0x8623;
		WebGLContext.VERTEX_ATTRIB_ARRAY_STRIDE = 0x8624;
		WebGLContext.VERTEX_ATTRIB_ARRAY_TYPE = 0x8625;
		WebGLContext.VERTEX_ATTRIB_ARRAY_NORMALIZED = 0x886A;
		WebGLContext.VERTEX_ATTRIB_ARRAY_POINTER = 0x8645;
		WebGLContext.VERTEX_ATTRIB_ARRAY_BUFFER_BINDING = 0x889F;
		WebGLContext.COMPILE_STATUS = 0x8B81;
		WebGLContext.LOW_FLOAT = 0x8DF0;
		WebGLContext.MEDIUM_FLOAT = 0x8DF1;
		WebGLContext.HIGH_FLOAT = 0x8DF2;
		WebGLContext.LOW_INT = 0x8DF3;
		WebGLContext.MEDIUM_INT = 0x8DF4;
		WebGLContext.HIGH_INT = 0x8DF5;
		WebGLContext.FRAMEBUFFER = 0x8D40;
		WebGLContext.RENDERBUFFER = 0x8D41;
		WebGLContext.RGBA4 = 0x8056;
		WebGLContext.RGB5_A1 = 0x8057;
		WebGLContext.RGB565 = 0x8D62;
		WebGLContext.DEPTH_COMPONENT16 = 0x81A5;
		WebGLContext.STENCIL_INDEX = 0x1901;
		WebGLContext.STENCIL_INDEX8 = 0x8D48;
		WebGLContext.DEPTH_STENCIL = 0x84F9;
		WebGLContext.RENDERBUFFER_WIDTH = 0x8D42;
		WebGLContext.RENDERBUFFER_HEIGHT = 0x8D43;
		WebGLContext.RENDERBUFFER_INTERNAL_FORMAT = 0x8D44;
		WebGLContext.RENDERBUFFER_RED_SIZE = 0x8D50;
		WebGLContext.RENDERBUFFER_GREEN_SIZE = 0x8D51;
		WebGLContext.RENDERBUFFER_BLUE_SIZE = 0x8D52;
		WebGLContext.RENDERBUFFER_ALPHA_SIZE = 0x8D53;
		WebGLContext.RENDERBUFFER_DEPTH_SIZE = 0x8D54;
		WebGLContext.RENDERBUFFER_STENCIL_SIZE = 0x8D55;
		WebGLContext.FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE = 0x8CD0;
		WebGLContext.FRAMEBUFFER_ATTACHMENT_OBJECT_NAME = 0x8CD1;
		WebGLContext.FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL = 0x8CD2;
		WebGLContext.FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE = 0x8CD3;
		WebGLContext.COLOR_ATTACHMENT0 = 0x8CE0;
		WebGLContext.DEPTH_ATTACHMENT = 0x8D00;
		WebGLContext.STENCIL_ATTACHMENT = 0x8D20;
		WebGLContext.DEPTH_STENCIL_ATTACHMENT = 0x821A;
		WebGLContext.NONE = 0;
		WebGLContext.FRAMEBUFFER_COMPLETE = 0x8CD5;
		WebGLContext.FRAMEBUFFER_INCOMPLETE_ATTACHMENT = 0x8CD6;
		WebGLContext.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT = 0x8CD7;
		WebGLContext.FRAMEBUFFER_INCOMPLETE_DIMENSIONS = 0x8CD9;
		WebGLContext.FRAMEBUFFER_UNSUPPORTED = 0x8CDD;
		WebGLContext.FRAMEBUFFER_BINDING = 0x8CA6;
		WebGLContext.RENDERBUFFER_BINDING = 0x8CA7;
		WebGLContext.MAX_RENDERBUFFER_SIZE = 0x84E8;
		WebGLContext.INVALID_FRAMEBUFFER_OPERATION = 0x0506;
		WebGLContext.UNPACK_FLIP_Y_WEBGL = 0x9240;
		WebGLContext.UNPACK_PREMULTIPLY_ALPHA_WEBGL = 0x9241;
		WebGLContext.CONTEXT_LOST_WEBGL = 0x9242;
		WebGLContext.UNPACK_COLORSPACE_CONVERSION_WEBGL = 0x9243;
		WebGLContext.BROWSER_DEFAULT_WEBGL = 0x9244;
		WebGLContext._useProgram = null;
		WebGLContext._depthTest = true;
		WebGLContext._depthMask = true;
		WebGLContext._blend = false;
		WebGLContext._cullFace = false;
		WebGLContext.curBindTexTarget = null;
		WebGLContext.curBindTexValue = null;
		__static(WebGLContext,
			['_depthFunc', function () { return this._depthFunc =/*CLASS CONST:laya.webgl.WebGLContext.LESS*/0x0201; }, '_sFactor', function () { return this._sFactor =/*CLASS CONST:laya.webgl.WebGLContext.ONE*/1; }, '_dFactor', function () { return this._dFactor =/*CLASS CONST:laya.webgl.WebGLContext.ZERO*/0; }, '_frontFace', function () { return this._frontFace =/*CLASS CONST:laya.webgl.WebGLContext.CCW*/0x0901; }
			]);
		return WebGLContext;
	})()


	//class laya.webgl.display.GraphicsGL extends laya.display.Graphics
	var GraphicsGL = (function (_super) {
		function GraphicsGL() {
			GraphicsGL.__super.call(this);
		}

		__class(GraphicsGL, 'laya.webgl.display.GraphicsGL', _super);
		var __proto = GraphicsGL.prototype;
		__proto.setShader = function (shader) {
			this._saveToCmd(Render.context._setShader, [shader]);
		}

		__proto.setIBVB = function (x, y, ib, vb, numElement, shader) {
			this._saveToCmd(Render.context._setIBVB, [x, y, ib, vb, numElement, shader]);
		}

		__proto.drawParticle = function (x, y, ps) {
			var pt = RunDriver.createParticleTemplate2D(ps);
			pt.x = x;
			pt.y = y;
			this._saveToCmd(Render.context._drawParticle, [pt]);
		}

		return GraphicsGL;
	})(Graphics)


	//class laya.webgl.canvas.WebGLContext2D extends laya.resource.Context
	var WebGLContext2D = (function (_super) {
		var ContextParams;
		function WebGLContext2D(c) {
			this._x = 0;
			this._y = 0;
			this._id = ++WebGLContext2D._COUNT;
			//this._other=null;
			this._path = null;
			//this._primitiveValue2D=null;
			this._drawCount = 1;
			this._maxNumEle = 0;
			this._clear = false;
			this._isMain = false;
			this._atlasResourceChange = 0;
			this._submits = null;
			this._curSubmit = null;
			this._ib = null;
			this._vb = null;
			//this._curMat=null;
			this._nBlendType = 0;
			//this._save=null;
			//this._targets=null;
			//this._renderKey=NaN;
			this._saveMark = null;
			this._shader2D = null;
			//this._triangleMesh=null;
			//drawTriangles专用mesh。由于ib不固定，所以不能与_mesh通用
			this.meshlist = [];
			/**所cacheAs精灵*/
			//this.sprite=null;
			/*******************************************start矢量绘制***************************************************/
			this.mId = -1;
			this.mHaveKey = false;
			this.mHaveLineKey = false;
			this.mX = 0;
			this.mY = 0;
			WebGLContext2D.__super.call(this);
			this._width = 99999999;
			this._height = 99999999;
			this._clipRect = WebGLContext2D.MAXCLIPRECT;
			this.mOutPoint
			this._canvas = c;
			WebGLContext2D._contextcount++;
			if (Render.isFlash) {
				this._ib = IndexBuffer2D.create(/*laya.webgl.WebGLContext.STATIC_DRAW*/0x88E4);
				GlUtils.fillIBQuadrangle(this._ib, 16);
			} else
				this._ib = IndexBuffer2D.QuadrangleIB;
			this.clear();
		}

		__class(WebGLContext2D, 'laya.webgl.canvas.WebGLContext2D', _super);
		var __proto = WebGLContext2D.prototype;
		__proto.setIsMainContext = function () {
			this._isMain = true;
		}

		__proto.clearBG = function (r, g, b, a) {
			var gl = WebGL.mainContext;
			gl.clearColor(r, g, b, a);
			gl.clear(/*laya.webgl.WebGLContext.COLOR_BUFFER_BIT*/0x00004000);
		}

		__proto._getSubmits = function () {
			return this._submits;
		}

		__proto._releaseMem = function () {
			if (!this._submits)
				return;
			this._curMat.destroy();
			this._curMat = null;
			this._shader2D.destroy();
			this._shader2D = null;
			for (var i = 0, n = this._submits._length; i < n; i++)
				this._submits[i].releaseRender();
			this._submits.length = 0;
			this._submits._length = 0;
			this._submits = null;
			this._curSubmit = null;
			this._path && this._path.recover();
			this._path = null;
			this._other && (this._other.font = null);
			this._save = null;
			if (this._vb) {
				this._vb.releaseResource();
				this._vb.destroy();
				this._vb.destory();
				this._vb = null;
			}
		}

		__proto.destroy = function () {
			--WebGLContext2D._contextcount;
			this.sprite = null;
			this._releaseMem();
			this._targets && this._targets.destroy();
			this._targets = null;
			this._canvas = null;
			this._ib && (this._ib != IndexBuffer2D.QuadrangleIB) && this._ib.releaseResource();
		}

		__proto.clear = function () {
			if (!this._submits) {
				this._other = ContextParams.DEFAULT;
				this._curMat = Matrix.create();
				this._vb = VertexBuffer2D.create(-1);
				this._submits = [];
				this._save = [SaveMark.Create(this)];
				this._save.length = 10;
				this._shader2D = new Shader2D();
				this._triangleMesh = MeshTexture.getAMesh();
			}
			this._vb.clear();
			this._targets && (this._targets.repaint = true);
			this._other = ContextParams.DEFAULT;
			this._clear = true;
			this._repaint = false;
			this._drawCount = 1;
			this._renderKey = 0;
			this._other.lineWidth = this._shader2D.ALPHA = 1.0;
			this._nBlendType = 0;
			this._clipRect = WebGLContext2D.MAXCLIPRECT;
			this._curSubmit = Submit.RENDERBASE;
			this._shader2D.glTexture = null;
			this._shader2D.fillStyle = this._shader2D.strokeStyle = DrawStyle.DEFAULT;
			for (var i = 0, n = this._submits._length; i < n; i++)
				this._submits[i].releaseRender();
			this._submits._length = 0;
			this._curMat.identity();
			this._other.clear();
			this._saveMark = this._save[0];
			this._save._length = 1;
		}

		__proto.size = function (w, h) {
			if (this._width != w || this._height != h) {
				if (w == 0 || h == 0) {
					if (this._vb._byteLength != 0) {
						this._width = w;
						this._height = h;
						this._vb.clear();
						this._vb.upload();
					}
					for (var i = 0, n = this._submits._length; i < n; i++)
						this._submits[i].releaseRender();
					this._submits.length = 0;
					this._submits._length = 0;
					this._curSubmit = null;
					this._path && this._path.recover();
					this._path = null;
					this.sprite = null;
					this._targets && (this._targets.destroy());
					this._targets = null;
				} else {
					this._width = w;
					this._height = h;
					this._targets && (this._targets.size(w, h));
					this._canvas.memorySize -= this._canvas.memorySize;
				}
			}
			if (w === 0 && h === 0) this._releaseMem();
		}

		__proto._getTransformMatrix = function () {
			return this._curMat;
		}

		__proto.translate = function (x, y) {
			if (x !== 0 || y !== 0) {
				SaveTranslate.save(this);
				if (this._curMat.bTransform) {
					SaveTransform.save(this);
					this._curMat.transformPointN(Point.TEMP.setTo(x, y));
					x = Point.TEMP.x;
					y = Point.TEMP.y;
				}
				this._x += x;
				this._y += y;
			}
		}

		__proto.save = function () {
			this._save[this._save._length++] = SaveMark.Create(this);
		}

		__proto.restore = function () {
			var sz = this._save._length;
			if (sz < 1)
				return;
			for (var i = sz - 1; i >= 0; i--) {
				var o = this._save[i];
				o.restore(this);
				if (o.isSaveMark()) {
					this._save._length = i;
					return;
				}
			}
		}

		__proto._fillText = function (txt, words, x, y, fontStr, color, strokeColor, lineWidth, textAlign, underLine) {
			(underLine === void 0) && (underLine = 0);
			var shader = this._shader2D;
			var curShader = this._curSubmit.shaderValue;
			var font = fontStr ? FontInContext.create(fontStr) : this._other.font;
			if (AtlasResourceManager.enabled) {
				if (shader.ALPHA !== curShader.ALPHA)
					shader.glTexture = null;
				DrawText.drawText(this, txt, words, this._curMat, font, textAlign || this._other.textAlign, color, strokeColor, lineWidth, x, y, underLine);
			} else {
				var preDef = this._shader2D.defines.getValue();
				var colorAdd = color ? Color.create(color)._color : shader.colorAdd;
				if (shader.ALPHA !== curShader.ALPHA || colorAdd !== shader.colorAdd || curShader.colorAdd !== shader.colorAdd) {
					shader.glTexture = null;
					shader.colorAdd = colorAdd;
				}
				DrawText.drawText(this, txt, words, this._curMat, font, textAlign || this._other.textAlign, color, strokeColor, lineWidth, x, y, underLine);
			}
		}

		//TODO:实现下划线
		__proto.fillWords = function (words, x, y, fontStr, color, underLine) {
			this._fillText(null, words, x, y, fontStr, color, null, -1, null, underLine);
		}

		__proto.fillBorderWords = function (words, x, y, font, color, borderColor, lineWidth) {
			this._fillBorderText(null, words, x, y, font, color, borderColor, lineWidth, null);
		}

		__proto.fillText = function (txt, x, y, fontStr, color, textAlign) {
			this._fillText(txt, null, x, y, fontStr, color, null, -1, textAlign);
		}

		__proto.strokeText = function (txt, x, y, fontStr, color, lineWidth, textAlign) {
			this._fillText(txt, null, x, y, fontStr, null, color, lineWidth || 1, textAlign);
		}

		__proto.fillBorderText = function (txt, x, y, fontStr, fillColor, borderColor, lineWidth, textAlign) {
			this._fillBorderText(txt, null, x, y, fontStr, fillColor, borderColor, lineWidth, textAlign);
		}

		__proto._fillBorderText = function (txt, words, x, y, fontStr, fillColor, borderColor, lineWidth, textAlign) {
			if (!AtlasResourceManager.enabled) {
				this._fillText(txt, words, x, y, fontStr, null, borderColor, lineWidth || 1, textAlign);
				this._fillText(txt, words, x, y, fontStr, fillColor, null, -1, textAlign);
				return;
			};
			var shader = this._shader2D;
			var curShader = this._curSubmit.shaderValue;
			if (shader.ALPHA !== curShader.ALPHA)
				shader.glTexture = null;
			var font = fontStr ? (WebGLContext2D._fontTemp.setFont(fontStr), WebGLContext2D._fontTemp) : this._other.font;
			DrawText.drawText(this, txt, words, this._curMat, font, textAlign || this._other.textAlign, fillColor, borderColor, lineWidth || 1, x, y, 0);
		}

		__proto.fillRect = function (x, y, width, height, fillStyle) {
			var vb = this._vb;
			if (GlUtils.fillRectImgVb(vb, this._clipRect, x, y, width, height, Texture.DEF_UV, this._curMat, this._x, this._y, 0, 0)) {
				this._renderKey = 0;
				var pre = this._shader2D.fillStyle;
				fillStyle && (this._shader2D.fillStyle = DrawStyle.create(fillStyle));
				var shader = this._shader2D;
				var curShader = this._curSubmit.shaderValue;
				if (shader.fillStyle !== curShader.fillStyle || shader.ALPHA !== curShader.ALPHA) {
					shader.glTexture = null;
					var submit = this._curSubmit = Submit.createSubmit(this, this._ib, vb, ((vb._byteLength - 16 */*laya.webgl.utils.Buffer2D.FLOAT32*/4) / 32) * 3, Value2D.create(/*laya.webgl.shader.d2.ShaderDefines2D.COLOR2D*/0x02, 0));
					submit.shaderValue.color = shader.fillStyle._color._color;
					submit.shaderValue.ALPHA = shader.ALPHA;
					this._submits[this._submits._length++] = submit;
				}
				this._curSubmit._numEle += 6;
				this._shader2D.fillStyle = pre;
			}
		}

		__proto.fillTexture = function (texture, x, y, width, height, type, offset, other) {
			if (!(texture.loaded && texture.bitmap && texture.source)) {
				if (this.sprite) {
					Laya.timer.callLater(this, this._repaintSprite);
				}
				return;
			};
			var vb = this._vb;
			var w = texture.bitmap.width, h = texture.bitmap.height, uv = texture.uv;
			var ox = offset.x % texture.width, oy = offset.y % texture.height;
			if (w != other.w || h != other.h) {
				if (!other.w && !other.h) {
					other.oy = other.ox = 0;
					switch (type) {
						case "repeat":
							other.width = width;
							other.height = height;
							break;
						case "no-repeat":
							other.width = w;
							other.height = h;
							break;
						case "repeat-x":
							other.width = width;
							if (oy < 0) {
								if (texture.height + oy > height) {
									other.height = height;
								} else {
									other.height = texture.height + oy;
								}
							} else {
								other.oy = oy;
								if (texture.height + oy > height) {
									other.height = height - oy;
								} else {
									other.height = texture.height;
								}
							}
							break;
						case "repeat-y":
							if (ox < 0) {
								if (texture.width + ox > width) {
									other.width = width;
								} else {
									other.width = texture.width + ox;
								}
							} else {
								other.ox = ox;
								if (texture.width + ox > width) {
									other.width = width - ox;
								} else {
									other.width = texture.width;
								}
							}
							other.height = height;
							break;
						default:
							other.width = width;
							other.height = height;
							break;
					}
				}
				other.w = w;
				other.h = h;
				other.uv = [0, 0, other.width / w, 0, other.width / w, other.height / h, 0, other.height / h];
			}
			x += other.ox;
			y += other.oy;
			ox -= other.ox;
			oy -= other.oy;
			if (GlUtils.fillRectImgVb(vb, this._clipRect, x, y, other.width, other.height, other.uv, this._curMat, this._x, this._y, 0, 0)) {
				this._renderKey = 0;
				var submit = SubmitTexture.create(this, this._ib, vb, ((vb._byteLength - 16 */*laya.webgl.utils.Buffer2D.FLOAT32*/4) / 32) * 3, Value2D.create(/*laya.webgl.shader.d2.ShaderDefines2D.FILLTEXTURE*/0x100, 0));
				this._submits[this._submits._length++] = submit;
				var shaderValue = submit.shaderValue;
				shaderValue.textureHost = texture;
				var tTextureX = uv[0] * w;
				var tTextureY = uv[1] * h;
				var tTextureW = (uv[2] - uv[0]) * w;
				var tTextureH = (uv[5] - uv[3]) * h;
				var tx = -ox / w;
				var ty = -oy / h;
				shaderValue.u_TexRange[0] = tTextureX / w;
				shaderValue.u_TexRange[1] = tTextureW / w;
				shaderValue.u_TexRange[2] = tTextureY / h;
				shaderValue.u_TexRange[3] = tTextureH / h;
				shaderValue.u_offset[0] = tx;
				shaderValue.u_offset[1] = ty;
				if (AtlasResourceManager.enabled && !this._isMain)
					submit.addTexture(texture, (vb._byteLength >> 2) -/*CLASS CONST:laya.webgl.canvas.WebGLContext2D._RECTVBSIZE*/16);
				this._curSubmit = submit;
				submit._renderType =/*laya.webgl.submit.Submit.TYPE_FILLTEXTURE*/10017;
				submit._numEle += 6;
			}
		}

		__proto.setShader = function (shader) {
			SaveBase.save(this,/*laya.webgl.canvas.save.SaveBase.TYPE_SHADER*/0x100000, this._shader2D, true);
			this._shader2D.shader = shader;
		}

		__proto.setFilters = function (value) {
			SaveBase.save(this,/*laya.webgl.canvas.save.SaveBase.TYPE_FILTERS*/0x200000, this._shader2D, true);
			this._shader2D.filters = value;
			this._curSubmit = Submit.RENDERBASE;
			this._renderKey = 0;
			this._drawCount++;
		}

		__proto.drawTexture = function (tex, x, y, width, height, tx, ty) {
			this._drawTextureM(tex, x, y, width, height, tx, ty, null, 1);
		}

		__proto.addTextureVb = function (invb, x, y) {
			var finalVB = this._curSubmit._vb || this._vb;
			var vpos = (finalVB._byteLength >> 2);
			finalVB.byteLength = ((vpos +/*CLASS CONST:laya.webgl.canvas.WebGLContext2D._RECTVBSIZE*/16) << 2);
			var vbdata = finalVB.getFloat32Array();
			for (var i = 0, ci = 0; i < 16; i += 4) {
				vbdata[vpos++] = invb[i] + x;
				vbdata[vpos++] = invb[i + 1] + y;
				vbdata[vpos++] = invb[i + 2];
				vbdata[vpos++] = invb[i + 3];
			}
			this._curSubmit._numEle += 6;
			this._maxNumEle = Math.max(this._maxNumEle, this._curSubmit._numEle);
			finalVB._upload = true;
		}

		__proto.willDrawTexture = function (tex, alpha) {
			if (!(tex.loaded && tex.bitmap && tex.source)) {
				if (this.sprite) {
					Laya.timer.callLater(this, this._repaintSprite);
				}
				return 0;
			};
			var webGLImg = tex.bitmap;
			var rid = webGLImg.id + this._shader2D.ALPHA * alpha +/*laya.webgl.submit.Submit.TYPE_TEXTURE*/10016;
			if (rid == this._renderKey) return rid;
			var shader = this._shader2D;
			var preAlpha = shader.ALPHA;
			var curShader = this._curSubmit.shaderValue;
			shader.ALPHA *= alpha;
			this._renderKey = rid;
			this._drawCount++;
			shader.glTexture = webGLImg;
			var vb = this._vb;
			var submit = null;
			var vbSize = (vb._byteLength / 32) * 3;
			submit = SubmitTexture.create(this, this._ib, vb, vbSize, Value2D.create(/*laya.webgl.shader.d2.ShaderDefines2D.TEXTURE2D*/0x01, 0));
			this._submits[this._submits._length++] = submit;
			submit.shaderValue.textureHost = tex;
			submit._renderType =/*laya.webgl.submit.Submit.TYPE_TEXTURE*/10016;
			submit._preIsSameTextureShader = this._curSubmit._renderType ===/*laya.webgl.submit.Submit.TYPE_TEXTURE*/10016 && shader.ALPHA === curShader.ALPHA;
			this._curSubmit = submit;
			shader.ALPHA = preAlpha;
			return rid;
		}

		__proto.drawTextures = function (tex, pos, tx, ty) {
			if (!(tex.loaded && tex.bitmap && tex.source)) {
				this.sprite && Laya.timer.callLater(this, this._repaintSprite);
				return;
			};
			var pre = this._clipRect;
			this._clipRect = WebGLContext2D.MAXCLIPRECT;
			if (!this._drawTextureM(tex, pos[0], pos[1], tex.width, tex.height, tx, ty, null, 1)) {
				alert("drawTextures err");
				return;
			}
			this._clipRect = pre;
			Stat.drawCall++;
			if (pos.length < 4)
				return;
			var finalVB = this._curSubmit._vb || this._vb;
			var sx = this._curMat.a, sy = this._curMat.d;
			for (var i = 2, sz = pos.length; i < sz; i += 2) {
				GlUtils.copyPreImgVb(finalVB, (pos[i] - pos[i - 2]) * sx, (pos[i + 1] - pos[i - 1]) * sy);
				this._curSubmit._numEle += 6;
			}
			this._maxNumEle = Math.max(this._maxNumEle, this._curSubmit._numEle);
		}

		__proto._drawTextureM = function (tex, x, y, width, height, tx, ty, m, alpha) {
			if (!(tex.loaded && tex.source)) {
				if (this.sprite) {
					Laya.timer.callLater(this, this._repaintSprite);
				}
				return false;
			};
			var finalVB = this._curSubmit._vb || this._vb;
			var webGLImg = tex.bitmap;
			x += tx;
			y += ty;
			this._drawCount++;
			var rid = webGLImg.id + this._shader2D.ALPHA * alpha +/*laya.webgl.submit.Submit.TYPE_TEXTURE*/10016;
			if (rid != this._renderKey) {
				this._renderKey = rid;
				var curShader = this._curSubmit.shaderValue;
				var shader = this._shader2D;
				var alphaBack = shader.ALPHA;
				shader.ALPHA *= alpha;
				shader.glTexture = webGLImg;
				var vb = this._vb;
				var submit = null;
				var vbSize = (vb._byteLength / 32) * 3;
				submit = SubmitTexture.create(this, this._ib, vb, vbSize, Value2D.create(/*laya.webgl.shader.d2.ShaderDefines2D.TEXTURE2D*/0x01, 0));
				this._submits[this._submits._length++] = submit;
				submit.shaderValue.textureHost = tex;
				submit._renderType =/*laya.webgl.submit.Submit.TYPE_TEXTURE*/10016;
				submit._preIsSameTextureShader = this._curSubmit._renderType ===/*laya.webgl.submit.Submit.TYPE_TEXTURE*/10016 && shader.ALPHA === curShader.ALPHA;
				this._curSubmit = submit;
				finalVB = this._curSubmit._vb || this._vb;
				shader.ALPHA = alphaBack;
			}
			if (GlUtils.fillRectImgVb(finalVB, this._clipRect, x, y, width || tex.width, height || tex.height, tex.uv, m || this._curMat, this._x, this._y, 0, 0)) {
				if (AtlasResourceManager.enabled && !this._isMain)
					(this._curSubmit).addTexture(tex, (finalVB._byteLength >> 2) -/*CLASS CONST:laya.webgl.canvas.WebGLContext2D._RECTVBSIZE*/16);
				this._curSubmit._numEle += 6;
				this._maxNumEle = Math.max(this._maxNumEle, this._curSubmit._numEle);
				return true;
			}
			return false;
		}

		__proto._repaintSprite = function () {
			if (this.sprite)
				this.sprite.repaint();
		}

		//}
		__proto._drawText = function (tex, x, y, width, height, m, tx, ty, dx, dy) {
			var webGLImg = tex.bitmap;
			this._drawCount++;
			var rid = webGLImg.id + this._shader2D.ALPHA +/*laya.webgl.submit.Submit.TYPE_TEXTURE*/10016;
			if (rid != this._renderKey) {
				this._renderKey = rid;
				var curShader = this._curSubmit.shaderValue;
				var shader = this._shader2D;
				shader.glTexture = webGLImg;
				var vb = this._vb;
				var submit = null;
				var submitID = NaN;
				var vbSize = (vb._byteLength / 32) * 3;
				if (AtlasResourceManager.enabled) {
					submit = SubmitTexture.create(this, this._ib, vb, vbSize, Value2D.create(/*laya.webgl.shader.d2.ShaderDefines2D.TEXTURE2D*/0x01, 0));
				} else {
					submit = SubmitTexture.create(this, this._ib, vb, vbSize, TextSV.create());
				}
				submit._preIsSameTextureShader = this._curSubmit._renderType ===/*laya.webgl.submit.Submit.TYPE_TEXTURE*/10016 && shader.ALPHA === curShader.ALPHA;
				this._submits[this._submits._length++] = submit;
				submit.shaderValue.textureHost = tex;
				submit._renderType =/*laya.webgl.submit.Submit.TYPE_TEXTURE*/10016;
				this._curSubmit = submit;
			}
			tex.active();
			var finalVB = this._curSubmit._vb || this._vb;
			if (GlUtils.fillRectImgVb(finalVB, this._clipRect, x + tx, y + ty, width || tex.width, height || tex.height, tex.uv, m || this._curMat, this._x, this._y, dx, dy, true)) {
				if (AtlasResourceManager.enabled && !this._isMain) {
					(this._curSubmit).addTexture(tex, (finalVB._byteLength >> 2) -/*CLASS CONST:laya.webgl.canvas.WebGLContext2D._RECTVBSIZE*/16);
				}
				this._curSubmit._numEle += 6;
				this._maxNumEle = Math.max(this._maxNumEle, this._curSubmit._numEle);
			}
		}

		__proto.drawTextureWithTransform = function (tex, x, y, width, height, transform, tx, ty, alpha) {
			if (!transform) {
				this._drawTextureM(tex, x, y, width, height, tx, ty, null, alpha);
				return;
			};
			var curMat = this._curMat;
			var prex = this._x;
			var prey = this._y;
			(tx !== 0 || ty !== 0) && (this._x = tx * curMat.a + ty * curMat.c, this._y = ty * curMat.d + tx * curMat.b);
			if (transform && curMat.bTransform) {
				Matrix.mul(transform, curMat, WebGLContext2D._tmpMatrix);
				transform = WebGLContext2D._tmpMatrix;
				transform._checkTransform();
			} else {
				this._x += curMat.tx;
				this._y += curMat.ty;
			}
			this._drawTextureM(tex, x, y, width, height, 0, 0, transform, alpha);
			this._x = prex;
			this._y = prey;
		}

		__proto.fillQuadrangle = function (tex, x, y, point4, m) {
			var submit = this._curSubmit;
			var vb = this._vb;
			var shader = this._shader2D;
			var curShader = submit.shaderValue;
			this._renderKey = 0;
			if (tex.bitmap) {
				var t_tex = tex.bitmap;
				if (shader.glTexture != t_tex || shader.ALPHA !== curShader.ALPHA) {
					shader.glTexture = t_tex;
					submit = this._curSubmit = Submit.createSubmit(this, this._ib, vb, ((vb._byteLength) / 32) * 3, Value2D.create(/*laya.webgl.shader.d2.ShaderDefines2D.TEXTURE2D*/0x01, 0));
					submit.shaderValue.glTexture = t_tex;
					this._submits[this._submits._length++] = submit;
				}
				GlUtils.fillQuadrangleImgVb(vb, x, y, point4, tex.uv, m || this._curMat, this._x, this._y);
			} else {
				if (!submit.shaderValue.fillStyle || !submit.shaderValue.fillStyle.equal(tex) || shader.ALPHA !== curShader.ALPHA) {
					shader.glTexture = null;
					submit = this._curSubmit = Submit.createSubmit(this, this._ib, vb, ((vb._byteLength) / 32) * 3, Value2D.create(/*laya.webgl.shader.d2.ShaderDefines2D.COLOR2D*/0x02, 0));
					submit.shaderValue.defines.add(/*laya.webgl.shader.d2.ShaderDefines2D.COLOR2D*/0x02);
					submit.shaderValue.fillStyle = DrawStyle.create(tex);
					this._submits[this._submits._length++] = submit;
				}
				GlUtils.fillQuadrangleImgVb(vb, x, y, point4, Texture.DEF_UV, m || this._curMat, this._x, this._y);
			}
			submit._numEle += 6;
		}

		__proto.drawTexture2 = function (x, y, pivotX, pivotY, transform, alpha, blendMode, args) {
			if (alpha == 0) return;
			var curMat = this._curMat;
			this._x = x * curMat.a + y * curMat.c;
			this._y = y * curMat.d + x * curMat.b;
			if (transform) {
				if (curMat.bTransform || transform.bTransform) {
					Matrix.mul(transform, curMat, WebGLContext2D._tmpMatrix);
					transform = WebGLContext2D._tmpMatrix;
				} else {
					this._x += transform.tx + curMat.tx;
					this._y += transform.ty + curMat.ty;
					transform = Matrix.EMPTY;
				}
			}
			if (alpha === 1 && !blendMode)
				this._drawTextureM(args[0], args[1] - pivotX, args[2] - pivotY, args[3], args[4], 0, 0, transform, 1);
			else {
				var preAlpha = this._shader2D.ALPHA;
				var preblendType = this._nBlendType;
				this._shader2D.ALPHA = alpha;
				blendMode && (this._nBlendType = BlendMode.TOINT(blendMode));
				this._drawTextureM(args[0], args[1] - pivotX, args[2] - pivotY, args[3], args[4], 0, 0, transform, 1);
				this._shader2D.ALPHA = preAlpha;
				this._nBlendType = preblendType;
			}
			this._x = this._y = 0;
		}

		__proto.drawCanvas = function (canvas, x, y, width, height) {
			var src = canvas.context;
			this._renderKey = 0;
			if (src._targets) {
				this._submits[this._submits._length++] = SubmitCanvas.create(src, 0, null);
				this._curSubmit = Submit.RENDERBASE;
				src._targets.drawTo(this, x, y, width, height);
			} else {
				var submit = this._submits[this._submits._length++] = SubmitCanvas.create(src, this._shader2D.ALPHA, this._shader2D.filters);
				var sx = width / canvas.width;
				var sy = height / canvas.height;
				var mat = submit._matrix;
				this._curMat.copyTo(mat);
				sx != 1 && sy != 1 && mat.scale(sx, sy);
				var tx = mat.tx, ty = mat.ty;
				mat.tx = mat.ty = 0;
				mat.transformPoint(Point.TEMP.setTo(x, y));
				mat.translate(Point.TEMP.x + tx, Point.TEMP.y + ty);
				this._curSubmit = Submit.RENDERBASE;
			}
			if (Config.showCanvasMark) {
				this.save();
				this.lineWidth = 4;
				this.strokeStyle = src._targets ? "yellow" : "green";
				this.strokeRect(x - 1, y - 1, width + 2, height + 2, 1);
				this.strokeRect(x, y, width, height, 1);
				this.restore();
			}
		}

		__proto.drawTarget = function (scope, x, y, width, height, m, proName, shaderValue, uv, blend) {
			(blend === void 0) && (blend = -1);
			var vb = this._vb;
			if (GlUtils.fillRectImgVb(vb, this._clipRect, x, y, width, height, uv || Texture.DEF_UV, m || this._curMat, this._x, this._y, 0, 0)) {
				this._renderKey = 0;
				var shader = this._shader2D;
				shader.glTexture = null;
				var curShader = this._curSubmit.shaderValue;
				var submit = this._curSubmit = SubmitTarget.create(this, this._ib, vb, ((vb._byteLength - 16 */*laya.webgl.utils.Buffer2D.FLOAT32*/4) / 32) * 3, shaderValue, proName);
				if (blend == -1) {
					submit.blendType = this._nBlendType;
				} else {
					submit.blendType = blend;
				}
				submit.scope = scope;
				this._submits[this._submits._length++] = submit;
				this._curSubmit._numEle += 6;
			}
		}

		/**
		*把颜色跟当前设置的alpha混合
		*@return
		*/
		__proto.mixRGBandAlpha = function (color) {
			return this._mixRGBandAlpha(color, this._shader2D.ALPHA);
		}

		__proto._mixRGBandAlpha = function (color, alpha) {
			var a = ((color & 0xff000000) >>> 24);
			if (a != 0) {
				a *= alpha;
			} else {
				a = alpha * 255;
			}
			return (color & 0x00ffffff) | (a << 24);
		}

		__proto.drawTriangles = function (tex, x, y, vertices, uvs, indices, matrix, alpha, color, blendMode) {
			if (!(tex.loaded && tex.source)) {
				if (this.sprite) {
					Laya.timer.callLater(this, this._repaintSprite);
				}
				return false;
			}
			this._drawCount++;
			var webGLImg = tex.bitmap;
			var rgba = this._mixRGBandAlpha(0xffffffff, alpha);
			var vertNum = vertices.length / 2;
			var eleNum = indices.length;
			this._renderKey = -1;
			var submit = this._curSubmit = SubmitTexture.create(this, this._triangleMesh.getIBR(), this._triangleMesh.getVBR(), this._triangleMesh.indexNum, Value2D.create(/*laya.webgl.shader.d2.ShaderDefines2D.TEXTURE2D*/0x01, 0));
			submit.shaderValue.textureHost = tex;
			submit._renderType =/*laya.webgl.submit.Submit.TYPE_TEXTURE*/10016;
			this._submits[this._submits._length++] = submit;
			if (matrix) {
				WebGLContext2D._tmpMatrix.a = matrix.a; WebGLContext2D._tmpMatrix.b = matrix.b; WebGLContext2D._tmpMatrix.c = matrix.c; WebGLContext2D._tmpMatrix.d = matrix.d; WebGLContext2D._tmpMatrix.tx = matrix.tx + x; WebGLContext2D._tmpMatrix.ty = matrix.ty + y;
				Matrix.mul(WebGLContext2D._tmpMatrix, this._curMat, WebGLContext2D._tmpMatrix);
			} else {
				WebGLContext2D._tmpMatrix.a = this._curMat.a; WebGLContext2D._tmpMatrix.b = this._curMat.b; WebGLContext2D._tmpMatrix.c = this._curMat.c; WebGLContext2D._tmpMatrix.d = this._curMat.d; WebGLContext2D._tmpMatrix.tx = this._curMat.tx + x; WebGLContext2D._tmpMatrix.ty = this._curMat.ty + y;
			}
			this._triangleMesh.addData(vertices, uvs, indices, WebGLContext2D._tmpMatrix, rgba, this);
			this._curSubmit._numEle += eleNum;
			this._maxNumEle = Math.max(this._maxNumEle, this._curSubmit._numEle);
			return true;
		}

		__proto.transform = function (a, b, c, d, tx, ty) {
			SaveTransform.save(this);
			Matrix.mul(Matrix.TEMP.setTo(a, b, c, d, tx, ty), this._curMat, this._curMat);
			this._curMat._checkTransform();
		}

		__proto.setTransformByMatrix = function (value) {
			value.copyTo(this._curMat);
		}

		__proto.transformByMatrix = function (value) {
			SaveTransform.save(this);
			Matrix.mul(value, this._curMat, this._curMat);
			this._curMat._checkTransform();
		}

		__proto.rotate = function (angle) {
			SaveTransform.save(this);
			this._curMat.rotateEx(angle);
		}

		__proto.scale = function (scaleX, scaleY) {
			SaveTransform.save(this);
			this._curMat.scaleEx(scaleX, scaleY);
		}

		__proto.clipRect = function (x, y, width, height) {
			if (this._curMat.b != 0 || this._curMat.c != 0) {
				this._renderKey = 0;
				var submitStencil0 = SubmitStencil.create(4);
				this.addRenderObject(submitStencil0);
				var vb = this._vb;
				var nPos = (vb._byteLength >> 2);
				if (GlUtils.fillRectImgVb(vb, null, x, y, width, height, Texture.DEF_UV, this._curMat, this._x, this._y, 0, 0)) {
					var shader = this._shader2D;
					shader.glTexture = null;
					var submit = this._curSubmit = Submit.createSubmit(this, this._ib, vb, ((vb._byteLength - 16 */*laya.webgl.utils.Buffer2D.FLOAT32*/4) / 32) * 3, Value2D.create(/*laya.webgl.shader.d2.ShaderDefines2D.COLOR2D*/0x02, 0));
					submit.shaderValue.ALPHA = 1.0;
					this._submits[this._submits._length++] = submit;
					this._curSubmit._numEle += 6;
				} else {
					alert("clipRect calc stencil rect error");
				};
				var submitStencil1 = SubmitStencil.create(5);
				this.addRenderObject(submitStencil1);
				var vbdata = vb.getFloat32Array();
				var minx = Math.min(Math.min(Math.min(vbdata[nPos + 0], vbdata[nPos + 4]), vbdata[nPos + 8]), vbdata[nPos + 12]);
				var maxx = Math.max(Math.max(Math.max(vbdata[nPos + 0], vbdata[nPos + 4]), vbdata[nPos + 8]), vbdata[nPos + 12]);
				var miny = Math.min(Math.min(Math.min(vbdata[nPos + 1], vbdata[nPos + 5]), vbdata[nPos + 9]), vbdata[nPos + 13]);
				var maxy = Math.max(Math.max(Math.max(vbdata[nPos + 1], vbdata[nPos + 5]), vbdata[nPos + 9]), vbdata[nPos + 13]);
				SaveClipRectStencil.save(this, submitStencil1, x, y, width, height, minx, miny, maxx - minx, maxy - miny);
				this._curSubmit = Submit.RENDERBASE;
			} else {
				width *= this._curMat.a;
				height *= this._curMat.d;
				var p = Point.TEMP;
				this._curMat.transformPoint(p.setTo(x, y));
				if (width < 0) {
					p.x = p.x + width;
					width = -width;
				}
				if (height < 0) {
					p.y = p.y + height;
					height = -height;
				}
				this._renderKey = 0;
				var submitSc = this._curSubmit = SubmitScissor.create(this);
				this._submits[this._submits._length++] = submitSc;
				submitSc.submitIndex = this._submits._length;
				submitSc.submitLength = 9999999;
				SaveClipRect.save(this, submitSc);
				var clip = this._clipRect;
				var x1 = clip.x, y1 = clip.y;
				var r = p.x + width, b = p.y + height;
				x1 < p.x && (clip.x = p.x);
				y1 < p.y && (clip.y = p.y);
				clip.width = Math.min(r, x1 + clip.width) - clip.x;
				clip.height = Math.min(b, y1 + clip.height) - clip.y;
				this._shader2D.glTexture = null;
				submitSc.clipRect.copyFrom(clip);
				this._curSubmit = Submit.RENDERBASE;
			}
		}

		__proto.setIBVB = function (x, y, ib, vb, numElement, mat, shader, shaderValues, startIndex, offset, type) {
			(startIndex === void 0) && (startIndex = 0);
			(offset === void 0) && (offset = 0);
			(type === void 0) && (type = 0);
			if (ib === null) {
				if (!Render.isFlash) {
					ib = this._ib;
				} else {
					var falshVB = vb;
					(falshVB._selfIB) || (falshVB._selfIB = IndexBuffer2D.create(/*laya.webgl.WebGLContext.STATIC_DRAW*/0x88E4));
					falshVB._selfIB.clear();
					ib = falshVB._selfIB;
				}
				GlUtils.expandIBQuadrangle(ib, (vb._byteLength / (/*laya.webgl.utils.Buffer2D.FLOAT32*/4 * vb.vertexStride * 4)));
			}
			if (!shaderValues || !shader)
				throw Error("setIBVB must input:shader shaderValues");
			var submit = SubmitOtherIBVB.create(this, vb, ib, numElement, shader, shaderValues, startIndex, offset, type);
			mat || (mat = Matrix.EMPTY);
			mat.translate(x, y);
			Matrix.mul(mat, this._curMat, submit._mat);
			mat.translate(-x, -y);
			this._submits[this._submits._length++] = submit;
			this._curSubmit = Submit.RENDERBASE;
			this._renderKey = 0;
		}

		__proto.addRenderObject = function (o) {
			this._submits[this._submits._length++] = o;
		}

		__proto.fillTrangles = function (tex, x, y, points, m) {
			var submit = this._curSubmit;
			var vb = this._vb;
			var shader = this._shader2D;
			var curShader = submit.shaderValue;
			var length = points.length >> 4;
			var t_tex = tex.bitmap;
			this._renderKey = 0;
			if (shader.glTexture != t_tex || shader.ALPHA !== curShader.ALPHA) {
				submit = this._curSubmit = Submit.createSubmit(this, this._ib, vb, ((vb._byteLength) / 32) * 3, Value2D.create(/*laya.webgl.shader.d2.ShaderDefines2D.TEXTURE2D*/0x01, 0));
				submit.shaderValue.textureHost = tex;
				this._submits[this._submits._length++] = submit;
			}
			GlUtils.fillTranglesVB(vb, x, y, points, m || this._curMat, this._x, this._y);
			submit._numEle += length * 6;
		}

		__proto.submitElement = function (start, end) {
			var renderList = this._submits;
			end < 0 && (end = renderList._length);
			while (start < end) {
				start += renderList[start].renderSubmit();
			}
		}

		__proto.finish = function () {
			WebGL.mainContext.finish();
		}

		__proto.flush = function () {
			var maxNum = Math.max(this._vb._byteLength / (/*laya.webgl.utils.Buffer2D.FLOAT32*/4 * 16), this._maxNumEle / 6) + 8;
			if (maxNum > (this._ib.bufferLength / (6 */*laya.webgl.utils.Buffer2D.SHORT*/2))) {
				GlUtils.expandIBQuadrangle(this._ib, maxNum);
			}
			if (!this._isMain && AtlasResourceManager.enabled && AtlasResourceManager._atlasRestore > this._atlasResourceChange) {
				this._atlasResourceChange = AtlasResourceManager._atlasRestore;
				var renderList = this._submits;
				for (var i = 0, s = renderList._length; i < s; i++) {
					var submit = renderList[i];
					if (submit.getRenderType() ===/*laya.webgl.submit.Submit.TYPE_TEXTURE*/10016)
						(submit).checkTexture();
				}
			}
			this.submitElement(0, this._submits._length);
			this._path && this._path.reset();
			SkinMeshBuffer.instance && SkinMeshBuffer.getInstance().reset();
			var sz = 0;
			for (i = 0, sz = this.meshlist.length; i < sz; i++) {
				var curm = this.meshlist[i];
				curm.canReuse ? (curm.releaseMesh()) : (curm.destroy());
			}
			this.meshlist.length = 0;
			this._curSubmit = Submit.RENDERBASE;
			this._renderKey = 0;
			this._triangleMesh = MeshTexture.getAMesh();
			this.meshlist.push(this._triangleMesh);
			return this._submits._length;
		}

		__proto.setPathId = function (id) {
			this.mId = id;
			if (this.mId != -1) {
				this.mHaveKey = false;
				var tVGM = VectorGraphManager.getInstance();
				if (tVGM.shapeDic[this.mId]) {
					this.mHaveKey = true;
				}
				this.mHaveLineKey = false;
				if (tVGM.shapeLineDic[this.mId]) {
					this.mHaveLineKey = true;
				}
			}
		}

		__proto.movePath = function (x, y) {
			var _x1 = x, _y1 = y;
			x = this._curMat.a * _x1 + this._curMat.c * _y1 + this._curMat.tx;
			y = this._curMat.b * _x1 + this._curMat.d * _y1 + this._curMat.ty;
			this.mX += x;
			this.mY += y;
		}

		__proto.beginPath = function () {
			var tPath = this._getPath();
			tPath.tempArray.length = 0;
			tPath.closePath = false;
			this.mX = 0;
			this.mY = 0;
		}

		__proto.closePath = function () {
			this._path.closePath = true;
		}

		__proto.fill = function (isConvexPolygon) {
			(isConvexPolygon === void 0) && (isConvexPolygon = false);
			var tPath = this._getPath();
			this.drawPoly(0, 0, tPath.tempArray, this.fillStyle._color.numColor, 0, 0, isConvexPolygon);
		}

		__proto.stroke = function () {
			var tPath = this._getPath();
			if (this.lineWidth > 0) {
				if (this.mId == -1) {
					tPath.drawLine(0, 0, tPath.tempArray, this.lineWidth, this.strokeStyle._color.numColor);
				} else {
					if (this.mHaveLineKey) {
						var tShapeLine = VectorGraphManager.getInstance().shapeLineDic[this.mId];
						tShapeLine.rebuild(tPath.tempArray);
						tPath.setGeomtry(tShapeLine);
					} else {
						VectorGraphManager.getInstance().addLine(this.mId, tPath.drawLine(0, 0, tPath.tempArray, this.lineWidth, this.strokeStyle._color.numColor));
					}
				}
				tPath.update();
				var tPosArray = [this.mX, this.mY];
				var tempSubmit = Submit.createShape(this, tPath.ib, tPath.vb, tPath.count, tPath.offset, Value2D.create(/*laya.webgl.shader.d2.ShaderDefines2D.PRIMITIVE*/0x04, 0));
				tempSubmit.shaderValue.ALPHA = this._shader2D.ALPHA;
				(tempSubmit.shaderValue).u_pos = tPosArray;
				tempSubmit.shaderValue.u_mmat2 = RenderState2D.TEMPMAT4_ARRAY;
				this._submits[this._submits._length++] = tempSubmit;
			}
		}

		__proto.line = function (fromX, fromY, toX, toY, lineWidth, mat) {
			var submit = this._curSubmit;
			var vb = this._vb;
			if (GlUtils.fillLineVb(vb, this._clipRect, fromX, fromY, toX, toY, lineWidth, mat)) {
				this._renderKey = 0;
				var shader = this._shader2D;
				var curShader = submit.shaderValue;
				if (shader.strokeStyle !== curShader.strokeStyle || shader.ALPHA !== curShader.ALPHA) {
					shader.glTexture = null;
					submit = this._curSubmit = Submit.createSubmit(this, this._ib, vb, ((vb._byteLength - 16 */*laya.webgl.utils.Buffer2D.FLOAT32*/4) / 32) * 3, Value2D.create(/*laya.webgl.shader.d2.ShaderDefines2D.COLOR2D*/0x02, 0));
					submit.shaderValue.strokeStyle = shader.strokeStyle;
					submit.shaderValue.mainID =/*laya.webgl.shader.d2.ShaderDefines2D.COLOR2D*/0x02;
					submit.shaderValue.ALPHA = shader.ALPHA;
					this._submits[this._submits._length++] = submit;
				}
				submit._numEle += 6;
			}
		}

		__proto.moveTo = function (x, y, b) {
			(b === void 0) && (b = true);
			var tPath = this._getPath();
			if (b) {
				var _x1 = x, _y1 = y;
				x = this._curMat.a * _x1 + this._curMat.c * _y1;
				y = this._curMat.b * _x1 + this._curMat.d * _y1;
			}
			tPath.addPoint(x, y);
		}

		__proto.lineTo = function (x, y, b) {
			(b === void 0) && (b = true);
			var tPath = this._getPath();
			if (b) {
				var _x1 = x, _y1 = y;
				x = this._curMat.a * _x1 + this._curMat.c * _y1;
				y = this._curMat.b * _x1 + this._curMat.d * _y1;
			}
			tPath.addPoint(x, y);
		}

		__proto.drawCurves = function (x, y, args) {
			this.setPathId(-1);
			this.beginPath();
			this.strokeStyle = args[3];
			this.lineWidth = args[4];
			var points = args[2];
			x += args[0], y += args[1];
			this.movePath(x, y);
			this.moveTo(points[0], points[1]);
			var i = 2, n = points.length;
			while (i < n) {
				this.quadraticCurveTo(points[i++], points[i++], points[i++], points[i++]);
			}
			this.stroke();
		}

		__proto.arcTo = function (x1, y1, x2, y2, r) {
			if (this.mId != -1) {
				if (this.mHaveKey) {
					return;
				}
			};
			var i = 0;
			var x = 0, y = 0;
			var tPath = this._getPath();
			this._curMat.copyTo(WebGLContext2D._tmpMatrix);
			WebGLContext2D._tmpMatrix.tx = WebGLContext2D._tmpMatrix.ty = 0;
			WebGLContext2D._tempPoint.setTo(tPath.getEndPointX(), tPath.getEndPointY());
			WebGLContext2D._tmpMatrix.invertTransformPoint(WebGLContext2D._tempPoint);
			var dx = WebGLContext2D._tempPoint.x - x1;
			var dy = WebGLContext2D._tempPoint.y - y1;
			var len1 = Math.sqrt(dx * dx + dy * dy);
			if (len1 <= 0.000001) {
				return;
			};
			var ndx = dx / len1;
			var ndy = dy / len1;
			var dx2 = x2 - x1;
			var dy2 = y2 - y1;
			var len22 = dx2 * dx2 + dy2 * dy2;
			var len2 = Math.sqrt(len22);
			if (len2 <= 0.000001) {
				return;
			};
			var ndx2 = dx2 / len2;
			var ndy2 = dy2 / len2;
			var odx = ndx + ndx2;
			var ody = ndy + ndy2;
			var olen = Math.sqrt(odx * odx + ody * ody);
			if (olen <= 0.000001) {
				return;
			};
			var nOdx = odx / olen;
			var nOdy = ody / olen;
			var alpha = Math.acos(nOdx * ndx + nOdy * ndy);
			var halfAng = Math.PI / 2 - alpha;
			len1 = r / Math.tan(halfAng);
			var ptx1 = len1 * ndx + x1;
			var pty1 = len1 * ndy + y1;
			var orilen = Math.sqrt(len1 * len1 + r * r);
			var orix = x1 + nOdx * orilen;
			var oriy = y1 + nOdy * orilen;
			var ptx2 = len1 * ndx2 + x1;
			var pty2 = len1 * ndy2 + y1;
			var dir = ndx * ndy2 - ndy * ndx2;
			var fChgAng = 0;
			var sinx = 0.0;
			var cosx = 0.0;
			if (dir >= 0) {
				fChgAng = halfAng * 2;
				var fda = fChgAng / WebGLContext2D.SEGNUM;
				sinx = Math.sin(fda);
				cosx = Math.cos(fda);
			}
			else {
				fChgAng = -halfAng * 2;
				fda = fChgAng / WebGLContext2D.SEGNUM;
				sinx = Math.sin(fda);
				cosx = Math.cos(fda);
			}
			x = this._curMat.a * ptx1 + this._curMat.c * pty1;
			y = this._curMat.b * ptx1 + this._curMat.d * pty1;
			if (x != this._path.getEndPointX() || y != this._path.getEndPointY()) {
				tPath.addPoint(x, y);
			};
			var cvx = ptx1 - orix;
			var cvy = pty1 - oriy;
			var tx = 0.0;
			var ty = 0.0;
			for (i = 0; i < WebGLContext2D.SEGNUM; i++) {
				var cx = cvx * cosx + cvy * sinx;
				var cy = -cvx * sinx + cvy * cosx;
				x = cx + orix;
				y = cy + oriy;
				x1 = this._curMat.a * x + this._curMat.c * y;
				y1 = this._curMat.b * x + this._curMat.d * y;
				x = x1;
				y = y1;
				if (x != this._path.getEndPointX() || y != this._path.getEndPointY()) {
					tPath.addPoint(x, y);
				}
				cvx = cx;
				cvy = cy;
			}
		}

		__proto.arc = function (cx, cy, r, startAngle, endAngle, counterclockwise, b) {
			(counterclockwise === void 0) && (counterclockwise = false);
			(b === void 0) && (b = true);
			if (this.mId != -1) {
				var tShape = VectorGraphManager.getInstance().shapeDic[this.mId];
				if (tShape) {
					if (this.mHaveKey && !tShape.needUpdate(this._curMat))
						return;
				}
				cx = 0;
				cy = 0;
			};
			var a = 0, da = 0, hda = 0, kappa = 0;
			var dx = 0, dy = 0, x = 0, y = 0, tanx = 0, tany = 0;
			var px = 0, py = 0, ptanx = 0, ptany = 0;
			var i = 0, ndivs = 0, nvals = 0;
			da = endAngle - startAngle;
			if (!counterclockwise) {
				if (Math.abs(da) >= Math.PI * 2) {
					da = Math.PI * 2;
				} else {
					while (da < 0.0) {
						da += Math.PI * 2;
					}
				}
			} else {
				if (Math.abs(da) >= Math.PI * 2) {
					da = -Math.PI * 2;
				} else {
					while (da > 0.0) {
						da -= Math.PI * 2;
					}
				}
			}
			if (r < 101) {
				ndivs = Math.max(10, da * r / 5);
			} else if (r < 201) {
				ndivs = Math.max(10, da * r / 20);
			} else {
				ndivs = Math.max(10, da * r / 40);
			}
			hda = (da / ndivs) / 2.0;
			kappa = Math.abs(4 / 3 * (1 - Math.cos(hda)) / Math.sin(hda));
			if (counterclockwise)
				kappa = -kappa;
			nvals = 0;
			var tPath = this._getPath();
			var _x1 = NaN, _y1 = NaN;
			for (i = 0; i <= ndivs; i++) {
				a = startAngle + da * (i / ndivs);
				dx = Math.cos(a);
				dy = Math.sin(a);
				x = cx + dx * r;
				y = cy + dy * r;
				if (b) {
					_x1 = x, _y1 = y;
					x = this._curMat.a * _x1 + this._curMat.c * _y1;
					y = this._curMat.b * _x1 + this._curMat.d * _y1;
				}
				if (x != this._path.getEndPointX() || y != this._path.getEndPointY()) {
					tPath.addPoint(x, y);
				}
			}
			dx = Math.cos(endAngle);
			dy = Math.sin(endAngle);
			x = cx + dx * r;
			y = cy + dy * r;
			if (b) {
				_x1 = x, _y1 = y;
				x = this._curMat.a * _x1 + this._curMat.c * _y1;
				y = this._curMat.b * _x1 + this._curMat.d * _y1;
			}
			if (x != this._path.getEndPointX() || y != this._path.getEndPointY()) {
				tPath.addPoint(x, y);
			}
		}

		__proto.quadraticCurveTo = function (cpx, cpy, x, y) {
			var tBezier = Bezier.I;
			var tResultArray = [];
			var _x1 = x, _y1 = y;
			x = this._curMat.a * _x1 + this._curMat.c * _y1;
			y = this._curMat.b * _x1 + this._curMat.d * _y1;
			_x1 = cpx, _y1 = cpy;
			cpx = this._curMat.a * _x1 + this._curMat.c * _y1;
			cpy = this._curMat.b * _x1 + this._curMat.d * _y1;
			var tArray = tBezier.getBezierPoints([this._path.getEndPointX(), this._path.getEndPointY(), cpx, cpy, x, y], 30, 2);
			for (var i = 0, n = tArray.length / 2; i < n; i++) {
				this.lineTo(tArray[i * 2], tArray[i * 2 + 1], false);
			}
			this.lineTo(x, y, false);
		}

		__proto.rect = function (x, y, width, height) {
			this._other = this._other.make();
			this._other.path || (this._other.path = new Path());
			this._other.path.rect(x, y, width, height);
		}

		__proto.strokeRect = function (x, y, width, height, parameterLineWidth) {
			var tW = parameterLineWidth * 0.5;
			this.line(x - tW, y, x + width + tW, y, parameterLineWidth, this._curMat);
			this.line(x + width, y, x + width, y + height, parameterLineWidth, this._curMat);
			this.line(x, y, x, y + height, parameterLineWidth, this._curMat);
			this.line(x - tW, y + height, x + width + tW, y + height, parameterLineWidth, this._curMat);
		}

		__proto.clip = function () { }
		/**
		*画多边形(用)
		*@param x
		*@param y
		*@param points
		*/
		__proto.drawPoly = function (x, y, points, color, lineWidth, boderColor, isConvexPolygon) {
			(isConvexPolygon === void 0) && (isConvexPolygon = false);
			this._renderKey = 0;
			this._shader2D.glTexture = null;
			var tPath = this._getPath();
			if (this.mId == -1) {
				tPath.polygon(x, y, points, color, lineWidth ? lineWidth : 1, boderColor)
			} else {
				if (this.mHaveKey) {
					var tShape = VectorGraphManager.getInstance().shapeDic[this.mId];
					tShape.setMatrix(this._curMat);
					tShape.rebuild(tPath.tempArray);
					tPath.setGeomtry(tShape);
				} else {
					var t = tPath.polygon(x, y, points, color, lineWidth ? lineWidth : 1, boderColor);
					VectorGraphManager.getInstance().addShape(this.mId, t);
					t.setMatrix(this._curMat);
				}
			}
			tPath.update();
			var tPosArray = [this.mX, this.mY];
			var tempSubmit;
			tempSubmit = Submit.createShape(this, tPath.ib, tPath.vb, tPath.count, tPath.offset, Value2D.create(/*laya.webgl.shader.d2.ShaderDefines2D.PRIMITIVE*/0x04, 0));
			tempSubmit.shaderValue.ALPHA = this._shader2D.ALPHA;
			(tempSubmit.shaderValue).u_pos = tPosArray;
			tempSubmit.shaderValue.u_mmat2 = RenderState2D.EMPTYMAT4_ARRAY;
			this._submits[this._submits._length++] = tempSubmit;
			if (lineWidth > 0) {
				if (this.mHaveLineKey) {
					var tShapeLine = VectorGraphManager.getInstance().shapeLineDic[this.mId];
					tShapeLine.rebuild(tPath.tempArray);
					tPath.setGeomtry(tShapeLine);
				} else {
					VectorGraphManager.getInstance().addShape(this.mId, tPath.drawLine(x, y, points, lineWidth, boderColor));
				}
				tPath.update();
				tempSubmit = Submit.createShape(this, tPath.ib, tPath.vb, tPath.count, tPath.offset, Value2D.create(/*laya.webgl.shader.d2.ShaderDefines2D.PRIMITIVE*/0x04, 0));
				tempSubmit.shaderValue.ALPHA = this._shader2D.ALPHA;
				tempSubmit.shaderValue.u_mmat2 = RenderState2D.EMPTYMAT4_ARRAY;
				this._submits[this._submits._length++] = tempSubmit;
			}
		}

		/*******************************************end矢量绘制***************************************************/
		__proto.drawParticle = function (x, y, pt) {
			pt.x = x;
			pt.y = y;
			this._submits[this._submits._length++] = pt;
		}

		__proto._getPath = function () {
			return this._path || (this._path = new Path());
		}

		/*,_shader2D.ALPHA=1*/
		__getset(0, __proto, 'globalCompositeOperation', function () {
			return BlendMode.NAMES[this._nBlendType];
		}, function (value) {
			var n = BlendMode.TOINT[value];
			n == null || (this._nBlendType === n) || (SaveBase.save(this,/*laya.webgl.canvas.save.SaveBase.TYPE_GLOBALCOMPOSITEOPERATION*/0x10000, this, true), this._curSubmit = Submit.RENDERBASE, this._renderKey = 0, this._nBlendType = n);
		});

		__getset(0, __proto, 'strokeStyle', function () {
			return this._shader2D.strokeStyle;
		}, function (value) {
			this._shader2D.strokeStyle.equal(value) || (SaveBase.save(this,/*laya.webgl.canvas.save.SaveBase.TYPE_STROKESTYLE*/0x200, this._shader2D, false), this._shader2D.strokeStyle = DrawStyle.create(value));
		});

		__getset(0, __proto, 'globalAlpha', function () {
			return this._shader2D.ALPHA;
		}, function (value) {
			value = Math.floor(value * 1000) / 1000;
			if (value != this._shader2D.ALPHA) {
				SaveBase.save(this,/*laya.webgl.canvas.save.SaveBase.TYPE_ALPHA*/0x1, this._shader2D, true);
				this._shader2D.ALPHA = value;
			}
		});

		__getset(0, __proto, 'asBitmap', null, function (value) {
			if (value) {
				this._targets || (this._targets = new RenderTargetMAX());
				this._targets.repaint = true;
				if (!this._width || !this._height)
					throw Error("asBitmap no size!");
				this._targets.setSP(this.sprite);
				this._targets.size(this._width, this._height);
			} else
				this._targets = null;
		});

		__getset(0, __proto, 'fillStyle', function () {
			return this._shader2D.fillStyle;
		}, function (value) {
			this._shader2D.fillStyle.equal(value) || (SaveBase.save(this,/*laya.webgl.canvas.save.SaveBase.TYPE_FILESTYLE*/0x2, this._shader2D, false), this._shader2D.fillStyle = DrawStyle.create(value));
		});

		__getset(0, __proto, 'textAlign', function () {
			return this._other.textAlign;
		}, function (value) {
			(this._other.textAlign === value) || (this._other = this._other.make(), SaveBase.save(this,/*laya.webgl.canvas.save.SaveBase.TYPE_TEXTALIGN*/0x8000, this._other, false), this._other.textAlign = value);
		});

		__getset(0, __proto, 'lineWidth', function () {
			return this._other.lineWidth;
		}, function (value) {
			(this._other.lineWidth === value) || (this._other = this._other.make(), SaveBase.save(this,/*laya.webgl.canvas.save.SaveBase.TYPE_LINEWIDTH*/0x100, this._other, false), this._other.lineWidth = value);
		});

		__getset(0, __proto, 'textBaseline', function () {
			return this._other.textBaseline;
		}, function (value) {
			(this._other.textBaseline === value) || (this._other = this._other.make(), SaveBase.save(this,/*laya.webgl.canvas.save.SaveBase.TYPE_TEXTBASELINE*/0x4000, this._other, false), this._other.textBaseline = value);
		});

		__getset(0, __proto, 'font', null, function (str) {
			if (str == this._other.font.toString())
				return;
			this._other = this._other.make();
			SaveBase.save(this,/*laya.webgl.canvas.save.SaveBase.TYPE_FONT*/0x8, this._other, false);
			this._other.font === FontInContext.EMPTY ? (this._other.font = new FontInContext(str)) : (this._other.font.setFont(str));
		});

		WebGLContext2D.__init__ = function () {
			ContextParams.DEFAULT = new ContextParams();
		}

		WebGLContext2D._tempPoint = new Point();
		WebGLContext2D._SUBMITVBSIZE = 32000;
		WebGLContext2D._MAXSIZE = 99999999;
		WebGLContext2D._RECTVBSIZE = 16;
		WebGLContext2D.MAXCLIPRECT = new Rectangle(0, 0, 99999999, 99999999);
		WebGLContext2D._COUNT = 0;
		WebGLContext2D._tmpMatrix = new Matrix();
		WebGLContext2D.SEGNUM = 32;
		WebGLContext2D._contextcount = 0;
		__static(WebGLContext2D,
			['_fontTemp', function () { return this._fontTemp = new FontInContext(); }, '_drawStyleTemp', function () { return this._drawStyleTemp = new DrawStyle(null); }
			]);
		WebGLContext2D.__init$ = function () {
			//class ContextParams
			ContextParams = (function () {
				function ContextParams() {
					this.lineWidth = 1;
					this.path = null;
					this.textAlign = null;
					this.textBaseline = null;
					this.font = FontInContext.EMPTY;
				}
				__class(ContextParams, '');
				var __proto = ContextParams.prototype;
				__proto.clear = function () {
					this.lineWidth = 1;
					this.path && this.path.clear();
					this.textAlign = this.textBaseline = null;
					this.font = FontInContext.EMPTY;
				}
				__proto.make = function () {
					return this === ContextParams.DEFAULT ? new ContextParams() : this;
				}
				ContextParams.DEFAULT = null;
				return ContextParams;
			})()
		}

		return WebGLContext2D;
	})(Context)


	//class laya.webgl.shader.d2.value.Value2D extends laya.webgl.shader.ShaderValue
	var Value2D = (function (_super) {
		function Value2D(mainID, subID) {
			this.size = [0, 0];
			this.alpha = 1.0;
			//this.mmat=null;
			this.ALPHA = 1.0;
			//this.shader=null;
			//this.mainID=0;
			this.subID = 0;
			//this.filters=null;
			//this.textureHost=null;
			//this.texture=null;
			//this.fillStyle=null;
			//this.color=null;
			//this.strokeStyle=null;
			//this.colorAdd=null;
			//this.glTexture=null;
			//this.u_mmat2=null;
			//this._inClassCache=null;
			this._cacheID = 0;
			Value2D.__super.call(this);
			this.defines = new ShaderDefines2D();
			this.position = Value2D._POSITION;
			this.mainID = mainID;
			this.subID = subID;
			this.textureHost = null;
			this.texture = null;
			this.fillStyle = null;
			this.color = null;
			this.strokeStyle = null;
			this.colorAdd = null;
			this.glTexture = null;
			this.u_mmat2 = null;
			this._cacheID = mainID | subID;
			this._inClassCache = Value2D._cache[this._cacheID];
			if (mainID > 0 && !this._inClassCache) {
				this._inClassCache = Value2D._cache[this._cacheID] = [];
				this._inClassCache._length = 0;
			}
			this.clear();
		}

		__class(Value2D, 'laya.webgl.shader.d2.value.Value2D', _super);
		var __proto = Value2D.prototype;
		__proto.setValue = function (value) { }
		//throw new Error("todo in subclass");
		__proto.refresh = function () {
			var size = this.size;
			size[0] = RenderState2D.width;
			size[1] = RenderState2D.height;
			this.alpha = this.ALPHA * RenderState2D.worldAlpha;
			this.mmat = RenderState2D.worldMatrix4;
			return this;
		}

		__proto._ShaderWithCompile = function () {
			return Shader.withCompile2D(0, this.mainID, this.defines.toNameDic(), this.mainID | this.defines._value, Shader2X.create);
		}

		__proto._withWorldShaderDefines = function () {
			var defs = RenderState2D.worldShaderDefines;
			var sd = Shader.sharders[this.mainID | this.defines._value | defs.getValue()];
			if (!sd) {
				var def = {};
				var dic;
				var name;
				dic = this.defines.toNameDic(); for (name in dic) def[name] = "";
				dic = defs.toNameDic(); for (name in dic) def[name] = "";
				sd = Shader.withCompile2D(0, this.mainID, def, this.mainID | this.defines._value | defs.getValue(), Shader2X.create);
			};
			var worldFilters = RenderState2D.worldFilters;
			if (!worldFilters) return sd;
			var n = worldFilters.length, f;
			for (var i = 0; i < n; i++) {
				((f = worldFilters[i])) && f.action.setValue(this);
			}
			return sd;
		}

		__proto.upload = function () {
			var renderstate2d = RenderState2D;
			this.alpha = this.ALPHA * renderstate2d.worldAlpha;
			if (RenderState2D.worldMatrix4 !== RenderState2D.TEMPMAT4_ARRAY) this.defines.add(/*laya.webgl.shader.d2.ShaderDefines2D.WORLDMAT*/0x80);
			(WebGL.shaderHighPrecision) && (this.defines.add(/*laya.webgl.shader.d2.ShaderDefines2D.SHADERDEFINE_FSHIGHPRECISION*/0x400));
			var sd = renderstate2d.worldShaderDefines ? this._withWorldShaderDefines() : (Shader.sharders[this.mainID | this.defines._value] || this._ShaderWithCompile());
			var params;
			this.size[0] = renderstate2d.width, this.size[1] = renderstate2d.height;
			this.mmat = renderstate2d.worldMatrix4;
			if (BaseShader.activeShader !== sd) {
				if (sd._shaderValueWidth !== renderstate2d.width || sd._shaderValueHeight !== renderstate2d.height) {
					sd._shaderValueWidth = renderstate2d.width;
					sd._shaderValueHeight = renderstate2d.height;
				}
				else {
					params = sd._params2dQuick2 || sd._make2dQuick2();
				}
				sd.upload(this, params);
			}
			else {
				if (sd._shaderValueWidth !== renderstate2d.width || sd._shaderValueHeight !== renderstate2d.height) {
					sd._shaderValueWidth = renderstate2d.width;
					sd._shaderValueHeight = renderstate2d.height;
				}
				else {
					params = (sd._params2dQuick1) || sd._make2dQuick1();
				}
				sd.upload(this, params);
			}
		}

		__proto.setFilters = function (value) {
			this.filters = value;
			if (!value)
				return;
			var n = value.length, f;
			for (var i = 0; i < n; i++) {
				f = value[i];
				if (f) {
					this.defines.add(f.type);
					f.action.setValue(this);
				}
			}
		}

		__proto.clear = function () {
			this.defines.setValue(this.subID);
		}

		__proto.release = function () {
			this._inClassCache[this._inClassCache._length++] = this;
			this.fillStyle = null;
			this.strokeStyle = null;
			this.clear();
		}

		Value2D._initone = function (type, classT) {
			Value2D._typeClass[type] = classT;
			Value2D._cache[type] = [];
			Value2D._cache[type]._length = 0;
		}

		Value2D.__init__ = function () {
			Value2D._POSITION = [2,/*laya.webgl.WebGLContext.FLOAT*/0x1406, false, 4 * CONST3D2D.BYTES_PE, 0];
			Value2D._TEXCOORD = [2,/*laya.webgl.WebGLContext.FLOAT*/0x1406, false, 4 * CONST3D2D.BYTES_PE, 2 * CONST3D2D.BYTES_PE];
			Value2D._initone(/*laya.webgl.shader.d2.ShaderDefines2D.COLOR2D*/0x02, Color2dSV);
			Value2D._initone(/*laya.webgl.shader.d2.ShaderDefines2D.PRIMITIVE*/0x04, PrimitiveSV);
			Value2D._initone(/*laya.webgl.shader.d2.ShaderDefines2D.FILLTEXTURE*/0x100, FillTextureSV);
			Value2D._initone(/*laya.webgl.shader.d2.ShaderDefines2D.SKINMESH*/0x200, SkinSV);
			Value2D._initone(/*laya.webgl.shader.d2.ShaderDefines2D.TEXTURE2D*/0x01, TextureSV);
			Value2D._initone(/*laya.webgl.shader.d2.ShaderDefines2D.TEXTURE2D*/0x01 | /*laya.webgl.shader.d2.ShaderDefines2D.COLORADD*/0x40, TextSV);
			Value2D._initone(/*laya.webgl.shader.d2.ShaderDefines2D.TEXTURE2D*/0x01 | /*laya.webgl.shader.d2.ShaderDefines2D.FILTERGLOW*/0x08, TextureSV);
		}

		Value2D.create = function (mainType, subType) {
			var types = Value2D._cache[mainType | subType];
			if (types._length)
				return types[--types._length];
			else
				return new Value2D._typeClass[mainType | subType](subType);
		}

		Value2D._POSITION = null;
		Value2D._TEXCOORD = null;
		Value2D._cache = [];
		Value2D._typeClass = [];
		Value2D.TEMPMAT4_ARRAY = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
		return Value2D;
	})(ShaderValue)


	//class laya.webgl.utils.RenderSprite3D extends laya.renders.RenderSprite
	var RenderSprite3D = (function (_super) {
		function RenderSprite3D(type, next) {
			RenderSprite3D.__super.call(this, type, next);
		}

		__class(RenderSprite3D, 'laya.webgl.utils.RenderSprite3D', _super);
		var __proto = RenderSprite3D.prototype;
		__proto.onCreate = function (type) {
			switch (type) {
				case 0x08:
					this._fun = this._blend;
					return;
				case 0x04:
					this._fun = this._transform;
					return;
			}
		}

		__proto._mask = function (sprite, context, x, y) {
			var next = this._next;
			var mask = sprite.mask;
			var submitCMD;
			var submitStencil;
			if (mask) {
				context.ctx.save();
				var preBlendMode = (context.ctx).globalCompositeOperation;
				var tRect = new Rectangle();
				tRect.copyFrom(mask.getBounds());
				tRect.width = Math.round(tRect.width);
				tRect.height = Math.round(tRect.height);
				tRect.x = Math.round(tRect.x);
				tRect.y = Math.round(tRect.y);
				if (tRect.width > 0 && tRect.height > 0) {
					var tf = sprite._style._tf;
					var scope = SubmitCMDScope.create();
					scope.addValue("bounds", tRect);
					submitCMD = SubmitCMD.create([scope, context], laya.webgl.utils.RenderSprite3D.tmpTarget);
					context.addRenderObject(submitCMD);
					mask.render(context, -tRect.x, -tRect.y);
					submitCMD = SubmitCMD.create([scope], laya.webgl.utils.RenderSprite3D.endTmpTarget);
					context.addRenderObject(submitCMD);
					context.ctx.save();
					context.clipRect(x - tf.translateX + tRect.x, y - tf.translateY + tRect.y, tRect.width, tRect.height);
					next._fun.call(next, sprite, context, x, y);
					context.ctx.restore();
					submitStencil = SubmitStencil.create(6);
					preBlendMode = (context.ctx).globalCompositeOperation;
					submitStencil.blendMode = "mask";
					context.addRenderObject(submitStencil);
					Matrix.TEMP.identity();
					var shaderValue = Value2D.create(/*laya.webgl.shader.d2.ShaderDefines2D.TEXTURE2D*/0x01, 0);
					var uv = Texture.INV_UV;
					var w = tRect.width;
					var h = tRect.height;
					var tempLimit = 32;
					if (tRect.width < tempLimit || tRect.height < tempLimit) {
						uv = RenderSprite3D.tempUV;
						uv[0] = 0;
						uv[1] = 0;
						uv[2] = (tRect.width >= 32) ? 1 : tRect.width / tempLimit;
						uv[3] = 0
						uv[4] = (tRect.width >= 32) ? 1 : tRect.width / tempLimit;
						uv[5] = (tRect.height >= 32) ? 1 : tRect.height / tempLimit;
						uv[6] = 0;
						uv[7] = (tRect.height >= 32) ? 1 : tRect.height / tempLimit;
						tRect.width = (tRect.width >= 32) ? tRect.width : tempLimit;
						tRect.height = (tRect.height >= 32) ? tRect.height : tempLimit;
						uv[1] *= -1; uv[3] *= -1; uv[5] *= -1; uv[7] *= -1;
						uv[1] += 1; uv[3] += 1; uv[5] += 1; uv[7] += 1;
					}
					(context.ctx).drawTarget(scope, x + tRect.x - tf.translateX, y + tRect.y - tf.translateY, w, h, Matrix.TEMP, "tmpTarget", shaderValue, uv, 6);
					submitCMD = SubmitCMD.create([scope], laya.webgl.utils.RenderSprite3D.recycleTarget);
					context.addRenderObject(submitCMD);
					submitStencil = SubmitStencil.create(6);
					submitStencil.blendMode = preBlendMode;
					context.addRenderObject(submitStencil);
				}
				context.ctx.restore();
			}
			else {
				next._fun.call(next, sprite, context, x, y);
			}
		}

		__proto._blend = function (sprite, context, x, y) {
			var style = sprite._style;
			var next = this._next;
			if (style.blendMode) {
				context.ctx.save();
				context.ctx.globalCompositeOperation = style.blendMode;
				next._fun.call(next, sprite, context, x, y);
				context.ctx.restore();
			}
			else {
				next._fun.call(next, sprite, context, x, y);
			}
		}

		__proto._transform = function (sprite, context, x, y) {
			'use strict';
			var transform = sprite.transform, _next = this._next;
			if (transform && _next != RenderSprite.NORENDER) {
				var ctx = context.ctx;
				var style = sprite._style;
				transform.tx = x;
				transform.ty = y;
				var m2 = ctx._getTransformMatrix();
				var m1 = m2.clone();
				Matrix.mul(transform, m2, m2);
				m2._checkTransform();
				transform.tx = transform.ty = 0;
				_next._fun.call(_next, sprite, context, 0, 0);
				m1.copyTo(m2);
				m1.destroy();
			} else {
				_next._fun.call(_next, sprite, context, x, y);
			}
		}

		RenderSprite3D.tmpTarget = function (scope, context) {
			var b = scope.getValue("bounds");
			var tmpTarget = RenderTarget2D.create(b.width, b.height);
			tmpTarget.start();
			tmpTarget.clear(0, 0, 0, 0);
			scope.addValue("tmpTarget", tmpTarget);
		}

		RenderSprite3D.endTmpTarget = function (scope) {
			var tmpTarget = scope.getValue("tmpTarget");
			tmpTarget.end();
		}

		RenderSprite3D.recycleTarget = function (scope) {
			var tmpTarget = scope.getValue("tmpTarget");
			tmpTarget.recycle();
			scope.recycle();
		}

		__static(RenderSprite3D,
			['tempUV', function () { return this.tempUV = new Array(8); }
			]);
		return RenderSprite3D;
	})(RenderSprite)


	//class laya.filters.webgl.ColorFilterActionGL extends laya.filters.webgl.FilterActionGL
	var ColorFilterActionGL = (function (_super) {
		function ColorFilterActionGL() {
			this.data = null;
			ColorFilterActionGL.__super.call(this);
		}

		__class(ColorFilterActionGL, 'laya.filters.webgl.ColorFilterActionGL', _super);
		var __proto = ColorFilterActionGL.prototype;
		Laya.imps(__proto, { "laya.filters.IFilterActionGL": true })
		__proto.setValue = function (shader) {
			shader.colorMat = this.data._mat;
			shader.colorAlpha = this.data._alpha;
		}

		__proto.apply3d = function (scope, sprite, context, x, y) {
			var b = scope.getValue("bounds");
			var shaderValue = Value2D.create(/*laya.webgl.shader.d2.ShaderDefines2D.TEXTURE2D*/0x01, 0);
			shaderValue.setFilters([this.data]);
			var tMatrix = Matrix.TEMP;
			tMatrix.identity();
			context.ctx.drawTarget(scope, 0, 0, b.width, b.height, tMatrix, "src", shaderValue);
		}

		return ColorFilterActionGL;
	})(FilterActionGL)


	//class laya.webgl.atlas.Atlaser extends laya.webgl.atlas.AtlasGrid
	var Atlaser = (function (_super) {
		function Atlaser(gridNumX, gridNumY, width, height, atlasID) {
			this._atlasCanvas = null;
			this._inAtlasTextureKey = null;
			this._inAtlasTextureBitmapValue = null;
			this._inAtlasTextureOriUVValue = null;
			this._InAtlasWebGLImagesKey = null;
			this._InAtlasWebGLImagesOffsetValue = null;
			Atlaser.__super.call(this, gridNumX, gridNumY, atlasID);
			this._inAtlasTextureKey = [];
			this._inAtlasTextureBitmapValue = [];
			this._inAtlasTextureOriUVValue = [];
			this._InAtlasWebGLImagesKey = {};
			this._InAtlasWebGLImagesOffsetValue = [];
			this._atlasCanvas = new AtlasWebGLCanvas();
			this._atlasCanvas._atlaser = this;
			this._atlasCanvas.width = width;
			this._atlasCanvas.height = height;
			this._atlasCanvas.activeResource();
			this._atlasCanvas.lock = true;
		}

		__class(Atlaser, 'laya.webgl.atlas.Atlaser', _super);
		var __proto = Atlaser.prototype;
		__proto.computeUVinAtlasTexture = function (texture, oriUV, offsetX, offsetY) {
			var tex = texture;
			var _width = AtlasResourceManager.atlasTextureWidth;
			var _height = AtlasResourceManager.atlasTextureHeight;
			var u1 = offsetX / _width, v1 = offsetY / _height, u2 = (offsetX + texture.bitmap.width) / _width, v2 = (offsetY + texture.bitmap.height) / _height;
			var inAltasUVWidth = texture.bitmap.width / _width, inAltasUVHeight = texture.bitmap.height / _height;
			texture.uv = [u1 + oriUV[0] * inAltasUVWidth, v1 + oriUV[1] * inAltasUVHeight, u2 - (1 - oriUV[2]) * inAltasUVWidth, v1 + oriUV[3] * inAltasUVHeight, u2 - (1 - oriUV[4]) * inAltasUVWidth, v2 - (1 - oriUV[5]) * inAltasUVHeight, u1 + oriUV[6] * inAltasUVWidth, v2 - (1 - oriUV[7]) * inAltasUVHeight];
		}

		__proto.findBitmapIsExist = function (bitmap) {
			if ((bitmap instanceof laya.webgl.resource.WebGLImage)) {
				var webImage = bitmap;
				var sUrl = webImage.url;
				var object = this._InAtlasWebGLImagesKey[sUrl ? sUrl : webImage.id]
				if (object) {
					return object.offsetInfoID;
				}
			}
			return -1;
		}

		/**
		*
		*@param inAtlasRes
		*@return 是否已经存在队列中
		*/
		__proto.addToAtlasTexture = function (mergeAtlasBitmap, offsetX, offsetY) {
			if ((mergeAtlasBitmap instanceof laya.webgl.resource.WebGLImage)) {
				var webImage = mergeAtlasBitmap;
				var sUrl = webImage.url;
				this._InAtlasWebGLImagesKey[sUrl ? sUrl : webImage.id] = { bitmap: mergeAtlasBitmap, offsetInfoID: this._InAtlasWebGLImagesOffsetValue.length };
				this._InAtlasWebGLImagesOffsetValue.push([offsetX, offsetY]);
			}
			this._atlasCanvas.texSubImage2D(offsetX, offsetY, mergeAtlasBitmap.atlasSource);
			mergeAtlasBitmap.clearAtlasSource();
		}

		__proto.addToAtlas = function (texture, offsetX, offsetY) {
			texture._atlasID = this._inAtlasTextureKey.length;
			var oriUV = texture.uv.slice();
			var oriBitmap = texture.bitmap;
			this._inAtlasTextureKey.push(texture);
			this._inAtlasTextureOriUVValue.push(oriUV);
			this._inAtlasTextureBitmapValue.push(oriBitmap);
			this.computeUVinAtlasTexture(texture, oriUV, offsetX, offsetY);
			texture.bitmap = this._atlasCanvas;
		}

		__proto.clear = function () {
			for (var i = 0, n = this._inAtlasTextureKey.length; i < n; i++) {
				this._inAtlasTextureKey[i].bitmap = this._inAtlasTextureBitmapValue[i];
				this._inAtlasTextureKey[i].uv = this._inAtlasTextureOriUVValue[i];
				this._inAtlasTextureKey[i]._atlasID = -1;
				this._inAtlasTextureKey[i].bitmap.lock = false;
				this._inAtlasTextureKey[i].bitmap.releaseResource();
			}
			this._inAtlasTextureKey.length = 0;
			this._inAtlasTextureBitmapValue.length = 0;
			this._inAtlasTextureOriUVValue.length = 0;
			this._InAtlasWebGLImagesKey = null;
			this._InAtlasWebGLImagesOffsetValue.length = 0;
		}

		__proto.dispose = function () {
			this.clear();
			this._atlasCanvas.destroy();
		}

		__getset(0, __proto, 'InAtlasWebGLImagesOffsetValue', function () {
			return this._InAtlasWebGLImagesOffsetValue;
		});

		__getset(0, __proto, 'texture', function () {
			return this._atlasCanvas;
		});

		__getset(0, __proto, 'inAtlasWebGLImagesKey', function () {
			return this._InAtlasWebGLImagesKey;
		});

		return Atlaser;
	})(AtlasGrid)


	//class laya.webgl.shader.d2.ShaderDefines2D extends laya.webgl.shader.ShaderDefines
	var ShaderDefines2D = (function (_super) {
		function ShaderDefines2D() {
			ShaderDefines2D.__super.call(this, ShaderDefines2D.__name2int, ShaderDefines2D.__int2name, ShaderDefines2D.__int2nameMap);
		}

		__class(ShaderDefines2D, 'laya.webgl.shader.d2.ShaderDefines2D', _super);
		ShaderDefines2D.__init__ = function () {
			ShaderDefines2D.reg("TEXTURE2D", 0x01);
			ShaderDefines2D.reg("COLOR2D", 0x02);
			ShaderDefines2D.reg("PRIMITIVE", 0x04);
			ShaderDefines2D.reg("GLOW_FILTER", 0x08);
			ShaderDefines2D.reg("BLUR_FILTER", 0x10);
			ShaderDefines2D.reg("COLOR_FILTER", 0x20);
			ShaderDefines2D.reg("COLOR_ADD", 0x40);
			ShaderDefines2D.reg("WORLDMAT", 0x80);
			ShaderDefines2D.reg("FILLTEXTURE", 0x100);
			ShaderDefines2D.reg("FSHIGHPRECISION", 0x400);
		}

		ShaderDefines2D.reg = function (name, value) {
			ShaderDefines._reg(name, value, ShaderDefines2D.__name2int, ShaderDefines2D.__int2name);
		}

		ShaderDefines2D.toText = function (value, int2name, int2nameMap) {
			return ShaderDefines._toText(value, int2name, int2nameMap);
		}

		ShaderDefines2D.toInt = function (names) {
			return ShaderDefines._toInt(names, ShaderDefines2D.__name2int);
		}

		ShaderDefines2D.TEXTURE2D = 0x01;
		ShaderDefines2D.COLOR2D = 0x02;
		ShaderDefines2D.PRIMITIVE = 0x04;
		ShaderDefines2D.FILTERGLOW = 0x08;
		ShaderDefines2D.FILTERBLUR = 0x10;
		ShaderDefines2D.FILTERCOLOR = 0x20;
		ShaderDefines2D.COLORADD = 0x40;
		ShaderDefines2D.WORLDMAT = 0x80;
		ShaderDefines2D.FILLTEXTURE = 0x100;
		ShaderDefines2D.SKINMESH = 0x200;
		ShaderDefines2D.SHADERDEFINE_FSHIGHPRECISION = 0x400;
		ShaderDefines2D.__name2int = {};
		ShaderDefines2D.__int2name = [];
		ShaderDefines2D.__int2nameMap = [];
		return ShaderDefines2D;
	})(ShaderDefines)


	//class laya.webgl.shapes.Ellipse extends laya.webgl.shapes.BasePoly
	var Ellipse = (function (_super) {
		function Ellipse(x, y, width, height, color, borderWidth, borderColor) {
			Ellipse.__super.call(this, x, y, width, height, 40, color, borderWidth, borderColor);
		}

		__class(Ellipse, 'laya.webgl.shapes.Ellipse', _super);
		return Ellipse;
	})(BasePoly)


	//class laya.webgl.shapes.Line extends laya.webgl.shapes.BasePoly
	var Line = (function (_super) {
		function Line(x, y, points, borderWidth, color) {
			this._points = [];
			this.rebuild(points);
			Line.__super.call(this, x, y, 0, 0, 0, color, borderWidth, color, 0);
		}

		__class(Line, 'laya.webgl.shapes.Line', _super);
		var __proto = Line.prototype;
		__proto.rebuild = function (points) {
			var len = points.length;
			var preLen = this._points.length;
			if (len != preLen) {
				this.mUint16Array = new Uint16Array((len / 2 - 1) * 6);
				this.mFloat32Array = new Float32Array(len * 5);
			}
			this._points.length = 0;
			var tCurrX = NaN;
			var tCurrY = NaN;
			var tLastX = -1;
			var tLastY = -1;
			var tLen = points.length / 2;
			for (var i = 0; i < tLen; i++) {
				tCurrX = points[i * 2];
				tCurrY = points[i * 2 + 1];
				if (Math.abs(tLastX - tCurrX) > 0.01 || Math.abs(tLastY - tCurrY) > 0.01) {
					this._points.push(tCurrX, tCurrY);
				}
				tLastX = tCurrX;
				tLastY = tCurrY;
			}
		}

		__proto.getData = function (ib, vb, start) {
			var indices = [];
			var verts = [];
			(this.borderWidth > 0) && this.createLine2(this._points, indices, this.borderWidth, start, verts, this._points.length / 2);
			this.mUint16Array.set(indices, 0);
			this.mFloat32Array.set(verts, 0);
			ib.append(this.mUint16Array);
			vb.append(this.mFloat32Array);
		}

		return Line;
	})(BasePoly)


	//class laya.webgl.shapes.LoopLine extends laya.webgl.shapes.BasePoly
	var LoopLine = (function (_super) {
		function LoopLine(x, y, points, width, color) {
			this._points = [];
			var tCurrX = NaN;
			var tCurrY = NaN;
			var tLastX = -1;
			var tLastY = -1;
			var tLen = points.length / 2 - 1;
			for (var i = 0; i < tLen; i++) {
				tCurrX = points[i * 2];
				tCurrY = points[i * 2 + 1];
				if (Math.abs(tLastX - tCurrX) > 0.01 || Math.abs(tLastY - tCurrY) > 0.01) {
					this._points.push(tCurrX, tCurrY);
				}
				tLastX = tCurrX;
				tLastY = tCurrY;
			}
			tCurrX = points[tLen * 2];
			tCurrY = points[tLen * 2 + 1];
			tLastX = this._points[0];
			tLastY = this._points[1];
			if (Math.abs(tLastX - tCurrX) > 0.01 || Math.abs(tLastY - tCurrY) > 0.01) {
				this._points.push(tCurrX, tCurrY);
			}
			LoopLine.__super.call(this, x, y, 0, 0, this._points.length / 2, 0, width, color);
		}

		__class(LoopLine, 'laya.webgl.shapes.LoopLine', _super);
		var __proto = LoopLine.prototype;
		__proto.getData = function (ib, vb, start) {
			if (this.borderWidth > 0) {
				var color = this.color;
				var r = ((color >> 16) & 0x0000ff) / 255, g = ((color >> 8) & 0xff) / 255, b = (color & 0x0000ff) / 255;
				var verts = [];
				var tLastX = -1, tLastY = -1;
				var tCurrX = 0, tCurrY = 0;
				var indices = [];
				var tLen = Math.floor(this._points.length / 2);
				for (var i = 0; i < tLen; i++) {
					tCurrX = this._points[i * 2];
					tCurrY = this._points[i * 2 + 1];
					verts.push(this.x + tCurrX, this.y + tCurrY, r, g, b);
				}
				this.createLoopLine(verts, indices, this.borderWidth, start + verts.length / 5);
				ib.append(new Uint16Array(indices));
				vb.append(new Float32Array(verts));
			}
		}

		__proto.createLoopLine = function (p, indices, lineWidth, len, outVertex, outIndex) {
			var tLen = p.length / 5;
			var points = p.concat();
			var result = outVertex ? outVertex : p;
			var color = this.borderColor;
			var r = ((color >> 16) & 0x0000ff) / 255, g = ((color >> 8) & 0xff) / 255, b = (color & 0x0000ff) / 255;
			var firstPoint = [points[0], points[1]];
			var lastPoint = [points[points.length - 5], points[points.length - 4]];
			var midPointX = lastPoint[0] + (firstPoint[0] - lastPoint[0]) * 0.5;
			var midPointY = lastPoint[1] + (firstPoint[1] - lastPoint[1]) * 0.5;
			points.unshift(midPointX, midPointY, 0, 0, 0);
			points.push(midPointX, midPointY, 0, 0, 0);
			var length = points.length / 5;
			var iStart = len, w = lineWidth / 2;
			var px, py, p1x, p1y, p2x, p2y, p3x, p3y;
			var perpx, perpy, perp2x, perp2y, perp3x, perp3y;
			var a1, b1, c1, a2, b2, c2;
			var denom, pdist, dist;
			p1x = points[0];
			p1y = points[1];
			p2x = points[5];
			p2y = points[6];
			perpx = -(p1y - p2y);
			perpy = p1x - p2x;
			dist = Math.sqrt(perpx * perpx + perpy * perpy);
			perpx = perpx / dist * w;
			perpy = perpy / dist * w;
			result.push(p1x - perpx, p1y - perpy, r, g, b, p1x + perpx, p1y + perpy, r, g, b);
			for (var i = 1; i < length - 1; i++) {
				p1x = points[(i - 1) * 5];
				p1y = points[(i - 1) * 5 + 1];
				p2x = points[(i) * 5];
				p2y = points[(i) * 5 + 1];
				p3x = points[(i + 1) * 5];
				p3y = points[(i + 1) * 5 + 1];
				perpx = -(p1y - p2y);
				perpy = p1x - p2x;
				dist = Math.sqrt(perpx * perpx + perpy * perpy);
				perpx = perpx / dist * w;
				perpy = perpy / dist * w;
				perp2x = -(p2y - p3y);
				perp2y = p2x - p3x;
				dist = Math.sqrt(perp2x * perp2x + perp2y * perp2y);
				perp2x = perp2x / dist * w;
				perp2y = perp2y / dist * w;
				a1 = (-perpy + p1y) - (-perpy + p2y);
				b1 = (-perpx + p2x) - (-perpx + p1x);
				c1 = (-perpx + p1x) * (-perpy + p2y) - (-perpx + p2x) * (-perpy + p1y);
				a2 = (-perp2y + p3y) - (-perp2y + p2y);
				b2 = (-perp2x + p2x) - (-perp2x + p3x);
				c2 = (-perp2x + p3x) * (-perp2y + p2y) - (-perp2x + p2x) * (-perp2y + p3y);
				denom = a1 * b2 - a2 * b1;
				if (Math.abs(denom) < 0.1) {
					denom += 10.1;
					result.push(p2x - perpx, p2y - perpy, r, g, b, p2x + perpx, p2y + perpy, r, g, b);
					continue;
				}
				px = (b1 * c2 - b2 * c1) / denom;
				py = (a2 * c1 - a1 * c2) / denom;
				pdist = (px - p2x) * (px - p2x) + (py - p2y) + (py - p2y);
				result.push(px, py, r, g, b, p2x - (px - p2x), p2y - (py - p2y), r, g, b);
			}
			if (outIndex) {
				indices = outIndex;
			};
			var groupLen = this.edges + 1;
			for (i = 1; i < groupLen; i++) {
				indices.push(iStart + (i - 1) * 2, iStart + (i - 1) * 2 + 1, iStart + i * 2 + 1, iStart + i * 2 + 1, iStart + i * 2, iStart + (i - 1) * 2);
			}
			indices.push(iStart + (i - 1) * 2, iStart + (i - 1) * 2 + 1, iStart + 1, iStart + 1, iStart, iStart + (i - 1) * 2);
			return result;
		}

		return LoopLine;
	})(BasePoly)


	//class laya.webgl.shapes.Polygon extends laya.webgl.shapes.BasePoly
	var Polygon = (function (_super) {
		function Polygon(x, y, points, color, borderWidth, borderColor) {
			this._points = null;
			this._start = -1;
			this._repaint = false;
			this.earcutTriangles = null;
			this._mat = Matrix.create();
			this._points = points.slice(0, points.length);
			Polygon.__super.call(this, x, y, 0, 0, this._points.length / 2, color, borderWidth, borderColor);
		}

		__class(Polygon, 'laya.webgl.shapes.Polygon', _super);
		var __proto = Polygon.prototype;
		__proto.rebuild = function (point) {
			if (!this._repaint) {
				this._points.length = 0;
				this._points = this._points.concat(point);
			}
		}

		__proto.setMatrix = function (mat) {
			mat.copyTo(this._mat);
		}

		__proto.needUpdate = function (mat) {
			this._repaint = (this._mat.a == mat.a && this._mat.b == mat.b && this._mat.c == mat.c && this._mat.d == mat.d && this._mat.tx == mat.tx && this._mat.ty == mat.ty);
			return !this._repaint;
		}

		__proto.getData = function (ib, vb, start) {
			var indices, i = 0;
			var tArray = this._points;
			var tLen = 0;
			if (this.mUint16Array && this.mFloat32Array && this._repaint) {
				if (this._start != start) {
					this._start = start;
					indices = [];
					tLen = this.earcutTriangles.length;
					for (i = 0; i < tLen; i++) {
						indices.push(this.earcutTriangles[i] + start);
					}
					this.mUint16Array = new Uint16Array(indices);
				}
			}
			else {
				this._start = start;
				indices = [];
				var verts = [];
				var vertsEarcut = [];
				var color = this.color;
				var r = ((color >> 16) & 0x0000ff) / 255, g = ((color >> 8) & 0xff) / 255, b = (color & 0x0000ff) / 255;
				tLen = Math.floor(tArray.length / 2);
				for (i = 0; i < tLen; i++) {
					verts.push(this.x + tArray[i * 2], this.y + tArray[i * 2 + 1], r, g, b);
					vertsEarcut.push(this.x + tArray[i * 2], this.y + tArray[i * 2 + 1]);
				}
				this.earcutTriangles = Earcut.earcut(vertsEarcut, null, 2);
				tLen = this.earcutTriangles.length;
				for (i = 0; i < tLen; i++) {
					indices.push(this.earcutTriangles[i] + start);
				}
				this.mUint16Array = new Uint16Array(indices);
				this.mFloat32Array = new Float32Array(verts);
			}
			ib.append(this.mUint16Array);
			vb.append(this.mFloat32Array);
		}

		return Polygon;
	})(BasePoly)


	//class laya.webgl.submit.SubmitCanvas extends laya.webgl.submit.Submit
	var SubmitCanvas = (function (_super) {
		function SubmitCanvas() {
			//this._ctx_src=null;
			this._matrix = new Matrix();
			this._matrix4 = CONST3D2D.defaultMatrix4.concat();
			SubmitCanvas.__super.call(this,/*laya.webgl.submit.Submit.TYPE_2D*/10000);
			this.shaderValue = new Value2D(0, 0);
		}

		__class(SubmitCanvas, 'laya.webgl.submit.SubmitCanvas', _super);
		var __proto = SubmitCanvas.prototype;
		__proto.renderSubmit = function () {
			if (this._ctx_src._targets) {
				this._ctx_src._targets.flush(this._ctx_src);
				return 1;
			};
			var preAlpha = RenderState2D.worldAlpha;
			var preMatrix4 = RenderState2D.worldMatrix4;
			var preMatrix = RenderState2D.worldMatrix;
			var preFilters = RenderState2D.worldFilters;
			var preWorldShaderDefines = RenderState2D.worldShaderDefines;
			var v = this.shaderValue;
			var m = this._matrix;
			var m4 = this._matrix4;
			var mout = Matrix.TEMP;
			Matrix.mul(m, preMatrix, mout);
			m4[0] = mout.a;
			m4[1] = mout.b;
			m4[4] = mout.c;
			m4[5] = mout.d;
			m4[12] = mout.tx;
			m4[13] = mout.ty;
			RenderState2D.worldMatrix = mout.clone();
			RenderState2D.worldMatrix4 = m4;
			RenderState2D.worldAlpha = RenderState2D.worldAlpha * v.alpha;
			if (v.filters && v.filters.length) {
				RenderState2D.worldFilters = v.filters;
				RenderState2D.worldShaderDefines = v.defines;
			}
			this._ctx_src.flush();
			RenderState2D.worldAlpha = preAlpha;
			RenderState2D.worldMatrix4 = preMatrix4;
			RenderState2D.worldMatrix.destroy();
			RenderState2D.worldMatrix = preMatrix;
			RenderState2D.worldFilters = preFilters;
			RenderState2D.worldShaderDefines = preWorldShaderDefines;
			return 1;
		}

		__proto.releaseRender = function () {
			var cache = SubmitCanvas._cache;
			this._ctx_src = null;
			cache[cache._length++] = this;
		}

		__proto.getRenderType = function () {
			return /*laya.webgl.submit.Submit.TYPE_CANVAS*/10003;
		}

		SubmitCanvas.create = function (ctx_src, alpha, filters) {
			var o = (!SubmitCanvas._cache._length) ? (new SubmitCanvas()) : SubmitCanvas._cache[--SubmitCanvas._cache._length];
			o._ctx_src = ctx_src;
			var v = o.shaderValue;
			v.alpha = alpha;
			v.defines.setValue(0);
			filters && filters.length && v.setFilters(filters);
			return o;
		}

		SubmitCanvas._cache = (SubmitCanvas._cache = [], SubmitCanvas._cache._length = 0, SubmitCanvas._cache);
		return SubmitCanvas;
	})(Submit)


	//class laya.webgl.submit.SubmitTexture extends laya.webgl.submit.Submit
	var SubmitTexture = (function (_super) {
		function SubmitTexture(renderType) {
			this._preIsSameTextureShader = false;
			this._isSameTexture = true;
			this._texs = new Array;
			this._texsID = new Array;
			this._vbPos = new Array;
			(renderType === void 0) && (renderType = 10000);
			SubmitTexture.__super.call(this, renderType);
		}

		__class(SubmitTexture, 'laya.webgl.submit.SubmitTexture', _super);
		var __proto = SubmitTexture.prototype;
		__proto.releaseRender = function () {
			var cache = SubmitTexture._cache;
			cache[cache._length++] = this;
			this.shaderValue.release();
			this._preIsSameTextureShader = false;
			this._vb = null;
			this._texs.length = 0;
			this._vbPos.length = 0;
			this._isSameTexture = true;
		}

		__proto.addTexture = function (tex, vbpos) {
			this._texsID[this._texs.length] = tex._uvID;
			this._texs.push(tex);
			this._vbPos.push(vbpos);
		}

		//检查材质是否修改，修改UV，设置是否是同一材质
		__proto.checkTexture = function () {
			if (this._texs.length < 1) {
				this._isSameTexture = true;
				return;
			};
			var _tex = this.shaderValue.textureHost;
			var webGLImg = _tex.bitmap;
			if (webGLImg === null) return;
			var vbdata = this._vb.getFloat32Array();
			for (var i = 0, s = this._texs.length; i < s; i++) {
				var tex = this._texs[i];
				tex.active();
				var newUV = tex.uv;
				if (this._texsID[i] !== tex._uvID) {
					this._texsID[i] = tex._uvID;
					var vbPos = this._vbPos[i];
					vbdata[vbPos + 2] = newUV[0];
					vbdata[vbPos + 3] = newUV[1];
					vbdata[vbPos + 6] = newUV[2];
					vbdata[vbPos + 7] = newUV[3];
					vbdata[vbPos + 10] = newUV[4];
					vbdata[vbPos + 11] = newUV[5];
					vbdata[vbPos + 14] = newUV[6];
					vbdata[vbPos + 15] = newUV[7];
					this._vb.setNeedUpload();
				}
				if (tex.bitmap !== webGLImg) {
					this._isSameTexture = false;
				}
			}
		}

		__proto.renderSubmit = function () {
			if (this._numEle === 0) {
				SubmitTexture._shaderSet = false;
				return 1;
			};
			var _tex = this.shaderValue.textureHost;
			if (_tex) {
				var source = _tex.source;
				if (!_tex.bitmap || !source) {
					SubmitTexture._shaderSet = false;
					return 1;
				}
				this.shaderValue.texture = source;
			}
			this._vb.bind_upload(this._ib);
			var gl = WebGL.mainContext;
			if (BlendMode.activeBlendFunction !== this._blendFn) {
				gl.enable(/*laya.webgl.WebGLContext.BLEND*/0x0BE2);
				this._blendFn(gl);
				BlendMode.activeBlendFunction = this._blendFn;
			}
			Stat.drawCall++;
			Stat.trianglesFaces += this._numEle / 3;
			if (this._preIsSameTextureShader && BaseShader.activeShader && SubmitTexture._shaderSet)
				(BaseShader.activeShader).uploadTexture2D(this.shaderValue.texture);
			else this.shaderValue.upload();
			SubmitTexture._shaderSet = true;
			if (this._texs.length > 1 && !this._isSameTexture) {
				var webGLImg = _tex.bitmap;
				var index = 0;
				var shader = BaseShader.activeShader;
				for (var i = 0, s = this._texs.length; i < s; i++) {
					var tex2 = this._texs[i];
					if (tex2.bitmap !== webGLImg || (i + 1) === s) {
						shader.uploadTexture2D(tex2.source);
						gl.drawElements(/*laya.webgl.WebGLContext.TRIANGLES*/0x0004, (i - index + 1) * 6,/*laya.webgl.WebGLContext.UNSIGNED_SHORT*/0x1403, this._startIdx + index * 6 * CONST3D2D.BYTES_PIDX);
						webGLImg = tex2.bitmap;
						index = i;
					}
				}
			} else {
				gl.drawElements(/*laya.webgl.WebGLContext.TRIANGLES*/0x0004, this._numEle,/*laya.webgl.WebGLContext.UNSIGNED_SHORT*/0x1403, this._startIdx);
			}
			return 1;
		}

		SubmitTexture.create = function (context, ib, vb, pos, sv) {
			var o = SubmitTexture._cache._length ? SubmitTexture._cache[--SubmitTexture._cache._length] : new SubmitTexture();
			if (vb == null) {
				vb = o._selfVb || (o._selfVb = VertexBuffer2D.create(-1));
				vb.clear();
				pos = 0;
			}
			o._ib = ib;
			o._vb = vb;
			o._startIdx = pos * CONST3D2D.BYTES_PIDX;
			o._numEle = 0;
			var blendType = context._nBlendType;
			o._blendFn = context._targets ? BlendMode.targetFns[blendType] : BlendMode.fns[blendType];
			o.shaderValue = sv;
			o.shaderValue.setValue(context._shader2D);
			var filters = context._shader2D.filters;
			filters && o.shaderValue.setFilters(filters);
			return o;
		}

		SubmitTexture._cache = (SubmitTexture._cache = [], SubmitTexture._cache._length = 0, SubmitTexture._cache);
		SubmitTexture._shaderSet = true;
		return SubmitTexture;
	})(Submit)


	/**
	*与MeshQuadTexture基本相同。不过index不是固定的
	*/
	//class laya.webgl.utils.MeshTexture extends laya.webgl.utils.Mesh2D
	var MeshTexture = (function (_super) {
		function MeshTexture() {
			MeshTexture.__super.call(this, laya.webgl.utils.MeshTexture.const_stride, 0, 0);
			this.canReuse = true;
			this.setAttributes(laya.webgl.utils.MeshTexture._fixattriInfo);
		}

		__class(MeshTexture, 'laya.webgl.utils.MeshTexture', _super);
		var __proto = MeshTexture.prototype;
		__proto.addData = function (vertices, uvs, idx, matrix, rgba, ctx) {
			var sz = vertices.length / 2;
			var startpos = this._vb.needSize(sz * MeshTexture.const_stride);
			var f32pos = startpos >> 2;
			var vbdata = this._vb.getFloat32Array();
			var ci = 0;
			for (var i = 0; i < sz; i++) {
				var x = vertices[ci], y = vertices[ci + 1];
				var x1 = x * matrix.a + y * matrix.c + matrix.tx;
				var y1 = x * matrix.b + y * matrix.d + matrix.ty;
				vbdata[f32pos++] = x1; vbdata[f32pos++] = y1;
				vbdata[f32pos++] = uvs[ci]; vbdata[f32pos++] = uvs[ci + 1];
				ci += 2;
			}
			this._vb.setNeedUpload();
			var vertN = this.vertNum;
			if (vertN > 0) {
				sz = idx.length;
				if (sz > MeshTexture.tmpIdx.length) MeshTexture.tmpIdx = new Uint16Array(sz);
				for (var ii = 0; ii < sz; ii++) {
					MeshTexture.tmpIdx[ii] = idx[ii] + vertN;
				}
				this._ib.appendU16Array(MeshTexture.tmpIdx, idx.length);
			} else {
				this._ib.append(idx);
			}
			this._ib.setNeedUpload();
			this.vertNum += sz;
			this.indexNum += idx.length;
		}

		/**
		*把本对象放到回收池中，以便getMesh能用。
		*/
		__proto.releaseMesh = function () {
			this._vb._byteLength = 0;
			this._ib._byteLength = 0;
			this.vertNum = 0;
			this.indexNum = 0;
			laya.webgl.utils.MeshTexture._POOL.push(this);
		}

		__proto.destroy = function () {
			this._ib.destroy();
			this._vb.destroy();
		}

		MeshTexture.getAMesh = function () {
			if (laya.webgl.utils.MeshTexture._POOL.length) {
				return laya.webgl.utils.MeshTexture._POOL.pop();
			}
			return new MeshTexture();
		}

		MeshTexture.const_stride = 16;
		MeshTexture._POOL = [];
		__static(MeshTexture,
			['_fixattriInfo', function () {
				return this._fixattriInfo = [
		/*laya.webgl.WebGLContext.FLOAT*/0x1406, 2, 0,
		/*laya.webgl.WebGLContext.FLOAT*/0x1406, 2, 8];
			}, 'tmpIdx', function () { return this.tmpIdx = new Uint16Array(4); }
			]);
		return MeshTexture;
	})(Mesh2D)


	/**
	*...
	*@author ...
	*/
	//class laya.webgl.shader.BaseShader extends laya.resource.Resource
	var BaseShader = (function (_super) {
		function BaseShader() {
			BaseShader.__super.call(this);
			this.lock = true;
		}

		__class(BaseShader, 'laya.webgl.shader.BaseShader', _super);
		BaseShader.activeShader = null;
		BaseShader.bindShader = null;
		return BaseShader;
	})(Resource)


	//class laya.webgl.resource.RenderTarget2D extends laya.resource.Texture
	var RenderTarget2D = (function (_super) {
		function RenderTarget2D(width, height, surfaceFormat, surfaceType, depthStencilFormat, mipMap, repeat, minFifter, magFifter) {
			this._type = 0;
			this._svWidth = NaN;
			this._svHeight = NaN;
			this._preRenderTarget = null;
			//TODO:.........................................................
			this._alreadyResolved = false;
			this._looked = false;
			this._surfaceFormat = 0;
			this._surfaceType = 0;
			this._depthStencilFormat = 0;
			this._mipMap = false;
			this._repeat = false;
			this._minFifter = 0;
			this._magFifter = 0;
			this._destroy = false;
			(surfaceFormat === void 0) && (surfaceFormat =/*laya.webgl.WebGLContext.RGBA*/0x1908);
			(surfaceType === void 0) && (surfaceType =/*laya.webgl.WebGLContext.UNSIGNED_BYTE*/0x1401);
			(depthStencilFormat === void 0) && (depthStencilFormat =/*laya.webgl.WebGLContext.DEPTH_STENCIL*/0x84F9);
			(mipMap === void 0) && (mipMap = false);
			(repeat === void 0) && (repeat = false);
			(minFifter === void 0) && (minFifter = -1);
			(magFifter === void 0) && (magFifter = -1);
			this._type = 1;
			this._w = width;
			this._h = height;
			this._surfaceFormat = surfaceFormat;
			this._surfaceType = surfaceType;
			this._depthStencilFormat = depthStencilFormat;
			this._mipMap = mipMap;
			this._repeat = repeat;
			this._minFifter = minFifter;
			this._magFifter = magFifter;
			this._createWebGLRenderTarget();
			this.bitmap.lock = true;
			RenderTarget2D.__super.call(this, this.bitmap, Texture.INV_UV);
		}

		__class(RenderTarget2D, 'laya.webgl.resource.RenderTarget2D', _super);
		var __proto = RenderTarget2D.prototype;
		Laya.imps(__proto, { "laya.resource.IDispose": true })
		//TODO:临时......................................................
		__proto.getType = function () {
			return this._type;
		}

		//*/
		__proto.getTexture = function () {
			return this;
		}

		__proto.size = function (w, h) {
			if (this._w == w && this._h == h) return;
			this._w = w;
			this._h = h;
			this.release();
			if (this._w != 0 && this._h != 0) this._createWebGLRenderTarget();
		}

		__proto.release = function () {
			this.destroy();
		}

		__proto.recycle = function () {
			RenderTarget2D.POOL.push(this);
		}

		__proto.start = function () {
			var gl = WebGL.mainContext;
			this._preRenderTarget = RenderState2D.curRenderTarget;
			RenderState2D.curRenderTarget = this;
			gl.bindFramebuffer(/*laya.webgl.WebGLContext.FRAMEBUFFER*/0x8D40, this.bitmap.frameBuffer);
			this._alreadyResolved = false;
			if (this._type == 1) {
				gl.viewport(0, 0, this._w, this._h);
				this._svWidth = RenderState2D.width;
				this._svHeight = RenderState2D.height;
				RenderState2D.width = this._w;
				RenderState2D.height = this._h;
				BaseShader.activeShader = null;
			}
			return this;
		}

		__proto.clear = function (r, g, b, a) {
			(r === void 0) && (r = 0.0);
			(g === void 0) && (g = 0.0);
			(b === void 0) && (b = 0.0);
			(a === void 0) && (a = 1.0);
			var gl = WebGL.mainContext;
			gl.clearColor(r, g, b, a);
			var clearFlag =/*laya.webgl.WebGLContext.COLOR_BUFFER_BIT*/0x00004000;
			switch (this._depthStencilFormat) {
				case /*laya.webgl.WebGLContext.DEPTH_COMPONENT16*/0x81A5:
					clearFlag |=/*laya.webgl.WebGLContext.DEPTH_BUFFER_BIT*/0x00000100;
					break;
				case /*laya.webgl.WebGLContext.STENCIL_INDEX8*/0x8D48:
					clearFlag |=/*laya.webgl.WebGLContext.STENCIL_BUFFER_BIT*/0x00000400;
					break;
				case /*laya.webgl.WebGLContext.DEPTH_STENCIL*/0x84F9:
					clearFlag |=/*laya.webgl.WebGLContext.DEPTH_BUFFER_BIT*/0x00000100;
					clearFlag |=/*laya.webgl.WebGLContext.STENCIL_BUFFER_BIT*/0x00000400
					break;
			}
			gl.clear(clearFlag);
		}

		__proto.end = function () {
			var gl = WebGL.mainContext;
			gl.bindFramebuffer(/*laya.webgl.WebGLContext.FRAMEBUFFER*/0x8D40, this._preRenderTarget ? this._preRenderTarget.bitmap.frameBuffer : null);
			this._alreadyResolved = true;
			RenderState2D.curRenderTarget = this._preRenderTarget;
			if (this._type == 1) {
				gl.viewport(0, 0, this._svWidth, this._svHeight);
				RenderState2D.width = this._svWidth;
				RenderState2D.height = this._svHeight;
				BaseShader.activeShader = null;
			} else gl.viewport(0, 0, Laya.stage.width, Laya.stage.height);
		}

		__proto.getData = function (x, y, width, height) {
			var gl = WebGL.mainContext;
			gl.bindFramebuffer(/*laya.webgl.WebGLContext.FRAMEBUFFER*/0x8D40, (this.bitmap).frameBuffer);
			var canRead = (gl.checkFramebufferStatus(/*laya.webgl.WebGLContext.FRAMEBUFFER*/0x8D40) ===/*laya.webgl.WebGLContext.FRAMEBUFFER_COMPLETE*/0x8CD5);
			if (!canRead) {
				gl.bindFramebuffer(/*laya.webgl.WebGLContext.FRAMEBUFFER*/0x8D40, null);
				return null;
			};
			var pixels = new Uint8Array(this._w * this._h * 4);
			gl.readPixels(x, y, width, height, this._surfaceFormat, this._surfaceType, pixels);
			gl.bindFramebuffer(/*laya.webgl.WebGLContext.FRAMEBUFFER*/0x8D40, null);
			return pixels;
		}

		/**彻底清理资源,注意会强制解锁清理*/
		__proto.destroy = function (foreDiposeTexture) {
			(foreDiposeTexture === void 0) && (foreDiposeTexture = false);
			if (!this._destroy) {
				this._loaded = false;
				this.bitmap.offAll();
				this.bitmap.disposeResource();
				this.bitmap.dispose();
				this.offAll();
				this.bitmap = null;
				this._alreadyResolved = false;
				this._destroy = true;
				_super.prototype.destroy.call(this);
			}
		}

		//待测试
		__proto.dispose = function () { }
		__proto._createWebGLRenderTarget = function () {
			this.bitmap = new WebGLRenderTarget(this.width, this.height, this._surfaceFormat, this._surfaceType, this._depthStencilFormat, this._mipMap, this._repeat, this._minFifter, this._magFifter);
			this.bitmap.activeResource();
			this._alreadyResolved = true;
			this._destroy = false;
			this._loaded = true;
			this.bitmap.on(/*laya.events.Event.RECOVERED*/"recovered", this, function (e) {
				this.event(/*laya.events.Event.RECOVERED*/"recovered");
			})
		}

		__getset(0, __proto, 'surfaceFormat', function () {
			return this._surfaceFormat;
		});

		__getset(0, __proto, 'magFifter', function () {
			return this._magFifter;
		});

		__getset(0, __proto, 'surfaceType', function () {
			return this._surfaceType;
		});

		__getset(0, __proto, 'mipMap', function () {
			return this._mipMap;
		});

		__getset(0, __proto, 'depthStencilFormat', function () {
			return this._depthStencilFormat;
		});

		//}
		__getset(0, __proto, 'minFifter', function () {
			return this._minFifter;
		});

		/**返回RenderTarget的Texture*/
		__getset(0, __proto, 'source', function () {
			if (this._alreadyResolved)
				return Laya.superGet(Texture, this, 'source');
			return null;
		});

		RenderTarget2D.create = function (w, h, surfaceFormat, surfaceType, depthStencilFormat, mipMap, repeat, minFifter, magFifter) {
			(surfaceFormat === void 0) && (surfaceFormat =/*laya.webgl.WebGLContext.RGBA*/0x1908);
			(surfaceType === void 0) && (surfaceType =/*laya.webgl.WebGLContext.UNSIGNED_BYTE*/0x1401);
			(depthStencilFormat === void 0) && (depthStencilFormat =/*laya.webgl.WebGLContext.DEPTH_STENCIL*/0x84F9);
			(mipMap === void 0) && (mipMap = false);
			(repeat === void 0) && (repeat = false);
			(minFifter === void 0) && (minFifter = -1);
			(magFifter === void 0) && (magFifter = -1);
			var t = RenderTarget2D.POOL.pop();
			t || (t = new RenderTarget2D(w, h));
			if (!t.bitmap || t._w != w || t._h != h || t._surfaceFormat != surfaceFormat || t._surfaceType != surfaceType || t._depthStencilFormat != depthStencilFormat || t._mipMap != mipMap || t._repeat != repeat || t._minFifter != minFifter || t._magFifter != magFifter) {
				t._w = w;
				t._h = h;
				t._surfaceFormat = surfaceFormat;
				t._surfaceType = surfaceType;
				t._depthStencilFormat = depthStencilFormat;
				t._mipMap = mipMap;
				t._repeat = repeat;
				t._minFifter = minFifter;
				t._magFifter = magFifter;
				t.release();
				t._createWebGLRenderTarget();
			}
			return t;
		}

		RenderTarget2D.TYPE2D = 1;
		RenderTarget2D.TYPE3D = 2;
		RenderTarget2D.POOL = [];
		return RenderTarget2D;
	})(Texture)


	//class laya.webgl.utils.Buffer extends laya.resource.Resource
	var Buffer = (function (_super) {
		function Buffer() {
			this._glBuffer = null;
			this._buffer = null;
			//可能为Float32Array、Uint16Array、Uint8Array、ArrayBuffer等。
			this._bufferType = 0;
			this._bufferUsage = 0;
			this._byteLength = 0;
			Buffer.__super.call(this);
			Buffer._gl = WebGL.mainContext;
		}

		__class(Buffer, 'laya.webgl.utils.Buffer', _super);
		var __proto = Buffer.prototype;
		__proto._bind = function () {
			this.activeResource();
			if (Buffer._bindActive[this._bufferType] !== this._glBuffer) {
				(this._bufferType ===/*laya.webgl.WebGLContext.ARRAY_BUFFER*/0x8892) && (Buffer._bindVertexBuffer = this._glBuffer);
				Buffer._gl.bindBuffer(this._bufferType, Buffer._bindActive[this._bufferType] = this._glBuffer);
				BaseShader.activeShader = null;
			}
		}

		__proto.recreateResource = function () {
			this._glBuffer || (this._glBuffer = Buffer._gl.createBuffer());
			this.completeCreate();
		}

		__proto.disposeResource = function () {
			if (this._glBuffer) {
				WebGL.mainContext.deleteBuffer(this._glBuffer);
				this._glBuffer = null;
			}
			this.memorySize = 0;
		}

		__getset(0, __proto, 'bufferUsage', function () {
			return this._bufferUsage;
		});

		Buffer._gl = null;
		Buffer._bindActive = {};
		Buffer._bindVertexBuffer = null;
		Buffer._enableAtributes = [];
		return Buffer;
	})(Resource)


	//class laya.webgl.shader.d2.skinAnishader.SkinSV extends laya.webgl.shader.d2.value.Value2D
	var SkinSV = (function (_super) {
		function SkinSV(type) {
			this.texcoord = null;
			this.offsetX = 300;
			this.offsetY = 0;
			SkinSV.__super.call(this,/*laya.webgl.shader.d2.ShaderDefines2D.SKINMESH*/0x200, 0);
			var _vlen = 8 * CONST3D2D.BYTES_PE;
			this.position = [2,/*laya.webgl.WebGLContext.FLOAT*/0x1406, false, _vlen, 0];
			this.texcoord = [2,/*laya.webgl.WebGLContext.FLOAT*/0x1406, false, _vlen, 2 * CONST3D2D.BYTES_PE];
			this.color = [4,/*laya.webgl.WebGLContext.FLOAT*/0x1406, false, _vlen, 4 * CONST3D2D.BYTES_PE];
		}

		__class(SkinSV, 'laya.webgl.shader.d2.skinAnishader.SkinSV', _super);
		return SkinSV;
	})(Value2D)


	//class laya.webgl.shader.d2.value.Color2dSV extends laya.webgl.shader.d2.value.Value2D
	var Color2dSV = (function (_super) {
		function Color2dSV(args) {
			Color2dSV.__super.call(this,/*laya.webgl.shader.d2.ShaderDefines2D.COLOR2D*/0x02, 0);
			this.color = [];
		}

		__class(Color2dSV, 'laya.webgl.shader.d2.value.Color2dSV', _super);
		var __proto = Color2dSV.prototype;
		__proto.setValue = function (value) {
			value.fillStyle && (this.color = value.fillStyle._color._color);
			value.strokeStyle && (this.color = value.strokeStyle._color._color);
		}

		return Color2dSV;
	})(Value2D)


	//class laya.webgl.shader.d2.value.FillTextureSV extends laya.webgl.shader.d2.value.Value2D
	var FillTextureSV = (function (_super) {
		function FillTextureSV(type) {
			this.u_colorMatrix = null;
			this.strength = 0;
			this.colorMat = null;
			this.colorAlpha = null;
			this.u_TexRange = [0, 1, 0, 1];
			this.u_offset = [0, 0];
			this.texcoord = Value2D._TEXCOORD;
			FillTextureSV.__super.call(this,/*laya.webgl.shader.d2.ShaderDefines2D.FILLTEXTURE*/0x100, 0);
		}

		__class(FillTextureSV, 'laya.webgl.shader.d2.value.FillTextureSV', _super);
		var __proto = FillTextureSV.prototype;
		//this.color=[4,WebGLContext.FLOAT,false,_vlen,4 *CONST3D2D.BYTES_PE];
		__proto.setValue = function (vo) {
			this.ALPHA = vo.ALPHA;
			vo.filters && this.setFilters(vo.filters);
		}

		__proto.clear = function () {
			this.texture = null;
			this.shader = null;
			this.defines.setValue(0);
		}

		return FillTextureSV;
	})(Value2D)


	//class laya.webgl.shader.d2.value.TextureSV extends laya.webgl.shader.d2.value.Value2D
	var TextureSV = (function (_super) {
		function TextureSV(subID) {
			this.u_colorMatrix = null;
			this.strength = 0;
			this.blurInfo = null;
			this.colorMat = null;
			this.colorAlpha = null;
			this.texcoord = Value2D._TEXCOORD;
			(subID === void 0) && (subID = 0);
			TextureSV.__super.call(this,/*laya.webgl.shader.d2.ShaderDefines2D.TEXTURE2D*/0x01, subID);
		}

		__class(TextureSV, 'laya.webgl.shader.d2.value.TextureSV', _super);
		var __proto = TextureSV.prototype;
		__proto.setValue = function (vo) {
			this.ALPHA = vo.ALPHA;
			vo.filters && this.setFilters(vo.filters);
		}

		__proto.clear = function () {
			this.texture = null;
			this.shader = null;
			this.defines.setValue(0);
		}

		return TextureSV;
	})(Value2D)


	//class laya.webgl.shader.d2.value.PrimitiveSV extends laya.webgl.shader.d2.value.Value2D
	var PrimitiveSV = (function (_super) {
		function PrimitiveSV(args) {
			this.a_color = null;
			this.u_pos = [0, 0];
			PrimitiveSV.__super.call(this,/*laya.webgl.shader.d2.ShaderDefines2D.PRIMITIVE*/0x04, 0);
			this.position = [2,/*laya.webgl.WebGLContext.FLOAT*/0x1406, false, 5 * CONST3D2D.BYTES_PE, 0];
			this.a_color = [3,/*laya.webgl.WebGLContext.FLOAT*/0x1406, false, 5 * CONST3D2D.BYTES_PE, 2 * CONST3D2D.BYTES_PE];
		}

		__class(PrimitiveSV, 'laya.webgl.shader.d2.value.PrimitiveSV', _super);
		return PrimitiveSV;
	})(Value2D)


	//class laya.webgl.atlas.AtlasWebGLCanvas extends laya.resource.Bitmap
	var AtlasWebGLCanvas = (function (_super) {
		function AtlasWebGLCanvas() {
			this._atlaser = null;
			/**兼容Stage3D使用*/
			this._flashCacheImage = null;
			this._flashCacheImageNeedFlush = false;
			AtlasWebGLCanvas.__super.call(this);
		}

		__class(AtlasWebGLCanvas, 'laya.webgl.atlas.AtlasWebGLCanvas', _super);
		var __proto = AtlasWebGLCanvas.prototype;
		/***重新创建资源*/
		__proto.recreateResource = function () {
			var gl = WebGL.mainContext;
			var glTex = this._source = gl.createTexture();
			var preTarget = WebGLContext.curBindTexTarget;
			var preTexture = WebGLContext.curBindTexValue;
			WebGLContext.bindTexture(gl,/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1, glTex);
			gl.texImage2D(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1, 0,/*laya.webgl.WebGLContext.RGBA*/0x1908, this._w, this._h, 0,/*laya.webgl.WebGLContext.RGBA*/0x1908,/*laya.webgl.WebGLContext.UNSIGNED_BYTE*/0x1401, null);
			gl.texParameteri(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,/*laya.webgl.WebGLContext.TEXTURE_MIN_FILTER*/0x2801,/*laya.webgl.WebGLContext.LINEAR*/0x2601);
			gl.texParameteri(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,/*laya.webgl.WebGLContext.TEXTURE_MAG_FILTER*/0x2800,/*laya.webgl.WebGLContext.LINEAR*/0x2601);
			gl.texParameteri(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,/*laya.webgl.WebGLContext.TEXTURE_WRAP_S*/0x2802,/*laya.webgl.WebGLContext.CLAMP_TO_EDGE*/0x812F);
			gl.texParameteri(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,/*laya.webgl.WebGLContext.TEXTURE_WRAP_T*/0x2803,/*laya.webgl.WebGLContext.CLAMP_TO_EDGE*/0x812F);
			(preTarget && preTexture) && (WebGLContext.bindTexture(gl, preTarget, preTexture));
			this.memorySize = this._w * this._h * 4;
			this.completeCreate();
		}

		/***销毁资源*/
		__proto.disposeResource = function () {
			if (this._source) {
				WebGL.mainContext.deleteTexture(this._source);
				this._source = null;
				this.memorySize = 0;
			}
		}

		/**采样image到WebGLTexture的一部分*/
		__proto.texSubImage2D = function (xoffset, yoffset, bitmap) {
			if (!Render.isFlash) {
				var gl = WebGL.mainContext;
				var preTarget = WebGLContext.curBindTexTarget;
				var preTexture = WebGLContext.curBindTexValue;
				WebGLContext.bindTexture(gl,/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1, this._source);
				gl.pixelStorei(/*laya.webgl.WebGLContext.UNPACK_PREMULTIPLY_ALPHA_WEBGL*/0x9241, true);
				(xoffset - 1 >= 0) && (gl.texSubImage2D(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1, 0, xoffset - 1, yoffset,/*laya.webgl.WebGLContext.RGBA*/0x1908,/*laya.webgl.WebGLContext.UNSIGNED_BYTE*/0x1401, bitmap));
				(xoffset + 1 <= this._w) && (gl.texSubImage2D(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1, 0, xoffset + 1, yoffset,/*laya.webgl.WebGLContext.RGBA*/0x1908,/*laya.webgl.WebGLContext.UNSIGNED_BYTE*/0x1401, bitmap));
				(yoffset - 1 >= 0) && (gl.texSubImage2D(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1, 0, xoffset, yoffset - 1,/*laya.webgl.WebGLContext.RGBA*/0x1908,/*laya.webgl.WebGLContext.UNSIGNED_BYTE*/0x1401, bitmap));
				(yoffset + 1 <= this._h) && (gl.texSubImage2D(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1, 0, xoffset, yoffset + 1,/*laya.webgl.WebGLContext.RGBA*/0x1908,/*laya.webgl.WebGLContext.UNSIGNED_BYTE*/0x1401, bitmap));
				gl.texSubImage2D(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1, 0, xoffset, yoffset,/*laya.webgl.WebGLContext.RGBA*/0x1908,/*laya.webgl.WebGLContext.UNSIGNED_BYTE*/0x1401, bitmap);
				gl.pixelStorei(/*laya.webgl.WebGLContext.UNPACK_PREMULTIPLY_ALPHA_WEBGL*/0x9241, false);
				(preTarget && preTexture) && (WebGLContext.bindTexture(gl, preTarget, preTexture));
			} else {
				if (!this._flashCacheImage) {
					this._flashCacheImage = HTMLImage.create("");
					this._flashCacheImage._image.createCanvas(this._w, this._h);
				};
				var bmData = bitmap.bitmapdata;
				this._flashCacheImage._image.copyPixels(bmData, 0, 0, bmData.width, bmData.height, xoffset, yoffset);
				(this._flashCacheImageNeedFlush) || (this._flashCacheImageNeedFlush = true);
			}
		}

		/**采样image到WebGLTexture的一部分*/
		__proto.texSubImage2DPixel = function (xoffset, yoffset, width, height, pixel) {
			var gl = WebGL.mainContext;
			var preTarget = WebGLContext.curBindTexTarget;
			var preTexture = WebGLContext.curBindTexValue;
			WebGLContext.bindTexture(gl,/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1, this._source);
			var pixels = new Uint8Array(pixel.data);
			gl.pixelStorei(/*laya.webgl.WebGLContext.UNPACK_PREMULTIPLY_ALPHA_WEBGL*/0x9241, true);
			gl.texSubImage2D(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1, 0, xoffset, yoffset, width, height,/*laya.webgl.WebGLContext.RGBA*/0x1908,/*laya.webgl.WebGLContext.UNSIGNED_BYTE*/0x1401, pixels);
			gl.pixelStorei(/*laya.webgl.WebGLContext.UNPACK_PREMULTIPLY_ALPHA_WEBGL*/0x9241, false);
			(preTarget && preTexture) && (WebGLContext.bindTexture(gl, preTarget, preTexture));
		}

		/***
		*设置图片宽度
		*@param value 图片宽度
		*/
		__getset(0, __proto, 'width', _super.prototype._$get_width, function (value) {
			this._w = value;
		});

		/***
		*设置图片高度
		*@param value 图片高度
		*/
		__getset(0, __proto, 'height', _super.prototype._$get_height, function (value) {
			this._h = value;
		});

		return AtlasWebGLCanvas;
	})(Bitmap)


	/**@private */
	//class laya.webgl.resource.WebGLCanvas extends laya.resource.Bitmap
	var WebGLCanvas = (function (_super) {
		function WebGLCanvas() {
			this.flipY = true;
			//上传的时候是否上下颠倒
			this.premulAlpha = false;
			//上传的时候是否预乘alpha
			//this._ctx=null;
			/**HTML Canvas*/
			//this._canvas=null;
			//this._imgData=null;
			//}
			//this.iscpuSource=false;
			this.alwaysChange = false;
			WebGLCanvas.__super.call(this);
		}

		__class(WebGLCanvas, 'laya.webgl.resource.WebGLCanvas', _super);
		var __proto = WebGLCanvas.prototype;
		//}
		__proto.getCanvas = function () {
			return this._canvas;
		}

		__proto.clear = function () {
			this._ctx && this._ctx.clear();
		}

		__proto.destroy = function () {
			this._ctx && this._ctx.destroy();
			this._ctx = null;
			_super.prototype.destroy.call(this);
		}

		__proto._setContext = function (context) {
			this._ctx = context;
		}

		__proto.getContext = function (contextID, other) {
			return this._ctx ? this._ctx : (this._ctx = WebGLCanvas._createContext(this));
		}

		/*override public function copyTo(dec:Bitmap):void {
		super.copyTo(dec);
		(dec as WebGLCanvas)._ctx=_ctx;
	}*/


		__proto.size = function (w, h) {
			if (this._w != w || this._h != h) {
				this._w = w;
				this._h = h;
				this._ctx && this._ctx.size(w, h);
				this._canvas && (this._canvas.height = h, this._canvas.width = w);
			}

		}


		__proto.activeResource = function (force) {
			(force === void 0) && (force = false);
			if (!this._source) {
				this.recreateResource();
			}

		}


		__proto.recreateResource = function () {
			this.createWebGlTexture();
			this.completeCreate();
		}


		__proto.disposeResource = function () {
			if (this._source && !this.iscpuSource) {
				WebGL.mainContext.deleteTexture(this._source);
				this._source = null;
				this.memorySize = 0;
			}

		}


		__proto.createWebGlTexture = function () {
			var gl = WebGL.mainContext;
			if (!this._canvas) {
			};

			var glTex = this._source = gl.createTexture();
			this.iscpuSource = false;
			var preTarget = WebGLContext.curBindTexTarget;
			var preTexture = WebGLContext.curBindTexValue;
			WebGLContext.bindTexture(gl,/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1, glTex);
			gl.pixelStorei(/*laya.webgl.WebGLContext.UNPACK_FLIP_Y_WEBGL*/0x9240, this.flipY ? 1 : 0);
			this.premulAlpha && gl.pixelStorei(/*laya.webgl.WebGLContext.UNPACK_PREMULTIPLY_ALPHA_WEBGL*/0x9241, true);
			gl.texImage2D(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1, 0,/*laya.webgl.WebGLContext.RGBA*/0x1908,/*laya.webgl.WebGLContext.RGBA*/0x1908,/*laya.webgl.WebGLContext.UNSIGNED_BYTE*/0x1401, this._imgData);
			this.premulAlpha && gl.pixelStorei(/*laya.webgl.WebGLContext.UNPACK_PREMULTIPLY_ALPHA_WEBGL*/0x9241, false);
			gl.texParameteri(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,/*laya.webgl.WebGLContext.TEXTURE_MAG_FILTER*/0x2800,/*laya.webgl.WebGLContext.LINEAR*/0x2601);
			gl.texParameteri(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,/*laya.webgl.WebGLContext.TEXTURE_MIN_FILTER*/0x2801,/*laya.webgl.WebGLContext.LINEAR*/0x2601);
			gl.texParameteri(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,/*laya.webgl.WebGLContext.TEXTURE_WRAP_S*/0x2802,/*laya.webgl.WebGLContext.CLAMP_TO_EDGE*/0x812F);
			gl.texParameteri(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,/*laya.webgl.WebGLContext.TEXTURE_WRAP_T*/0x2803,/*laya.webgl.WebGLContext.CLAMP_TO_EDGE*/0x812F);
			gl.pixelStorei(/*laya.webgl.WebGLContext.UNPACK_FLIP_Y_WEBGL*/0x9240, 0);
			this.memorySize = this._w * this._h * 4;
			(preTarget && preTexture) && (WebGLContext.bindTexture(gl, preTarget, preTexture));
		}


		//_canvas=null;
		__proto.reloadCanvasData = function () {
			var gl = WebGL.mainContext;
			if (!this._source) {
				throw "reloadCanvasData error, gl texture not created!";
			};

			var preTarget = WebGLContext.curBindTexTarget;
			var preTexture = WebGLContext.curBindTexValue;
			WebGLContext.bindTexture(gl,/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1, this._source);
			this.premulAlpha && gl.pixelStorei(/*laya.webgl.WebGLContext.UNPACK_PREMULTIPLY_ALPHA_WEBGL*/0x9241, true);
			gl.texImage2D(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1, 0,/*laya.webgl.WebGLContext.RGBA*/0x1908,/*laya.webgl.WebGLContext.RGBA*/0x1908,/*laya.webgl.WebGLContext.UNSIGNED_BYTE*/0x1401, this._imgData);
			this.premulAlpha && gl.pixelStorei(/*laya.webgl.WebGLContext.UNPACK_PREMULTIPLY_ALPHA_WEBGL*/0x9241, false);
			gl.pixelStorei(/*laya.webgl.WebGLContext.UNPACK_FLIP_Y_WEBGL*/0x9240, 0);
			(preTarget && preTexture) && (WebGLContext.bindTexture(gl, preTarget, preTexture));
		}


		//_canvas=null;
		__proto.texSubImage2D = function (webglCanvas, xoffset, yoffset) {
			var gl = WebGL.mainContext;
			var preTarget = WebGLContext.curBindTexTarget;
			var preTexture = WebGLContext.curBindTexValue;
			WebGLContext.bindTexture(gl,/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1, this._source);
			gl.pixelStorei(/*laya.webgl.WebGLContext.UNPACK_PREMULTIPLY_ALPHA_WEBGL*/0x9241, true);
			gl.texSubImage2D(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1, 0, xoffset, yoffset,/*laya.webgl.WebGLContext.RGBA*/0x1908,/*laya.webgl.WebGLContext.UNSIGNED_BYTE*/0x1401, webglCanvas._source);
			gl.pixelStorei(/*laya.webgl.WebGLContext.UNPACK_PREMULTIPLY_ALPHA_WEBGL*/0x9241, false);
			(preTarget && preTexture) && (WebGLContext.bindTexture(gl, preTarget, preTexture));
		}


		__proto.toBase64 = function (type, encoderOptions, callBack) {
			var base64Data = null;
			if (this._canvas) {
				base64Data = this._canvas.toDataURL(type, encoderOptions);
			}

			callBack.call(this, base64Data);
		}


		__getset(0, __proto, 'context', function () {
			return this._ctx;
		});


		__getset(0, __proto, 'source', function () {
			if (this.alwaysChange) this.reloadCanvasData();
			return this._source;
		});


		__getset(0, __proto, 'asBitmap', null, function (value) {
			this._ctx && (this._ctx.asBitmap = value);
		});


		WebGLCanvas._createContext = null;
		return WebGLCanvas;
	})(Bitmap)


	//class laya.webgl.resource.WebGLCharImage extends laya.resource.Bitmap
	var WebGLCharImage = (function (_super) {
		function WebGLCharImage(content, drawValue) {
			this.CborderSize = 12;
			//this._ctx=null;
			/***是否创建私有Source*/
			//this._allowMerageInAtlas=false;
			/**是否允许加入大图合集*/
			//this._enableMerageInAtlas=false;
			/**HTML Canvas，绘制字符载体,非私有数据载体*/
			//this.canvas=null;
			/**********************************************************************************/
			//this.cw=NaN;
			//this.ch=NaN;
			//this.xs=NaN;
			//this.ys=NaN;
			//this.char=null;
			//this.fillColor=null;
			//this.borderColor=null;
			//this.borderSize=0;
			//this.font=null;
			//this.fontSize=0;
			//this.texture=null;
			//this.lineWidth=0;
			//this.UV=null;
			//this.isSpace=false;
			//this.underLine=0;
			WebGLCharImage.__super.call(this);
			this.char = content;
			this.isSpace = content === ' ';
			this.xs = drawValue.scaleX;
			this.ys = drawValue.scaleY;
			this.font = drawValue.font.toString();
			this.fontSize = drawValue.font.size;
			this.fillColor = drawValue.fillColor;
			this.borderColor = drawValue.borderColor;
			this.lineWidth = drawValue.lineWidth;
			this.underLine = drawValue.underLine;
			var bIsConchApp = Render.isConchApp;
			var pCanvas;
			if (bIsConchApp) {
			/*__JS__ */pCanvas = ConchTextCanvas;
			/*__JS__ */pCanvas._source = ConchTextCanvas;
			/*__JS__ */pCanvas._source.canvas = ConchTextCanvas;
			} else {
				pCanvas = Browser.canvas.source;
			}
			this.canvas = pCanvas;
			this._enableMerageInAtlas = true;
			if (bIsConchApp) {
			/*__JS__ */this._ctx = pCanvas;
			} else {
				this._ctx = this.canvas.getContext('2d', undefined);
			};
			var t = Utils.measureText(this.char, this.font);
			this.cw = t.width * this.xs;
			this.ch = (t.height || this.fontSize) * this.ys;
			this.onresize(this.cw + this.CborderSize * 2, this.ch + this.CborderSize * 2);
			this.texture = new Texture(this);
		}

		__class(WebGLCharImage, 'laya.webgl.resource.WebGLCharImage', _super);
		var __proto = WebGLCharImage.prototype;
		Laya.imps(__proto, { "laya.webgl.resource.IMergeAtlasBitmap": true })
		__proto.active = function () {
			this.texture.active();
		}

		__proto.recreateResource = function () {
			var bIsConchApp = Render.isConchApp;
			this.onresize(this.cw + this.CborderSize * 2, this.ch + this.CborderSize * 2);
			this.canvas && (this.canvas.height = this._h, this.canvas.width = this._w);
			if (bIsConchApp) {
				var nFontSize = this.fontSize;
				if (this.xs != 1 || this.ys != 1) {
					nFontSize = parseInt(nFontSize * ((this.xs > this.ys) ? this.xs : this.ys) + "");
				};
				var sFont = "normal 100 " + nFontSize + "px Arial";
				if (this.borderColor) {
					sFont += " 1 " + this.borderColor;
				}
				this._ctx.font = sFont;
				this._ctx.textBaseline = "top";
				this._ctx.fillStyle = this.fillColor;
				this._ctx.fillText(this.char, this.CborderSize, this.CborderSize, null, null, null);
			} else {
				this._ctx.save();
				(this._ctx).clearRect(0, 0, this.cw + this.CborderSize * 2, this.ch + this.CborderSize * 2);
				this._ctx.font = this.font;
				if (Text.RightToLeft) {
					this._ctx.textAlign = "end";
				}
				this._ctx.textBaseline = "top";
				this._ctx.translate(this.CborderSize, this.CborderSize);
				if (this.xs != 1 || this.ys != 1) {
					this._ctx.scale(this.xs, this.ys);
				}
				if (this.fillColor && this.borderColor) {
					this._ctx.strokeStyle = this.borderColor;
					this._ctx.lineWidth = this.lineWidth;
					this._ctx.strokeText(this.char, 0, 0, null, null, 0, null);
					this._ctx.fillStyle = this.fillColor;
					this._ctx.fillText(this.char, 0, 0, null, null, null);
				} else {
					if (this.lineWidth === -1) {
						this._ctx.fillStyle = this.fillColor ? this.fillColor : "white";
						this._ctx.fillText(this.char, 0, 0, null, null, null);
					} else {
						this._ctx.strokeStyle = this.borderColor ? this.borderColor : 'white';
						this._ctx.lineWidth = this.lineWidth;
						this._ctx.strokeText(this.char, 0, 0, null, null, 0, null);
					}
				}
				if (this.underLine) {
					this._ctx.lineWidth = 1;
					this._ctx.strokeStyle = this.fillColor;
					this._ctx.beginPath();
					this._ctx.moveTo(0, this.fontSize + 1);
					var nW = this._ctx.measureText(this.char).width + 1;
					this._ctx.lineTo(nW, this.fontSize + 1);
					this._ctx.stroke();
				}
				this._ctx.restore();
			}
			this.borderSize = this.CborderSize;
			this.completeCreate();
		}

		__proto.onresize = function (w, h) {
			this._w = w;
			this._h = h;
			this._allowMerageInAtlas = true;
		}

		__proto.clearAtlasSource = function () { }
		/**
		*是否创建私有Source
		*@return 是否创建
		*/
		__getset(0, __proto, 'allowMerageInAtlas', function () {
			return this._allowMerageInAtlas;
		});

		__getset(0, __proto, 'atlasSource', function () {
			return this.canvas;
		});

		/**
		*是否创建私有Source,通常禁止修改
		*@param value 是否创建
		*/
		/**
		*是否创建私有Source
		*@return 是否创建
		*/
		__getset(0, __proto, 'enableMerageInAtlas', function () {
			return this._enableMerageInAtlas;
		}, function (value) {
			this._enableMerageInAtlas = value;
		});

		WebGLCharImage.createOneChar = function (content, drawValue) {
			var char = new WebGLCharImage(content, drawValue);
			return char;
		}

		return WebGLCharImage;
	})(Bitmap)


	//class laya.webgl.resource.WebGLRenderTarget extends laya.resource.Bitmap
	var WebGLRenderTarget = (function (_super) {
		function WebGLRenderTarget(width, height, surfaceFormat, surfaceType, depthStencilFormat, mipMap, repeat, minFifter, magFifter) {
			//this._frameBuffer=null;
			//this._depthStencilBuffer=null;
			//this._surfaceFormat=0;
			//this._surfaceType=0;
			//this._depthStencilFormat=0;
			//this._mipMap=false;
			//this._repeat=false;
			//this._minFifter=0;
			//this._magFifter=0;
			(surfaceFormat === void 0) && (surfaceFormat =/*laya.webgl.WebGLContext.RGBA*/0x1908);
			(surfaceType === void 0) && (surfaceType =/*laya.webgl.WebGLContext.UNSIGNED_BYTE*/0x1401);
			(depthStencilFormat === void 0) && (depthStencilFormat =/*laya.webgl.WebGLContext.DEPTH_STENCIL*/0x84F9);
			(mipMap === void 0) && (mipMap = false);
			(repeat === void 0) && (repeat = false);
			(minFifter === void 0) && (minFifter = -1);
			(magFifter === void 0) && (magFifter = 1);
			WebGLRenderTarget.__super.call(this);
			this._w = width;
			this._h = height;
			this._surfaceFormat = surfaceFormat;
			this._surfaceType = surfaceType;
			this._depthStencilFormat = depthStencilFormat;
			this._mipMap = mipMap;
			this._repeat = repeat;
			this._minFifter = minFifter;
			this._magFifter = magFifter;
		}

		__class(WebGLRenderTarget, 'laya.webgl.resource.WebGLRenderTarget', _super);
		var __proto = WebGLRenderTarget.prototype;
		__proto.recreateResource = function () {
			var gl = WebGL.mainContext;
			this._frameBuffer || (this._frameBuffer = gl.createFramebuffer());
			this._source || (this._source = gl.createTexture());
			var preTarget = WebGLContext.curBindTexTarget;
			var preTexture = WebGLContext.curBindTexValue;
			WebGLContext.bindTexture(gl,/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1, this._source);
			gl.texImage2D(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1, 0,/*laya.webgl.WebGLContext.RGBA*/0x1908, this._w, this._h, 0, this._surfaceFormat, this._surfaceType, null);
			var minFifter = this._minFifter;
			var magFifter = this._magFifter;
			var repeat = this._repeat ? /*laya.webgl.WebGLContext.REPEAT*/0x2901 :/*laya.webgl.WebGLContext.CLAMP_TO_EDGE*/0x812F;
			var isPot = Arith.isPOT(this._w, this._h);
			if (isPot) {
				if (this._mipMap)
					(minFifter !== -1) || (minFifter =/*laya.webgl.WebGLContext.LINEAR_MIPMAP_LINEAR*/0x2703);
				else
					(minFifter !== -1) || (minFifter =/*laya.webgl.WebGLContext.LINEAR*/0x2601);
				(magFifter !== -1) || (magFifter =/*laya.webgl.WebGLContext.LINEAR*/0x2601);
				gl.texParameteri(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,/*laya.webgl.WebGLContext.TEXTURE_MIN_FILTER*/0x2801, minFifter);
				gl.texParameteri(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,/*laya.webgl.WebGLContext.TEXTURE_MAG_FILTER*/0x2800, magFifter);
				gl.texParameteri(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,/*laya.webgl.WebGLContext.TEXTURE_WRAP_S*/0x2802, repeat);
				gl.texParameteri(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,/*laya.webgl.WebGLContext.TEXTURE_WRAP_T*/0x2803, repeat);
				this._mipMap && gl.generateMipmap(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1);
			} else {
				(minFifter !== -1) || (minFifter =/*laya.webgl.WebGLContext.LINEAR*/0x2601);
				(magFifter !== -1) || (magFifter =/*laya.webgl.WebGLContext.LINEAR*/0x2601);
				gl.texParameteri(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,/*laya.webgl.WebGLContext.TEXTURE_MIN_FILTER*/0x2801, minFifter);
				gl.texParameteri(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,/*laya.webgl.WebGLContext.TEXTURE_MAG_FILTER*/0x2800, magFifter);
				gl.texParameteri(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,/*laya.webgl.WebGLContext.TEXTURE_WRAP_S*/0x2802,/*laya.webgl.WebGLContext.CLAMP_TO_EDGE*/0x812F);
				gl.texParameteri(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,/*laya.webgl.WebGLContext.TEXTURE_WRAP_T*/0x2803,/*laya.webgl.WebGLContext.CLAMP_TO_EDGE*/0x812F);
			}
			gl.bindFramebuffer(/*laya.webgl.WebGLContext.FRAMEBUFFER*/0x8D40, this._frameBuffer);
			gl.framebufferTexture2D(/*laya.webgl.WebGLContext.FRAMEBUFFER*/0x8D40,/*laya.webgl.WebGLContext.COLOR_ATTACHMENT0*/0x8CE0,/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1, this._source, 0);
			if (this._depthStencilFormat) {
				this._depthStencilBuffer || (this._depthStencilBuffer = gl.createRenderbuffer());
				gl.bindRenderbuffer(/*laya.webgl.WebGLContext.RENDERBUFFER*/0x8D41, this._depthStencilBuffer);
				gl.renderbufferStorage(/*laya.webgl.WebGLContext.RENDERBUFFER*/0x8D41, this._depthStencilFormat, this._w, this._h);
				switch (this._depthStencilFormat) {
					case /*laya.webgl.WebGLContext.DEPTH_COMPONENT16*/0x81A5:
						gl.framebufferRenderbuffer(/*laya.webgl.WebGLContext.FRAMEBUFFER*/0x8D40,/*laya.webgl.WebGLContext.DEPTH_ATTACHMENT*/0x8D00,/*laya.webgl.WebGLContext.RENDERBUFFER*/0x8D41, this._depthStencilBuffer);
						break;
					case /*laya.webgl.WebGLContext.STENCIL_INDEX8*/0x8D48:
						gl.framebufferRenderbuffer(/*laya.webgl.WebGLContext.FRAMEBUFFER*/0x8D40,/*laya.webgl.WebGLContext.STENCIL_ATTACHMENT*/0x8D20,/*laya.webgl.WebGLContext.RENDERBUFFER*/0x8D41, this._depthStencilBuffer);
						break;
					case /*laya.webgl.WebGLContext.DEPTH_STENCIL*/0x84F9:
						gl.framebufferRenderbuffer(/*laya.webgl.WebGLContext.FRAMEBUFFER*/0x8D40,/*laya.webgl.WebGLContext.DEPTH_STENCIL_ATTACHMENT*/0x821A,/*laya.webgl.WebGLContext.RENDERBUFFER*/0x8D41, this._depthStencilBuffer);
						break;
				}
			}
			gl.bindFramebuffer(/*laya.webgl.WebGLContext.FRAMEBUFFER*/0x8D40, null);
			(preTarget && preTexture) && (WebGLContext.bindTexture(gl, preTarget, preTexture));
			gl.bindRenderbuffer(/*laya.webgl.WebGLContext.RENDERBUFFER*/0x8D41, null);
			if (isPot && this._mipMap)
				this.memorySize = this._w * this._h * 4 * (1 + 1 / 3);
			else
				this.memorySize = this._w * this._h * 4;
			this.completeCreate();
		}

		__proto.disposeResource = function () {
			if (this._frameBuffer) {
				WebGL.mainContext.deleteTexture(this._source);
				WebGL.mainContext.deleteFramebuffer(this._frameBuffer);
				WebGL.mainContext.deleteRenderbuffer(this._depthStencilBuffer);
				this._source = null;
				this._frameBuffer = null;
				this._depthStencilBuffer = null;
				this.memorySize = 0;
			}
		}

		__getset(0, __proto, 'depthStencilBuffer', function () {
			return this._depthStencilBuffer;
		});

		__getset(0, __proto, 'frameBuffer', function () {
			return this._frameBuffer;
		});

		return WebGLRenderTarget;
	})(Bitmap)


	//class laya.webgl.resource.WebGLSubImage extends laya.resource.Bitmap
	var WebGLSubImage = (function (_super) {
		function WebGLSubImage(canvas, offsetX, offsetY, width, height, atlasImage, src) {
			/**HTML Context*/
			//this._ctx=null;
			/***是否创建私有Source,值为false时不根据src创建私有WebGLTexture,同时销毁时也只清空source=null,不调用WebGL.mainContext.deleteTexture类似函数，调用资源激活前有效*/
			//this._allowMerageInAtlas=false;
			/**是否允许加入大图合集*/
			//this._enableMerageInAtlas=false;
			/**HTML Canvas，绘制子图载体,非私有数据载体*/
			//this.canvas=null;
			/**是否使用重复模式纹理寻址*/
			//this.repeat=false;
			/**是否使用mipLevel*/
			//this.mipmap=false;
			/**缩小过滤器*/
			//this.minFifter=0;
			/**放大过滤器*/
			//this.magFifter=0;
			//动态默认值，判断是否可生成miplevel
			//this.atlasImage=null;
			this.offsetX = 0;
			this.offsetY = 0;
			//this.src=null;
			WebGLSubImage.__super.call(this);
			this.repeat = true;
			this.mipmap = false;
			this.minFifter = -1;
			this.magFifter = -1;
			this.atlasImage = atlasImage;
			this.canvas = canvas;
			this._ctx = canvas.getContext('2d', undefined);
			this._w = width;
			this._h = height;
			this.offsetX = offsetX;
			this.offsetY = offsetY;
			this.src = src;
			this._enableMerageInAtlas = true;
			(AtlasResourceManager.enabled) && (this._w < AtlasResourceManager.atlasLimitWidth && this._h < AtlasResourceManager.atlasLimitHeight) ? this._allowMerageInAtlas = true : this._allowMerageInAtlas = false;
		}

		__class(WebGLSubImage, 'laya.webgl.resource.WebGLSubImage', _super);
		var __proto = WebGLSubImage.prototype;
		Laya.imps(__proto, { "laya.webgl.resource.IMergeAtlasBitmap": true })
		/*override public function copyTo(dec:Bitmap):void {
		var d:WebGLSubImage=dec as WebGLSubImage;
		super.copyTo(dec);
		d._ctx=_ctx;
	}*/


		__proto.size = function (w, h) {
			this._w = w;
			this._h = h;
			this._ctx && this._ctx.size(w, h);
			this.canvas && (this.canvas.height = h, this.canvas.width = w);
		}


		__proto.recreateResource = function () {
			this.size(this._w, this._h);
			this._ctx.drawImage(this.atlasImage, this.offsetX, this.offsetY, this._w, this._h, 0, 0, this._w, this._h);
			(!(this._allowMerageInAtlas && this._enableMerageInAtlas)) ? (this.createWebGlTexture()) : (this.memorySize = 0);
			this.completeCreate();
		}


		__proto.createWebGlTexture = function () {
			var gl = WebGL.mainContext;
			if (!this.canvas) {
				throw "create GLTextur err:no data:" + this.canvas;
			};

			var glTex = this._source = gl.createTexture();
			var preTarget = WebGLContext.curBindTexTarget;
			var preTexture = WebGLContext.curBindTexValue;
			WebGLContext.bindTexture(gl,/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1, glTex);
			gl.pixelStorei(/*laya.webgl.WebGLContext.UNPACK_PREMULTIPLY_ALPHA_WEBGL*/0x9241, true);
			gl.texImage2D(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1, 0,/*laya.webgl.WebGLContext.RGBA*/0x1908,/*laya.webgl.WebGLContext.RGBA*/0x1908,/*laya.webgl.WebGLContext.UNSIGNED_BYTE*/0x1401, this.canvas);
			gl.pixelStorei(/*laya.webgl.WebGLContext.UNPACK_PREMULTIPLY_ALPHA_WEBGL*/0x9241, false);
			var minFifter = this.minFifter;
			var magFifter = this.magFifter;
			var repeat = this.repeat ? /*laya.webgl.WebGLContext.REPEAT*/0x2901 :/*laya.webgl.WebGLContext.CLAMP_TO_EDGE*/0x812F;
			var isPOT = Arith.isPOT(this.width, this.height);
			if (isPOT) {
				if (this.mipmap)
					(minFifter !== -1) || (minFifter =/*laya.webgl.WebGLContext.LINEAR_MIPMAP_LINEAR*/0x2703);
				else
					(minFifter !== -1) || (minFifter =/*laya.webgl.WebGLContext.LINEAR*/0x2601);
				(magFifter !== -1) || (magFifter =/*laya.webgl.WebGLContext.LINEAR*/0x2601);
				gl.texParameteri(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,/*laya.webgl.WebGLContext.TEXTURE_MAG_FILTER*/0x2800, magFifter);
				gl.texParameteri(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,/*laya.webgl.WebGLContext.TEXTURE_MIN_FILTER*/0x2801, minFifter);
				gl.texParameteri(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,/*laya.webgl.WebGLContext.TEXTURE_WRAP_S*/0x2802, repeat);
				gl.texParameteri(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,/*laya.webgl.WebGLContext.TEXTURE_WRAP_T*/0x2803, repeat);
				this.mipmap && gl.generateMipmap(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1);
			} else {
				(minFifter !== -1) || (minFifter =/*laya.webgl.WebGLContext.LINEAR*/0x2601);
				(magFifter !== -1) || (magFifter =/*laya.webgl.WebGLContext.LINEAR*/0x2601);
				gl.texParameteri(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,/*laya.webgl.WebGLContext.TEXTURE_MIN_FILTER*/0x2801, minFifter);
				gl.texParameteri(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,/*laya.webgl.WebGLContext.TEXTURE_MAG_FILTER*/0x2800, magFifter);
				gl.texParameteri(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,/*laya.webgl.WebGLContext.TEXTURE_WRAP_S*/0x2802,/*laya.webgl.WebGLContext.CLAMP_TO_EDGE*/0x812F);
				gl.texParameteri(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,/*laya.webgl.WebGLContext.TEXTURE_WRAP_T*/0x2803,/*laya.webgl.WebGLContext.CLAMP_TO_EDGE*/0x812F);
			}

			(preTarget && preTexture) && (WebGLContext.bindTexture(gl, preTarget, preTexture));
			this.canvas = null;
			if (isPOT && this.mipmap)
				this.memorySize = this._w * this._h * 4 * (1 + 1 / 3);
			else
				this.memorySize = this._w * this._h * 4;
		}


		__proto.disposeResource = function () {
			if (!(AtlasResourceManager.enabled && this._allowMerageInAtlas) && this._source) {
				WebGL.mainContext.deleteTexture(this._source);
				this._source = null;
				this.memorySize = 0;
			}

		}


		//}
		__proto.clearAtlasSource = function () { }
		/**
		*是否创建私有Source
		*@return 是否创建
		*/
		__getset(0, __proto, 'allowMerageInAtlas', function () {
			return this._allowMerageInAtlas;
		});


		//public var createFromPixel:Boolean=true;
		__getset(0, __proto, 'atlasSource', function () {
			return this.canvas;
		});


		/**
		*是否创建私有Source,通常禁止修改
		*@param value 是否创建
		*/
		/**
		*是否创建私有Source
		*@return 是否创建
		*/
		__getset(0, __proto, 'enableMerageInAtlas', function () {
			return this._allowMerageInAtlas;
		}, function (value) {

			this._allowMerageInAtlas = value;
		});


		return WebGLSubImage;
	})(Bitmap)


	//class laya.webgl.shader.Shader extends laya.webgl.shader.BaseShader
	var Shader = (function (_super) {
		function Shader(vs, ps, saveName, nameMap) {
			this.customCompile = false;
			//this._nameMap=null;
			//shader参数别名，语义
			//this._vs=null;
			//this._ps=null;
			this._curActTexIndex = 0;
			//this._reCompile=false;
			//存储一些私有变量
			this.tag = {};
			//this._vshader=null;
			//this._pshader=null;
			this._program = null;
			this._params = null;
			this._paramsMap = {};
			this._offset = 0;
			//this._id=0;
			Shader.__super.call(this);
			if ((!vs) || (!ps)) throw "Shader Error";
			if (Render.isConchApp || Render.isFlash) {
				this.customCompile = true;
			}
			this._id = ++Shader._count;
			this._vs = vs;
			this._ps = ps;
			this._nameMap = nameMap ? nameMap : {};
			saveName != null && (Shader.sharders[saveName] = this);
		}

		__class(Shader, 'laya.webgl.shader.Shader', _super);
		var __proto = Shader.prototype;
		__proto.recreateResource = function () {
			this._compile();
			this.completeCreate();
			this.memorySize = 0;
		}

		//忽略尺寸尺寸
		__proto.disposeResource = function () {
			WebGL.mainContext.deleteShader(this._vshader);
			WebGL.mainContext.deleteShader(this._pshader);
			WebGL.mainContext.deleteProgram(this._program);
			this._vshader = this._pshader = this._program = null;
			this._params = null;
			this._paramsMap = {};
			this.memorySize = 0;
			this._curActTexIndex = 0;
		}

		__proto._compile = function () {
			if (!this._vs || !this._ps || this._params)
				return;
			this._reCompile = true;
			this._params = [];
			var text = [this._vs, this._ps];
			var result;
			if (this.customCompile)
				result = ShaderCompile.preGetParams(this._vs, this._ps);
			var gl = WebGL.mainContext;
			this._program = gl.createProgram();
			this._vshader = Shader._createShader(gl, text[0],/*laya.webgl.WebGLContext.VERTEX_SHADER*/0x8B31);
			this._pshader = Shader._createShader(gl, text[1],/*laya.webgl.WebGLContext.FRAGMENT_SHADER*/0x8B30);
			gl.attachShader(this._program, this._vshader);
			gl.attachShader(this._program, this._pshader);
			gl.linkProgram(this._program);
			if (!this.customCompile && !gl.getProgramParameter(this._program,/*laya.webgl.WebGLContext.LINK_STATUS*/0x8B82)) {
				throw gl.getProgramInfoLog(this._program);
			};
			var one, i = 0, j = 0, n = 0, location;
			var attribNum = this.customCompile ? result.attributes.length : gl.getProgramParameter(this._program,/*laya.webgl.WebGLContext.ACTIVE_ATTRIBUTES*/0x8B89);
			for (i = 0; i < attribNum; i++) {
				var attrib = this.customCompile ? result.attributes[i] : gl.getActiveAttrib(this._program, i);
				location = gl.getAttribLocation(this._program, attrib.name);
				one = { vartype: "attribute", glfun: null, ivartype: 0, attrib: attrib, location: location, name: attrib.name, type: attrib.type, isArray: false, isSame: false, preValue: null, indexOfParams: 0 };
				this._params.push(one);
			};
			var nUniformNum = this.customCompile ? result.uniforms.length : gl.getProgramParameter(this._program,/*laya.webgl.WebGLContext.ACTIVE_UNIFORMS*/0x8B86);
			for (i = 0; i < nUniformNum; i++) {
				var uniform = this.customCompile ? result.uniforms[i] : gl.getActiveUniform(this._program, i);
				location = gl.getUniformLocation(this._program, uniform.name);
				one = { vartype: "uniform", glfun: null, ivartype: 1, attrib: attrib, location: location, name: uniform.name, type: uniform.type, isArray: false, isSame: false, preValue: null, indexOfParams: 0 };
				if (one.name.indexOf('[0]') > 0) {
					one.name = one.name.substr(0, one.name.length - 3);
					one.isArray = true;
					one.location = gl.getUniformLocation(this._program, one.name);
				}
				this._params.push(one);
			}
			for (i = 0, n = this._params.length; i < n; i++) {
				one = this._params[i];
				one.indexOfParams = i;
				one.index = 1;
				one.value = [one.location, null];
				one.codename = one.name;
				one.name = this._nameMap[one.codename] ? this._nameMap[one.codename] : one.codename;
				this._paramsMap[one.name] = one;
				one._this = this;
				one.uploadedValue = [];
				if (one.vartype === "attribute") {
					one.fun = this._attribute;
					continue;
				}
				switch (one.type) {
					case /*laya.webgl.WebGLContext.INT*/0x1404:
						one.fun = one.isArray ? this._uniform1iv : this._uniform1i;
						break;
					case /*laya.webgl.WebGLContext.FLOAT*/0x1406:
						one.fun = one.isArray ? this._uniform1fv : this._uniform1f;
						break;
					case /*laya.webgl.WebGLContext.FLOAT_VEC2*/0x8B50:
						one.fun = one.isArray ? this._uniform_vec2v : this._uniform_vec2;
						break;
					case /*laya.webgl.WebGLContext.FLOAT_VEC3*/0x8B51:
						one.fun = one.isArray ? this._uniform_vec3v : this._uniform_vec3;
						break;
					case /*laya.webgl.WebGLContext.FLOAT_VEC4*/0x8B52:
						one.fun = one.isArray ? this._uniform_vec4v : this._uniform_vec4;
						break;
					case /*laya.webgl.WebGLContext.SAMPLER_2D*/0x8B5E:
						one.fun = this._uniform_sampler2D;
						break;
					case /*laya.webgl.WebGLContext.SAMPLER_CUBE*/0x8B60:
						one.fun = this._uniform_samplerCube;
						break;
					case /*laya.webgl.WebGLContext.FLOAT_MAT4*/0x8B5C:
						one.glfun = gl.uniformMatrix4fv;
						one.fun = this._uniformMatrix4fv;
						break;
					case /*laya.webgl.WebGLContext.BOOL*/0x8B56:
						one.fun = this._uniform1i;
						break;
					case /*laya.webgl.WebGLContext.FLOAT_MAT2*/0x8B5A:
					case /*laya.webgl.WebGLContext.FLOAT_MAT3*/0x8B5B:
						throw new Error("compile shader err!");
						break;
					default:
						throw new Error("compile shader err!");
						break;
				}
			}
		}

		/**
		*根据变量名字获得
		*@param name
		*@return
		*/
		__proto.getUniform = function (name) {
			return this._paramsMap[name];
		}

		__proto._attribute = function (one, value) {
			var gl = WebGL.mainContext;
			var enableAtributes = Buffer._enableAtributes;
			var location = one.location;
			(enableAtributes[location]) || (gl.enableVertexAttribArray(location));
			gl.vertexAttribPointer(location, value[0], value[1], value[2], value[3], value[4] + this._offset);
			enableAtributes[location] = Buffer._bindVertexBuffer;
			return 1;
		}

		__proto._uniform1f = function (one, value) {
			var uploadedValue = one.uploadedValue;
			if (uploadedValue[0] !== value) {
				WebGL.mainContext.uniform1f(one.location, uploadedValue[0] = value);
				return 1;
			}
			return 0;
		}

		__proto._uniform1fv = function (one, value) {
			if (value.length < 4) {
				var uploadedValue = one.uploadedValue;
				if (uploadedValue[0] !== value[0] || uploadedValue[1] !== value[1] || uploadedValue[2] !== value[2] || uploadedValue[3] !== value[3]) {
					WebGL.mainContext.uniform1fv(one.location, value);
					uploadedValue[0] = value[0];
					uploadedValue[1] = value[1];
					uploadedValue[2] = value[2];
					uploadedValue[3] = value[3];
					return 1;
				}
				return 0;
			} else {
				WebGL.mainContext.uniform1fv(one.location, value);
				return 1;
			}
		}

		__proto._uniform_vec2 = function (one, value) {
			var uploadedValue = one.uploadedValue;
			if (uploadedValue[0] !== value[0] || uploadedValue[1] !== value[1]) {
				WebGL.mainContext.uniform2f(one.location, uploadedValue[0] = value[0], uploadedValue[1] = value[1]);
				return 1;
			}
			return 0;
		}

		__proto._uniform_vec2v = function (one, value) {
			if (value.length < 2) {
				var uploadedValue = one.uploadedValue;
				if (uploadedValue[0] !== value[0] || uploadedValue[1] !== value[1] || uploadedValue[2] !== value[2] || uploadedValue[3] !== value[3]) {
					WebGL.mainContext.uniform2fv(one.location, value);
					uploadedValue[0] = value[0];
					uploadedValue[1] = value[1];
					uploadedValue[2] = value[2];
					uploadedValue[3] = value[3];
					return 1;
				}
				return 0;
			} else {
				WebGL.mainContext.uniform2fv(one.location, value);
				return 1;
			}
		}

		__proto._uniform_vec3 = function (one, value) {
			var uploadedValue = one.uploadedValue;
			if (uploadedValue[0] !== value[0] || uploadedValue[1] !== value[1] || uploadedValue[2] !== value[2]) {
				WebGL.mainContext.uniform3f(one.location, uploadedValue[0] = value[0], uploadedValue[1] = value[1], uploadedValue[2] = value[2]);
				return 1;
			}
			return 0;
		}

		__proto._uniform_vec3v = function (one, value) {
			WebGL.mainContext.uniform3fv(one.location, value);
			return 1;
		}

		__proto._uniform_vec4 = function (one, value) {
			var uploadedValue = one.uploadedValue;
			if (uploadedValue[0] !== value[0] || uploadedValue[1] !== value[1] || uploadedValue[2] !== value[2] || uploadedValue[3] !== value[3]) {
				WebGL.mainContext.uniform4f(one.location, uploadedValue[0] = value[0], uploadedValue[1] = value[1], uploadedValue[2] = value[2], uploadedValue[3] = value[3]);
				return 1;
			}
			return 0;
		}

		__proto._uniform_vec4v = function (one, value) {
			WebGL.mainContext.uniform4fv(one.location, value);
			return 1;
		}

		__proto._uniformMatrix2fv = function (one, value) {
			WebGL.mainContext.uniformMatrix2fv(one.location, false, value);
			return 1;
		}

		__proto._uniformMatrix3fv = function (one, value) {
			WebGL.mainContext.uniformMatrix3fv(one.location, false, value);
			return 1;
		}

		__proto._uniformMatrix4fv = function (one, value) {
			WebGL.mainContext.uniformMatrix4fv(one.location, false, value);
			return 1;
		}

		__proto._uniform1i = function (one, value) {
			var uploadedValue = one.uploadedValue;
			if (uploadedValue[0] !== value) {
				WebGL.mainContext.uniform1i(one.location, uploadedValue[0] = value);
				return 1;
			}
			return 0;
		}

		__proto._uniform1iv = function (one, value) {
			WebGL.mainContext.uniform1iv(one.location, value);
			return 1;
		}

		__proto._uniform_ivec2 = function (one, value) {
			var uploadedValue = one.uploadedValue;
			if (uploadedValue[0] !== value[0] || uploadedValue[1] !== value[1]) {
				WebGL.mainContext.uniform2i(one.location, uploadedValue[0] = value[0], uploadedValue[1] = value[1]);
				return 1;
			}
			return 0;
		}

		__proto._uniform_ivec2v = function (one, value) {
			WebGL.mainContext.uniform2iv(one.location, value);
			return 1;
		}

		__proto._uniform_vec3i = function (one, value) {
			var uploadedValue = one.uploadedValue;
			if (uploadedValue[0] !== value[0] || uploadedValue[1] !== value[1] || uploadedValue[2] !== value[2]) {
				WebGL.mainContext.uniform3i(one.location, uploadedValue[0] = value[0], uploadedValue[1] = value[1], uploadedValue[2] = value[2]);
				return 1;
			}
			return 0;
		}

		__proto._uniform_vec3vi = function (one, value) {
			WebGL.mainContext.uniform3iv(one.location, value);
			return 1;
		}

		__proto._uniform_vec4i = function (one, value) {
			var uploadedValue = one.uploadedValue;
			if (uploadedValue[0] !== value[0] || uploadedValue[1] !== value[1] || uploadedValue[2] !== value[2] || uploadedValue[3] !== value[3]) {
				WebGL.mainContext.uniform4i(one.location, uploadedValue[0] = value[0], uploadedValue[1] = value[1], uploadedValue[2] = value[2], uploadedValue[3] = value[3]);
				return 1;
			}
			return 0;
		}

		__proto._uniform_vec4vi = function (one, value) {
			WebGL.mainContext.uniform4iv(one.location, value);
			return 1;
		}

		__proto._uniform_sampler2D = function (one, value) {
			var gl = WebGL.mainContext;
			var uploadedValue = one.uploadedValue;
			if (uploadedValue[0] == null) {
				uploadedValue[0] = this._curActTexIndex;
				gl.uniform1i(one.location, this._curActTexIndex);
				gl.activeTexture(Shader._TEXTURES[this._curActTexIndex]);
				WebGLContext.bindTexture(gl,/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1, value);
				this._curActTexIndex++;
				return 1;
			} else {
				gl.activeTexture(Shader._TEXTURES[uploadedValue[0]]);
				WebGLContext.bindTexture(gl,/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1, value);
				return 0;
			}
		}

		__proto._uniform_samplerCube = function (one, value) {
			var gl = WebGL.mainContext;
			var uploadedValue = one.uploadedValue;
			if (uploadedValue[0] == null) {
				uploadedValue[0] = this._curActTexIndex;
				gl.uniform1i(one.location, this._curActTexIndex);
				gl.activeTexture(Shader._TEXTURES[this._curActTexIndex]);
				WebGLContext.bindTexture(gl,/*laya.webgl.WebGLContext.TEXTURE_CUBE_MAP*/0x8513, value);
				this._curActTexIndex++;
				return 1;
			} else {
				gl.activeTexture(Shader._TEXTURES[uploadedValue[0]]);
				WebGLContext.bindTexture(gl,/*laya.webgl.WebGLContext.TEXTURE_CUBE_MAP*/0x8513, value);
				return 0;
			}
		}

		__proto._noSetValue = function (one) {
			console.log("no....:" + one.name);
		}

		//throw new Error("upload shader err,must set value:"+one.name);
		__proto.uploadOne = function (name, value) {
			this.activeResource();
			WebGLContext.UseProgram(this._program);
			var one = this._paramsMap[name];
			one.fun.call(this, one, value);
		}

		__proto.uploadTexture2D = function (value) {
			Stat.shaderCall++;
			var gl = WebGL.mainContext;
			gl.activeTexture(/*laya.webgl.WebGLContext.TEXTURE0*/0x84C0);
			WebGLContext.bindTexture(gl,/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1, value);
		}

		/**
		*提交shader到GPU
		*@param shaderValue
		*/
		__proto.upload = function (shaderValue, params) {
			BaseShader.activeShader = BaseShader.bindShader = this;
			this._lastUseFrameCount === Stat.loopCount || this.activeResource();
			WebGLContext.UseProgram(this._program);
			if (this._reCompile) {
				params = this._params;
				this._reCompile = false;
			} else {
				params = params || this._params;
			};
			var gl = WebGL.mainContext;
			var one, value, n = params.length, shaderCall = 0;
			for (var i = 0; i < n; i++) {
				one = params[i];
				if ((value = shaderValue[one.name]) !== null)
					shaderCall += one.fun.call(this, one, value);
			}
			Stat.shaderCall += shaderCall;
		}

		/**
		*按数组的定义提交
		*@param shaderValue 数组格式[name,value,...]
		*/
		__proto.uploadArray = function (shaderValue, length, _bufferUsage) {
			BaseShader.activeShader = this;
			BaseShader.bindShader = this;
			this.activeResource();
			WebGLContext.UseProgram(this._program);
			var params = this._params, value;
			var one, shaderCall = 0;
			for (var i = length - 2; i >= 0; i -= 2) {
				one = this._paramsMap[shaderValue[i]];
				if (!one)
					continue;
				value = shaderValue[i + 1];
				if (value != null) {
					_bufferUsage && _bufferUsage[one.name] && _bufferUsage[one.name].bind();
					shaderCall += one.fun.call(this, one, value);
				}
			}
			Stat.shaderCall += shaderCall;
		}

		/**
		*得到编译后的变量及相关预定义
		*@return
		*/
		__proto.getParams = function () {
			return this._params;
		}

		Shader.getShader = function (name) {
			return Shader.sharders[name];
		}

		Shader.create = function (vs, ps, saveName, nameMap) {
			return new Shader(vs, ps, saveName, nameMap);
		}

		Shader.withCompile = function (nameID, define, shaderName, createShader) {
			if (shaderName && Shader.sharders[shaderName])
				return Shader.sharders[shaderName];
			var pre = Shader._preCompileShader[0.0002 * nameID];
			if (!pre)
				throw new Error("withCompile shader err!" + nameID);
			return pre.createShader(define, shaderName, createShader);
		}

		Shader.withCompile2D = function (nameID, mainID, define, shaderName, createShader) {
			if (shaderName && Shader.sharders[shaderName])
				return Shader.sharders[shaderName];
			var pre = Shader._preCompileShader[0.0002 * nameID + mainID];
			if (!pre)
				throw new Error("withCompile shader err!" + nameID + " " + mainID);
			return pre.createShader(define, shaderName, createShader);
		}

		Shader.addInclude = function (fileName, txt) {
			ShaderCompile.addInclude(fileName, txt);
		}

		Shader.preCompile = function (nameID, vs, ps, nameMap) {
			var id = 0.0002 * nameID;
			Shader._preCompileShader[id] = new ShaderCompile(id, vs, ps, nameMap);
		}

		Shader.preCompile2D = function (nameID, mainID, vs, ps, nameMap) {
			var id = 0.0002 * nameID + mainID;
			Shader._preCompileShader[id] = new ShaderCompile(id, vs, ps, nameMap);
		}

		Shader._createShader = function (gl, str, type) {
			var shader = gl.createShader(type);
			gl.shaderSource(shader, str);
			gl.compileShader(shader);
			return shader;
		}

		Shader._TEXTURES = [ /*laya.webgl.WebGLContext.TEXTURE0*/0x84C0,/*laya.webgl.WebGLContext.TEXTURE1*/0x84C1,/*laya.webgl.WebGLContext.TEXTURE2*/0x84C2,/*laya.webgl.WebGLContext.TEXTURE3*/0x84C3,/*laya.webgl.WebGLContext.TEXTURE4*/0x84C4,/*laya.webgl.WebGLContext.TEXTURE5*/0x84C5,/*laya.webgl.WebGLContext.TEXTURE6*/0x84C6, ,/*laya.webgl.WebGLContext.TEXTURE7*/0x84C7,/*laya.webgl.WebGLContext.TEXTURE8*/0x84C8];
		Shader._count = 0;
		Shader._preCompileShader = {};
		Shader.SHADERNAME2ID = 0.0002;
		Shader.sharders = (Shader.sharders = [], Shader.sharders.length = 0x20, Shader.sharders);
		__static(Shader,
			['nameKey', function () { return this.nameKey = new StringKey(); }
			]);
		return Shader;
	})(BaseShader)


	//class laya.webgl.utils.Buffer2D extends laya.webgl.utils.Buffer
	var Buffer2D = (function (_super) {
		function Buffer2D() {
			this._maxsize = 0;
			this._upload = true;
			this._uploadSize = 0;
			Buffer2D.__super.call(this);
			this.lock = true;
		}

		__class(Buffer2D, 'laya.webgl.utils.Buffer2D', _super);
		var __proto = Buffer2D.prototype;
		/**
		*在当前的基础上需要多大空间，单位是byte
		*@param sz
		*@return 增加大小之前的写位置。单位是byte
		*/
		__proto.needSize = function (sz) {
			var old = this._byteLength;
			if (sz) {
				var needsz = this._byteLength + sz;
				needsz <= this._buffer.byteLength || (this._resizeBuffer(needsz << 1, true));
				this._byteLength = needsz;
			}
			return old;
		}

		__proto._bufferData = function () {
			this._maxsize = Math.max(this._maxsize, this._byteLength);
			if (Stat.loopCount % 30 == 0) {
				if (this._buffer.byteLength > (this._maxsize + 64)) {
					this.memorySize = this._buffer.byteLength;
					this._buffer = this._buffer.slice(0, this._maxsize + 64);
					this._checkArrayUse();
				}
				this._maxsize = this._byteLength;
			}
			if (this._uploadSize < this._buffer.byteLength) {
				this._uploadSize = this._buffer.byteLength;
				Buffer._gl.bufferData(this._bufferType, this._uploadSize, this._bufferUsage);
				this.memorySize = this._uploadSize;
			}
			Buffer._gl.bufferSubData(this._bufferType, 0, this._buffer);
		}

		__proto._bufferSubData = function (offset, dataStart, dataLength) {
			(offset === void 0) && (offset = 0);
			(dataStart === void 0) && (dataStart = 0);
			(dataLength === void 0) && (dataLength = 0);
			this._maxsize = Math.max(this._maxsize, this._byteLength);
			if (Stat.loopCount % 30 == 0) {
				if (this._buffer.byteLength > (this._maxsize + 64)) {
					this.memorySize = this._buffer.byteLength;
					this._buffer = this._buffer.slice(0, this._maxsize + 64);
					this._checkArrayUse();
				}
				this._maxsize = this._byteLength;
			}
			if (this._uploadSize < this._buffer.byteLength) {
				this._uploadSize = this._buffer.byteLength;
				Buffer._gl.bufferData(this._bufferType, this._uploadSize, this._bufferUsage);
				this.memorySize = this._uploadSize;
			}
			if (dataStart || dataLength) {
				var subBuffer = this._buffer.slice(dataStart, dataLength);
				Buffer._gl.bufferSubData(this._bufferType, offset, subBuffer);
			} else {
				Buffer._gl.bufferSubData(this._bufferType, offset, this._buffer);
			}
		}

		__proto._checkArrayUse = function () { }
		__proto._bind_upload = function () {
			if (!this._upload)
				return false;
			this._upload = false;
			this._bind();
			this._bufferData();
			return true;
		}

		__proto._bind_subUpload = function (offset, dataStart, dataLength) {
			(offset === void 0) && (offset = 0);
			(dataStart === void 0) && (dataStart = 0);
			(dataLength === void 0) && (dataLength = 0);
			if (!this._upload)
				return false;
			this._upload = false;
			this._bind();
			this._bufferSubData(offset, dataStart, dataLength);
			return true;
		}

		__proto._resizeBuffer = function (nsz, copy) {
			if (nsz < this._buffer.byteLength)
				return this;
			this.memorySize = nsz;
			if (copy && this._buffer && this._buffer.byteLength > 0) {
				var newbuffer = new ArrayBuffer(nsz);
				var n = new Uint8Array(newbuffer);
				n.set(new Uint8Array(this._buffer), 0);
				this._buffer = newbuffer;
			} else
				this._buffer = new ArrayBuffer(nsz);
			this._checkArrayUse();
			this._upload = true;
			return this;
		}

		__proto.append = function (data) {
			this._upload = true;
			var byteLen = 0, n;
			byteLen = data.byteLength;
			if ((data instanceof Uint8Array)) {
				this._resizeBuffer(this._byteLength + byteLen, true);
				n = new Uint8Array(this._buffer, this._byteLength);
			} else if ((data instanceof Uint16Array)) {
				this._resizeBuffer(this._byteLength + byteLen, true);
				n = new Uint16Array(this._buffer, this._byteLength);
			} else if ((data instanceof Float32Array)) {
				this._resizeBuffer(this._byteLength + byteLen, true);
				n = new Float32Array(this._buffer, this._byteLength);
			}
			n.set(data, 0);
			this._byteLength += byteLen;
			this._checkArrayUse();
		}

		/**
		*附加Uint16Array的数据。数据长度是len。byte的话要*2
		*@param data
		*@param len
		*/
		__proto.appendU16Array = function (data, len) {
			this._resizeBuffer(this._byteLength + len * 2, true);
			var u = new Uint16Array(this._buffer, this._byteLength, len);
			for (var i = 0; i < len; i++) {
				u[i] = data[i];
			}
			this._byteLength += len * 2;
			this._checkArrayUse();
		}

		__proto.appendEx = function (data, type) {
			this._upload = true;
			var byteLen = 0, n;
			byteLen = data.byteLength;
			this._resizeBuffer(this._byteLength + byteLen, true);
			n = new type(this._buffer, this._byteLength);
			n.set(data, 0);
			this._byteLength += byteLen;
			this._checkArrayUse();
		}

		__proto.appendEx2 = function (data, type, dataLen, perDataLen) {
			(perDataLen === void 0) && (perDataLen = 1);
			this._upload = true;
			var byteLen = 0, n;
			byteLen = dataLen * perDataLen;
			this._resizeBuffer(this._byteLength + byteLen, true);
			n = new type(this._buffer, this._byteLength);
			var i = 0;
			for (i = 0; i < dataLen; i++) {
				n[i] = data[i];
			}
			this._byteLength += byteLen;
			this._checkArrayUse();
		}

		__proto.getBuffer = function () {
			return this._buffer;
		}

		__proto.setNeedUpload = function () {
			this._upload = true;
		}

		__proto.getNeedUpload = function () {
			return this._upload;
		}

		__proto.upload = function () {
			var scuess = this._bind_upload();
			Buffer._gl.bindBuffer(this._bufferType, null);
			Buffer._bindActive[this._bufferType] = null;
			BaseShader.activeShader = null
			return scuess;
		}

		__proto.subUpload = function (offset, dataStart, dataLength) {
			(offset === void 0) && (offset = 0);
			(dataStart === void 0) && (dataStart = 0);
			(dataLength === void 0) && (dataLength = 0);
			var scuess = this._bind_subUpload();
			Buffer._gl.bindBuffer(this._bufferType, null);
			Buffer._bindActive[this._bufferType] = null;
			BaseShader.activeShader = null
			return scuess;
		}

		__proto.disposeResource = function () {
			_super.prototype.disposeResource.call(this);
			this._upload = true;
			this._uploadSize = 0;
		}

		__proto.clear = function () {
			this._byteLength = 0;
			this._upload = true;
		}

		__getset(0, __proto, 'bufferLength', function () {
			return this._buffer.byteLength;
		});

		__getset(0, __proto, 'byteLength', null, function (value) {
			if (this._byteLength === value)
				return;
			value <= this._buffer.byteLength || (this._resizeBuffer(value * 2 + 256, true));
			this._byteLength = value;
		});

		Buffer2D.__int__ = function (gl) {
			IndexBuffer2D.QuadrangleIB = IndexBuffer2D.create(/*laya.webgl.WebGLContext.STATIC_DRAW*/0x88E4);
			GlUtils.fillIBQuadrangle(IndexBuffer2D.QuadrangleIB, 16);
		}

		Buffer2D.FLOAT32 = 4;
		Buffer2D.SHORT = 2;
		return Buffer2D;
	})(Buffer)


	//class laya.webgl.shader.d2.value.GlowSV extends laya.webgl.shader.d2.value.TextureSV
	var GlowSV = (function (_super) {
		function GlowSV(args) {
			this.u_blurX = false;
			this.u_color = null;
			this.u_offset = null;
			this.u_strength = NaN;
			this.u_texW = 0;
			this.u_texH = 0;
			GlowSV.__super.call(this,/*laya.webgl.shader.d2.ShaderDefines2D.FILTERGLOW*/0x08 | /*laya.webgl.shader.d2.ShaderDefines2D.TEXTURE2D*/0x01);
		}

		__class(GlowSV, 'laya.webgl.shader.d2.value.GlowSV', _super);
		var __proto = GlowSV.prototype;
		__proto.setValue = function (vo) {
			_super.prototype.setValue.call(this, vo);
		}

		__proto.clear = function () {
			_super.prototype.clear.call(this);
		}

		return GlowSV;
	})(TextureSV)


	//class laya.webgl.shader.d2.value.TextSV extends laya.webgl.shader.d2.value.TextureSV
	var TextSV = (function (_super) {
		function TextSV(args) {
			TextSV.__super.call(this,/*laya.webgl.shader.d2.ShaderDefines2D.COLORADD*/0x40);
			this.defines.add(/*laya.webgl.shader.d2.ShaderDefines2D.COLORADD*/0x40);
		}

		__class(TextSV, 'laya.webgl.shader.d2.value.TextSV', _super);
		var __proto = TextSV.prototype;
		__proto.release = function () {
			TextSV.pool[TextSV._length++] = this;
			this.clear();
		}

		__proto.clear = function () {
			_super.prototype.clear.call(this);
		}

		TextSV.create = function () {
			if (TextSV._length) return TextSV.pool[--TextSV._length];
			else return new TextSV(null);
		}

		TextSV.pool = [];
		TextSV._length = 0;
		return TextSV;
	})(TextureSV)


	//class laya.webgl.shader.d2.Shader2X extends laya.webgl.shader.Shader
	var Shader2X = (function (_super) {
		function Shader2X(vs, ps, saveName, nameMap) {
			this._params2dQuick1 = null;
			this._params2dQuick2 = null;
			this._shaderValueWidth = NaN;
			this._shaderValueHeight = NaN;
			Shader2X.__super.call(this, vs, ps, saveName, nameMap);
		}

		__class(Shader2X, 'laya.webgl.shader.d2.Shader2X', _super);
		var __proto = Shader2X.prototype;
		__proto.upload2dQuick1 = function (shaderValue) {
			this.upload(shaderValue, this._params2dQuick1 || this._make2dQuick1());
		}

		__proto._make2dQuick1 = function () {
			if (!this._params2dQuick1) {
				this.activeResource();
				this._params2dQuick1 = [];
				var params = this._params, one;
				for (var i = 0, n = params.length; i < n; i++) {
					one = params[i];
					if (!Render.isFlash && (one.name === "size" || one.name === "position" || one.name === "texcoord")) continue;
					this._params2dQuick1.push(one);
				}
			}
			return this._params2dQuick1;
		}

		__proto.disposeResource = function () {
			_super.prototype.disposeResource.call(this);
			this._params2dQuick1 = null;
			this._params2dQuick2 = null;
		}

		__proto.upload2dQuick2 = function (shaderValue) {
			this.upload(shaderValue, this._params2dQuick2 || this._make2dQuick2());
		}

		__proto._make2dQuick2 = function () {
			if (!this._params2dQuick2) {
				this.activeResource();
				this._params2dQuick2 = [];
				var params = this._params, one;
				for (var i = 0, n = params.length; i < n; i++) {
					one = params[i];
					if (!Render.isFlash && (one.name === "size")) continue;
					this._params2dQuick2.push(one);
				}
			}
			return this._params2dQuick2;
		}

		Shader2X.create = function (vs, ps, saveName, nameMap) {
			return new Shader2X(vs, ps, saveName, nameMap);
		}

		return Shader2X;
	})(Shader)


	//class laya.webgl.utils.IndexBuffer2D extends laya.webgl.utils.Buffer2D
	var IndexBuffer2D = (function (_super) {
		function IndexBuffer2D(bufferUsage) {
			this._uint8Array = null;
			this._uint16Array = null;
			(bufferUsage === void 0) && (bufferUsage =/*laya.webgl.WebGLContext.STATIC_DRAW*/0x88E4);
			IndexBuffer2D.__super.call(this);
			this._bufferUsage = bufferUsage;
			this._bufferType =/*laya.webgl.WebGLContext.ELEMENT_ARRAY_BUFFER*/0x8893;
			Render.isFlash || (this._buffer = new ArrayBuffer(8));
		}

		__class(IndexBuffer2D, 'laya.webgl.utils.IndexBuffer2D', _super);
		var __proto = IndexBuffer2D.prototype;
		__proto._checkArrayUse = function () {
			this._uint8Array && (this._uint8Array = new Uint8Array(this._buffer));
			this._uint16Array && (this._uint16Array = new Uint16Array(this._buffer));
		}

		__proto.getUint8Array = function () {
			return this._uint8Array || (this._uint8Array = new Uint8Array(this._buffer));
		}

		__proto.getUint16Array = function () {
			return this._uint16Array || (this._uint16Array = new Uint16Array(this._buffer));
		}

		__proto.destory = function () {
			this._uint16Array = null;
			this._uint8Array = null;
			this._buffer = null;
		}

		IndexBuffer2D.QuadrangleIB = null;
		IndexBuffer2D.create = function (bufferUsage) {
			(bufferUsage === void 0) && (bufferUsage =/*laya.webgl.WebGLContext.STATIC_DRAW*/0x88E4);
			return new IndexBuffer2D(bufferUsage);
		}

		return IndexBuffer2D;
	})(Buffer2D)


	//class laya.webgl.utils.VertexBuffer2D extends laya.webgl.utils.Buffer2D
	var VertexBuffer2D = (function (_super) {
		function VertexBuffer2D(vertexStride, bufferUsage) {
			this._floatArray32 = null;
			this._vertexStride = 0;
			VertexBuffer2D.__super.call(this);
			this._vertexStride = vertexStride;
			this._bufferUsage = bufferUsage;
			this._bufferType =/*laya.webgl.WebGLContext.ARRAY_BUFFER*/0x8892;
			Render.isFlash || (this._buffer = new ArrayBuffer(8));
			this.getFloat32Array();
		}

		__class(VertexBuffer2D, 'laya.webgl.utils.VertexBuffer2D', _super);
		var __proto = VertexBuffer2D.prototype;
		__proto.getFloat32Array = function () {
			return this._floatArray32 || (this._floatArray32 = new Float32Array(this._buffer));
		}

		__proto.bind = function (ibBuffer) {
			(ibBuffer) && (ibBuffer._bind());
			this._bind();
		}

		__proto.insertData = function (data, pos) {
			var vbdata = this.getFloat32Array();
			vbdata.set(data, pos);
			this._upload = true;
		}

		__proto.bind_upload = function (ibBuffer) {
			(ibBuffer._bind_upload()) || (ibBuffer._bind());
			(this._bind_upload()) || (this._bind());
		}

		__proto._checkArrayUse = function () {
			this._floatArray32 && (this._floatArray32 = new Float32Array(this._buffer));
		}

		__proto.disposeResource = function () {
			_super.prototype.disposeResource.call(this);
			var enableAtributes = Buffer._enableAtributes;
			for (var i = 0; i < 10; i++) {
				WebGL.mainContext.disableVertexAttribArray(i);
				enableAtributes[i] = null;
			}
		}

		//}
		__proto.destory = function () {
			this._byteLength = 0;
			this._upload = true;
			this._buffer = null;
			this._floatArray32 = null;
		}

		__getset(0, __proto, 'vertexStride', function () {
			return this._vertexStride;
		});

		VertexBuffer2D.create = function (vertexStride, bufferUsage) {
			(bufferUsage === void 0) && (bufferUsage =/*laya.webgl.WebGLContext.DYNAMIC_DRAW*/0x88E8);
			return new VertexBuffer2D(vertexStride, bufferUsage);
		}

		return VertexBuffer2D;
	})(Buffer2D)


	//class laya.webgl.resource.WebGLImage extends laya.resource.HTMLImage
	var WebGLImage = (function (_super) {
		function WebGLImage(data, def, format, mipmap) {
			/**@private */
			this._format = 0;
			/**@private */
			this._mipmap = false;
			/***是否创建私有Source,值为false时不根据src创建私有WebGLTexture,同时销毁时也只清空source=null,不调用WebGL.mainContext.deleteTexture类似函数，调用资源激活前有效*/
			this._allowMerageInAtlas = false;
			/**是否允许加入大图合集*/
			this._enableMerageInAtlas = false;
			/**是否使用重复模式纹理寻址*/
			this.repeat = false;
			/**@private */
			this._image = null;
			/**缩小过滤器*/
			this.minFifter = 0;
			/**放大过滤器*/
			this.magFifter = 0;
			(format === void 0) && (format =/*laya.webgl.WebGLContext.RGBA*/0x1908);
			(mipmap === void 0) && (mipmap = true);
			WebGLImage.__super.call(this, data, def);
			this._format = format;
			this._mipmap = mipmap;
			this.repeat = false;
			this.minFifter = -1;
			this.magFifter = -1;
			if ((typeof data == 'string')) {
				this._url = data;
				this._src = data;
				this._image = new Browser.window.Image();
				if (def) {
					def.onload && (this.onload = def.onload);
					def.onerror && (this.onerror = def.onerror);
					def.onCreate && def.onCreate(this);
				}
				this._image.crossOrigin = (data && (data.indexOf("data:") == 0)) ? null : "";
				(data) && (this._image.src = data);
			} else if ((data instanceof ArrayBuffer)) {
				this._src = def;
				this._url = this._src;
				var readData = new Byte(data);
				var magicNumber = readData.readUTFBytes(4);
				var version = readData.readUTFBytes(2);
				var dataType = readData.getInt16();
				readData.endian =/*laya.utils.Byte.BIG_ENDIAN*/"bigEndian";
				this._w = readData.getInt16();
				this._h = readData.getInt16();
				var originalWidth = readData.getInt16();
				var originalHeight = readData.getInt16();
				this._image = new Uint8Array(data, readData.pos);
				this._format = WebGL.compressEtc1.COMPRESSED_RGB_ETC1_WEBGL;
				(AtlasResourceManager.enabled) && (this._w < AtlasResourceManager.atlasLimitWidth && this._h < AtlasResourceManager.atlasLimitHeight) ? this._allowMerageInAtlas = true : this._allowMerageInAtlas = false;
			} else {
				this._src = def;
				this._url = this._src;
				this._image = data["source"] || data;
				this.onresize();
			}
			this._$5__enableMerageInAtlas = true;
		}

		__class(WebGLImage, 'laya.webgl.resource.WebGLImage', _super);
		var __proto = WebGLImage.prototype;
		Laya.imps(__proto, { "laya.webgl.resource.IMergeAtlasBitmap": true })
		__proto._init_ = function (src, def) { }
		__proto._createWebGlTexture = function () {
			if (!this._image) {
				throw "create GLTextur err:no data:" + this._image;
			};
			var gl = WebGL.mainContext;
			var glTex = this._source = gl.createTexture();
			var preTarget = WebGLContext.curBindTexTarget;
			var preTexture = WebGLContext.curBindTexValue;
			WebGLContext.bindTexture(gl,/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1, glTex);
			gl.pixelStorei(/*laya.webgl.WebGLContext.UNPACK_PREMULTIPLY_ALPHA_WEBGL*/0x9241, true);
			switch (this._format) {
				case /*laya.webgl.WebGLContext.RGBA*/0x1908:
					gl.texImage2D(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1, 0, this._format,/*laya.webgl.WebGLContext.RGBA*/0x1908,/*laya.webgl.WebGLContext.UNSIGNED_BYTE*/0x1401, this._image);
					break;
				case WebGL.compressEtc1.COMPRESSED_RGB_ETC1_WEBGL:
					gl.compressedTexImage2D(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1, 0, this._format, this._w, this._h, 0, this._image);
					break;
			}
			gl.pixelStorei(/*laya.webgl.WebGLContext.UNPACK_PREMULTIPLY_ALPHA_WEBGL*/0x9241, false);
			var minFifter = this.minFifter;
			var magFifter = this.magFifter;
			var repeat = this.repeat ? /*laya.webgl.WebGLContext.REPEAT*/0x2901 :/*laya.webgl.WebGLContext.CLAMP_TO_EDGE*/0x812F;
			var isPot = Arith.isPOT(this._w, this._h);
			if (isPot) {
				if (this.mipmap)
					(minFifter !== -1) || (minFifter =/*laya.webgl.WebGLContext.LINEAR_MIPMAP_LINEAR*/0x2703);
				else
					(minFifter !== -1) || (minFifter =/*laya.webgl.WebGLContext.LINEAR*/0x2601);
				(magFifter !== -1) || (magFifter =/*laya.webgl.WebGLContext.LINEAR*/0x2601);
				gl.texParameteri(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,/*laya.webgl.WebGLContext.TEXTURE_MIN_FILTER*/0x2801, minFifter);
				gl.texParameteri(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,/*laya.webgl.WebGLContext.TEXTURE_MAG_FILTER*/0x2800, magFifter);
				gl.texParameteri(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,/*laya.webgl.WebGLContext.TEXTURE_WRAP_S*/0x2802, repeat);
				gl.texParameteri(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,/*laya.webgl.WebGLContext.TEXTURE_WRAP_T*/0x2803, repeat);
				this.mipmap && gl.generateMipmap(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1);
			} else {
				(minFifter !== -1) || (minFifter =/*laya.webgl.WebGLContext.LINEAR*/0x2601);
				(magFifter !== -1) || (magFifter =/*laya.webgl.WebGLContext.LINEAR*/0x2601);
				gl.texParameteri(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,/*laya.webgl.WebGLContext.TEXTURE_MIN_FILTER*/0x2801, minFifter);
				gl.texParameteri(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,/*laya.webgl.WebGLContext.TEXTURE_MAG_FILTER*/0x2800, magFifter);
				gl.texParameteri(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,/*laya.webgl.WebGLContext.TEXTURE_WRAP_S*/0x2802,/*laya.webgl.WebGLContext.CLAMP_TO_EDGE*/0x812F);
				gl.texParameteri(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,/*laya.webgl.WebGLContext.TEXTURE_WRAP_T*/0x2803,/*laya.webgl.WebGLContext.CLAMP_TO_EDGE*/0x812F);
			}
			(preTarget && preTexture) && (WebGLContext.bindTexture(gl, preTarget, preTexture));
			this._image.onload = null;
			this._image = null;
			if (isPot && this.mipmap)
				this.memorySize = this._w * this._h * 4 * (1 + 1 / 3);
			else
				this.memorySize = this._w * this._h * 4;
			this._recreateLock = false;
		}

		/***重新创建资源，如果异步创建中被强制释放再创建，则需等待释放完成后再重新加载创建。*/
		__proto.recreateResource = function () {
			var _$this = this;
			if (this._src == null || this._src === "")
				return;
			this._needReleaseAgain = false;
			if (!this._image) {
				this._recreateLock = true;
				var _this = this;
				this._image = new Browser.window.Image();
				this._image.crossOrigin = this._src.indexOf("data:") == 0 ? null : "";
				this._image.onload = function () {
					if (_this._needReleaseAgain) {
						_this._needReleaseAgain = false;
						_this._image.onload = null;
						_this._image = null;
						return;
					}
					(!(_this._allowMerageInAtlas && _this._enableMerageInAtlas)) ? (_this._createWebGlTexture()) : (_$this.memorySize = 0, _$this._recreateLock = false);
					_this.completeCreate();
				};
				this._image.src = this._src;
			} else {
				if (this._recreateLock) {
					return;
				}
				(!(this._allowMerageInAtlas && this._$5__enableMerageInAtlas)) ? (this._createWebGlTexture()) : (this.memorySize = 0, this._recreateLock = false);
				this.completeCreate();
			}
		}

		/***销毁资源*/
		__proto.disposeResource = function () {
			if (this._recreateLock) {
				this._needReleaseAgain = true;
			}
			if (this._source) {
				WebGL.mainContext.deleteTexture(this._source);
				this._source = null;
				this._image = null;
				this.memorySize = 0;
			}
		}

		/***调整尺寸*/
		__proto.onresize = function () {
			this._w = this._image.width;
			this._h = this._image.height;
			(AtlasResourceManager.enabled) && (this._w < AtlasResourceManager.atlasLimitWidth && this._h < AtlasResourceManager.atlasLimitHeight) ? this._allowMerageInAtlas = true : this._allowMerageInAtlas = false;
		}

		__proto.clearAtlasSource = function () {
			this._image = null;
		}

		/**
		*获取纹理格式。
		*/
		__getset(0, __proto, 'format', function () {
			return this._format;
		});

		/**
		*是否创建私有Source,通常禁止修改
		*@param value 是否创建
		*/
		/**
		*是否创建私有Source
		*@return 是否创建
		*/
		__getset(0, __proto, 'enableMerageInAtlas', function () {
			return this._$5__enableMerageInAtlas;
		}, function (value) {
			this._$5__enableMerageInAtlas = value;
		});

		/**
		*获取是否具有mipmap。
		*/
		__getset(0, __proto, 'mipmap', function () {
			return this._mipmap;
		});

		/**
		*是否创建私有Source
		*@return 是否创建
		*/
		__getset(0, __proto, 'allowMerageInAtlas', function () {
			return this._allowMerageInAtlas;
		});

		__getset(0, __proto, 'atlasSource', function () {
			return this._image;
		});

		/***
		*设置onload函数
		*@param value onload函数
		*/
		__getset(0, __proto, 'onload', null, function (value) {
			var _$this = this;
			this._onload = value;
			this._image && (this._image.onload = this._onload != null ? (function () {
				_$this.onresize();
				_$this._onload();
			}) : null);
		});

		/***
		*设置onerror函数
		*@param value onerror函数
		*/
		__getset(0, __proto, 'onerror', null, function (value) {
			var _$this = this;
			this._onerror = value;
			this._image && (this._image.onerror = this._onerror != null ? (function () {
				_$this._onerror()
			}) : null);
		});

		return WebGLImage;
	})(HTMLImage)


	Laya.__init([DrawText, AtlasGrid, WebGLContext2D, ShaderCompile]);
})(window, document, Laya);

if (typeof define === 'function' && define.amd) {
	define('laya.core', ['require', "exports"], function (require, exports) {
		'use strict';
		Object.defineProperty(exports, '__esModule', { value: true });
		for (var i in Laya) {
			var o = Laya[i];
			o && o.__isclass && (exports[i] = o);
		}
	});
}


(function (window, document, Laya) {
	var __un = Laya.un, __uns = Laya.uns, __static = Laya.static, __class = Laya.class, __getset = Laya.getset, __newvec = Laya.__newvec;

	var Animation = laya.display.Animation, Browser = laya.utils.Browser, ClassUtils = laya.utils.ClassUtils, ColorFilter = laya.filters.ColorFilter;
	var Ease = laya.utils.Ease, Event = laya.events.Event, EventDispatcher = laya.events.EventDispatcher, Font = laya.display.css.Font;
	var FrameAnimation = laya.display.FrameAnimation, Graphics = laya.display.Graphics, Handler = laya.utils.Handler;
	var Input = laya.display.Input, Loader = laya.net.Loader, Node = laya.display.Node, Point = laya.maths.Point, Rectangle = laya.maths.Rectangle;
	var Render = laya.renders.Render, Sprite = laya.display.Sprite, Text = laya.display.Text, Texture = laya.resource.Texture;
	var Tween = laya.utils.Tween, Utils = laya.utils.Utils, WeakObject = laya.utils.WeakObject;
	Laya.interface('laya.ui.IItem');
	Laya.interface('laya.ui.ISelect');
	Laya.interface('laya.ui.IRender');
	Laya.interface('laya.ui.IComponent');
	Laya.interface('laya.ui.IBox', 'IComponent');
	/**
	*<code>LayoutStyle</code> 是一个布局样式类。
	*/
	//class laya.ui.LayoutStyle
	var LayoutStyle = (function () {
		function LayoutStyle() {
			/**一个布尔值，表示是否有效。*/
			this.enable = false;
			this.top = NaN;
			this.bottom = NaN;
			this.left = NaN;
			this.right = NaN;
			this.centerX = NaN;
			this.centerY = NaN;
			this.anchorX = NaN;
			this.anchorY = NaN;
		}

		__class(LayoutStyle, 'laya.ui.LayoutStyle');
		__static(LayoutStyle,
			['EMPTY', function () { return this.EMPTY = new LayoutStyle(); }
			]);
		return LayoutStyle;
	})()


	/**
	*<code>Styles</code> 定义了组件常用的样式属性。
	*/
	//class laya.ui.Styles
	var Styles = (function () {
		function Styles() { }
		__class(Styles, 'laya.ui.Styles');
		Styles.labelColor = "#000000";
		Styles.buttonStateNum = 3;
		Styles.scrollBarMinNum = 15;
		Styles.scrollBarDelayTime = 500;
		__static(Styles,
			['defaultSizeGrid', function () { return this.defaultSizeGrid = [4, 4, 4, 4, 0]; }, 'labelPadding', function () { return this.labelPadding = [2, 2, 2, 2]; }, 'inputLabelPadding', function () { return this.inputLabelPadding = [1, 1, 1, 3]; }, 'buttonLabelColors', function () { return this.buttonLabelColors = ["#32556b", "#32cc6b", "#ff0000", "#C0C0C0"]; }, 'comboBoxItemColors', function () { return this.comboBoxItemColors = ["#5e95b6", "#ffffff", "#000000", "#8fa4b1", "#ffffff"]; }
			]);
		return Styles;
	})()


	/**
	*<code>UIUtils</code> 是文本工具集。
	*/
	//class laya.ui.UIUtils
	var UIUtils = (function () {
		function UIUtils() { }
		__class(UIUtils, 'laya.ui.UIUtils');
		UIUtils.fillArray = function (arr, str, type) {
			var temp = arr.concat();
			if (str) {
				var a = str.split(",");
				for (var i = 0, n = Math.min(temp.length, a.length); i < n; i++) {
					var value = a[i];
					temp[i] = (value == "true" ? true : (value == "false" ? false : value));
					if (type != null) temp[i] = type(value);
				}
			}
			return temp;
		}

		UIUtils.toColor = function (color) {
			return Utils.toHexColor(color);
		}

		UIUtils.gray = function (traget, isGray) {
			(isGray === void 0) && (isGray = true);
			if (isGray) {
				UIUtils.addFilter(traget, UIUtils.grayFilter);
			} else {
				UIUtils.clearFilter(traget, ColorFilter);
			}
		}

		UIUtils.addFilter = function (target, filter) {
			var filters = target.filters || [];
			filters.push(filter);
			target.filters = filters;
		}

		UIUtils.clearFilter = function (target, filterType) {
			var filters = target.filters;
			if (filters != null && filters.length > 0) {
				for (var i = filters.length - 1; i > -1; i--) {
					var filter = filters[i];
					if (Laya.__typeof(filter, filterType)) filters.splice(i, 1);
				}
				target.filters = filters;
			}
		}

		UIUtils._getReplaceStr = function (word) {
			return UIUtils.escapeSequence[word];
		}

		UIUtils.adptString = function (str) {
			return str.replace(/\\(\w)/g, UIUtils._getReplaceStr);
		}

		UIUtils.getBindFun = function (value) {
			var fun = UIUtils._funMap.get(value);
			if (fun == null) {
				var temp = "\"" + value + "\"";
				temp = temp.replace(/^"\${|}"$/g, "").replace(/\${/g, "\"+").replace(/}/g, "+\"");
				var str = "(function(data){if(data==null)return;with(data){try{\nreturn " + temp + "\n}catch(e){}}})";
				fun = Browser.window.eval(str);
				UIUtils._funMap.set(value, fun);
			}
			return fun;
		}

		__static(UIUtils,
			['grayFilter', function () { return this.grayFilter = new ColorFilter([0.3086, 0.6094, 0.082, 0, 0, 0.3086, 0.6094, 0.082, 0, 0, 0.3086, 0.6094, 0.082, 0, 0, 0, 0, 0, 1, 0]); }, 'escapeSequence', function () { return this.escapeSequence = { "\\n": "\n", "\\t": "\t" }; }, '_funMap', function () { return this._funMap = new WeakObject(); }
			]);
		return UIUtils;
	})()


	/**全局配置*/
	//class UIConfig
	var UIConfig = (function () {
		function UIConfig() { }
		__class(UIConfig, 'UIConfig');
		UIConfig.touchScrollEnable = true;
		UIConfig.mouseWheelEnable = true;
		UIConfig.showButtons = true;
		UIConfig.popupBgColor = "#000000";
		UIConfig.popupBgAlpha = 0.5;
		UIConfig.closeDialogOnSide = true;
		return UIConfig;
	})()


	/**
	*<code>AutoBitmap</code> 类是用于表示位图图像或绘制图形的显示对象。
	*<p>封装了位置，宽高及九宫格的处理，供UI组件使用。</p>
	*/
	//class laya.ui.AutoBitmap extends laya.display.Graphics
	var AutoBitmap = (function (_super) {
		function AutoBitmap() {
			/**@private 是否自动缓存命令*/
			this.autoCacheCmd = true;
			/**@private 宽度*/
			this._width = 0;
			/**@private 高度*/
			this._height = 0;
			/**@private 源数据*/
			this._source = null;
			/**@private 网格数据*/
			this._sizeGrid = null;
			/**@private */
			this._isChanged = false;
			/**@private */
			this._offset = null;
			AutoBitmap.__super.call(this);
		}

		__class(AutoBitmap, 'laya.ui.AutoBitmap', _super);
		var __proto = AutoBitmap.prototype;
		/**@inheritDoc */
		__proto.destroy = function () {
			_super.prototype.destroy.call(this);
			this._source = null;
			this._sizeGrid = null;
			this._offset = null;
		}

		/**@private */
		__proto._setChanged = function () {
			if (!this._isChanged) {
				this._isChanged = true;
				Laya.timer.callLater(this, this.changeSource);
			}
		}

		/**
		*@private
		*修改纹理资源。
		*/
		__proto.changeSource = function () {
			this._isChanged = false;
			var source = this._source;
			if (!source || !source.bitmap) return;
			var width = this.width;
			var height = this.height;
			var sizeGrid = this._sizeGrid;
			var sw = source.sourceWidth;
			var sh = source.sourceHeight;
			if (!sizeGrid || (sw === width && sh === height)) {
				this.cleanByTexture(source, this._offset ? this._offset[0] : 0, this._offset ? this._offset[1] : 0, width, height);
			} else {
				source.$_GID || (source.$_GID = Utils.getGID());
				var key = source.$_GID + "." + width + "." + height + "." + sizeGrid.join(".");
				if (Utils.isOKCmdList(WeakObject.I.get(key))) {
					this.cmds = WeakObject.I.get(key);
					return;
				}
				this.clear();
				var top = sizeGrid[0];
				var right = sizeGrid[1];
				var bottom = sizeGrid[2];
				var left = sizeGrid[3];
				var repeat = sizeGrid[4];
				var needClip = false;
				if (width == sw) {
					left = right = 0;
				}
				if (height == sh) {
					top = bottom = 0;
				}
				if (left + right > width) {
					var clipWidth = width;
					needClip = true;
					width = left + right;
					this.save();
					this.clipRect(0, 0, clipWidth, height);
				}
				left && top && this.drawTexture(AutoBitmap.getTexture(source, 0, 0, left, top), 0, 0, left, top);
				right && top && this.drawTexture(AutoBitmap.getTexture(source, sw - right, 0, right, top), width - right, 0, right, top);
				left && bottom && this.drawTexture(AutoBitmap.getTexture(source, 0, sh - bottom, left, bottom), 0, height - bottom, left, bottom);
				right && bottom && this.drawTexture(AutoBitmap.getTexture(source, sw - right, sh - bottom, right, bottom), width - right, height - bottom, right, bottom);
				top && this.drawBitmap(repeat, AutoBitmap.getTexture(source, left, 0, sw - left - right, top), left, 0, width - left - right, top);
				bottom && this.drawBitmap(repeat, AutoBitmap.getTexture(source, left, sh - bottom, sw - left - right, bottom), left, height - bottom, width - left - right, bottom);
				left && this.drawBitmap(repeat, AutoBitmap.getTexture(source, 0, top, left, sh - top - bottom), 0, top, left, height - top - bottom);
				right && this.drawBitmap(repeat, AutoBitmap.getTexture(source, sw - right, top, right, sh - top - bottom), width - right, top, right, height - top - bottom);
				this.drawBitmap(repeat, AutoBitmap.getTexture(source, left, top, sw - left - right, sh - top - bottom), left, top, width - left - right, height - top - bottom);
				if (needClip) this.restore();
				if (this.autoCacheCmd && !Render.isConchApp) WeakObject.I.set(key, this.cmds);
			}
			this._repaint();
		}

		__proto.drawBitmap = function (repeat, tex, x, y, width, height) {
			(width === void 0) && (width = 0);
			(height === void 0) && (height = 0);
			if (width < 0.1 || height < 0.1) return;
			if (repeat && (tex.width != width || tex.height != height)) this.fillTexture(tex, x, y, width, height);
			else this.drawTexture(tex, x, y, width, height);
		}

		__proto.clear = function (recoverCmds) {
			(recoverCmds === void 0) && (recoverCmds = true);
			_super.prototype.clear.call(this, false);
		}

		/**
		*当前实例的有效缩放网格数据。
		*<p>如果设置为null,则在应用任何缩放转换时，将正常缩放整个显示对象。</p>
		*<p>数据格式：[上边距,右边距,下边距,左边距,是否重复填充(值为0：不重复填充，1：重复填充)]。
		*<ul><li>例如：[4,4,4,4,1]</li></ul></p>
		*<p> <code>sizeGrid</code> 的值如下所示：
		*<ol>
		*<li>上边距</li>
		*<li>右边距</li>
		*<li>下边距</li>
		*<li>左边距</li>
		*<li>是否重复填充(值为0：不重复填充，1：重复填充)</li>
		*</ol></p>
		*<p>当定义 <code>sizeGrid</code> 属性时，该显示对象被分割到以 <code>sizeGrid</code> 数据中的"上边距,右边距,下边距,左边距" 组成的矩形为基础的具有九个区域的网格中，该矩形定义网格的中心区域。网格的其它八个区域如下所示：
		*<ul>
		*<li>矩形上方的区域</li>
		*<li>矩形外的右上角</li>
		*<li>矩形左侧的区域</li>
		*<li>矩形右侧的区域</li>
		*<li>矩形外的左下角</li>
		*<li>矩形下方的区域</li>
		*<li>矩形外的右下角</li>
		*<li>矩形外的左上角</li>
		*</ul>
		*同时也支持3宫格，比如0,4,0,4,1为水平3宫格，4,0,4,0,1为垂直3宫格，3宫格性能比9宫格高。
		*</p>
		*/
		__getset(0, __proto, 'sizeGrid', function () {
			return this._sizeGrid;
		}, function (value) {
			this._sizeGrid = value;
			this._setChanged();
		});

		/**
		*表示显示对象的宽度，以像素为单位。
		*/
		__getset(0, __proto, 'width', function () {
			if (this._width) return this._width;
			if (this._source) return this._source.sourceWidth;
			return 0;
		}, function (value) {
			if (this._width != value) {
				this._width = value;
				this._setChanged();
			}
		});

		/**
		*表示显示对象的高度，以像素为单位。
		*/
		__getset(0, __proto, 'height', function () {
			if (this._height) return this._height;
			if (this._source) return this._source.sourceHeight;
			return 0;
		}, function (value) {
			if (this._height != value) {
				this._height = value;
				this._setChanged();
			}
		});

		/**
		*对象的纹理资源。
		*@see laya.resource.Texture
		*/
		__getset(0, __proto, 'source', function () {
			return this._source;
		}, function (value) {
			if (value) {
				this._source = value
				this._setChanged();
			} else {
				this._source = null;
				this.clear();
			}
		});

		AutoBitmap.getTexture = function (tex, x, y, width, height) {
			if (width <= 0) width = 1;
			if (height <= 0) height = 1;
			tex.$_GID || (tex.$_GID = Utils.getGID())
			var key = tex.$_GID + "." + x + "." + y + "." + width + "." + height;
			var texture = WeakObject.I.get(key);
			if (!texture || !texture.source) {
				texture = Texture.createFromTexture(tex, x, y, width, height);
				WeakObject.I.set(key, texture);
			}
			return texture;
		}

		return AutoBitmap;
	})(Graphics)


	/**
	*<code>UIEvent</code> 类用来定义UI组件类的事件类型。
	*/
	//class laya.ui.UIEvent extends laya.events.Event
	var UIEvent = (function (_super) {
		function UIEvent() {
			UIEvent.__super.call(this);;
		}

		__class(UIEvent, 'laya.ui.UIEvent', _super);
		UIEvent.SHOW_TIP = "showtip";
		UIEvent.HIDE_TIP = "hidetip";
		return UIEvent;
	})(Event)


	/**
	*<code>Component</code> 是ui控件类的基类。
	*<p>生命周期：preinitialize > createChildren > initialize > 组件构造函数</p>
	*/
	//class laya.ui.Component extends laya.display.Sprite
	var Component = (function (_super) {
		function Component() {
			this._comXml = null;
			/**@private 控件的元数据。 */
			this._dataSource = null;
			/**@private 鼠标悬停提示 */
			this._toolTip = null;
			/**@private 标签 */
			this._tag = null;
			/**@private 禁用 */
			this._disabled = false;
			/**@private 变灰*/
			this._gray = false;
			/**
			*是否启用相对布局
			*/
			this.layoutEnabled = true;
			Component.__super.call(this);
			this._layout = LayoutStyle.EMPTY;
			this.preinitialize();
			this.createChildren();
			this.initialize();
		}

		__class(Component, 'laya.ui.Component', _super);
		var __proto = Component.prototype;
		Laya.imps(__proto, { "laya.ui.IComponent": true })
		/**@inheritDoc */
		__proto.destroy = function (destroyChild) {
			(destroyChild === void 0) && (destroyChild = true);
			_super.prototype.destroy.call(this, destroyChild);
			this._dataSource = this._layout = null;
			this._tag = null;
			this._toolTip = null;
		}

		/**
		*<p>预初始化。</p>
		*@internal 子类可在此函数内设置、修改属性默认值
		*/
		__proto.preinitialize = function () { }
		/**
		*<p>创建并添加控件子节点。</p>
		*@internal 子类可在此函数内创建并添加子节点。
		*/
		__proto.createChildren = function () { }
		/**
		*<p>控件初始化。</p>
		*@internal 在此子对象已被创建，可以对子对象进行修改。
		*/
		__proto.initialize = function () { }
		/**
		*<p>延迟运行指定的函数。</p>
		*<p>在控件被显示在屏幕之前调用，一般用于延迟计算数据。</p>
		*@param method 要执行的函数的名称。例如，functionName。
		*@param args 传递给 <code>method</code> 函数的可选参数列表。
		*
		*@see #runCallLater()
		*/
		__proto.callLater = function (method, args) {
			Laya.timer.callLater(this, method, args);
		}

		/**
		*<p>如果有需要延迟调用的函数（通过 <code>callLater</code> 函数设置），则立即执行延迟调用函数。</p>
		*@param method 要执行的函数名称。例如，functionName。
		*@see #callLater()
		*/
		__proto.runCallLater = function (method) {
			Laya.timer.runCallLater(this, method);
		}

		/**
		*<p>立即执行影响宽高度量的延迟调用函数。</p>
		*@internal <p>使用 <code>runCallLater</code> 函数，立即执行影响宽高度量的延迟运行函数(使用 <code>callLater</code> 设置延迟执行函数)。</p>
		*@see #callLater()
		*@see #runCallLater()
		*/
		__proto.commitMeasure = function () { }
		/**
		*<p>重新调整对象的大小。</p>
		*/
		__proto.changeSize = function () {
			this.event(/*laya.events.Event.RESIZE*/"resize");
		}

		/**
		*@private
		*<p>获取对象的布局样式。</p>
		*/
		__proto.getLayout = function () {
			this._layout === LayoutStyle.EMPTY && (this._layout = new LayoutStyle());
			return this._layout;
		}

		/**
		*@private
		*<p>指定对象是否可使用布局。</p>
		*<p>如果值为true,则此对象可以使用布局样式，否则不使用布局样式。</p>
		*@param value 一个 Boolean 值，指定对象是否可使用布局。
		*/
		__proto._setLayoutEnabled = function (value) {
			if (this._layout && this._layout.enable != value) {
				this._layout.enable = value;
				this.on(/*laya.events.Event.ADDED*/"added", this, this.onAdded);
				this.on(/*laya.events.Event.REMOVED*/"removed", this, this.onRemoved);
				if (this.parent) {
					this.onAdded();
				}
			}
		}

		/**
		*对象从显示列表移除的事件侦听处理函数。
		*/
		__proto.onRemoved = function () {
			this.parent.off(/*laya.events.Event.RESIZE*/"resize", this, this.onCompResize);
		}

		/**
		*对象被添加到显示列表的事件侦听处理函数。
		*/
		__proto.onAdded = function () {
			this.parent.on(/*laya.events.Event.RESIZE*/"resize", this, this.onCompResize);
			this.resetLayoutX();
			this.resetLayoutY();
		}

		/**
		*父容器的 <code>Event.RESIZE</code> 事件侦听处理函数。
		*/
		__proto.onCompResize = function () {
			if (this._layout && this._layout.enable) {
				this.resetLayoutX();
				this.resetLayoutY();
			}
		}

		/**
		*<p>重置对象的 <code>X</code> 轴（水平方向）布局。</p>
		*/
		__proto.resetLayoutX = function () {
			var layout = this._layout;
			if (!isNaN(layout.anchorX)) this.pivotX = layout.anchorX * this.width;
			if (!this.layoutEnabled) return;
			var parent = this.parent;
			if (parent) {
				if (!isNaN(layout.centerX)) {
					this.x = Math.round((parent.width - this.displayWidth) * 0.5 + layout.centerX + this.pivotX * this.scaleX);
				} else if (!isNaN(layout.left)) {
					this.x = Math.round(layout.left + this.pivotX * this.scaleX);
					if (!isNaN(layout.right)) {
						this.width = (parent._width - layout.left - layout.right) / (this.scaleX || 0.01);
					}
				} else if (!isNaN(layout.right)) {
					this.x = Math.round(parent.width - this.displayWidth - layout.right + this.pivotX * this.scaleX);
				}
			}
		}

		/**
		*<p>重置对象的 <code>Y</code> 轴（垂直方向）布局。</p>
		*/
		__proto.resetLayoutY = function () {
			var layout = this._layout;
			if (!isNaN(layout.anchorY)) this.pivotY = layout.anchorY * this.height;
			if (!this.layoutEnabled) return;
			var parent = this.parent;
			if (parent) {
				if (!isNaN(layout.centerY)) {
					this.y = Math.round((parent.height - this.displayHeight) * 0.5 + layout.centerY + this.pivotY * this.scaleY);
				} else if (!isNaN(layout.top)) {
					this.y = Math.round(layout.top + this.pivotY * this.scaleY);
					if (!isNaN(layout.bottom)) {
						this.height = (parent._height - layout.top - layout.bottom) / (this.scaleY || 0.01);
					}
				} else if (!isNaN(layout.bottom)) {
					this.y = Math.round(parent.height - this.displayHeight - layout.bottom + this.pivotY * this.scaleY);
				}
			}
		}

		/**
		*对象的 <code>Event.MOUSE_OVER</code> 事件侦听处理函数。
		*/
		__proto.onMouseOver = function (e) {
			Laya.stage.event(/*laya.ui.UIEvent.SHOW_TIP*/"showtip", this._toolTip);
		}

		/**
		*对象的 <code>Event.MOUSE_OUT</code> 事件侦听处理函数。
		*/
		__proto.onMouseOut = function (e) {
			Laya.stage.event(/*laya.ui.UIEvent.HIDE_TIP*/"hidetip", this._toolTip);
		}

		/**
		*<p>对象的显示宽度（以像素为单位）。</p>
		*/
		__getset(0, __proto, 'displayWidth', function () {
			return this.width * this.scaleX;
		});

		/**
		*<p>表示显示对象的宽度，以像素为单位。</p>
		*<p><b>注：</b>当值为0时，宽度为自适应大小。</p>
		*/
		__getset(0, __proto, 'width', function () {
			if (this._width) return this._width;
			return this.measureWidth;
		}, function (value) {
			if (this._width != value) {
				this._width = value;
				this.conchModel && this.conchModel.size(this._width, this._height);
				this.callLater(this.changeSize);
				if (this._layout.enable && (!isNaN(this._layout.centerX) || !isNaN(this._layout.right) || !isNaN(this._layout.anchorX))) this.resetLayoutX();
			}
		});

		/**
		*<p>显示对象的实际显示区域宽度（以像素为单位）。</p>
		*/
		__getset(0, __proto, 'measureWidth', function () {
			var max = 0;
			this.commitMeasure();
			for (var i = this.numChildren - 1; i > -1; i--) {
				var comp = this.getChildAt(i);
				if (comp.visible) {
					max = Math.max(comp.x + comp.width * comp.scaleX, max);
				}
			}
			return max;
		});

		/**
		*<p>对象的显示高度（以像素为单位）。</p>
		*/
		__getset(0, __proto, 'displayHeight', function () {
			return this.height * this.scaleY;
		});

		/**
		*<p>表示显示对象的高度，以像素为单位。</p>
		*<p><b>注：</b>当值为0时，高度为自适应大小。</p>
		*/
		__getset(0, __proto, 'height', function () {
			if (this._height) return this._height;
			return this.measureHeight;
		}, function (value) {
			if (this._height != value) {
				this._height = value;
				this.conchModel && this.conchModel.size(this._width, this._height);
				this.callLater(this.changeSize);
				if (this._layout.enable && (!isNaN(this._layout.centerY) || !isNaN(this._layout.bottom) || !isNaN(this._layout.anchorY))) this.resetLayoutY();
			}
		});

		/**
		*<p>数据赋值，通过对UI赋值来控制UI显示逻辑。</p>
		*<p>简单赋值会更改组件的默认属性，使用大括号可以指定组件的任意属性进行赋值。</p>
		*@example
		//默认属性赋值
		dataSource={label1:"改变了label",checkbox1:true};//(更改了label1的text属性值，更改checkbox1的selected属性)。
		//任意属性赋值
		dataSource={label2:{text:"改变了label",size:14},checkbox2:{selected:true,x:10}};
		*/
		__getset(0, __proto, 'dataSource', function () {
			return this._dataSource;
		}, function (value) {
			this._dataSource = value;
			for (var prop in this._dataSource) {
				if (this.hasOwnProperty(prop) && !((typeof (this[prop]) == 'function'))) {
					this[prop] = this._dataSource[prop];
				}
			}
		});

		/**@inheritDoc */
		__getset(0, __proto, 'scaleY', _super.prototype._$get_scaleY, function (value) {
			if (Laya.superGet(Sprite, this, 'scaleY') != value) {
				Laya.superSet(Sprite, this, 'scaleY', value);
				this.callLater(this.changeSize);
				this._layout.enable && this.resetLayoutY();
			}
		});

		/**
		*<p>显示对象的实际显示区域高度（以像素为单位）。</p>
		*/
		__getset(0, __proto, 'measureHeight', function () {
			var max = 0;
			this.commitMeasure();
			for (var i = this.numChildren - 1; i > -1; i--) {
				var comp = this.getChildAt(i);
				if (comp.visible) {
					max = Math.max(comp.y + comp.height * comp.scaleY, max);
				}
			}
			return max;
		});

		/**@inheritDoc */
		__getset(0, __proto, 'scaleX', _super.prototype._$get_scaleX, function (value) {
			if (Laya.superGet(Sprite, this, 'scaleX') != value) {
				Laya.superSet(Sprite, this, 'scaleX', value);
				this.callLater(this.changeSize);
				this._layout.enable && this.resetLayoutX();
			}
		});

		/**
		*<p>从组件顶边到其内容区域顶边之间的垂直距离（以像素为单位）。</p>
		*/
		__getset(0, __proto, 'top', function () {
			return this._layout.top;
		}, function (value) {
			if (value != this._layout.top) {
				this.getLayout().top = value;
				this._setLayoutEnabled(true);
			}
			this.resetLayoutY();
		});

		/**
		*<p>从组件底边到其内容区域底边之间的垂直距离（以像素为单位）。</p>
		*/
		__getset(0, __proto, 'bottom', function () {
			return this._layout.bottom;
		}, function (value) {
			if (value != this._layout.bottom) {
				this.getLayout().bottom = value;
				this._setLayoutEnabled(true);
			}
			this.resetLayoutY();
		});

		/**
		*<p>从组件左边到其内容区域左边之间的水平距离（以像素为单位）。</p>
		*/
		__getset(0, __proto, 'left', function () {
			return this._layout.left;
		}, function (value) {
			if (value != this._layout.left) {
				this.getLayout().left = value;
				this._setLayoutEnabled(true);
			}
			this.resetLayoutX();
		});

		/**
		*<p>从组件右边到其内容区域右边之间的水平距离（以像素为单位）。</p>
		*/
		__getset(0, __proto, 'right', function () {
			return this._layout.right;
		}, function (value) {
			if (value != this._layout.right) {
				this.getLayout().right = value;
				this._setLayoutEnabled(true);
			}
			this.resetLayoutX();
		});

		/**
		*<p>在父容器中，此对象的水平方向中轴线与父容器的水平方向中心线的距离（以像素为单位）。</p>
		*/
		__getset(0, __proto, 'centerX', function () {
			return this._layout.centerX;
		}, function (value) {
			if (value != this._layout.centerX) {
				this.getLayout().centerX = value;
				this._setLayoutEnabled(true);
			}
			this.resetLayoutX();
		});

		/**
		*<p>在父容器中，此对象的垂直方向中轴线与父容器的垂直方向中心线的距离（以像素为单位）。</p>
		*/
		__getset(0, __proto, 'centerY', function () {
			return this._layout.centerY;
		}, function (value) {
			if (value != this._layout.centerY) {
				this.getLayout().centerY = value;
				this._setLayoutEnabled(true);
			}
			this.resetLayoutY();
		});

		/**X轴锚点，值为0-1*/
		__getset(0, __proto, 'anchorX', function () {
			return this._layout.anchorX;
		}, function (value) {
			if (value != this._layout.anchorX) {
				this.getLayout().anchorX = value;
				this._setLayoutEnabled(true);
			}
			this.resetLayoutX();
		});

		/**Y轴锚点，值为0-1*/
		__getset(0, __proto, 'anchorY', function () {
			return this._layout.anchorY;
		}, function (value) {
			if (value != this._layout.anchorY) {
				this.getLayout().anchorY = value;
				this._setLayoutEnabled(true);
			}
			this.resetLayoutY();
		});

		/**
		*<p>对象的标签。</p>
		*@internal 冗余字段，可以用来储存数据。
		*/
		__getset(0, __proto, 'tag', function () {
			return this._tag;
		}, function (value) {
			this._tag = value;
		});

		/**
		*<p>鼠标悬停提示。</p>
		*<p>可以赋值为文本 <code>String</code> 或函数 <code>Handler</code> ，用来实现自定义样式的鼠标提示和参数携带等。</p>
		*@example
		*private var _testTips:TestTipsUI=new TestTipsUI();
		*private function testTips():void {
			//简单鼠标提示
			*btn2.toolTip="这里是鼠标提示&lt;b&gt;粗体&lt;/b&gt;&lt;br&gt;换行";
			//自定义的鼠标提示
			*btn1.toolTip=showTips1;
			//带参数的自定义鼠标提示
			*clip.toolTip=new Handler(this,showTips2,["clip"]);
			*}
		*private function showTips1():void {
			*_testTips.label.text="这里是按钮["+btn1.label+"]";
			*tip.addChild(_testTips);
			*}
		*private function showTips2(name:String):void {
			*_testTips.label.text="这里是"+name;
			*tip.addChild(_testTips);
			*}
		*/
		__getset(0, __proto, 'toolTip', function () {
			return this._toolTip;
		}, function (value) {
			if (this._toolTip != value) {
				this._toolTip = value;
				if (value != null) {
					this.on(/*laya.events.Event.MOUSE_OVER*/"mouseover", this, this.onMouseOver);
					this.on(/*laya.events.Event.MOUSE_OUT*/"mouseout", this, this.onMouseOut);
				} else {
					this.off(/*laya.events.Event.MOUSE_OVER*/"mouseover", this, this.onMouseOver);
					this.off(/*laya.events.Event.MOUSE_OUT*/"mouseout", this, this.onMouseOut);
				}
			}
		});

		/**
		*XML 数据。
		*/
		__getset(0, __proto, 'comXml', function () {
			return this._comXml;
		}, function (value) {
			this._comXml = value;
		});

		/**是否变灰。*/
		__getset(0, __proto, 'gray', function () {
			return this._gray;
		}, function (value) {
			if (value !== this._gray) {
				this._gray = value;
				UIUtils.gray(this, value);
			}
		});

		/**是否禁用页面，设置为true后，会变灰并且禁用鼠标。*/
		__getset(0, __proto, 'disabled', function () {
			return this._disabled;
		}, function (value) {
			if (value !== this._disabled) {
				this.gray = this._disabled = value;
				this.mouseEnabled = !value;
			}
		});

		return Component;
	})(Sprite)


	/**
	*<code>DialogManager</code> 对话框管理容器，所有的对话框都在该容器内，并且受管理器管理。
	*任意对话框打开和关闭，都会出发管理类的open和close事件
	*可以通过UIConfig设置弹出框背景透明度，模式窗口点击边缘是否关闭，点击窗口是否切换层次等
	*通过设置对话框的zOrder属性，可以更改弹出的层次
	*/
	//class laya.ui.DialogManager extends laya.display.Sprite
	var DialogManager = (function (_super) {
		function DialogManager() {
			/**锁屏层*/
			this.lockLayer = null;
			/**@private 全局默认弹出对话框效果，可以设置一个效果代替默认的弹出效果，如果不想有任何效果，可以赋值为null*/
			this.popupEffect = function (dialog) {
				dialog.scale(1, 1);
				Tween.from(dialog, { x: Laya.stage.width / 2, y: Laya.stage.height / 2, scaleX: 0, scaleY: 0 }, 300, Ease.backOut, Handler.create(this, this.doOpen, [dialog]));
			}
			/**@private 全局默认关闭对话框效果，可以设置一个效果代替默认的关闭效果，如果不想有任何效果，可以赋值为null*/
			this.closeEffect = function (dialog, type) {
				Tween.to(dialog, { x: Laya.stage.width / 2, y: Laya.stage.height / 2, scaleX: 0, scaleY: 0 }, 300, Ease.strongOut, Handler.create(this, this.doClose, [dialog, type]));
			}
			DialogManager.__super.call(this);
			this.maskLayer = new Sprite();
			this.popupEffectHandler = new Handler(this, this.popupEffect);
			this.closeEffectHandler = new Handler(this, this.closeEffect);
			this.mouseEnabled = this.maskLayer.mouseEnabled = true;
			this.zOrder = 1000;
			Laya.stage.addChild(this);
			Laya.stage.on(/*laya.events.Event.RESIZE*/"resize", this, this._onResize);
			if (UIConfig.closeDialogOnSide) this.maskLayer.on("click", this, this._closeOnSide);
			this._onResize(null);
		}

		__class(DialogManager, 'laya.ui.DialogManager', _super);
		var __proto = DialogManager.prototype;
		__proto._closeOnSide = function () {
			var dialog = this.getChildAt(this.numChildren - 1);
			if ((dialog instanceof laya.ui.Dialog)) dialog.close("side");
		}

		/**设置锁定界面，如果为空则什么都不显示*/
		__proto.setLockView = function (value) {
			if (!this.lockLayer) {
				this.lockLayer = new Box();
				this.lockLayer.mouseEnabled = true;
				this.lockLayer.size(Laya.stage.width, Laya.stage.height);
			}
			this.lockLayer.removeChildren();
			if (value) {
				value.centerX = value.centerY = 0;
				this.lockLayer.addChild(value);
			}
		}

		/**@private */
		__proto._onResize = function (e) {
			var width = this.maskLayer.width = Laya.stage.width;
			var height = this.maskLayer.height = Laya.stage.height;
			if (this.lockLayer) this.lockLayer.size(width, height);
			this.maskLayer.graphics.clear();
			this.maskLayer.graphics.drawRect(0, 0, width, height, UIConfig.popupBgColor);
			this.maskLayer.alpha = UIConfig.popupBgAlpha;
			for (var i = this.numChildren - 1; i > -1; i--) {
				var item = this.getChildAt(i);
				if (item.popupCenter) this._centerDialog(item);
			}
		}

		__proto._centerDialog = function (dialog) {
			dialog.x = Math.round(((Laya.stage.width - dialog.width) >> 1) + dialog.pivotX);
			dialog.y = Math.round(((Laya.stage.height - dialog.height) >> 1) + dialog.pivotY);
		}

		/**
		*显示对话框(非模式窗口类型)。
		*@param dialog 需要显示的对象框 <code>Dialog</code> 实例。
		*@param closeOther 是否关闭其它对话框，若值为ture，则关闭其它的对话框。
		*@param showEffect 是否显示弹出效果
		*/
		__proto.open = function (dialog, closeOther, showEffect) {
			(closeOther === void 0) && (closeOther = false);
			(showEffect === void 0) && (showEffect = false);
			if (closeOther) this._closeAll();
			if (dialog.popupCenter) this._centerDialog(dialog);
			this.addChild(dialog);
			if (dialog.isModal || this._$P["hasZorder"]) this.timer.callLater(this, this._checkMask);
			if (showEffect && dialog.popupEffect != null) dialog.popupEffect.runWith(dialog);
			else this.doOpen(dialog);
			this.event(/*laya.events.Event.OPEN*/"open");
		}

		/**
		*执行打开对话框。
		*@param dialog 需要关闭的对象框 <code>Dialog</code> 实例。
		*@param type 关闭的类型，默认为空
		*/
		__proto.doOpen = function (dialog) {
			dialog.onOpened();
		}

		/**
		*锁定所有层，显示加载条信息，防止双击
		*/
		__proto.lock = function (value) {
			if (this.lockLayer) {
				if (value) this.addChild(this.lockLayer);
				else this.lockLayer.removeSelf();
			}
		}

		/**
		*关闭对话框。
		*@param dialog 需要关闭的对象框 <code>Dialog</code> 实例。
		*@param type 关闭的类型，默认为空
		*@param showEffect 是否显示弹出效果
		*/
		__proto.close = function (dialog, type, showEffect) {
			(showEffect === void 0) && (showEffect = false);
			if (showEffect && dialog.closeEffect != null) dialog.closeEffect.runWith([dialog, type]);
			else this.doClose(dialog, type);
			this.event(/*laya.events.Event.CLOSE*/"close");
		}

		/**
		*执行关闭对话框。
		*@param dialog 需要关闭的对象框 <code>Dialog</code> 实例。
		*@param type 关闭的类型，默认为空
		*/
		__proto.doClose = function (dialog, type) {
			dialog.removeSelf();
			dialog.isModal && this._checkMask();
			dialog.closeHandler && dialog.closeHandler.runWith(type);
			dialog.onClosed(type);
		}

		/**
		*关闭所有的对话框。
		*/
		__proto.closeAll = function () {
			this._closeAll();
			this.event(/*laya.events.Event.CLOSE*/"close");
		}

		/**@private */
		__proto._closeAll = function () {
			for (var i = this.numChildren - 1; i > -1; i--) {
				var item = this.getChildAt(i);
				if (item && item.close != null) {
					this.doClose(item);
				}
			}
		}

		/**
		*根据组获取所有对话框
		*@param group 组名称
		*@return 对话框数组
		*/
		__proto.getDialogsByGroup = function (group) {
			var arr = [];
			for (var i = this.numChildren - 1; i > -1; i--) {
				var item = this.getChildAt(i);
				if (item && item.group === group) {
					arr.push(item);
				}
			}
			return arr;
		}

		/**
		*根据组关闭所有弹出框
		*@param group 需要关闭的组名称
		*@return 需要关闭的对话框数组
		*/
		__proto.closeByGroup = function (group) {
			var arr = [];
			for (var i = this.numChildren - 1; i > -1; i--) {
				var item = this.getChildAt(i);
				if (item && item.group === group) {
					item.close();
					arr.push(item);
				}
			}
			return arr;
		}

		/**@private 发生层次改变后，重新检查遮罩层是否正确*/
		__proto._checkMask = function () {
			this.maskLayer.removeSelf();
			for (var i = this.numChildren - 1; i > -1; i--) {
				var dialog = this.getChildAt(i);
				if (dialog && dialog.isModal) {
					this.addChildAt(this.maskLayer, i);
					return;
				}
			}
		}

		return DialogManager;
	})(Sprite)


	/**
	*<code>Box</code> 类是一个控件容器类。
	*/
	//class laya.ui.Box extends laya.ui.Component
	var Box = (function (_super) {
		function Box() {
			Box.__super.call(this);;
		}

		__class(Box, 'laya.ui.Box', _super);
		var __proto = Box.prototype;
		Laya.imps(__proto, { "laya.ui.IBox": true })
		/**@inheritDoc */
		__getset(0, __proto, 'dataSource', _super.prototype._$get_dataSource, function (value) {
			this._dataSource = value;
			for (var name in value) {
				var comp = this.getChildByName(name);
				if (comp) comp.dataSource = value[name];
				else if (this.hasOwnProperty(name) && !((typeof (this[name]) == 'function'))) this[name] = value[name];
			}
		});

		return Box;
	})(Component)


	/**
	*<code>Button</code> 组件用来表示常用的多态按钮。 <code>Button</code> 组件可显示文本标签、图标或同时显示两者。 *
	*<p>可以是单态，两态和三态，默认三态(up,over,down)。</p>
	*
	*@example <caption>以下示例代码，创建了一个 <code>Button</code> 实例。</caption>
	*package
	*{
		*import laya.ui.Button;
		*import laya.utils.Handler;
		*public class Button_Example
		*{
			*public function Button_Example()
			*{
				*Laya.init(640,800);//设置游戏画布宽高。
				*Laya.stage.bgColor="#efefef";//设置画布的背景颜色。
				*Laya.loader.load("resource/ui/button.png",Handler.create(this,onLoadComplete));//加载资源。
				*}
			*private function onLoadComplete():void
			*{
				*trace("资源加载完成！");
				*var button:Button=new Button("resource/ui/button.png","label");//创建一个 Button 类的实例对象 button ,并传入它的皮肤。
				*button.x=100;//设置 button 对象的属性 x 的值，用于控制 button 对象的显示位置。
				*button.y=100;//设置 button 对象的属性 y 的值，用于控制 button 对象的显示位置。
				*button.clickHandler=new Handler(this,onClickButton,[button]);//设置 button 的点击事件处理器。
				*Laya.stage.addChild(button);//将此 button 对象添加到显示列表。
				*}
			*private function onClickButton(button:Button):void
			*{
				*trace("按钮button被点击了！");
				*}
			*}
		*}
	*@example
	*Laya.init(640,800);//设置游戏画布宽高、渲染模式。
	*Laya.stage.bgColor="#efefef";//设置画布的背景颜色。
	*Laya.loader.load("resource/ui/button.png",laya.utils.Handler.create(this,loadComplete));//加载资源
	*function loadComplete()
	*{
		*console.log("资源加载完成！");
		*var button=new laya.ui.Button("resource/ui/button.png","label");//创建一个 Button 类的实例对象 button ,传入它的皮肤skin和标签label。
		*button.x=100;//设置 button 对象的属性 x 的值，用于控制 button 对象的显示位置。
		*button.y=100;//设置 button 对象的属性 y 的值，用于控制 button 对象的显示位置。
		*button.clickHandler=laya.utils.Handler.create(this,onClickButton,[button],false);//设置 button 的点击事件处理函数。
		*Laya.stage.addChild(button);//将此 button 对象添加到显示列表。
		*}
	*function onClickButton(button)
	*{
		*console.log("按钮被点击了。",button);
		*}
	*@example
	*import Button=laya.ui.Button;
	*import Handler=laya.utils.Handler;
	*class Button_Example{
		*constructor()
		*{
			*Laya.init(640,800);
			*Laya.stage.bgColor="#efefef";//设置画布的背景颜色。
			*Laya.loader.load("resource/ui/button.png",laya.utils.Handler.create(this,this.onLoadComplete));//加载资源。
			*}
		*private onLoadComplete()
		*{
			*var button:Button=new Button("resource/ui/button.png","label");//创建一个 Button 类的实例对象 button ,并传入它的皮肤。
			*button.x=100;//设置 button 对象的属性 x 的值，用于控制 button 对象的显示位置。
			*button.y=100;//设置 button 对象的属性 y 的值，用于控制 button 对象的显示位置。
			*button.clickHandler=new Handler(this,this.onClickButton,[button]);//设置 button 的点击事件处理器。
			*Laya.stage.addChild(button);//将此 button 对象添加到显示列表。
			*}
		*private onClickButton(button:Button):void
		*{
			*console.log("按钮button被点击了！")
			*}
		*}
	*/
	//class laya.ui.Button extends laya.ui.Component
	var Button = (function (_super) {
		function Button(skin, label) {
			/**
			*指定按钮按下时是否是切换按钮的显示状态。
			*
			*@example 以下示例代码，创建了一个 <code>Button</code> 实例，并设置为切换按钮。
			*@example
			*package
			*{
				*import laya.ui.Button;
				*import laya.utils.Handler;
				*public class Button_toggle
				*{
					*public function Button_toggle()
					*{
						*Laya.init(640,800);//设置游戏画布宽高、渲染模式。
						*Laya.stage.bgColor="#efefef";//设置画布的背景颜色。
						*Laya.loader.load("resource/ui/button.png",Handler.create(this,onLoadComplete));
						*}
					*private function onLoadComplete():void
					*{
						*trace("资源加载完成！");
						*var button:Button=new Button("resource/ui/button.png","label");//创建一个 Button 实例对象 button ,传入它的皮肤skin和标签label。
						*button.x=100;//设置 button 对象的属性 x 的值，用于控制 button 对象的显示位置。
						*button.y=100;//设置 button 对象的属性 y 的值，用于控制 button 对象的显示位置。
						*button.toggle=true;//设置 button 对象为切换按钮。
						*button.clickHandler=new Handler(this,onClickButton,[button]);//设置 button 的点击事件处理器。
						*Laya.stage.addChild(button);//将此 button 对象添加到显示列表。
						*}
					*private function onClickButton(button:Button):void
					*{
						*trace("button.selected = "+button.selected);
						*}
					*}
				*}
			*@example
			*Laya.init(640,800);//设置游戏画布宽高、渲染模式。
			*Laya.stage.bgColor="#efefef";//设置画布的背景颜色。
			*Laya.loader.load("resource/ui/button.png",laya.utils.Handler.create(this,loadComplete));//加载资源
			*function loadComplete()
			*{
				*console.log("资源加载完成！");
				*var button=new laya.ui.Button("resource/ui/button.png","label");//创建一个 Button 类的实例对象 button ,传入它的皮肤skin和标签label。
				*button.x=100;//设置 button 对象的属性 x 的值，用于控制 button 对象的显示位置。
				*button.y=100;//设置 button 对象的属性 y 的值，用于控制 button 对象的显示位置。
				*button.toggle=true;//设置 button 对象为切换按钮。
				*button.clickHandler=laya.utils.Handler.create(this,onClickButton,[button],false);//设置 button 的点击事件处理器。
				*Laya.stage.addChild(button);//将此 button 对象添加到显示列表。
				*}
			*function onClickButton(button)
			*{
				*console.log("button.selected = ",button.selected);
				*}
			*@example
			*Laya.init(640,800);//设置游戏画布宽高、渲染模式。
			*Laya.stage.bgColor="#efefef";//设置画布的背景颜色。
			*Laya.loader.load("button.png",null,null,null,null,null);//加载资源
			*function loadComplete(){
				*console.log("资源加载完成！");
				*var button:laya.ui.Button=new laya.ui.Button("button.png","label");//创建一个 Button 类的实例对象 button ,传入它的皮肤skin和标签label。
				*button.x=100;//设置 button 对象的属性 x 的值，用于控制 button 对象的显示位置。
				*button.y=100;//设置 button 对象的属性 y 的值，用于控制 button 对象的显示位置。
				*button.toggle=true;//设置 button 对象为切换按钮。
				*button.clickHandler=laya.utils.Handler.create(this,onClickButton,[button],false);//设置 button 的点击事件处理器。
				*Laya.stage.addChild(button);//将此 button 对象添加到显示列表。
				*}
			*function onClickButton(button){
				*console.log("button.selected = ",button.selected);
				*}
			*/
			this.toggle = false;
			/**
			*@private
			*/
			this._bitmap = null;
			/**
			*@private
			*按钮上的文本。
			*/
			this._text = null;
			/**
			*@private
			*按钮文本标签描边的颜色值。
			*/
			this._strokeColors = null;
			/**
			*@private
			*按钮的状态值。
			*/
			this._state = 0;
			/**
			*@private
			*表示按钮的选中状态。
			*/
			this._selected = false;
			/**
			*@private
			*按钮的皮肤资源。
			*/
			this._skin = null;
			/**
			*@private
			*指定此显示对象是否自动计算并改变大小等属性。
			*/
			this._autoSize = true;
			/**
			*@private
			*源数据。
			*/
			this._sources = null;
			/**
			*@private
			*按钮的点击事件函数。
			*/
			this._clickHandler = null;
			/**
			*@private
			*/
			this._stateChanged = false;
			Button.__super.call(this);
			this._labelColors = Styles.buttonLabelColors;
			this._stateNum = Styles.buttonStateNum;
			(label === void 0) && (label = "");
			this.skin = skin;
			this.label = label;
		}

		__class(Button, 'laya.ui.Button', _super);
		var __proto = Button.prototype;
		Laya.imps(__proto, { "laya.ui.ISelect": true })
		/**@inheritDoc */
		__proto.destroy = function (destroyChild) {
			(destroyChild === void 0) && (destroyChild = true);
			_super.prototype.destroy.call(this, destroyChild);
			this._bitmap && this._bitmap.destroy();
			this._text && this._text.destroy(destroyChild);
			this._bitmap = null;
			this._text = null;
			this._clickHandler = null;
			this._labelColors = this._sources = this._strokeColors = null;
		}

		/**@inheritDoc */
		__proto.createChildren = function () {
			this.graphics = this._bitmap = new AutoBitmap();
		}

		/**@private */
		__proto.createText = function () {
			if (!this._text) {
				this._text = new Text();
				this._text.overflow = Text.HIDDEN;
				this._text.align = "center";
				this._text.valign = "middle";
				this._text.width = this._width;
				this._text.height = this._height;
			}
		}

		/**@inheritDoc */
		__proto.initialize = function () {
			if (this._mouseEnableState !== 1) {
				this.mouseEnabled = true;
				this._setBit(/*laya.display.Node.MOUSEENABLE*/0x2, true);
			}
			this._createListener(/*laya.events.Event.MOUSE_OVER*/"mouseover", this, this.onMouse, null, false, false);
			this._createListener(/*laya.events.Event.MOUSE_OUT*/"mouseout", this, this.onMouse, null, false, false);
			this._createListener(/*laya.events.Event.MOUSE_DOWN*/"mousedown", this, this.onMouse, null, false, false);
			this._createListener(/*laya.events.Event.MOUSE_UP*/"mouseup", this, this.onMouse, null, false, false);
			this._createListener(/*laya.events.Event.CLICK*/"click", this, this.onMouse, null, false, false);
		}

		/**
		*对象的 <code>Event.MOUSE_OVER、Event.MOUSE_OUT、Event.MOUSE_DOWN、Event.MOUSE_UP、Event.CLICK</code> 事件侦听处理函数。
		*@param e Event 对象。
		*/
		__proto.onMouse = function (e) {
			if (this.toggle === false && this._selected) return;
			if (e.type ===/*laya.events.Event.CLICK*/"click") {
				this.toggle && (this.selected = !this._selected);
				this._clickHandler && this._clickHandler.run();
				return;
			}
			!this._selected && (this.state = Button.stateMap[e.type]);
		}

		/**
		*@private
		*对象的资源切片发生改变。
		*/
		__proto.changeClips = function () {
			var img = Loader.getRes(this._skin);
			if (!img) {
				console.log("lose skin", this._skin);
				return;
			};
			var width = img.sourceWidth;
			var height = img.sourceHeight / this._stateNum;
			img.$_GID || (img.$_GID = Utils.getGID());
			var key = img.$_GID + "-" + this._stateNum;
			var clips = WeakObject.I.get(key);
			if (!Utils.isOkTextureList(clips)) {
				clips = null;
			}
			if (clips) this._sources = clips;
			else {
				this._sources = [];
				if (this._stateNum === 1) {
					this._sources.push(img);
				} else {
					for (var i = 0; i < this._stateNum; i++) {
						this._sources.push(Texture.createFromTexture(img, 0, height * i, width, height));
					}
				}
				WeakObject.I.set(key, this._sources);
			}
			if (this._autoSize) {
				this._bitmap.width = this._width || width;
				this._bitmap.height = this._height || height;
				if (this._text) {
					this._text.width = this._bitmap.width;
					this._text.height = this._bitmap.height;
				}
			} else {
				this._text && (this._text.x = width);
			}
		}

		/**
		*@private
		*改变对象的状态。
		*/
		__proto.changeState = function () {
			this._stateChanged = false;
			this.runCallLater(this.changeClips);
			var index = this._state < this._stateNum ? this._state : this._stateNum - 1;
			this._sources && (this._bitmap.source = this._sources[index]);
			if (this.label) {
				this._text.color = this._labelColors[index];
				if (this._strokeColors) this._text.strokeColor = this._strokeColors[index];
			}
		}

		/**@private */
		__proto._setStateChanged = function () {
			if (!this._stateChanged) {
				this._stateChanged = true;
				this.callLater(this.changeState);
			}
		}

		/**
		*<p>描边颜色，以字符串表示。</p>
		*默认值为 "#000000"（黑色）;
		*@see laya.display.Text.strokeColor()
		*/
		__getset(0, __proto, 'labelStrokeColor', function () {
			this.createText();
			return this._text.strokeColor;
		}, function (value) {
			this.createText();
			this._text.strokeColor = value
		});

		/**
		*@inheritDoc
		*/
		__getset(0, __proto, 'measureHeight', function () {
			this.runCallLater(this.changeClips);
			return this._text ? Math.max(this._bitmap.height, this._text.height) : this._bitmap.height;
		});

		/**
		*<p>对象的皮肤资源地址。</p>
		*支持单态，两态和三态，用 <code>stateNum</code> 属性设置
		*<p>对象的皮肤地址，以字符串表示。</p>
		*@see #stateNum
		*/
		__getset(0, __proto, 'skin', function () {
			return this._skin;
		}, function (value) {
			if (this._skin != value) {
				this._skin = value;
				this.callLater(this.changeClips);
				this._setStateChanged();
			}
		});

		/**
		*对象的状态值。
		*@see #stateMap
		*/
		__getset(0, __proto, 'state', function () {
			return this._state;
		}, function (value) {
			if (this._state != value) {
				this._state = value;
				this._setStateChanged();
			}
		});

		/**
		*按钮文本标签 <code>Text</code> 控件。
		*/
		__getset(0, __proto, 'text', function () {
			this.createText();
			return this._text;
		});

		/**
		*<p>指定对象的状态值，以数字表示。</p>
		*<p>默认值为3。此值决定皮肤资源图片的切割方式。</p>
		*<p><b>取值：</b>
		*<li>1：单态。图片不做切割，按钮的皮肤状态只有一种。</li>
		*<li>2：两态。图片将以竖直方向被等比切割为2部分，从上向下，依次为
		*弹起状态皮肤、
		*按下和经过及选中状态皮肤。</li>
		*<li>3：三态。图片将以竖直方向被等比切割为3部分，从上向下，依次为
		*弹起状态皮肤、
		*经过状态皮肤、
		*按下和选中状态皮肤</li>
		*</p>
		*/
		__getset(0, __proto, 'stateNum', function () {
			return this._stateNum;
		}, function (value) {
			if ((typeof value == 'string')) {
				value = parseInt(value);
			}
			if (this._stateNum != value) {
				this._stateNum = value < 1 ? 1 : value > 3 ? 3 : value;
				this.callLater(this.changeClips);
			}
		});

		/**
		*表示按钮各个状态下的描边颜色。
		*<p><b>格式:</b> "upColor,overColor,downColor,disableColor"。</p>
		*/
		__getset(0, __proto, 'strokeColors', function () {
			return this._strokeColors ? this._strokeColors.join(",") : "";
		}, function (value) {
			this._strokeColors = UIUtils.fillArray(Styles.buttonLabelColors, value, String);
			this._setStateChanged();
		});

		/**
		*表示按钮各个状态下的文本颜色。
		*<p><b>格式:</b> "upColor,overColor,downColor,disableColor"。</p>
		*/
		__getset(0, __proto, 'labelColors', function () {
			return this._labelColors.join(",");
		}, function (value) {
			this._labelColors = UIUtils.fillArray(Styles.buttonLabelColors, value, String);
			this._setStateChanged();
		});

		/**
		*@inheritDoc
		*/
		__getset(0, __proto, 'measureWidth', function () {
			this.runCallLater(this.changeClips);
			if (this._autoSize) return this._bitmap.width;
			this.runCallLater(this.changeState);
			return this._bitmap.width + (this._text ? this._text.width : 0);
		});

		/**
		*按钮的文本内容。
		*/
		__getset(0, __proto, 'label', function () {
			return this._text ? this._text.text : null;
		}, function (value) {
			if (!this._text && !value) return;
			this.createText();
			if (this._text.text != value) {
				value && !this._text.parent && this.addChild(this._text);
				this._text.text = (value + "").replace(/\\n/g, "\n");
				this._setStateChanged();
			}
		});

		/**
		*表示按钮的选中状态。
		*<p>如果值为true，表示该对象处于选中状态。否则该对象处于未选中状态。</p>
		*/
		__getset(0, __proto, 'selected', function () {
			return this._selected;
		}, function (value) {
			if (this._selected != value) {
				this._selected = value;
				this.state = this._selected ? 2 : 0;
				this.event(/*laya.events.Event.CHANGE*/"change");
			}
		});

		/**
		*表示按钮文本标签的边距。
		*<p><b>格式：</b>"上边距,右边距,下边距,左边距"。</p>
		*/
		__getset(0, __proto, 'labelPadding', function () {
			this.createText();
			return this._text.padding.join(",");
		}, function (value) {
			this.createText();
			this._text.padding = UIUtils.fillArray(Styles.labelPadding, value, Number);
		});

		/**
		*表示按钮文本标签的字体大小。
		*@see laya.display.Text.fontSize()
		*/
		__getset(0, __proto, 'labelSize', function () {
			this.createText();
			return this._text.fontSize;
		}, function (value) {
			this.createText();
			this._text.fontSize = value
		});

		/**
		*<p>描边宽度（以像素为单位）。</p>
		*默认值0，表示不描边。
		*@see laya.display.Text.stroke()
		*/
		__getset(0, __proto, 'labelStroke', function () {
			this.createText();
			return this._text.stroke;
		}, function (value) {
			this.createText();
			this._text.stroke = value
		});

		/**
		*表示按钮文本标签是否为粗体字。
		*@see laya.display.Text.bold()
		*/
		__getset(0, __proto, 'labelBold', function () {
			this.createText();
			return this._text.bold;
		}, function (value) {
			this.createText();
			this._text.bold = value;
		});

		/**
		*表示按钮文本标签的字体名称，以字符串形式表示。
		*@see laya.display.Text.font()
		*/
		__getset(0, __proto, 'labelFont', function () {
			this.createText();
			return this._text.font;
		}, function (value) {
			this.createText();
			this._text.font = value;
		});

		/**标签对齐模式，默认为居中对齐。*/
		__getset(0, __proto, 'labelAlign', function () {
			this.createText()
			return this._text.align;
		}, function (value) {
			this.createText()
			this._text.align = value;
		});

		/**
		*对象的点击事件处理器函数（无默认参数）。
		*/
		__getset(0, __proto, 'clickHandler', function () {
			return this._clickHandler;
		}, function (value) {
			this._clickHandler = value;
		});

		/**
		*<p>当前实例的位图 <code>AutoImage</code> 实例的有效缩放网格数据。</p>
		*<p>数据格式："上边距,右边距,下边距,左边距,是否重复填充(值为0：不重复填充，1：重复填充)"，以逗号分隔。
		*<ul><li>例如："4,4,4,4,1"</li></ul></p>
		*@see laya.ui.AutoBitmap.sizeGrid
		*/
		__getset(0, __proto, 'sizeGrid', function () {
			if (this._bitmap.sizeGrid) return this._bitmap.sizeGrid.join(",");
			return null;
		}, function (value) {
			this._bitmap.sizeGrid = UIUtils.fillArray(Styles.defaultSizeGrid, value, Number);
		});

		/**@inheritDoc */
		__getset(0, __proto, 'width', _super.prototype._$get_width, function (value) {
			Laya.superSet(Component, this, 'width', value);
			if (this._autoSize) {
				this._bitmap.width = value;
				this._text && (this._text.width = value);
			}
		});

		/**@inheritDoc */
		__getset(0, __proto, 'height', _super.prototype._$get_height, function (value) {
			Laya.superSet(Component, this, 'height', value);
			if (this._autoSize) {
				this._bitmap.height = value;
				this._text && (this._text.height = value);
			}
		});

		/**@inheritDoc */
		__getset(0, __proto, 'dataSource', _super.prototype._$get_dataSource, function (value) {
			this._dataSource = value;
			if ((typeof value == 'number') || (typeof value == 'string')) this.label = value + "";
			else Laya.superSet(Component, this, 'dataSource', value);
		});

		/**图标x,y偏移，格式：100,100*/
		__getset(0, __proto, 'iconOffset', function () {
			return this._bitmap._offset ? this._bitmap._offset.join(",") : null;
		}, function (value) {
			if (value) this._bitmap._offset = UIUtils.fillArray([1, 1], value, Number);
			else this._bitmap._offset = [];
		});

		__static(Button,
			['stateMap', function () { return this.stateMap = { "mouseup": 0, "mouseover": 1, "mousedown": 2, "mouseout": 0 }; }
			]);
		return Button;
	})(Component)


	/**
	*<p> <code>Clip</code> 类是位图切片动画。</p>
	*<p> <code>Clip</code> 可将一张图片，按横向分割数量 <code>clipX</code> 、竖向分割数量 <code>clipY</code> ，
	*或横向分割每个切片的宽度 <code>clipWidth</code> 、竖向分割每个切片的高度 <code>clipHeight</code> ，
	*从左向右，从上到下，分割组合为一个切片动画。</p>
	*Image和Clip组件是唯一支持异步加载的两个组件，比如clip.skin="abc/xxx.png"，其他UI组件均不支持异步加载。
	*
	*@example <caption>以下示例代码，创建了一个 <code>Clip</code> 实例。</caption>
	*package
	*{
		*import laya.ui.Clip;
		*public class Clip_Example
		*{
			*private var clip:Clip;
			*public function Clip_Example()
			*{
				*Laya.init(640,800);//设置游戏画布宽高。
				*Laya.stage.bgColor="#efefef";//设置画布的背景颜色。
				*onInit();
				*}
			*private function onInit():void
			*{
				*clip=new Clip("resource/ui/clip_num.png",10,1);//创建一个 Clip 类的实例对象 clip ,传入它的皮肤skin和横向分割数量、竖向分割数量。
				*clip.autoPlay=true;//设置 clip 动画自动播放。
				*clip.interval=100;//设置 clip 动画的播放时间间隔。
				*clip.x=100;//设置 clip 对象的属性 x 的值，用于控制 clip 对象的显示位置。
				*clip.y=100;//设置 clip 对象的属性 y 的值，用于控制 clip 对象的显示位置。
				*clip.on(Event.CLICK,this,onClick);//给 clip 添加点击事件函数侦听。
				*Laya.stage.addChild(clip);//将此 clip 对象添加到显示列表。
				*}
			*private function onClick():void
			*{
				*trace("clip 的点击事件侦听处理函数。clip.total="+clip.total);
				*if (clip.isPlaying==true)
				*{
					*clip.stop();//停止动画。
					*}else {
					*clip.play();//播放动画。
					*}
				*}
			*}
		*}
	*@example
	*Laya.init(640,800);//设置游戏画布宽高
	*Laya.stage.bgColor="#efefef";//设置画布的背景颜色
	*var clip;
	*Laya.loader.load("resource/ui/clip_num.png",laya.utils.Handler.create(this,loadComplete));//加载资源
	*function loadComplete(){
		*console.log("资源加载完成！");
		*clip=new laya.ui.Clip("resource/ui/clip_num.png",10,1);//创建一个 Clip 类的实例对象 clip ,传入它的皮肤skin和横向分割数量、竖向分割数量。
		*clip.autoPlay=true;//设置 clip 动画自动播放。
		*clip.interval=100;//设置 clip 动画的播放时间间隔。
		*clip.x=100;//设置 clip 对象的属性 x 的值，用于控制 clip 对象的显示位置。
		*clip.y=100;//设置 clip 对象的属性 y 的值，用于控制 clip 对象的显示位置。
		*clip.on(Event.CLICK,this,onClick);//给 clip 添加点击事件函数侦听。
		*Laya.stage.addChild(clip);//将此 clip 对象添加到显示列表。
		*}
	*function onClick()
	*{
		*console.log("clip 的点击事件侦听处理函数。");
		*if(clip.isPlaying==true)
		*{
			*clip.stop();
			*}else {
			*clip.play();
			*}
		*}
	*@example
	*import Clip=laya.ui.Clip;
	*import Handler=laya.utils.Handler;
	*class Clip_Example {
		*private clip:Clip;
		*constructor(){
			*Laya.init(640,800);//设置游戏画布宽高。
			*Laya.stage.bgColor="#efefef";//设置画布的背景颜色。
			*this.onInit();
			*}
		*private onInit():void {
			*this.clip=new Clip("resource/ui/clip_num.png",10,1);//创建一个 Clip 类的实例对象 clip ,传入它的皮肤skin和横向分割数量、竖向分割数量。
			*this.clip.autoPlay=true;//设置 clip 动画自动播放。
			*this.clip.interval=100;//设置 clip 动画的播放时间间隔。
			*this.clip.x=100;//设置 clip 对象的属性 x 的值，用于控制 clip 对象的显示位置。
			*this.clip.y=100;//设置 clip 对象的属性 y 的值，用于控制 clip 对象的显示位置。
			*this.clip.on(laya.events.Event.CLICK,this,this.onClick);//给 clip 添加点击事件函数侦听。
			*Laya.stage.addChild(this.clip);//将此 clip 对象添加到显示列表。
			*}
		*private onClick():void {
			*console.log("clip 的点击事件侦听处理函数。clip.total="+this.clip.total);
			*if (this.clip.isPlaying==true){
				*this.clip.stop();//停止动画。
				*}else {
				*this.clip.play();//播放动画。
				*}
			*}
		*}
	*
	*/
	//class laya.ui.Clip extends laya.ui.Component
	var Clip = (function (_super) {
		function Clip(url, clipX, clipY) {
			/**@private */
			this._sources = null;
			/**@private */
			this._bitmap = null;
			/**@private */
			this._skin = null;
			/**@private */
			this._clipX = 1;
			/**@private */
			this._clipY = 1;
			/**@private */
			this._clipWidth = 0;
			/**@private */
			this._clipHeight = 0;
			/**@private */
			this._autoPlay = false;
			/**@private */
			this._interval = 50;
			/**@private */
			this._complete = null;
			/**@private */
			this._isPlaying = false;
			/**@private */
			this._index = 0;
			/**@private */
			this._clipChanged = false;
			/**@private */
			this._group = null;
			/**@private */
			this._toIndex = -1;
			Clip.__super.call(this);
			(clipX === void 0) && (clipX = 1);
			(clipY === void 0) && (clipY = 1);
			this._clipX = clipX;
			this._clipY = clipY;
			this.skin = url;
		}

		__class(Clip, 'laya.ui.Clip', _super);
		var __proto = Clip.prototype;
		/**@inheritDoc */
		__proto.destroy = function (destroyChild) {
			(destroyChild === void 0) && (destroyChild = true);
			_super.prototype.destroy.call(this, true);
			this._bitmap && this._bitmap.destroy();
			this._bitmap = null;
			this._sources = null;
		}

		/**
		*销毁对象并释放加载的皮肤资源。
		*/
		__proto.dispose = function () {
			this.destroy(true);
			Laya.loader.clearRes(this._skin);
		}

		/**@inheritDoc */
		__proto.createChildren = function () {
			this.graphics = this._bitmap = new AutoBitmap();
		}

		/**@private */
		__proto._onDisplay = function (e) {
			if (this._isPlaying) {
				if (this._displayedInStage) this.play();
				else this.stop();
			} else if (this._autoPlay) {
				this.play();
			}
		}

		/**
		*@private
		*改变切片的资源、切片的大小。
		*/
		__proto.changeClip = function () {
			this._clipChanged = false;
			if (!this._skin) return;
			var img = Loader.getRes(this._skin);
			if (img) {
				this.loadComplete(this._skin, img);
			} else {
				Laya.loader.load(this._skin, Handler.create(this, this.loadComplete, [this._skin]));
			}
		}

		/**
		*@private
		*加载切片图片资源完成函数。
		*@param url 资源地址。
		*@param img 纹理。
		*/
		__proto.loadComplete = function (url, img) {
			if (url === this._skin && img) {
				var w = this._clipWidth || Math.ceil(img.sourceWidth / this._clipX);
				var h = this._clipHeight || Math.ceil(img.sourceHeight / this._clipY);
				var key = this._skin + w + h;
				var clips = WeakObject.I.get(key);
				if (!Utils.isOkTextureList(clips)) {
					clips = null;
				}
				if (clips) this._sources = clips;
				else {
					this._sources = [];
					for (var i = 0; i < this._clipY; i++) {
						for (var j = 0; j < this._clipX; j++) {
							this._sources.push(Texture.createFromTexture(img, w * j, h * i, w, h));
						}
					}
					WeakObject.I.set(key, this._sources);
				}
				this.index = this._index;
				this.event(/*laya.events.Event.LOADED*/"loaded");
				this.onCompResize();
			}
		}

		/**
		*播放动画。
		*@param from 开始索引
		*@param to 结束索引，-1为不限制
		*/
		__proto.play = function (from, to) {
			(from === void 0) && (from = 0);
			(to === void 0) && (to = -1);
			this._isPlaying = true;
			this.index = from;
			this._toIndex = to;
			this._index++;
			Laya.timer.loop(this.interval, this, this._loop);
			this.on(/*laya.events.Event.DISPLAY*/"display", this, this._onDisplay);
			this.on(/*laya.events.Event.UNDISPLAY*/"undisplay", this, this._onDisplay);
		}

		/**
		*@private
		*/
		__proto._loop = function () {
			if (this._style.visible && this._sources) {
				this._index++;
				if (this._toIndex > -1 && this._index >= this._toIndex) this.stop();
				else if (this._index >= this._sources.length) this._index = 0;
				this.index = this._index;
			}
		}

		/**
		*停止动画。
		*/
		__proto.stop = function () {
			this._isPlaying = false;
			Laya.timer.clear(this, this._loop);
			this.event(/*laya.events.Event.COMPLETE*/"complete");
		}

		/**@private */
		__proto._setClipChanged = function () {
			if (!this._clipChanged) {
				this._clipChanged = true;
				this.callLater(this.changeClip);
			}
		}

		/**
		*表示动画播放间隔时间(以毫秒为单位)。
		*/
		__getset(0, __proto, 'interval', function () {
			return this._interval;
		}, function (value) {
			if (this._interval != value) {
				this._interval = value;
				if (this._isPlaying) this.play();
			}
		});

		/**
		*@copy laya.ui.Image#skin
		*/
		__getset(0, __proto, 'skin', function () {
			return this._skin;
		}, function (value) {
			if (this._skin != value) {
				this._skin = value;
				if (value) {
					this._setClipChanged()
				} else {
					this._bitmap.source = null;
				}
			}
		});

		/**
		*源数据。
		*/
		__getset(0, __proto, 'sources', function () {
			return this._sources;
		}, function (value) {
			this._sources = value;
			this.index = this._index;
			this.event(/*laya.events.Event.LOADED*/"loaded");
		});

		/**X轴（横向）切片数量。*/
		__getset(0, __proto, 'clipX', function () {
			return this._clipX;
		}, function (value) {
			this._clipX = value || 1;
			this._setClipChanged()
		});

		/**Y轴(竖向)切片数量。*/
		__getset(0, __proto, 'clipY', function () {
			return this._clipY;
		}, function (value) {
			this._clipY = value || 1;
			this._setClipChanged()
		});

		/**
		*切片动画的总帧数。
		*/
		__getset(0, __proto, 'total', function () {
			this.runCallLater(this.changeClip);
			return this._sources ? this._sources.length : 0;
		});

		/**
		*横向分割时每个切片的宽度，与 <code>clipX</code> 同时设置时优先级高于 <code>clipX</code> 。
		*/
		__getset(0, __proto, 'clipWidth', function () {
			return this._clipWidth;
		}, function (value) {
			this._clipWidth = value;
			this._setClipChanged()
		});

		/**
		*<p>当前实例的位图 <code>AutoImage</code> 实例的有效缩放网格数据。</p>
		*<p>数据格式："上边距,右边距,下边距,左边距,是否重复填充(值为0：不重复填充，1：重复填充)"，以逗号分隔。
		*<ul><li>例如："4,4,4,4,1"</li></ul></p>
		*@see laya.ui.AutoBitmap.sizeGrid
		*/
		__getset(0, __proto, 'sizeGrid', function () {
			if (this._bitmap.sizeGrid) return this._bitmap.sizeGrid.join(",");
			return null;
		}, function (value) {
			this._bitmap.sizeGrid = UIUtils.fillArray(Styles.defaultSizeGrid, value, Number);
		});

		/**
		*资源分组。
		*/
		__getset(0, __proto, 'group', function () {
			return this._group;
		}, function (value) {
			if (value && this._skin) Loader.setGroup(this._skin, value);
			this._group = value;
		});

		/**
		*竖向分割时每个切片的高度，与 <code>clipY</code> 同时设置时优先级高于 <code>clipY</code> 。
		*/
		__getset(0, __proto, 'clipHeight', function () {
			return this._clipHeight;
		}, function (value) {
			this._clipHeight = value;
			this._setClipChanged()
		});

		/**@inheritDoc */
		__getset(0, __proto, 'width', _super.prototype._$get_width, function (value) {
			Laya.superSet(Component, this, 'width', value);
			this._bitmap.width = value;
		});

		/**@inheritDoc */
		__getset(0, __proto, 'height', _super.prototype._$get_height, function (value) {
			Laya.superSet(Component, this, 'height', value);
			this._bitmap.height = value;
		});

		/**@inheritDoc */
		__getset(0, __proto, 'measureWidth', function () {
			this.runCallLater(this.changeClip);
			return this._bitmap.width;
		});

		/**@inheritDoc */
		__getset(0, __proto, 'measureHeight', function () {
			this.runCallLater(this.changeClip);
			return this._bitmap.height;
		});

		/**
		*当前帧索引。
		*/
		__getset(0, __proto, 'index', function () {
			return this._index;
		}, function (value) {
			this._index = value;
			this._bitmap && this._sources && (this._bitmap.source = this._sources[value]);
			this.event(/*laya.events.Event.CHANGE*/"change");
		});

		/**
		*表示是否自动播放动画，若自动播放值为true,否则值为false;
		*<p>可控制切片动画的播放、停止。</p>
		*/
		__getset(0, __proto, 'autoPlay', function () {
			return this._autoPlay;
		}, function (value) {
			if (this._autoPlay != value) {
				this._autoPlay = value;
				value ? this.play() : this.stop();
			}
		});

		/**
		*表示动画的当前播放状态。
		*如果动画正在播放中，则为true，否则为flash。
		*/
		__getset(0, __proto, 'isPlaying', function () {
			return this._isPlaying;
		}, function (value) {
			this._isPlaying = value;
		});

		/**@inheritDoc */
		__getset(0, __proto, 'dataSource', _super.prototype._$get_dataSource, function (value) {
			this._dataSource = value;
			if (((typeof value == 'number') && Math.floor(value) == value) || (typeof value == 'string')) this.index = parseInt(value);
			else Laya.superSet(Component, this, 'dataSource', value);
		});

		/**
		*<code>AutoBitmap</code> 位图实例。
		*/
		__getset(0, __proto, 'bitmap', function () {
			return this._bitmap;
		});

		return Clip;
	})(Component)


	/**
	*<code>ColorPicker</code> 组件将显示包含多个颜色样本的列表，用户可以从中选择颜色。
	*
	*@example <caption>以下示例代码，创建了一个 <code>ColorPicker</code> 实例。</caption>
	*package
	*{
		*import laya.ui.ColorPicker;
		*import laya.utils.Handler;
		*public class ColorPicker_Example
		*{
			*public function ColorPicker_Example()
			*{
				*Laya.init(640,800);//设置游戏画布宽高。
				*Laya.stage.bgColor="#efefef";//设置画布的背景颜色。
				*Laya.loader.load("resource/ui/color.png",Handler.create(this,onLoadComplete));//加载资源。
				*}
			*private function onLoadComplete():void
			*{
				*trace("资源加载完成！");
				*var colorPicket:ColorPicker=new ColorPicker();//创建一个 ColorPicker 类的实例对象 colorPicket 。
				*colorPicket.skin="resource/ui/color.png";//设置 colorPicket 的皮肤。
				*colorPicket.x=100;//设置 colorPicket 对象的属性 x 的值，用于控制 colorPicket 对象的显示位置。
				*colorPicket.y=100;//设置 colorPicket 对象的属性 y 的值，用于控制 colorPicket 对象的显示位置。
				*colorPicket.changeHandler=new Handler(this,onChangeColor,[colorPicket]);//设置 colorPicket 的颜色改变回调函数。
				*Laya.stage.addChild(colorPicket);//将此 colorPicket 对象添加到显示列表。
				*}
			*private function onChangeColor(colorPicket:ColorPicker):void
			*{
				*trace("当前选择的颜色： "+colorPicket.selectedColor);
				*}
			*}
		*}
	*@example
	*Laya.init(640,800);//设置游戏画布宽高
	*Laya.stage.bgColor="#efefef";//设置画布的背景颜色
	*Laya.loader.load("resource/ui/color.png",laya.utils.Handler.create(this,loadComplete));//加载资源
	*function loadComplete()
	*{
		*console.log("资源加载完成！");
		*var colorPicket=new laya.ui.ColorPicker();//创建一个 ColorPicker 类的实例对象 colorPicket 。
		*colorPicket.skin="resource/ui/color.png";//设置 colorPicket 的皮肤。
		*colorPicket.x=100;//设置 colorPicket 对象的属性 x 的值，用于控制 colorPicket 对象的显示位置。
		*colorPicket.y=100;//设置 colorPicket 对象的属性 y 的值，用于控制 colorPicket 对象的显示位置。
		*colorPicket.changeHandler=laya.utils.Handler.create(this,onChangeColor,[colorPicket],false);//设置 colorPicket 的颜色改变回调函数。
		*Laya.stage.addChild(colorPicket);//将此 colorPicket 对象添加到显示列表。
		*}
	*function onChangeColor(colorPicket)
	*{
		*console.log("当前选择的颜色： "+colorPicket.selectedColor);
		*}
	*@example
	*import ColorPicker=laya.ui.ColorPicker;
	*import Handler=laya.utils.Handler;
	*class ColorPicker_Example {
		*constructor(){
			*Laya.init(640,800);//设置游戏画布宽高。
			*Laya.stage.bgColor="#efefef";//设置画布的背景颜色。
			*Laya.loader.load("resource/ui/color.png",Handler.create(this,this.onLoadComplete));//加载资源。
			*}
		*private onLoadComplete():void {
			*console.log("资源加载完成！");
			*var colorPicket:ColorPicker=new ColorPicker();//创建一个 ColorPicker 类的实例对象 colorPicket 。
			*colorPicket.skin="resource/ui/color.png";//设置 colorPicket 的皮肤。
			*colorPicket.x=100;//设置 colorPicket 对象的属性 x 的值，用于控制 colorPicket 对象的显示位置。
			*colorPicket.y=100;//设置 colorPicket 对象的属性 y 的值，用于控制 colorPicket 对象的显示位置。
			*colorPicket.changeHandler=new Handler(this,this.onChangeColor,[colorPicket]);//设置 colorPicket 的颜色改变回调函数。
			*Laya.stage.addChild(colorPicket);//将此 colorPicket 对象添加到显示列表。
			*}
		*private onChangeColor(colorPicket:ColorPicker):void {
			*console.log("当前选择的颜色： "+colorPicket.selectedColor);
			*}
		*}
	*/
	//class laya.ui.ColorPicker extends laya.ui.Component
	var ColorPicker = (function (_super) {
		function ColorPicker() {
			/**
			*当颜色发生改变时执行的函数处理器。
			*默认返回参数color：颜色值字符串。
			*/
			this.changeHandler = null;
			/**
			*@private
			*指定每个正方形的颜色小格子的宽高（以像素为单位）。
			*/
			this._gridSize = 11;
			/**
			*@private
			*表示颜色样本列表面板的背景颜色值。
			*/
			this._bgColor = "#ffffff";
			/**
			*@private
			*表示颜色样本列表面板的边框颜色值。
			*/
			this._borderColor = "#000000";
			/**
			*@private
			*表示颜色样本列表面板选择或输入的颜色值。
			*/
			this._inputColor = "#000000";
			/**
			*@private
			*表示颜色输入框的背景颜色值。
			*/
			this._inputBgColor = "#efefef";
			/**
			*@private
			*表示颜色样本列表面板。
			*/
			this._colorPanel = null;
			/**
			*@private
			*表示颜色网格。
			*/
			this._colorTiles = null;
			/**
			*@private
			*表示颜色块显示对象。
			*/
			this._colorBlock = null;
			/**
			*@private
			*表示颜色输入框控件 <code>Input</code> 。
			*/
			this._colorInput = null;
			/**
			*@private
			*表示点击后显示颜色样本列表面板的按钮控件 <code>Button</code> 。
			*/
			this._colorButton = null;
			/**
			*@private
			*表示颜色值列表。
			*/
			this._colors = [];
			/**
			*@private
			*表示选择的颜色值。
			*/
			this._selectedColor = "#000000";
			/**@private */
			this._panelChanged = false;
			ColorPicker.__super.call(this);
		}

		__class(ColorPicker, 'laya.ui.ColorPicker', _super);
		var __proto = ColorPicker.prototype;
		/**@inheritDoc */
		__proto.destroy = function (destroyChild) {
			(destroyChild === void 0) && (destroyChild = true);
			_super.prototype.destroy.call(this, destroyChild);
			this._colorPanel && this._colorPanel.destroy(destroyChild);
			this._colorButton && this._colorButton.destroy(destroyChild);
			this._colorPanel = null;
			this._colorTiles = null;
			this._colorBlock = null;
			this._colorInput = null;
			this._colorButton = null;
			this._colors = null;
			this.changeHandler = null;
		}

		/**@inheritDoc */
		__proto.createChildren = function () {
			this.addChild(this._colorButton = new Button());
			this._colorPanel = new Box();
			this._colorPanel.size(230, 166);
			this._colorPanel.addChild(this._colorTiles = new Sprite());
			this._colorPanel.addChild(this._colorBlock = new Sprite());
			this._colorPanel.addChild(this._colorInput = new Input());
		}

		/**@inheritDoc */
		__proto.initialize = function () {
			this._colorButton.on(/*laya.events.Event.CLICK*/"click", this, this.onColorButtonClick);
			this._colorBlock.pos(5, 5);
			this._colorInput.pos(60, 5);
			this._colorInput.size(60, 20);
			this._colorInput.on(/*laya.events.Event.CHANGE*/"change", this, this.onColorInputChange);
			this._colorInput.on(/*laya.events.Event.KEY_DOWN*/"keydown", this, this.onColorFieldKeyDown);
			this._colorTiles.pos(5, 30);
			this._colorTiles.on(/*laya.events.Event.MOUSE_MOVE*/"mousemove", this, this.onColorTilesMouseMove);
			this._colorTiles.on(/*laya.events.Event.CLICK*/"click", this, this.onColorTilesClick);
			this._colorTiles.size(20 * this._gridSize, 12 * this._gridSize);
			this._colorPanel.on(/*laya.events.Event.MOUSE_DOWN*/"mousedown", this, this.onPanelMouseDown);
			this.bgColor = this._bgColor;
		}

		__proto.onPanelMouseDown = function (e) {
			e.stopPropagation();
		}

		/**
		*改变颜色样本列表面板。
		*/
		__proto.changePanel = function () {
			this._panelChanged = false;
			var g = this._colorPanel.graphics;
			g.clear();
			g.drawRect(0, 0, 230, 166, this._bgColor, this._borderColor);
			this.drawBlock(this._selectedColor);
			this._colorInput.borderColor = this._borderColor;
			this._colorInput.bgColor = this._inputBgColor;
			this._colorInput.color = this._inputColor;
			g = this._colorTiles.graphics;
			g.clear();
			var mainColors = [0x000000, 0x333333, 0x666666, 0x999999, 0xCCCCCC, 0xFFFFFF, 0xFF0000, 0x00FF00, 0x0000FF, 0xFFFF00, 0x00FFFF, 0xFF00FF];
			for (var i = 0; i < 12; i++) {
				for (var j = 0; j < 20; j++) {
					var color = 0;
					if (j === 0) color = mainColors[i];
					else if (j === 1) color = 0x000000;
					else color = (((i * 3 + j / 6) % 3 << 0) + ((i / 6) << 0) * 3) * 0x33 << 16 | j % 6 * 0x33 << 8 | (i << 0) % 6 * 0x33;
					var strColor = UIUtils.toColor(color);
					this._colors.push(strColor);
					var x = j * this._gridSize;
					var y = i * this._gridSize;
					g.drawRect(x, y, this._gridSize, this._gridSize, strColor, "#000000");
				}
			}
		}

		/**
		*颜色样本列表面板的显示按钮的 <code>Event.MOUSE_DOWN</code> 事件侦听处理函数。
		*/
		__proto.onColorButtonClick = function (e) {
			if (this._colorPanel.parent) this.close();
			else this.open();
		}

		/**
		*打开颜色样本列表面板。
		*/
		__proto.open = function () {
			var p = this.localToGlobal(new Point());
			var px = p.x + this._colorPanel.width <= Laya.stage.width ? p.x : Laya.stage.width - this._colorPanel.width;
			var py = p.y + this._colorButton.height;
			py = py + this._colorPanel.height <= Laya.stage.height ? py : p.y - this._colorPanel.height;
			this._colorPanel.pos(px, py);
			this._colorPanel.zOrder = 1001;
			Laya._currentStage.addChild(this._colorPanel);
			Laya.stage.on(/*laya.events.Event.MOUSE_DOWN*/"mousedown", this, this.removeColorBox);
		}

		/**
		*关闭颜色样本列表面板。
		*/
		__proto.close = function () {
			Laya.stage.off(/*laya.events.Event.MOUSE_DOWN*/"mousedown", this, this.removeColorBox);
			this._colorPanel.removeSelf();
		}

		/**
		*舞台的 <code>Event.MOUSE_DOWN</code> 事件侦听处理函数。
		*/
		__proto.removeColorBox = function (e) {
			this.close();
		}

		/**
		*小格子色块的 <code>Event.KEY_DOWN</code> 事件侦听处理函数。
		*/
		__proto.onColorFieldKeyDown = function (e) {
			if (e.keyCode == 13) {
				if (this._colorInput.text) this.selectedColor = this._colorInput.text;
				else this.selectedColor = null;
				this.close();
				e.stopPropagation();
			}
		}

		/**
		*颜色值输入框 <code>Event.CHANGE</code> 事件侦听处理函数。
		*/
		__proto.onColorInputChange = function (e) {
			if (this._colorInput.text) this.drawBlock(this._colorInput.text);
			else this.drawBlock("#FFFFFF");
		}

		/**
		*小格子色块的 <code>Event.CLICK</code> 事件侦听处理函数。
		*/
		__proto.onColorTilesClick = function (e) {
			this.selectedColor = this.getColorByMouse();
			this.close();
		}

		/**
		*@private
		*小格子色块的 <code>Event.MOUSE_MOVE</code> 事件侦听处理函数。
		*/
		__proto.onColorTilesMouseMove = function (e) {
			this._colorInput.focus = false;
			var color = this.getColorByMouse();
			this._colorInput.text = color;
			this.drawBlock(color);
		}

		/**
		*通过鼠标位置取对应的颜色块的颜色值。
		*/
		__proto.getColorByMouse = function () {
			var point = this._colorTiles.getMousePoint();
			var x = Math.floor(point.x / this._gridSize);
			var y = Math.floor(point.y / this._gridSize);
			return this._colors[y * 20 + x];
		}

		/**
		*绘制颜色块。
		*@param color 需要绘制的颜色块的颜色值。
		*/
		__proto.drawBlock = function (color) {
			var g = this._colorBlock.graphics;
			g.clear();
			var showColor = color ? color : "#ffffff";
			g.drawRect(0, 0, 50, 20, showColor, this._borderColor);
			color || g.drawLine(0, 0, 50, 20, "#ff0000");
		}

		/**
		*改变颜色。
		*/
		__proto.changeColor = function () {
			var g = this.graphics;
			g.clear();
			var showColor = this._selectedColor || "#000000";
			g.drawRect(0, 0, this._colorButton.width, this._colorButton.height, showColor);
		}

		/**@private */
		__proto._setPanelChanged = function () {
			if (!this._panelChanged) {
				this._panelChanged = true;
				this.callLater(this.changePanel);
			}
		}

		/**
		*表示颜色输入框的背景颜色值。
		*/
		__getset(0, __proto, 'inputBgColor', function () {
			return this._inputBgColor;
		}, function (value) {
			this._inputBgColor = value;
			this._setPanelChanged();
		});

		/**
		*表示选择的颜色值。
		*/
		__getset(0, __proto, 'selectedColor', function () {
			return this._selectedColor;
		}, function (value) {
			if (this._selectedColor != value) {
				this._selectedColor = this._colorInput.text = value;
				this.drawBlock(value);
				this.changeColor();
				this.changeHandler && this.changeHandler.runWith(this._selectedColor);
				this.event(/*laya.events.Event.CHANGE*/"change", Event.EMPTY.setTo(/*laya.events.Event.CHANGE*/"change", this, this));
			}
		});

		/**
		*@copy laya.ui.Button#skin
		*/
		__getset(0, __proto, 'skin', function () {
			return this._colorButton.skin;
		}, function (value) {
			this._colorButton.skin = value;
			this.changeColor();
		});

		/**
		*表示颜色样本列表面板的背景颜色值。
		*/
		__getset(0, __proto, 'bgColor', function () {
			return this._bgColor;
		}, function (value) {
			this._bgColor = value;
			this._setPanelChanged();
		});

		/**
		*表示颜色样本列表面板的边框颜色值。
		*/
		__getset(0, __proto, 'borderColor', function () {
			return this._borderColor;
		}, function (value) {
			this._borderColor = value;
			this._setPanelChanged();
		});

		/**
		*表示颜色样本列表面板选择或输入的颜色值。
		*/
		__getset(0, __proto, 'inputColor', function () {
			return this._inputColor;
		}, function (value) {
			this._inputColor = value;
			this._setPanelChanged();
		});

		return ColorPicker;
	})(Component)


	/**
	*<code>ComboBox</code> 组件包含一个下拉列表，用户可以从该列表中选择单个值。
	*
	*@example <caption>以下示例代码，创建了一个 <code>ComboBox</code> 实例。</caption>
	*package
	*{
		*import laya.ui.ComboBox;
		*import laya.utils.Handler;
		*public class ComboBox_Example
		*{
			*public function ComboBox_Example()
			*{
				*Laya.init(640,800);//设置游戏画布宽高。
				*Laya.stage.bgColor="#efefef";//设置画布的背景颜色。
				*Laya.loader.load("resource/ui/button.png",Handler.create(this,onLoadComplete));//加载资源。
				*}
			*private function onLoadComplete():void
			*{
				*trace("资源加载完成！");
				*var comboBox:ComboBox=new ComboBox("resource/ui/button.png","item0,item1,item2,item3,item4,item5");//创建一个 ComboBox 类的实例对象 comboBox ,传入它的皮肤和标签集。
				*comboBox.x=100;//设置 comboBox 对象的属性 x 的值，用于控制 comboBox 对象的显示位置。
				*comboBox.y=100;//设置 comboBox 对象的属性 x 的值，用于控制 comboBox 对象的显示位置。
				*comboBox.selectHandler=new Handler(this,onSelect);//设置 comboBox 选择项改变时执行的处理器。
				*Laya.stage.addChild(comboBox);//将此 comboBox 对象添加到显示列表。
				*}
			*private function onSelect(index:int):void
			*{
				*trace("当前选中的项对象索引： ",index);
				*}
			*}
		*}
	*@example
	*Laya.init(640,800);//设置游戏画布宽高。
	*Laya.stage.bgColor="#efefef";//设置画布的背景颜色。
	*Laya.loader.load("resource/ui/button.png",laya.utils.Handler.create(this,loadComplete));//加载资源
	*function loadComplete(){
		*console.log("资源加载完成！");
		*var comboBox=new laya.ui.ComboBox("resource/ui/button.png","item0,item1,item2,item3,item4,item5");//创建一个 ComboBox 类的实例对象 comboBox ,传入它的皮肤和标签集。
		*comboBox.x=100;//设置 comboBox 对象的属性 x 的值，用于控制 comboBox 对象的显示位置。
		*comboBox.y=100;//设置 comboBox 对象的属性 x 的值，用于控制 comboBox 对象的显示位置。
		*comboBox.selectHandler=new laya.utils.Handler(this,onSelect);//设置 comboBox 选择项改变时执行的处理器。
		*Laya.stage.addChild(comboBox);//将此 comboBox 对象添加到显示列表。
		*}
	*function onSelect(index)
	*{
		*console.log("当前选中的项对象索引： ",index);
		*}
	*@example
	*import ComboBox=laya.ui.ComboBox;
	*import Handler=laya.utils.Handler;
	*class ComboBox_Example {
		*constructor(){
			*Laya.init(640,800);//设置游戏画布宽高。
			*Laya.stage.bgColor="#efefef";//设置画布的背景颜色。
			*Laya.loader.load("resource/ui/button.png",Handler.create(this,this.onLoadComplete));//加载资源。
			*}
		*private onLoadComplete():void {
			*console.log("资源加载完成！");
			*var comboBox:ComboBox=new ComboBox("resource/ui/button.png","item0,item1,item2,item3,item4,item5");//创建一个 ComboBox 类的实例对象 comboBox ,传入它的皮肤和标签集。
			*comboBox.x=100;//设置 comboBox 对象的属性 x 的值，用于控制 comboBox 对象的显示位置。
			*comboBox.y=100;//设置 comboBox 对象的属性 x 的值，用于控制 comboBox 对象的显示位置。
			*comboBox.selectHandler=new Handler(this,this.onSelect);//设置 comboBox 选择项改变时执行的处理器。
			*Laya.stage.addChild(comboBox);//将此 comboBox 对象添加到显示列表。
			*}
		*private onSelect(index:number):void {
			*console.log("当前选中的项对象索引： ",index);
			*}
		*}
	*
	*/
	//class laya.ui.ComboBox extends laya.ui.Component
	var ComboBox = (function (_super) {
		function ComboBox(skin, labels) {
			/**@private */
			this._visibleNum = 6;
			/**
			*@private
			*/
			this._button = null;
			/**
			*@private
			*/
			this._list = null;
			/**
			*@private
			*/
			this._isOpen = false;
			/**
			*@private
			*/
			this._itemSize = 12;
			/**
			*@private
			*/
			this._labels = [];
			/**
			*@private
			*/
			this._selectedIndex = -1;
			/**
			*@private
			*/
			this._selectHandler = null;
			/**
			*@private
			*/
			this._itemHeight = NaN;
			/**
			*@private
			*/
			this._listHeight = NaN;
			/**
			*@private
			*/
			this._listChanged = false;
			/**
			*@private
			*/
			this._itemChanged = false;
			/**
			*@private
			*/
			this._scrollBarSkin = null;
			/**
			*@private
			*/
			this._isCustomList = false;
			/**
			*渲染项，用来显示下拉列表展示对象
			*/
			this.itemRender = null;
			ComboBox.__super.call(this);
			this._itemColors = Styles.comboBoxItemColors;
			this.skin = skin;
			this.labels = labels;
		}

		__class(ComboBox, 'laya.ui.ComboBox', _super);
		var __proto = ComboBox.prototype;
		/**@inheritDoc */
		__proto.destroy = function (destroyChild) {
			(destroyChild === void 0) && (destroyChild = true);
			_super.prototype.destroy.call(this, destroyChild);
			this._button && this._button.destroy(destroyChild);
			this._list && this._list.destroy(destroyChild);
			this._button = null;
			this._list = null;
			this._itemColors = null;
			this._labels = null;
			this._selectHandler = null;
		}

		/**@inheritDoc */
		__proto.createChildren = function () {
			this.addChild(this._button = new Button());
			this._button.text.align = "left";
			this._button.labelPadding = "0,0,0,5";
			this._button.on(/*laya.events.Event.MOUSE_DOWN*/"mousedown", this, this.onButtonMouseDown);
		}

		__proto._createList = function () {
			this._list = new List();
			if (this._scrollBarSkin) this._list.vScrollBarSkin = this._scrollBarSkin;
			this._setListEvent(this._list);
		}

		__proto._setListEvent = function (list) {
			this._list.selectEnable = true;
			this._list.on(/*laya.events.Event.MOUSE_DOWN*/"mousedown", this, this.onListDown);
			this._list.mouseHandler = Handler.create(this, this.onlistItemMouse, null, false);
			if (this._list.scrollBar) this._list.scrollBar.on(/*laya.events.Event.MOUSE_DOWN*/"mousedown", this, this.onScrollBarDown);
		}

		/**
		*@private
		*/
		__proto.onListDown = function (e) {
			e.stopPropagation();
		}

		__proto.onScrollBarDown = function (e) {
			e.stopPropagation();
		}

		__proto.onButtonMouseDown = function (e) {
			this.callLater(this.switchTo, [!this._isOpen]);
		}

		/**
		*@private
		*/
		__proto.changeList = function () {
			this._listChanged = false;
			var labelWidth = this.width - 2;
			var labelColor = this._itemColors[2];
			this._itemHeight = this._itemSize + 6;
			this._list.itemRender = this.itemRender || { type: "Box", child: [{ type: "Label", props: { name: "label", x: 1, padding: "3,3,3,3", width: labelWidth, height: this._itemHeight, fontSize: this._itemSize, color: labelColor } }] };
			this._list.repeatY = this._visibleNum;
			this._list.refresh();
		}

		/**
		*@private
		*下拉列表的鼠标事件响应函数。
		*/
		__proto.onlistItemMouse = function (e, index) {
			var type = e.type;
			if (type ===/*laya.events.Event.MOUSE_OVER*/"mouseover" || type ===/*laya.events.Event.MOUSE_OUT*/"mouseout") {
				if (this._isCustomList) return;
				var box = this._list.getCell(index);
				if (!box) return;
				var label = box.getChildByName("label");
				if (label) {
					if (type ===/*laya.events.Event.ROLL_OVER*/"mouseover") {
						label.bgColor = this._itemColors[0];
						label.color = this._itemColors[1];
					} else {
						label.bgColor = null;
						label.color = this._itemColors[2];
					}
				}
			} else if (type ===/*laya.events.Event.CLICK*/"click") {
				this.selectedIndex = index;
				this.isOpen = false;
			}
		}

		/**
		*@private
		*/
		__proto.switchTo = function (value) {
			this.isOpen = value;
		}

		/**
		*更改下拉列表的打开状态。
		*/
		__proto.changeOpen = function () {
			this.isOpen = !this._isOpen;
		}

		/**
		*更改下拉列表。
		*/
		__proto.changeItem = function () {
			this._itemChanged = false;
			this._listHeight = this._labels.length > 0 ? Math.min(this._visibleNum, this._labels.length) * this._itemHeight : this._itemHeight;
			if (!this._isCustomList) {
				var g = this._list.graphics;
				g.clear();
				g.drawRect(0, 0, this.width - 1, this._listHeight, this._itemColors[4], this._itemColors[3]);
			};
			var a = this._list.array || [];
			a.length = 0;
			for (var i = 0, n = this._labels.length; i < n; i++) {
				a.push({ label: this._labels[i] });
			}
			this._list.height = this._listHeight;
			this._list.array = a;
		}

		__proto.changeSelected = function () {
			this._button.label = this.selectedLabel;
		}

		__proto._onStageMouseWheel = function (e) {
			if (!this._list || this._list.contains(e.target)) return;
			this.removeList(null);
		}

		/**
		*关闭下拉列表。
		*/
		__proto.removeList = function (e) {
			Laya.stage.off(/*laya.events.Event.MOUSE_DOWN*/"mousedown", this, this.removeList);
			Laya.stage.off(/*laya.events.Event.MOUSE_WHEEL*/"mousewheel", this, this._onStageMouseWheel);
			this.isOpen = false;
		}

		/**
		*表示选择的下拉列表项的索引。
		*/
		__getset(0, __proto, 'selectedIndex', function () {
			return this._selectedIndex;
		}, function (value) {
			if (this._selectedIndex != value) {
				this._selectedIndex = value;
				if (this._labels.length > 0) this.changeSelected();
				else this.callLater(this.changeSelected);
				this.event(/*laya.events.Event.CHANGE*/"change", [Event.EMPTY.setTo(/*laya.events.Event.CHANGE*/"change", this, this)]);
				this._selectHandler && this._selectHandler.runWith(this._selectedIndex);
			}
		});

		/**@inheritDoc */
		__getset(0, __proto, 'measureHeight', function () {
			return this._button.height;
		});

		/**
		*@copy laya.ui.Button#skin
		*/
		__getset(0, __proto, 'skin', function () {
			return this._button.skin;
		}, function (value) {
			if (this._button.skin != value) {
				this._button.skin = value;
				this._listChanged = true;
			}
		});

		/**@inheritDoc */
		__getset(0, __proto, 'measureWidth', function () {
			return this._button.width;
		});

		/**@inheritDoc */
		__getset(0, __proto, 'width', _super.prototype._$get_width, function (value) {
			Laya.superSet(Component, this, 'width', value);
			this._button.width = this._width;
			this._itemChanged = true;
			this._listChanged = true;
		});

		/**
		*表示选择的下拉列表项的的标签。
		*/
		__getset(0, __proto, 'selectedLabel', function () {
			return this._selectedIndex > -1 && this._selectedIndex < this._labels.length ? this._labels[this._selectedIndex] : null;
		}, function (value) {
			this.selectedIndex = this._labels.indexOf(value);
		});

		/**
		*标签集合字符串。
		*/
		__getset(0, __proto, 'labels', function () {
			return this._labels.join(",");
		}, function (value) {
			if (this._labels.length > 0) this.selectedIndex = -1;
			if (value) this._labels = value.split(",");
			else this._labels.length = 0;
			this._itemChanged = true;
		});

		/**@inheritDoc */
		__getset(0, __proto, 'height', _super.prototype._$get_height, function (value) {
			Laya.superSet(Component, this, 'height', value);
			this._button.height = this._height;
		});

		/**
		*改变下拉列表的选择项时执行的处理器(默认返回参数index:int)。
		*/
		__getset(0, __proto, 'selectHandler', function () {
			return this._selectHandler;
		}, function (value) {
			this._selectHandler = value;
		});

		/**
		*获取或设置没有滚动条的下拉列表中可显示的最大行数。
		*/
		__getset(0, __proto, 'visibleNum', function () {
			return this._visibleNum;
		}, function (value) {
			this._visibleNum = value;
			this._listChanged = true;
		});

		/**
		*表示按钮文本标签是否为粗体字。
		*@see laya.display.Text#bold
		*/
		__getset(0, __proto, 'labelBold', function () {
			return this._button.text.bold;
		}, function (value) {
			this._button.text.bold = value
		});

		/**
		*下拉列表项颜色。
		*<p><b>格式：</b>"悬停或被选中时背景颜色,悬停或被选中时标签颜色,标签颜色,边框颜色,背景颜色"</p>
		*/
		__getset(0, __proto, 'itemColors', function () {
			return String(this._itemColors)
		}, function (value) {
			this._itemColors = UIUtils.fillArray(this._itemColors, value, String);
			this._listChanged = true;
		});

		/**
		*下拉列表项标签的字体大小。
		*/
		__getset(0, __proto, 'itemSize', function () {
			return this._itemSize;
		}, function (value) {
			this._itemSize = value;
			this._listChanged = true;
		});

		/**
		*获取对 <code>ComboBox</code> 组件所包含的 <code>VScrollBar</code> 滚动条组件的引用。
		*/
		__getset(0, __proto, 'scrollBar', function () {
			return this.list.scrollBar;
		});

		/**
		*表示下拉列表的打开状态。
		*/
		__getset(0, __proto, 'isOpen', function () {
			return this._isOpen;
		}, function (value) {
			if (this._isOpen != value) {
				this._isOpen = value;
				this._button.selected = this._isOpen;
				if (this._isOpen) {
					this._list || this._createList();
					this._listChanged && !this._isCustomList && this.changeList();
					this._itemChanged && this.changeItem();
					var p = this.localToGlobal(Point.TEMP.setTo(0, 0));
					var py = p.y + this._button.height;
					py = py + this._listHeight <= Laya.stage.height ? py : p.y - this._listHeight;
					this._list.pos(p.x, py);
					this._list.zOrder = 1001;
					Laya._currentStage.addChild(this._list);
					Laya.stage.once(/*laya.events.Event.MOUSE_DOWN*/"mousedown", this, this.removeList);
					Laya.stage.on(/*laya.events.Event.MOUSE_WHEEL*/"mousewheel", this, this._onStageMouseWheel);
					this._list.selectedIndex = this._selectedIndex;
				} else {
					this._list && this._list.removeSelf();
				}
			}
		});

		/**
		*滚动条皮肤。
		*/
		__getset(0, __proto, 'scrollBarSkin', function () {
			return this._scrollBarSkin;
		}, function (value) {
			this._scrollBarSkin = value;
		});

		/**
		*<p>当前实例的位图 <code>AutoImage</code> 实例的有效缩放网格数据。</p>
		*<p>数据格式："上边距,右边距,下边距,左边距,是否重复填充(值为0：不重复填充，1：重复填充)"，以逗号分隔。
		*<ul><li>例如："4,4,4,4,1"</li></ul></p>
		*@see laya.ui.AutoBitmap.sizeGrid
		*/
		__getset(0, __proto, 'sizeGrid', function () {
			return this._button.sizeGrid;
		}, function (value) {
			this._button.sizeGrid = value;
		});

		/**
		*获取对 <code>ComboBox</code> 组件所包含的 <code>Button</code> 组件的引用。
		*/
		__getset(0, __proto, 'button', function () {
			return this._button;
		});

		/**
		*获取对 <code>ComboBox</code> 组件所包含的 <code>List</code> 列表组件的引用。
		*/
		__getset(0, __proto, 'list', function () {
			this._list || this._createList();
			return this._list;
		}, function (value) {
			if (value) {
				value.removeSelf();
				this._isCustomList = true;
				this._list = value;
				this._setListEvent(value);
				this._itemHeight = value.getCell(0).height + value.spaceY;
			}
		});

		/**@inheritDoc */
		__getset(0, __proto, 'dataSource', _super.prototype._$get_dataSource, function (value) {
			this._dataSource = value;
			if (((typeof value == 'number') && Math.floor(value) == value) || (typeof value == 'string')) this.selectedIndex = parseInt(value);
			else if ((value instanceof Array)) this.labels = (value).join(",");
			else Laya.superSet(Component, this, 'dataSource', value);
		});

		/**
		*获取或设置对 <code>ComboBox</code> 组件所包含的 <code>Button</code> 组件的文本标签颜色。
		*<p><b>格式：</b>upColor,overColor,downColor,disableColor</p>
		*/
		__getset(0, __proto, 'labelColors', function () {
			return this._button.labelColors;
		}, function (value) {
			if (this._button.labelColors != value) {
				this._button.labelColors = value;
			}
		});

		/**
		*获取或设置对 <code>ComboBox</code> 组件所包含的 <code>Button</code> 组件的文本边距。
		*<p><b>格式：</b>上边距,右边距,下边距,左边距</p>
		*/
		__getset(0, __proto, 'labelPadding', function () {
			return this._button.text.padding.join(",");
		}, function (value) {
			this._button.text.padding = UIUtils.fillArray(Styles.labelPadding, value, Number);
		});

		/**
		*获取或设置对 <code>ComboBox</code> 组件所包含的 <code>Button</code> 组件的标签字体大小。
		*/
		__getset(0, __proto, 'labelSize', function () {
			return this._button.text.fontSize;
		}, function (value) {
			this._button.text.fontSize = value
		});

		/**
		*表示按钮文本标签的字体名称，以字符串形式表示。
		*@see laya.display.Text#font
		*/
		__getset(0, __proto, 'labelFont', function () {
			return this._button.text.font;
		}, function (value) {
			this._button.text.font = value
		});

		/**
		*表示按钮的状态值。
		*@see laya.ui.Button#stateNum
		*/
		__getset(0, __proto, 'stateNum', function () {
			return this._button.stateNum;
		}, function (value) {
			this._button.stateNum = value
		});

		return ComboBox;
	})(Component)


	/**
	*<code>ScrollBar</code> 组件是一个滚动条组件。
	*<p>当数据太多以至于显示区域无法容纳时，最终用户可以使用 <code>ScrollBar</code> 组件控制所显示的数据部分。</p>
	*<p> 滚动条由四部分组成：两个箭头按钮、一个轨道和一个滑块。 </p> *
	*
	*@see laya.ui.VScrollBar
	*@see laya.ui.HScrollBar
	*/
	//class laya.ui.ScrollBar extends laya.ui.Component
	var ScrollBar = (function (_super) {
		function ScrollBar(skin) {
			/**滚动衰减系数*/
			this.rollRatio = 0.95;
			/**滚动变化时回调，回传value参数。*/
			this.changeHandler = null;
			/**是否缩放滑动条，默认值为true。 */
			this.scaleBar = true;
			/**一个布尔值，指定是否自动隐藏滚动条(无需滚动时)，默认值为false。*/
			this.autoHide = false;
			/**橡皮筋效果极限距离，0为没有橡皮筋效果。*/
			this.elasticDistance = 0;
			/**橡皮筋回弹时间，单位为毫秒。*/
			this.elasticBackTime = 500;
			/**上按钮 */
			this.upButton = null;
			/**下按钮 */
			this.downButton = null;
			/**滑条 */
			this.slider = null;
			/**@private */
			this._scrollSize = 1;
			/**@private */
			this._skin = null;
			/**@private */
			this._thumbPercent = 1;
			/**@private */
			this._target = null;
			/**@private */
			this._lastPoint = null;
			/**@private */
			this._lastOffset = 0;
			/**@private */
			this._checkElastic = false;
			/**@private */
			this._isElastic = false;
			/**@private */
			this._value = NaN;
			/**@private */
			this._hide = false;
			/**@private */
			this._clickOnly = true;
			/**@private */
			this._offsets = null;
			ScrollBar.__super.call(this);
			this._showButtons = UIConfig.showButtons;
			this._touchScrollEnable = UIConfig.touchScrollEnable;
			this._mouseWheelEnable = UIConfig.mouseWheelEnable;
			this.skin = skin;
			this.max = 1;
		}

		__class(ScrollBar, 'laya.ui.ScrollBar', _super);
		var __proto = ScrollBar.prototype;
		/**@inheritDoc */
		__proto.destroy = function (destroyChild) {
			(destroyChild === void 0) && (destroyChild = true);
			this.stopScroll();
			this.target = null;
			_super.prototype.destroy.call(this, destroyChild);
			this.upButton && this.upButton.destroy(destroyChild);
			this.downButton && this.downButton.destroy(destroyChild);
			this.slider && this.slider.destroy(destroyChild);
			this.upButton = this.downButton = null;
			this.slider = null;
			this.changeHandler = null;
			this._offsets = null;
		}

		/**@inheritDoc */
		__proto.createChildren = function () {
			this.addChild(this.slider = new Slider());
			this.addChild(this.upButton = new Button());
			this.addChild(this.downButton = new Button());
		}

		/**@inheritDoc */
		__proto.initialize = function () {
			this.slider.showLabel = false;
			this.slider.on(/*laya.events.Event.CHANGE*/"change", this, this.onSliderChange);
			this.slider.setSlider(0, 0, 0);
			this.upButton.on(/*laya.events.Event.MOUSE_DOWN*/"mousedown", this, this.onButtonMouseDown);
			this.downButton.on(/*laya.events.Event.MOUSE_DOWN*/"mousedown", this, this.onButtonMouseDown);
		}

		/**
		*@private
		*滑块位置发生改变的处理函数。
		*/
		__proto.onSliderChange = function () {
			if (this._value != this.slider.value) this.value = this.slider.value;
		}

		/**
		*@private
		*向上和向下按钮的 <code>Event.MOUSE_DOWN</code> 事件侦听处理函数。
		*/
		__proto.onButtonMouseDown = function (e) {
			var isUp = e.currentTarget === this.upButton;
			this.slide(isUp);
			Laya.timer.once(Styles.scrollBarDelayTime, this, this.startLoop, [isUp]);
			Laya.stage.once(/*laya.events.Event.MOUSE_UP*/"mouseup", this, this.onStageMouseUp);
		}

		/**@private */
		__proto.startLoop = function (isUp) {
			Laya.timer.frameLoop(1, this, this.slide, [isUp]);
		}

		/**@private */
		__proto.slide = function (isUp) {
			if (isUp) this.value -= this._scrollSize;
			else this.value += this._scrollSize;
		}

		/**
		*@private
		*舞台的 <code>Event.MOUSE_DOWN</code> 事件侦听处理函数。
		*/
		__proto.onStageMouseUp = function (e) {
			Laya.timer.clear(this, this.startLoop);
			Laya.timer.clear(this, this.slide);
		}

		/**
		*@private
		*更改对象的皮肤及位置。
		*/
		__proto.changeScrollBar = function () {
			this.upButton.visible = this._showButtons;
			this.downButton.visible = this._showButtons;
			if (this._showButtons) {
				this.upButton.skin = this._skin.replace(".png", "$up.png");
				this.downButton.skin = this._skin.replace(".png", "$down.png");
			}
			if (this.slider.isVertical) this.slider.y = this._showButtons ? this.upButton.height : 0;
			else this.slider.x = this._showButtons ? this.upButton.width : 0;
			this.resetPositions();
			this.repaint();
		}

		/**@inheritDoc */
		__proto.changeSize = function () {
			_super.prototype.changeSize.call(this);
			this.repaint();
			this.resetPositions();
			this.event(/*laya.events.Event.CHANGE*/"change");
			this.changeHandler && this.changeHandler.runWith(this.value);
		}

		/**@private */
		__proto.resetPositions = function () {
			if (this.slider.isVertical) this.slider.height = this.height - (this._showButtons ? (this.upButton.height + this.downButton.height) : 0);
			else this.slider.width = this.width - (this._showButtons ? (this.upButton.width + this.downButton.width) : 0);
			this.resetButtonPosition();
		}

		/**@private */
		__proto.resetButtonPosition = function () {
			if (this.slider.isVertical) this.downButton.y = this.slider.y + this.slider.height;
			else this.downButton.x = this.slider.x + this.slider.width;
		}

		/**
		*设置滚动条信息。
		*@param min 滚动条最小位置值。
		*@param max 滚动条最大位置值。
		*@param value 滚动条当前位置值。
		*/
		__proto.setScroll = function (min, max, value) {
			this.runCallLater(this.changeSize);
			this.slider.setSlider(min, max, value);
			this.slider.bar.visible = max > 0;
			if (!this._hide && this.autoHide) this.visible = false;
		}

		/**@private */
		__proto.onTargetMouseWheel = function (e) {
			this.value -= e.delta * this._scrollSize;
			this.target = this._target;
		}

		/**@private */
		__proto.onTargetMouseDown = function (e) {
			this._clickOnly = true;
			this._lastOffset = 0;
			this._checkElastic = false;
			this._lastPoint || (this._lastPoint = new Point());
			this._lastPoint.setTo(Laya.stage.mouseX, Laya.stage.mouseY);
			Laya.timer.clear(this, this.tweenMove);
			Tween.clearTween(this);
			Laya.stage.once(/*laya.events.Event.MOUSE_UP*/"mouseup", this, this.onStageMouseUp2);
			Laya.stage.once(/*laya.events.Event.MOUSE_OUT*/"mouseout", this, this.onStageMouseUp2);
			Laya.timer.frameLoop(1, this, this.loop);
		}

		/**@private */
		__proto.loop = function () {
			var mouseY = Laya.stage.mouseY;
			var mouseX = Laya.stage.mouseX;
			this._lastOffset = this.isVertical ? (mouseY - this._lastPoint.y) : (mouseX - this._lastPoint.x);
			if (this._clickOnly) {
				if (Math.abs(this._lastOffset * (this.isVertical ? Laya.stage._canvasTransform.getScaleY() : Laya.stage._canvasTransform.getScaleX())) > 1) {
					this._clickOnly = false;
					this._offsets || (this._offsets = []);
					this._offsets.length = 0;
					this._target.mouseEnabled = false;
					if (!this.hide && this.autoHide) {
						this.alpha = 1;
						this.visible = true;
					}
					this.event(/*laya.events.Event.START*/"start");
				} else return;
			}
			this._offsets.push(this._lastOffset);
			this._lastPoint.x = mouseX;
			this._lastPoint.y = mouseY;
			if (this._lastOffset === 0) return;
			if (!this._checkElastic) {
				if (this.elasticDistance > 0) {
					if (!this._checkElastic && this._lastOffset != 0) {
						if ((this._lastOffset > 0 && this._value <= this.min) || (this._lastOffset < 0 && this._value >= this.max)) {
							this._isElastic = true;
							this._checkElastic = true;
						} else {
							this._isElastic = false;
						}
					}
				} else {
					this._checkElastic = true;
				}
			}
			if (this._isElastic) {
				if (this._value <= this.min) {
					this.value -= this._lastOffset * Math.max(0, (1 - ((this.min - this._value) / this.elasticDistance)));
				} else if (this._value >= this.max) {
					this.value -= this._lastOffset * Math.max(0, (1 - ((this._value - this.max) / this.elasticDistance)));
				}
			} else {
				this.value -= this._lastOffset;
			}
		}

		/**@private */
		__proto.onStageMouseUp2 = function (e) {
			Laya.stage.off(/*laya.events.Event.MOUSE_UP*/"mouseup", this, this.onStageMouseUp2);
			Laya.stage.off(/*laya.events.Event.MOUSE_OUT*/"mouseout", this, this.onStageMouseUp2);
			Laya.timer.clear(this, this.loop);
			if (this._clickOnly) {
				if (this._value >= this.min && this._value <= this.max)
					return;
			}
			this._target.mouseEnabled = true;
			if (this._isElastic) {
				if (this._value < this.min) {
					Tween.to(this, { value: this.min }, this.elasticBackTime, Ease.sineOut, Handler.create(this, this.elasticOver));
				} else if (this._value > this.max) {
					Tween.to(this, { value: this.max }, this.elasticBackTime, Ease.sineOut, Handler.create(this, this.elasticOver));
				}
			} else {
				if (!this._offsets) return;
				if (this._offsets.length < 1) {
					this._offsets[0] = this.isVertical ? Laya.stage.mouseY - this._lastPoint.y : Laya.stage.mouseX - this._lastPoint.x;
				};
				var offset = 0;
				var n = Math.min(this._offsets.length, 3);
				for (var i = 0; i < n; i++) {
					offset += this._offsets[this._offsets.length - 1 - i];
				}
				this._lastOffset = offset / n;
				offset = Math.abs(this._lastOffset);
				if (offset < 2) {
					this.event(/*laya.events.Event.END*/"end");
					return;
				}
				if (offset > 60) this._lastOffset = this._lastOffset > 0 ? 60 : -60;
				var dis = Math.round(Math.abs(this.elasticDistance * (this._lastOffset / 240)));
				Laya.timer.frameLoop(1, this, this.tweenMove, [dis]);
			}
		}

		/**@private */
		__proto.elasticOver = function () {
			this._isElastic = false;
			if (!this.hide && this.autoHide) {
				Tween.to(this, { alpha: 0 }, 500);
			}
			this.event(/*laya.events.Event.END*/"end");
		}

		/**@private */
		__proto.tweenMove = function (maxDistance) {
			this._lastOffset *= this.rollRatio;
			var tarSpeed = NaN;
			if (maxDistance > 0) {
				if (this._lastOffset > 0 && this.value <= this.min) {
					this._isElastic = true;
					tarSpeed = -(this.min - maxDistance - this.value) * 0.5;
					if (this._lastOffset > tarSpeed) this._lastOffset = tarSpeed;
				} else if (this._lastOffset < 0 && this.value >= this.max) {
					this._isElastic = true;
					tarSpeed = -(this.max + maxDistance - this.value) * 0.5;
					if (this._lastOffset < tarSpeed) this._lastOffset = tarSpeed;
				}
			}
			this.value -= this._lastOffset;
			if (Math.abs(this._lastOffset) < 1) {
				Laya.timer.clear(this, this.tweenMove);
				if (this._isElastic) {
					if (this._value < this.min) {
						Tween.to(this, { value: this.min }, this.elasticBackTime, Ease.sineOut, Handler.create(this, this.elasticOver));
					} else if (this._value > this.max) {
						Tween.to(this, { value: this.max }, this.elasticBackTime, Ease.sineOut, Handler.create(this, this.elasticOver));
					} else {
						this.elasticOver();
					}
					return;
				}
				this.event(/*laya.events.Event.END*/"end");
				if (!this.hide && this.autoHide) {
					Tween.to(this, { alpha: 0 }, 500);
				}
			}
		}

		/**
		*停止滑动。
		*/
		__proto.stopScroll = function () {
			this.onStageMouseUp2(null);
			Laya.timer.clear(this, this.tweenMove);
			Tween.clearTween(this);
		}

		/**@inheritDoc */
		__getset(0, __proto, 'measureHeight', function () {
			if (this.slider.isVertical) return 100;
			return this.slider.height;
		});

		/**
		*@copy laya.ui.Image#skin
		*/
		__getset(0, __proto, 'skin', function () {
			return this._skin;
		}, function (value) {
			if (this._skin != value) {
				this._skin = value;
				this.slider.skin = this._skin;
				this.callLater(this.changeScrollBar);
			}
		});

		/**
		*获取或设置表示最高滚动位置的数字。
		*/
		__getset(0, __proto, 'max', function () {
			return this.slider.max;
		}, function (value) {
			this.slider.max = value;
		});

		/**一个布尔值，指定是否显示向上、向下按钮，默认值为true。*/
		__getset(0, __proto, 'showButtons', function () {
			return this._showButtons;
		}, function (value) {
			this._showButtons = value;
			this.callLater(this.changeScrollBar);
		});

		/**@inheritDoc */
		__getset(0, __proto, 'measureWidth', function () {
			if (this.slider.isVertical) return this.slider.width;
			return 100;
		});

		/**
		*获取或设置表示最低滚动位置的数字。
		*/
		__getset(0, __proto, 'min', function () {
			return this.slider.min;
		}, function (value) {
			this.slider.min = value;
		});

		/**
		*获取或设置表示当前滚动位置的数字。
		*/
		__getset(0, __proto, 'value', function () {
			return this._value;
		}, function (v) {
			if (v !== this._value) {
				this._value = v;
				if (!this._isElastic) {
					if (this.slider._value != v) {
						this.slider._value = v;
						this.slider.changeValue();
					}
					this._value = this.slider._value;
				}
				this.event(/*laya.events.Event.CHANGE*/"change");
				this.changeHandler && this.changeHandler.runWith(this._value);
			}
		});

		/**
		*一个布尔值，指示滚动条是否为垂直滚动。如果值为true，则为垂直滚动，否则为水平滚动。
		*<p>默认值为：true。</p>
		*/
		__getset(0, __proto, 'isVertical', function () {
			return this.slider.isVertical;
		}, function (value) {
			this.slider.isVertical = value;
		});

		/**
		*<p>当前实例的 <code>Slider</code> 实例的有效缩放网格数据。</p>
		*<p>数据格式："上边距,右边距,下边距,左边距,是否重复填充(值为0：不重复填充，1：重复填充)"，以逗号分隔。
		*<ul><li>例如："4,4,4,4,1"</li></ul></p>
		*@see laya.ui.AutoBitmap.sizeGrid
		*/
		__getset(0, __proto, 'sizeGrid', function () {
			return this.slider.sizeGrid;
		}, function (value) {
			this.slider.sizeGrid = value;
		});

		/**获取或设置一个值，该值表示按下滚动条轨道时页面滚动的增量。 */
		__getset(0, __proto, 'scrollSize', function () {
			return this._scrollSize;
		}, function (value) {
			this._scrollSize = value;
		});

		/**@inheritDoc */
		__getset(0, __proto, 'dataSource', _super.prototype._$get_dataSource, function (value) {
			this._dataSource = value;
			if ((typeof value == 'number') || (typeof value == 'string')) this.value = Number(value);
			else Laya.superSet(Component, this, 'dataSource', value);
		});

		/**获取或设置一个值，该值表示滑条长度比例，值为：（0-1）。 */
		__getset(0, __proto, 'thumbPercent', function () {
			return this._thumbPercent;
		}, function (value) {
			this.runCallLater(this.changeScrollBar);
			this.runCallLater(this.changeSize);
			value = value >= 1 ? 0.99 : value;
			this._thumbPercent = value;
			if (this.scaleBar) {
				if (this.slider.isVertical) this.slider.bar.height = Math.max(this.slider.height * value, Styles.scrollBarMinNum);
				else this.slider.bar.width = Math.max(this.slider.width * value, Styles.scrollBarMinNum);
			}
		});

		/**
		*设置滚动对象。
		*@see laya.ui.TouchScroll#target
		*/
		__getset(0, __proto, 'target', function () {
			return this._target;
		}, function (value) {
			if (this._target) {
				this._target.off(/*laya.events.Event.MOUSE_WHEEL*/"mousewheel", this, this.onTargetMouseWheel);
				this._target.off(/*laya.events.Event.MOUSE_DOWN*/"mousedown", this, this.onTargetMouseDown);
			}
			this._target = value;
			if (value) {
				this._mouseWheelEnable && this._target.on(/*laya.events.Event.MOUSE_WHEEL*/"mousewheel", this, this.onTargetMouseWheel);
				this._touchScrollEnable && this._target.on(/*laya.events.Event.MOUSE_DOWN*/"mousedown", this, this.onTargetMouseDown);
			}
		});

		/**是否隐藏滚动条，不显示滚动条，但是可以正常滚动，默认为false。*/
		__getset(0, __proto, 'hide', function () {
			return this._hide;
		}, function (value) {
			this._hide = value;
			this.visible = !value;
		});

		/**一个布尔值，指定是否开启触摸，默认值为true。*/
		__getset(0, __proto, 'touchScrollEnable', function () {
			return this._touchScrollEnable;
		}, function (value) {
			this._touchScrollEnable = value;
			this.target = this._target;
		});

		/**一个布尔值，指定是否滑轮滚动，默认值为true。*/
		__getset(0, __proto, 'mouseWheelEnable', function () {
			return this._mouseWheelEnable;
		}, function (value) {
			this._mouseWheelEnable = value;
		});

		/**
		*滚动的刻度值，滑动数值为tick的整数倍。默认值为1。
		*/
		__getset(0, __proto, 'tick', function () {
			return this.slider.tick;
		}, function (value) {
			this.slider.tick = value;
		});

		return ScrollBar;
	})(Component)


	/**
	*使用 <code>Slider</code> 控件，用户可以通过在滑块轨道的终点之间移动滑块来选择值。
	*<p>滑块的当前值由滑块端点（对应于滑块的最小值和最大值）之间滑块的相对位置确定。</p>
	*<p>滑块允许最小值和最大值之间特定间隔内的值。滑块还可以使用数据提示显示其当前值。</p>
	*
	*@see laya.ui.HSlider
	*@see laya.ui.VSlider
	*/
	//class laya.ui.Slider extends laya.ui.Component
	var Slider = (function (_super) {
		function Slider(skin) {
			/**
			*数据变化处理器。
			*<p>默认回调参数为滑块位置属性 <code>value</code>属性值：Number 。</p>
			*/
			this.changeHandler = null;
			/**
			*一个布尔值，指示是否为垂直滚动。如果值为true，则为垂直方向，否则为水平方向。
			*<p>默认值为：true。</p>
			*@default true
			*/
			this.isVertical = true;
			/**
			*一个布尔值，指示是否显示标签。
			*@default true
			*/
			this.showLabel = true;
			/**@private */
			this._allowClickBack = false;
			/**@private */
			this._max = 100;
			/**@private */
			this._min = 0;
			/**@private */
			this._tick = 1;
			/**@private */
			this._value = 0;
			/**@private */
			this._skin = null;
			/**@private */
			this._bg = null;
			/**@private */
			this._progress = null;
			/**@private */
			this._bar = null;
			/**@private */
			this._tx = NaN;
			/**@private */
			this._ty = NaN;
			/**@private */
			this._maxMove = NaN;
			/**@private */
			this._globalSacle = null;
			Slider.__super.call(this);
			this.skin = skin;
		}

		__class(Slider, 'laya.ui.Slider', _super);
		var __proto = Slider.prototype;
		/**
		*@inheritDoc
		*/
		__proto.destroy = function (destroyChild) {
			(destroyChild === void 0) && (destroyChild = true);
			_super.prototype.destroy.call(this, destroyChild);
			this._bg && this._bg.destroy(destroyChild);
			this._bar && this._bar.destroy(destroyChild);
			this._progress && this._progress.destroy(destroyChild);
			this._bg = null;
			this._bar = null;
			this._progress = null;
			this.changeHandler = null;
		}

		/**@inheritDoc */
		__proto.createChildren = function () {
			this.addChild(this._bg = new Image());
			this.addChild(this._bar = new Button());
		}

		/**@inheritDoc */
		__proto.initialize = function () {
			this._bar.on(/*laya.events.Event.MOUSE_DOWN*/"mousedown", this, this.onBarMouseDown);
			this._bg.sizeGrid = this._bar.sizeGrid = "4,4,4,4,0";
			if (this._progress) this._progress.sizeGrid = this._bar.sizeGrid;
			this.allowClickBack = true;
		}

		/**
		*@private
		*滑块的的 <code>Event.MOUSE_DOWN</code> 事件侦听处理函数。
		*/
		__proto.onBarMouseDown = function (e) {
			this._globalSacle || (this._globalSacle = new Point());
			this._globalSacle.setTo(this.globalScaleX || 0.01, this.globalScaleY || 0.01);
			this._maxMove = this.isVertical ? (this.height - this._bar.height) : (this.width - this._bar.width);
			this._tx = Laya.stage.mouseX;
			this._ty = Laya.stage.mouseY;
			Laya.stage.on(/*laya.events.Event.MOUSE_MOVE*/"mousemove", this, this.mouseMove);
			Laya.stage.once(/*laya.events.Event.MOUSE_UP*/"mouseup", this, this.mouseUp);
			Laya.stage.once(/*laya.events.Event.MOUSE_OUT*/"mouseout", this, this.mouseUp);
			this.showValueText();
		}

		/**
		*@private
		*显示标签。
		*/
		__proto.showValueText = function () {
			if (this.showLabel) {
				var label = laya.ui.Slider.label;
				this.addChild(label);
				label.textField.changeText(this._value + "");
				if (this.isVertical) {
					label.x = this._bar.x + 20;
					label.y = (this._bar.height - label.height) * 0.5 + this._bar.y;
				} else {
					label.y = this._bar.y - 20;
					label.x = (this._bar.width - label.width) * 0.5 + this._bar.x;
				}
			}
		}

		/**
		*@private
		*隐藏标签。
		*/
		__proto.hideValueText = function () {
			laya.ui.Slider.label && laya.ui.Slider.label.removeSelf();
		}

		/**
		*@private
		*/
		__proto.mouseUp = function (e) {
			Laya.stage.off(/*laya.events.Event.MOUSE_MOVE*/"mousemove", this, this.mouseMove);
			Laya.stage.off(/*laya.events.Event.MOUSE_UP*/"mouseup", this, this.mouseUp);
			Laya.stage.off(/*laya.events.Event.MOUSE_OUT*/"mouseout", this, this.mouseUp);
			this.sendChangeEvent(/*laya.events.Event.CHANGED*/"changed");
			this.hideValueText();
		}

		/**
		*@private
		*/
		__proto.mouseMove = function (e) {
			var oldValue = this._value;
			if (this.isVertical) {
				this._bar.y += (Laya.stage.mouseY - this._ty) / this._globalSacle.y;
				if (this._bar.y > this._maxMove) this._bar.y = this._maxMove;
				else if (this._bar.y < 0) this._bar.y = 0;
				this._value = this._bar.y / this._maxMove * (this._max - this._min) + this._min;
				if (this._progress) this._progress.height = this._bar.y + 0.5 * this._bar.height;
			} else {
				this._bar.x += (Laya.stage.mouseX - this._tx) / this._globalSacle.x;
				if (this._bar.x > this._maxMove) this._bar.x = this._maxMove;
				else if (this._bar.x < 0) this._bar.x = 0;
				this._value = this._bar.x / this._maxMove * (this._max - this._min) + this._min;
				if (this._progress) this._progress.width = this._bar.x + 0.5 * this._bar.width;
			}
			this._tx = Laya.stage.mouseX;
			this._ty = Laya.stage.mouseY;
			var pow = Math.pow(10, (this._tick + "").length - 1);
			this._value = Math.round(Math.round(this._value / this._tick) * this._tick * pow) / pow;
			if (this._value != oldValue) {
				this.sendChangeEvent();
			}
			this.showValueText();
		}

		/**
		*@private
		*/
		__proto.sendChangeEvent = function (type) {
			(type === void 0) && (type =/*laya.events.Event.CHANGE*/"change");
			this.event(type);
			this.changeHandler && this.changeHandler.runWith(this._value);
		}

		/**
		*@private
		*设置滑块的位置信息。
		*/
		__proto.setBarPoint = function () {
			if (this.isVertical) this._bar.x = Math.round((this._bg.width - this._bar.width) * 0.5);
			else this._bar.y = Math.round((this._bg.height - this._bar.height) * 0.5);
		}

		/**@inheritDoc */
		__proto.changeSize = function () {
			_super.prototype.changeSize.call(this);
			if (this.isVertical) this._bg.height = this.height;
			else this._bg.width = this.width;
			this.setBarPoint();
			this.changeValue();
		}

		/**
		*设置滑动条的信息。
		*@param min 滑块的最小值。
		*@param max 滑块的最小值。
		*@param value 滑块的当前值。
		*/
		__proto.setSlider = function (min, max, value) {
			this._value = -1;
			this._min = min;
			this._max = max > min ? max : min;
			this.value = value < min ? min : value > max ? max : value;
		}

		/**
		*@private
		*改变滑块的位置值。
		*/
		__proto.changeValue = function () {
			var pow = Math.pow(10, (this._tick + "").length - 1);
			this._value = Math.round(Math.round(this._value / this._tick) * this._tick * pow) / pow;
			this._value = this._value > this._max ? this._max : this._value < this._min ? this._min : this._value;
			var num = this._max - this._min;
			if (num === 0) num = 1;
			if (this.isVertical) {
				this._bar.y = (this._value - this._min) / num * (this.height - this._bar.height);
				if (this._progress) this._progress.height = this._bar.y + 0.5 * this._bar.height;
			}
			else {
				this._bar.x = (this._value - this._min) / num * (this.width - this._bar.width);
				if (this._progress) this._progress.width = this._bar.x + 0.5 * this._bar.width;
			}
		}

		/**
		*@private
		*滑动条的 <code>Event.MOUSE_DOWN</code> 事件侦听处理函数。
		*/
		__proto.onBgMouseDown = function (e) {
			var point = this._bg.getMousePoint();
			if (this.isVertical) this.value = point.y / (this.height - this._bar.height) * (this._max - this._min) + this._min;
			else this.value = point.x / (this.width - this._bar.width) * (this._max - this._min) + this._min;
		}

		/**@inheritDoc */
		__getset(0, __proto, 'measureHeight', function () {
			return Math.max(this._bg.height, this._bar.height);
		});

		/**
		*@copy laya.ui.Image#skin
		*/
		__getset(0, __proto, 'skin', function () {
			return this._skin;
		}, function (value) {
			if (this._skin != value) {
				this._skin = value;
				this._bg.skin = this._skin;
				this._bar.skin = this._skin.replace(".png", "$bar.png");
				var progressSkin = this._skin.replace(".png", "$progress.png");
				if (Loader.getRes(progressSkin)) {
					if (!this._progress) {
						this.addChild(this._progress = new Image());
						this._progress.sizeGrid = this._bar.sizeGrid;
						this.setChildIndex(this._progress, 1);
					}
					this._progress.skin = progressSkin;
				}
				this.setBarPoint();
				this.callLater(this.changeValue);
			}
		});

		/**
		*一个布尔值，指定是否允许通过点击滑动条改变 <code>Slider</code> 的 <code>value</code> 属性值。
		*/
		__getset(0, __proto, 'allowClickBack', function () {
			return this._allowClickBack;
		}, function (value) {
			if (this._allowClickBack != value) {
				this._allowClickBack = value;
				if (value) this._bg.on(/*laya.events.Event.MOUSE_DOWN*/"mousedown", this, this.onBgMouseDown);
				else this._bg.off(/*laya.events.Event.MOUSE_DOWN*/"mousedown", this, this.onBgMouseDown);
			}
		});

		/**
		*获取或设置表示最高位置的数字。 默认值为100。
		*/
		__getset(0, __proto, 'max', function () {
			return this._max;
		}, function (value) {
			if (this._max != value) {
				this._max = value;
				this.callLater(this.changeValue);
			}
		});

		/**@inheritDoc */
		__getset(0, __proto, 'measureWidth', function () {
			return Math.max(this._bg.width, this._bar.width);
		});

		/**
		*滑动的刻度值，滑动数值为tick的整数倍。默认值为1。
		*/
		__getset(0, __proto, 'tick', function () {
			return this._tick;
		}, function (value) {
			if (this._tick != value) {
				this._tick = value;
				this.callLater(this.changeValue);
			}
		});

		/**
		*<p>当前实例的背景图（ <code>Image</code> ）和滑块按钮（ <code>Button</code> ）实例的有效缩放网格数据。</p>
		*<p>数据格式："上边距,右边距,下边距,左边距,是否重复填充(值为0：不重复填充，1：重复填充)"，以逗号分隔。
		*<ul><li>例如："4,4,4,4,1"</li></ul></p>
		*@see laya.ui.AutoBitmap.sizeGrid
		*/
		__getset(0, __proto, 'sizeGrid', function () {
			return this._bg.sizeGrid;
		}, function (value) {
			this._bg.sizeGrid = value;
			this._bar.sizeGrid = value;
			if (this._progress) this._progress.sizeGrid = this._bar.sizeGrid;
		});

		/**
		*获取或设置表示最低位置的数字。 默认值为0。
		*/
		__getset(0, __proto, 'min', function () {
			return this._min;
		}, function (value) {
			if (this._min != value) {
				this._min = value;
				this.callLater(this.changeValue);
			}
		});

		/**
		*获取或设置表示当前滑块位置的数字。
		*/
		__getset(0, __proto, 'value', function () {
			return this._value;
		}, function (num) {
			if (this._value != num) {
				var oldValue = this._value;
				this._value = num;
				this.changeValue();
				if (this._value != oldValue) {
					this.sendChangeEvent();
				}
			}
		});

		/**@inheritDoc */
		__getset(0, __proto, 'dataSource', _super.prototype._$get_dataSource, function (value) {
			this._dataSource = value;
			if ((typeof value == 'number') || (typeof value == 'string')) this.value = Number(value);
			else Laya.superSet(Component, this, 'dataSource', value);
		});

		/**
		*表示滑块按钮的引用。
		*/
		__getset(0, __proto, 'bar', function () {
			return this._bar;
		});

		__static(Slider,
			['label', function () { return this.label = new Label(); }
			]);
		return Slider;
	})(Component)


	/**
	*<code>Image</code> 类是用于表示位图图像或绘制图形的显示对象。
	*Image和Clip组件是唯一支持异步加载的两个组件，比如img.skin="abc/xxx.png"，其他UI组件均不支持异步加载。
	*
	*@example <caption>以下示例代码，创建了一个新的 <code>Image</code> 实例，设置了它的皮肤、位置信息，并添加到舞台上。</caption>
	*package
	*{
		*import laya.ui.Image;
		*public class Image_Example
		*{
			*public function Image_Example()
			*{
				*Laya.init(640,800);//设置游戏画布宽高。
				*Laya.stage.bgColor="#efefef";//设置画布的背景颜色。
				*onInit();
				*}
			*private function onInit():void
			*{
				*var bg:Image=new Image("resource/ui/bg.png");//创建一个 Image 类的实例对象 bg ,并传入它的皮肤。
				*bg.x=100;//设置 bg 对象的属性 x 的值，用于控制 bg 对象的显示位置。
				*bg.y=100;//设置 bg 对象的属性 y 的值，用于控制 bg 对象的显示位置。
				*bg.sizeGrid="40,10,5,10";//设置 bg 对象的网格信息。
				*bg.width=150;//设置 bg 对象的宽度。
				*bg.height=250;//设置 bg 对象的高度。
				*Laya.stage.addChild(bg);//将此 bg 对象添加到显示列表。
				*var image:Image=new Image("resource/ui/image.png");//创建一个 Image 类的实例对象 image ,并传入它的皮肤。
				*image.x=100;//设置 image 对象的属性 x 的值，用于控制 image 对象的显示位置。
				*image.y=100;//设置 image 对象的属性 y 的值，用于控制 image 对象的显示位置。
				*Laya.stage.addChild(image);//将此 image 对象添加到显示列表。
				*}
			*}
		*}
	*@example
	*Laya.init(640,800);//设置游戏画布宽高
	*Laya.stage.bgColor="#efefef";//设置画布的背景颜色
	*onInit();
	*function onInit(){
		*var bg=new laya.ui.Image("resource/ui/bg.png");//创建一个 Image 类的实例对象 bg ,并传入它的皮肤。
		*bg.x=100;//设置 bg 对象的属性 x 的值，用于控制 bg 对象的显示位置。
		*bg.y=100;//设置 bg 对象的属性 y 的值，用于控制 bg 对象的显示位置。
		*bg.sizeGrid="40,10,5,10";//设置 bg 对象的网格信息。
		*bg.width=150;//设置 bg 对象的宽度。
		*bg.height=250;//设置 bg 对象的高度。
		*Laya.stage.addChild(bg);//将此 bg 对象添加到显示列表。
		*var image=new laya.ui.Image("resource/ui/image.png");//创建一个 Image 类的实例对象 image ,并传入它的皮肤。
		*image.x=100;//设置 image 对象的属性 x 的值，用于控制 image 对象的显示位置。
		*image.y=100;//设置 image 对象的属性 y 的值，用于控制 image 对象的显示位置。
		*Laya.stage.addChild(image);//将此 image 对象添加到显示列表。
		*}
	*@example
	*class Image_Example {
		*constructor(){
			*Laya.init(640,800);//设置游戏画布宽高。
			*Laya.stage.bgColor="#efefef";//设置画布的背景颜色。
			*this.onInit();
			*}
		*private onInit():void {
			*var bg:laya.ui.Image=new laya.ui.Image("resource/ui/bg.png");//创建一个 Image 类的实例对象 bg ,并传入它的皮肤。
			*bg.x=100;//设置 bg 对象的属性 x 的值，用于控制 bg 对象的显示位置。
			*bg.y=100;//设置 bg 对象的属性 y 的值，用于控制 bg 对象的显示位置。
			*bg.sizeGrid="40,10,5,10";//设置 bg 对象的网格信息。
			*bg.width=150;//设置 bg 对象的宽度。
			*bg.height=250;//设置 bg 对象的高度。
			*Laya.stage.addChild(bg);//将此 bg 对象添加到显示列表。
			*var image:laya.ui.Image=new laya.ui.Image("resource/ui/image.png");//创建一个 Image 类的实例对象 image ,并传入它的皮肤。
			*image.x=100;//设置 image 对象的属性 x 的值，用于控制 image 对象的显示位置。
			*image.y=100;//设置 image 对象的属性 y 的值，用于控制 image 对象的显示位置。
			*Laya.stage.addChild(image);//将此 image 对象添加到显示列表。
			*}
		*}
	*@see laya.ui.AutoBitmap
	*/
	//class laya.ui.Image extends laya.ui.Component
	var Image = (function (_super) {
		function Image(skin) {
			/**@private */
			this._bitmap = null;
			/**@private */
			this._skin = null;
			/**@private */
			this._group = null;
			Image.__super.call(this);
			this.skin = skin;
		}

		__class(Image, 'laya.ui.Image', _super);
		var __proto = Image.prototype;
		/**@inheritDoc */
		__proto.destroy = function (destroyChild) {
			(destroyChild === void 0) && (destroyChild = true);
			_super.prototype.destroy.call(this, true);
			this._bitmap && this._bitmap.destroy();
			this._bitmap = null;
		}

		/**
		*销毁对象并释放加载的皮肤资源。
		*/
		__proto.dispose = function () {
			this.destroy(true);
			Laya.loader.clearRes(this._skin);
		}

		/**@inheritDoc */
		__proto.createChildren = function () {
			this.graphics = this._bitmap = new AutoBitmap();
			this._bitmap.autoCacheCmd = false;
		}

		/**
		*@private
		*设置皮肤资源。
		*/
		__proto.setSource = function (url, img) {
			if (url === this._skin && img) {
				this.source = img
				this.onCompResize();
			}
		}

		/**
		*@copy laya.ui.AutoBitmap#source
		*/
		__getset(0, __proto, 'source', function () {
			return this._bitmap.source;
		}, function (value) {
			if (!this._bitmap) return;
			this._bitmap.source = value;
			this.event(/*laya.events.Event.LOADED*/"loaded");
			this.repaint();
		});

		/**@inheritDoc */
		__getset(0, __proto, 'dataSource', _super.prototype._$get_dataSource, function (value) {
			this._dataSource = value;
			if ((typeof value == 'string')) this.skin = value;
			else Laya.superSet(Component, this, 'dataSource', value);
		});

		/**@inheritDoc */
		__getset(0, __proto, 'measureHeight', function () {
			return this._bitmap.height;
		});

		/**
		*<p>对象的皮肤地址，以字符串表示。</p>
		*<p>如果资源未加载，则先加载资源，加载完成后应用于此对象。</p>
		*<b>注意：</b>资源加载完成后，会自动缓存至资源库中。
		*/
		__getset(0, __proto, 'skin', function () {
			return this._skin;
		}, function (value) {
			if (this._skin != value) {
				this._skin = value;
				if (value) {
					var source = Loader.getRes(value);
					if (source) {
						this.source = source;
						this.onCompResize();
					} else Laya.loader.load(this._skin, Handler.create(this, this.setSource, [this._skin]), null,/*laya.net.Loader.IMAGE*/"image", 1, true, this._group);
				} else {
					this.source = null;
				}
			}
		});

		/**
		*资源分组。
		*/
		__getset(0, __proto, 'group', function () {
			return this._group;
		}, function (value) {
			if (value && this._skin) Loader.setGroup(this._skin, value);
			this._group = value;
		});

		/**
		*<p>当前实例的位图 <code>AutoImage</code> 实例的有效缩放网格数据。</p>
		*<p>数据格式："上边距,右边距,下边距,左边距,是否重复填充(值为0：不重复填充，1：重复填充)"，以逗号分隔。
		*<ul><li>例如："4,4,4,4,1"。</li></ul></p>
		*@see laya.ui.AutoBitmap#sizeGrid
		*/
		__getset(0, __proto, 'sizeGrid', function () {
			if (this._bitmap.sizeGrid) return this._bitmap.sizeGrid.join(",");
			return null;
		}, function (value) {
			this._bitmap.sizeGrid = UIUtils.fillArray(Styles.defaultSizeGrid, value, Number);
		});

		/**@inheritDoc */
		__getset(0, __proto, 'measureWidth', function () {
			return this._bitmap.width;
		});

		/**@inheritDoc */
		__getset(0, __proto, 'width', _super.prototype._$get_width, function (value) {
			Laya.superSet(Component, this, 'width', value);
			this._bitmap.width = value == 0 ? 0.0000001 : value;
		});

		/**@inheritDoc */
		__getset(0, __proto, 'height', _super.prototype._$get_height, function (value) {
			Laya.superSet(Component, this, 'height', value);
			this._bitmap.height = value == 0 ? 0.0000001 : value;
		});

		return Image;
	})(Component)


	/**
	*<p> <code>Label</code> 类用于创建显示对象以显示文本。</p>
	*
	*@example <caption>以下示例代码，创建了一个 <code>Label</code> 实例。</caption>
	*package
	*{
		*import laya.ui.Label;
		*public class Label_Example
		*{
			*public function Label_Example()
			*{
				*Laya.init(640,800);//设置游戏画布宽高、渲染模式。
				*Laya.stage.bgColor="#efefef";//设置画布的背景颜色。
				*onInit();
				*}
			*private function onInit():void
			*{
				*var label:Label=new Label();//创建一个 Label 类的实例对象 label 。
				*label.font="Arial";//设置 label 的字体。
				*label.bold=true;//设置 label 显示为粗体。
				*label.leading=4;//设置 label 的行间距。
				*label.wordWrap=true;//设置 label 自动换行。
				*label.padding="10,10,10,10";//设置 label 的边距。
				*label.color="#ff00ff";//设置 label 的颜色。
				*label.text="Hello everyone,我是一个可爱的文本！";//设置 label 的文本内容。
				*label.x=100;//设置 label 对象的属性 x 的值，用于控制 label 对象的显示位置。
				*label.y=100;//设置 label 对象的属性 y 的值，用于控制 label 对象的显示位置。
				*label.width=300;//设置 label 的宽度。
				*label.height=200;//设置 label 的高度。
				*Laya.stage.addChild(label);//将 label 添加到显示列表。
				*var passwordLabel:Label=new Label("请原谅我，我不想被人看到我心里话。");//创建一个 Label 类的实例对象 passwordLabel 。
				*passwordLabel.asPassword=true;//设置 passwordLabel 的显示反式为密码显示。
				*passwordLabel.x=100;//设置 passwordLabel 对象的属性 x 的值，用于控制 passwordLabel 对象的显示位置。
				*passwordLabel.y=350;//设置 passwordLabel 对象的属性 y 的值，用于控制 passwordLabel 对象的显示位置。
				*passwordLabel.width=300;//设置 passwordLabel 的宽度。
				*passwordLabel.color="#000000";//设置 passwordLabel 的文本颜色。
				*passwordLabel.bgColor="#ccffff";//设置 passwordLabel 的背景颜色。
				*passwordLabel.fontSize=20;//设置 passwordLabel 的文本字体大小。
				*Laya.stage.addChild(passwordLabel);//将 passwordLabel 添加到显示列表。
				*}
			*}
		*}
	*@example
	*Laya.init(640,800);//设置游戏画布宽高
	*Laya.stage.bgColor="#efefef";//设置画布的背景颜色
	*onInit();
	*function onInit(){
		*var label=new laya.ui.Label();//创建一个 Label 类的实例对象 label 。
		*label.font="Arial";//设置 label 的字体。
		*label.bold=true;//设置 label 显示为粗体。
		*label.leading=4;//设置 label 的行间距。
		*label.wordWrap=true;//设置 label 自动换行。
		*label.padding="10,10,10,10";//设置 label 的边距。
		*label.color="#ff00ff";//设置 label 的颜色。
		*label.text="Hello everyone,我是一个可爱的文本！";//设置 label 的文本内容。
		*label.x=100;//设置 label 对象的属性 x 的值，用于控制 label 对象的显示位置。
		*label.y=100;//设置 label 对象的属性 y 的值，用于控制 label 对象的显示位置。
		*label.width=300;//设置 label 的宽度。
		*label.height=200;//设置 label 的高度。
		*Laya.stage.addChild(label);//将 label 添加到显示列表。
		*var passwordLabel=new laya.ui.Label("请原谅我，我不想被人看到我心里话。");//创建一个 Label 类的实例对象 passwordLabel 。
		*passwordLabel.asPassword=true;//设置 passwordLabel 的显示反式为密码显示。
		*passwordLabel.x=100;//设置 passwordLabel 对象的属性 x 的值，用于控制 passwordLabel 对象的显示位置。
		*passwordLabel.y=350;//设置 passwordLabel 对象的属性 y 的值，用于控制 passwordLabel 对象的显示位置。
		*passwordLabel.width=300;//设置 passwordLabel 的宽度。
		*passwordLabel.color="#000000";//设置 passwordLabel 的文本颜色。
		*passwordLabel.bgColor="#ccffff";//设置 passwordLabel 的背景颜色。
		*passwordLabel.fontSize=20;//设置 passwordLabel 的文本字体大小。
		*Laya.stage.addChild(passwordLabel);//将 passwordLabel 添加到显示列表。
		*}
	*@example
	*import Label=laya.ui.Label;
	*class Label_Example {
		*constructor(){
			*Laya.init(640,800);//设置游戏画布宽高。
			*Laya.stage.bgColor="#efefef";//设置画布的背景颜色。
			*this.onInit();
			*}
		*private onInit():void {
			*var label:Label=new Label();//创建一个 Label 类的实例对象 label 。
			*label.font="Arial";//设置 label 的字体。
			*label.bold=true;//设置 label 显示为粗体。
			*label.leading=4;//设置 label 的行间距。
			*label.wordWrap=true;//设置 label 自动换行。
			*label.padding="10,10,10,10";//设置 label 的边距。
			*label.color="#ff00ff";//设置 label 的颜色。
			*label.text="Hello everyone,我是一个可爱的文本！";//设置 label 的文本内容。
			*label.x=100;//设置 label 对象的属性 x 的值，用于控制 label 对象的显示位置。
			*label.y=100;//设置 label 对象的属性 y 的值，用于控制 label 对象的显示位置。
			*label.width=300;//设置 label 的宽度。
			*label.height=200;//设置 label 的高度。
			*Laya.stage.addChild(label);//将 label 添加到显示列表。
			*var passwordLabel:Label=new Label("请原谅我，我不想被人看到我心里话。");//创建一个 Label 类的实例对象 passwordLabel 。
			*passwordLabel.asPassword=true;//设置 passwordLabel 的显示反式为密码显示。
			*passwordLabel.x=100;//设置 passwordLabel 对象的属性 x 的值，用于控制 passwordLabel 对象的显示位置。
			*passwordLabel.y=350;//设置 passwordLabel 对象的属性 y 的值，用于控制 passwordLabel 对象的显示位置。
			*passwordLabel.width=300;//设置 passwordLabel 的宽度。
			*passwordLabel.color="#000000";//设置 passwordLabel 的文本颜色。
			*passwordLabel.bgColor="#ccffff";//设置 passwordLabel 的背景颜色。
			*passwordLabel.fontSize=20;//设置 passwordLabel 的文本字体大小。
			*Laya.stage.addChild(passwordLabel);//将 passwordLabel 添加到显示列表。
			*}
		*}
	*@see laya.display.Text
	*/
	//class laya.ui.Label extends laya.ui.Component
	var Label = (function (_super) {
		function Label(text) {
			/**
			*@private
			*文本 <code>Text</code> 实例。
			*/
			this._tf = null;
			Label.__super.call(this);
			(text === void 0) && (text = "");
			Font.defaultColor = Styles.labelColor;
			this.text = text;
		}

		__class(Label, 'laya.ui.Label', _super);
		var __proto = Label.prototype;
		/**@inheritDoc */
		__proto.destroy = function (destroyChild) {
			(destroyChild === void 0) && (destroyChild = true);
			_super.prototype.destroy.call(this, destroyChild);
			this._tf = null;
		}

		/**@inheritDoc */
		__proto.createChildren = function () {
			this.addChild(this._tf = new Text());
		}

		/**@copy laya.display.Text#changeText()
		**/
		__proto.changeText = function (text) {
			this._tf.changeText(text);
		}

		/**
		*<p>边距信息</p>
		*<p>"上边距，右边距，下边距 , 左边距（边距以像素为单位）"</p>
		*@see laya.display.Text.padding
		*/
		__getset(0, __proto, 'padding', function () {
			return this._tf.padding.join(",");
		}, function (value) {
			this._tf.padding = UIUtils.fillArray(Styles.labelPadding, value, Number);
		});

		/**
		*@copy laya.display.Text#bold
		*/
		__getset(0, __proto, 'bold', function () {
			return this._tf.bold;
		}, function (value) {
			this._tf.bold = value;
		});

		/**
		*@copy laya.display.Text#align
		*/
		__getset(0, __proto, 'align', function () {
			return this._tf.align;
		}, function (value) {
			this._tf.align = value;
		});

		/**
		*当前文本内容字符串。
		*@see laya.display.Text.text
		*/
		__getset(0, __proto, 'text', function () {
			return this._tf.text;
		}, function (value) {
			if (this._tf.text != value) {
				if (value)
					value = UIUtils.adptString(value + "");
				this._tf.text = value;
				this.event(/*laya.events.Event.CHANGE*/"change");
				if (!this._width || !this._height) this.onCompResize();
			}
		});

		/**
		*@copy laya.display.Text#italic
		*/
		__getset(0, __proto, 'italic', function () {
			return this._tf.italic;
		}, function (value) {
			this._tf.italic = value;
		});

		/**
		*@copy laya.display.Text#wordWrap
		*/
		/**
		*@copy laya.display.Text#wordWrap
		*/
		__getset(0, __proto, 'wordWrap', function () {
			return this._tf.wordWrap;
		}, function (value) {
			this._tf.wordWrap = value;
		});

		/**
		*@copy laya.display.Text#font
		*/
		__getset(0, __proto, 'font', function () {
			return this._tf.font;
		}, function (value) {
			this._tf.font = value;
		});

		/**@inheritDoc */
		__getset(0, __proto, 'dataSource', _super.prototype._$get_dataSource, function (value) {
			this._dataSource = value;
			if ((typeof value == 'number') || (typeof value == 'string')) this.text = value + "";
			else Laya.superSet(Component, this, 'dataSource', value);
		});

		/**
		*@copy laya.display.Text#color
		*/
		__getset(0, __proto, 'color', function () {
			return this._tf.color;
		}, function (value) {
			this._tf.color = value;
		});

		/**
		*@copy laya.display.Text#valign
		*/
		__getset(0, __proto, 'valign', function () {
			return this._tf.valign;
		}, function (value) {
			this._tf.valign = value;
		});

		/**
		*@copy laya.display.Text#leading
		*/
		__getset(0, __proto, 'leading', function () {
			return this._tf.leading;
		}, function (value) {
			this._tf.leading = value;
		});

		/**
		*@copy laya.display.Text#fontSize
		*/
		__getset(0, __proto, 'fontSize', function () {
			return this._tf.fontSize;
		}, function (value) {
			this._tf.fontSize = value;
		});

		/**
		*@copy laya.display.Text#bgColor
		*/
		__getset(0, __proto, 'bgColor', function () {
			return this._tf.bgColor
		}, function (value) {
			this._tf.bgColor = value;
		});

		/**
		*@copy laya.display.Text#borderColor
		*/
		__getset(0, __proto, 'borderColor', function () {
			return this._tf.borderColor
		}, function (value) {
			this._tf.borderColor = value;
		});

		/**
		*@copy laya.display.Text#stroke
		*/
		__getset(0, __proto, 'stroke', function () {
			return this._tf.stroke;
		}, function (value) {
			this._tf.stroke = value;
		});

		/**
		*@copy laya.display.Text#strokeColor
		*/
		__getset(0, __proto, 'strokeColor', function () {
			return this._tf.strokeColor;
		}, function (value) {
			this._tf.strokeColor = value;
		});

		/**
		*文本控件实体 <code>Text</code> 实例。
		*/
		__getset(0, __proto, 'textField', function () {
			return this._tf;
		});

		/**
		*@inheritDoc
		*/
		__getset(0, __proto, 'measureWidth', function () {
			return this._tf.width;
		});

		/**
		*@inheritDoc
		*/
		__getset(0, __proto, 'measureHeight', function () {
			return this._tf.height;
		});

		/**
		*@inheritDoc
		*/
		/**
		*@inheritDoc
		*/
		__getset(0, __proto, 'width', function () {
			if (this._width || this._tf.text) return Laya.superGet(Component, this, 'width');
			return 0;
		}, function (value) {
			Laya.superSet(Component, this, 'width', value);
			this._tf.width = value;
		});

		/**
		*@inheritDoc
		*/
		/**
		*@inheritDoc
		*/
		__getset(0, __proto, 'height', function () {
			if (this._height || this._tf.text) return Laya.superGet(Component, this, 'height');
			return 0;
		}, function (value) {
			Laya.superSet(Component, this, 'height', value);
			this._tf.height = value;
		});

		/**
		*@copy laya.display.Text#overflow
		*/
		/**
		*@copy laya.display.Text#overflow
		*/
		__getset(0, __proto, 'overflow', function () {
			return this._tf.overflow;
		}, function (value) {
			this._tf.overflow = value;
		});

		/**
		*@copy laya.display.Text#underline
		*/
		/**
		*@copy laya.display.Text#underline
		*/
		__getset(0, __proto, 'underline', function () {
			return this._tf.underline;
		}, function (value) {
			this._tf.underline = value;
		});

		/**
		*@copy laya.display.Text#underlineColor
		*/
		/**
		*@copy laya.display.Text#underlineColor
		*/
		__getset(0, __proto, 'underlineColor', function () {
			return this._tf.underlineColor;
		}, function (value) {
			this._tf.underlineColor = value;
		});

		return Label;
	})(Component)


	/**
	*<code>ProgressBar</code> 组件显示内容的加载进度。
	*@example <caption>以下示例代码，创建了一个新的 <code>ProgressBar</code> 实例，设置了它的皮肤、位置、宽高、网格等信息，并添加到舞台上。</caption>
	*package
	*{
		*import laya.ui.ProgressBar;
		*import laya.utils.Handler;
		*public class ProgressBar_Example
		*{
			*private var progressBar:ProgressBar;
			*public function ProgressBar_Example()
			*{
				*Laya.init(640,800);//设置游戏画布宽高。
				*Laya.stage.bgColor="#efefef";//设置画布的背景颜色。
				*Laya.loader.load(["resource/ui/progress.png","resource/ui/progress$bar.png"],Handler.create(this,onLoadComplete));//加载资源。
				*}
			*private function onLoadComplete():void
			*{
				*progressBar=new ProgressBar("resource/ui/progress.png");//创建一个 ProgressBar 类的实例对象 progressBar 。
				*progressBar.x=100;//设置 progressBar 对象的属性 x 的值，用于控制 progressBar 对象的显示位置。
				*progressBar.y=100;//设置 progressBar 对象的属性 y 的值，用于控制 progressBar 对象的显示位置。
				*progressBar.value=0.3;//设置 progressBar 的进度值。
				*progressBar.width=200;//设置 progressBar 的宽度。
				*progressBar.height=50;//设置 progressBar 的高度。
				*progressBar.sizeGrid="5,10,5,10";//设置 progressBar 的网格信息。
				*progressBar.changeHandler=new Handler(this,onChange);//设置 progressBar 的value值改变时执行的处理器。
				*Laya.stage.addChild(progressBar);//将 progressBar 添加到显示列表。
				*Laya.timer.once(3000,this,changeValue);//设定 3000ms（毫秒）后，执行函数changeValue。
				*}
			*private function changeValue():void
			*{
				*trace("改变进度条的进度值。");
				*progressBar.value=0.6;
				*}
			*private function onChange(value:Number):void
			*{
				*trace("进度发生改变： value=" ,value);
				*}
			*}
		*}
	*@example
	*Laya.init(640,800);//设置游戏画布宽高
	*Laya.stage.bgColor="#efefef";//设置画布的背景颜色
	*var res=["resource/ui/progress.png","resource/ui/progress$bar.png"];
	*Laya.loader.load(res,laya.utils.Handler.create(this,onLoadComplete));//加载资源。
	*function onLoadComplete()
	*{
		*progressBar=new laya.ui.ProgressBar("resource/ui/progress.png");//创建一个 ProgressBar 类的实例对象 progressBar 。
		*progressBar.x=100;//设置 progressBar 对象的属性 x 的值，用于控制 progressBar 对象的显示位置。
		*progressBar.y=100;//设置 progressBar 对象的属性 y 的值，用于控制 progressBar 对象的显示位置。
		*progressBar.value=0.3;//设置 progressBar 的进度值。
		*progressBar.width=200;//设置 progressBar 的宽度。
		*progressBar.height=50;//设置 progressBar 的高度。
		*progressBar.sizeGrid="10,5,10,5";//设置 progressBar 的网格信息。
		*progressBar.changeHandler=new laya.utils.Handler(this,onChange);//设置 progressBar 的value值改变时执行的处理器。
		*Laya.stage.addChild(progressBar);//将 progressBar 添加到显示列表。
		*Laya.timer.once(3000,this,changeValue);//设定 3000ms（毫秒）后，执行函数changeValue。
		*}
	*function changeValue()
	*{
		*console.log("改变进度条的进度值。");
		*progressBar.value=0.6;
		*}
	*function onChange(value)
	*{
		*console.log("进度发生改变： value=" ,value);
		*}
	*@example
	*import ProgressBar=laya.ui.ProgressBar;
	*import Handler=laya.utils.Handler;
	*class ProgressBar_Example {
		*private progressBar:ProgressBar;
		*public ProgressBar_Example(){
			*Laya.init(640,800);//设置游戏画布宽高。
			*Laya.stage.bgColor="#efefef";//设置画布的背景颜色。
			*Laya.loader.load(["resource/ui/progress.png","resource/ui/progress$bar.png"],Handler.create(this,this.onLoadComplete));//加载资源。
			*}
		*private onLoadComplete():void {
			*this.progressBar=new ProgressBar("resource/ui/progress.png");//创建一个 ProgressBar 类的实例对象 progressBar 。
			*this.progressBar.x=100;//设置 progressBar 对象的属性 x 的值，用于控制 progressBar 对象的显示位置。
			*this.progressBar.y=100;//设置 progressBar 对象的属性 y 的值，用于控制 progressBar 对象的显示位置。
			*this.progressBar.value=0.3;//设置 progressBar 的进度值。
			*this.progressBar.width=200;//设置 progressBar 的宽度。
			*this.progressBar.height=50;//设置 progressBar 的高度。
			*this.progressBar.sizeGrid="5,10,5,10";//设置 progressBar 的网格信息。
			*this.progressBar.changeHandler=new Handler(this,this.onChange);//设置 progressBar 的value值改变时执行的处理器。
			*Laya.stage.addChild(this.progressBar);//将 progressBar 添加到显示列表。
			*Laya.timer.once(3000,this,this.changeValue);//设定 3000ms（毫秒）后，执行函数changeValue。
			*}
		*private changeValue():void {
			*console.log("改变进度条的进度值。");
			*this.progressBar.value=0.6;
			*}
		*private onChange(value:number):void {
			*console.log("进度发生改变： value=",value);
			*}
		*}
	*/
	//class laya.ui.ProgressBar extends laya.ui.Component
	var ProgressBar = (function (_super) {
		function ProgressBar(skin) {
			/**
			*当 <code>ProgressBar</code> 实例的 <code>value</code> 属性发生变化时的函数处理器。
			*<p>默认返回参数<code>value</code> 属性（进度值）。</p>
			*/
			this.changeHandler = null;
			/**@private */
			this._bg = null;
			/**@private */
			this._bar = null;
			/**@private */
			this._skin = null;
			/**@private */
			this._value = 0.5;
			ProgressBar.__super.call(this);
			this.skin = skin;
		}

		__class(ProgressBar, 'laya.ui.ProgressBar', _super);
		var __proto = ProgressBar.prototype;
		/**@inheritDoc */
		__proto.destroy = function (destroyChild) {
			(destroyChild === void 0) && (destroyChild = true);
			_super.prototype.destroy.call(this, destroyChild);
			this._bg && this._bg.destroy(destroyChild);
			this._bar && this._bar.destroy(destroyChild);
			this._bg = this._bar = null;
			this.changeHandler = null;
		}

		/**@inheritDoc */
		__proto.createChildren = function () {
			this.addChild(this._bg = new Image());
			this.addChild(this._bar = new Image());
			this._bar._bitmap.autoCacheCmd = false;
		}

		/**
		*@private
		*更改进度值的显示。
		*/
		__proto.changeValue = function () {
			if (this.sizeGrid) {
				var grid = this.sizeGrid.split(",");
				var left = Number(grid[3]);
				var right = Number(grid[1]);
				var max = this.width - left - right;
				var sw = max * this._value;
				this._bar.width = left + right + sw;
				this._bar.visible = this._bar.width > left + right;
			} else {
				this._bar.width = this.width * this._value;
			}
		}

		/**@inheritDoc */
		__getset(0, __proto, 'measureHeight', function () {
			return this._bg.height;
		});

		/**
		*@copy laya.ui.Image#skin
		*/
		__getset(0, __proto, 'skin', function () {
			return this._skin;
		}, function (value) {
			if (this._skin != value) {
				this._skin = value;
				this._bg.skin = this._skin;
				this._bar.skin = this._skin.replace(".png", "$bar.png");
				this.callLater(this.changeValue);
			}
		});

		/**@inheritDoc */
		__getset(0, __proto, 'measureWidth', function () {
			return this._bg.width;
		});

		/**@inheritDoc */
		__getset(0, __proto, 'height', _super.prototype._$get_height, function (value) {
			Laya.superSet(Component, this, 'height', value);
			this._bg.height = this._height;
			this._bar.height = this._height;
		});

		/**
		*获取进度条对象。
		*/
		__getset(0, __proto, 'bar', function () {
			return this._bar;
		});

		/**
		*当前的进度量。
		*<p><b>取值：</b>介于0和1之间。</p>
		*/
		__getset(0, __proto, 'value', function () {
			return this._value;
		}, function (num) {
			if (this._value != num) {
				num = num > 1 ? 1 : num < 0 ? 0 : num;
				this._value = num;
				this.callLater(this.changeValue);
				this.event(/*laya.events.Event.CHANGE*/"change");
				this.changeHandler && this.changeHandler.runWith(num);
			}
		});

		/**
		*获取背景条对象。
		*/
		__getset(0, __proto, 'bg', function () {
			return this._bg;
		});

		/**
		*<p>当前 <code>ProgressBar</code> 实例的进度条背景位图（ <code>Image</code> 实例）的有效缩放网格数据。</p>
		*<p>数据格式："上边距,右边距,下边距,左边距,是否重复填充(值为0：不重复填充，1：重复填充)"，以逗号分隔。
		*<ul><li>例如："4,4,4,4,1"</li></ul></p>
		*@see laya.ui.AutoBitmap.sizeGrid
		*/
		__getset(0, __proto, 'sizeGrid', function () {
			return this._bg.sizeGrid;
		}, function (value) {
			this._bg.sizeGrid = this._bar.sizeGrid = value;
		});

		/**@inheritDoc */
		__getset(0, __proto, 'width', _super.prototype._$get_width, function (value) {
			Laya.superSet(Component, this, 'width', value);
			this._bg.width = this._width;
			this.callLater(this.changeValue);
		});

		/**@inheritDoc */
		__getset(0, __proto, 'dataSource', _super.prototype._$get_dataSource, function (value) {
			this._dataSource = value;
			if ((typeof value == 'number') || (typeof value == 'string')) this.value = Number(value);
			else Laya.superSet(Component, this, 'dataSource', value);
		});

		return ProgressBar;
	})(Component)


	/**鼠标提示管理类*/
	//class laya.ui.TipManager extends laya.ui.Component
	var TipManager = (function (_super) {
		function TipManager() {
			this._tipBox = null;
			this._tipText = null;
			this._defaultTipHandler = null;
			TipManager.__super.call(this);
			this._tipBox = new Component();
			this._tipBox.addChild(this._tipText = new Text());
			this._tipText.x = this._tipText.y = 5;
			this._tipText.color = TipManager.tipTextColor;
			this._defaultTipHandler = this._showDefaultTip;
			Laya.stage.on(/*laya.ui.UIEvent.SHOW_TIP*/"showtip", this, this._onStageShowTip);
			Laya.stage.on(/*laya.ui.UIEvent.HIDE_TIP*/"hidetip", this, this._onStageHideTip);
			this.zOrder = 1100
		}

		__class(TipManager, 'laya.ui.TipManager', _super);
		var __proto = TipManager.prototype;
		/**
		*@private
		*/
		__proto._onStageHideTip = function (e) {
			Laya.timer.clear(this, this._showTip);
			this.closeAll();
			this.removeSelf();
		}

		/**
		*@private
		*/
		__proto._onStageShowTip = function (data) {
			Laya.timer.once(TipManager.tipDelay, this, this._showTip, [data], true);
		}

		/**
		*@private
		*/
		__proto._showTip = function (tip) {
			if ((typeof tip == 'string')) {
				var text = String(tip);
				if (Boolean(text)) {
					this._defaultTipHandler(text);
				}
			} else if ((tip instanceof laya.utils.Handler)) {
				(tip).run();
			} else if ((typeof tip == 'function')) {
				(tip).apply();
			}
			if (true) {
				Laya.stage.on(/*laya.events.Event.MOUSE_MOVE*/"mousemove", this, this._onStageMouseMove);
				Laya.stage.on(/*laya.events.Event.MOUSE_DOWN*/"mousedown", this, this._onStageMouseDown);
			}
			this._onStageMouseMove(null);
		}

		/**
		*@private
		*/
		__proto._onStageMouseDown = function (e) {
			this.closeAll();
		}

		/**
		*@private
		*/
		__proto._onStageMouseMove = function (e) {
			this._showToStage(this, TipManager.offsetX, TipManager.offsetY);
		}

		/**
		*@private
		*/
		__proto._showToStage = function (dis, offX, offY) {
			(offX === void 0) && (offX = 0);
			(offY === void 0) && (offY = 0);
			var rec = dis.getBounds();
			dis.x = Laya.stage.mouseX + offX;
			dis.y = Laya.stage.mouseY + offY;
			if (dis.x + rec.width > Laya.stage.width) {
				dis.x -= rec.width + offX;
			}
			if (dis.y + rec.height > Laya.stage.height) {
				dis.y -= rec.height + offY;
			}
		}

		/**关闭所有鼠标提示*/
		__proto.closeAll = function () {
			Laya.timer.clear(this, this._showTip);
			Laya.stage.off(/*laya.events.Event.MOUSE_MOVE*/"mousemove", this, this._onStageMouseMove);
			Laya.stage.off(/*laya.events.Event.MOUSE_DOWN*/"mousedown", this, this._onStageMouseDown);
			this.removeChildren();
		}

		/**
		*显示显示对象类型的tip
		*/
		__proto.showDislayTip = function (tip) {
			this.addChild(tip);
			this._showToStage(this);
			Laya._currentStage.addChild(this);
		}

		/**
		*@private
		*/
		__proto._showDefaultTip = function (text) {
			this._tipText.text = text;
			var g = this._tipBox.graphics;
			g.clear();
			g.drawRect(0, 0, this._tipText.width + 10, this._tipText.height + 10, TipManager.tipBackColor);
			this.addChild(this._tipBox);
			this._showToStage(this);
			Laya._currentStage.addChild(this);
		}

		/**默认鼠标提示函数*/
		__getset(0, __proto, 'defaultTipHandler', function () {
			return this._defaultTipHandler;
		}, function (value) {
			this._defaultTipHandler = value;
		});

		TipManager.offsetX = 10;
		TipManager.offsetY = 15;
		TipManager.tipTextColor = "#ffffff";
		TipManager.tipBackColor = "#111111";
		TipManager.tipDelay = 200;
		return TipManager;
	})(Component)


	/**
	*<code>View</code> 是一个视图类。
	*@internal <p><code>View</code></p>
	*/
	//class laya.ui.View extends laya.ui.Box
	var View = (function (_super) {
		var DataWatcher;
		function View() {
			/**@private */
			this._idMap = null;
			/**@private */
			this._aniList = null;
			/**@private */
			this._watchMap = {};
			View.__super.call(this);
		}

		__class(View, 'laya.ui.View', _super);
		var __proto = View.prototype;
		/**
		*@private
		*通过视图数据创建视图。
		*@param uiView 视图数据信息。
		*/
		__proto.createView = function (uiView) {
			if (uiView.animations && !this._idMap) this._idMap = {};
			View.createComp(uiView, this, this);
			if (uiView.animations) {
				var anilist = [];
				var animations = uiView.animations;
				var i = 0, len = animations.length;
				var tAni;
				var tAniO;
				for (i = 0; i < len; i++) {
					tAni = new FrameAnimation();
					tAniO = animations[i];
					tAni._setUp(this._idMap, tAniO);
					this[tAniO.name] = tAni;
					tAni._setControlNode(this);
					switch (tAniO.action) {
						case 1:
							tAni.play(0, false);
							break;
						case 2:
							tAni.play(0, true);
							break;
					}
					anilist.push(tAni);
				}
				this._aniList = anilist;
			}
			if (this._width > 0 && uiView.props.hitTestPrior == null && !this.mouseThrough) this.hitTestPrior = true;
		}

		__proto.onEvent = function (type, event) { }
		/**
		*@private
		*装载UI视图。用于加载模式。
		*@param path UI资源地址。
		*/
		__proto.loadUI = function (path) {
			var uiView = View.uiMap[path];
			uiView && this.createView(uiView);
		}

		/**
		*<p>销毁此对象。</p>
		*@param destroyChild 是否同时销毁子节点，若值为true,则销毁子节点，否则不销毁子节点。
		*/
		__proto.destroy = function (destroyChild) {
			(destroyChild === void 0) && (destroyChild = true);
			if (this._aniList) this._aniList.length = 0;
			this._idMap = null;
			this._aniList = null;
			this._watchMap = null;
			laya.ui.Component.prototype.destroy.call(this, destroyChild);
		}

		/**@private */
		__proto.changeData = function (key) {
			var arr = this._watchMap[key];
			if (!arr) return;
			console.log("change", key);
			for (var i = 0, n = arr.length; i < n; i++) {
				var watcher = arr[i];
				watcher.exe(this);
			}
		}

		View._regs = function () {
			for (var key in View.uiClassMap) {
				ClassUtils.regClass(key, View.uiClassMap[key]);
			}
		}

		View.createComp = function (uiView, comp, view, dataMap) {
			comp = comp || View.getCompInstance(uiView);
			if (!comp) {
				console.warn("can not create:" + uiView.type);
				return null;
			};
			var child = uiView.child;
			if (child) {
				var isList = (comp instanceof laya.ui.List);
				for (var i = 0, n = child.length; i < n; i++) {
					var node = child[i];
					if (comp.hasOwnProperty("itemRender") && (node.props.name == "render" || node.props.renderType === "render")) {
						(comp).itemRender = node;
					} else if (node.type == "Graphic") {
						ClassUtils.addGraphicsToSprite(node, comp);
					} else if (ClassUtils.isDrawType(node.type)) {
						ClassUtils.addGraphicToSprite(node, comp, true);
					} else {
						if (isList) {
							var arr = [];
							var tChild = View.createComp(node, null, view, arr);
							if (arr.length) tChild["_$bindData"] = arr;
						} else {
							tChild = View.createComp(node, null, view, dataMap);
						}
						if (node.type == "Script") {
							if ("owner" in tChild) {
								tChild["owner"] = comp;
							} else if ("target" in tChild) {
								tChild["target"] = comp;
							}
						} else if (node.props.renderType == "mask" || node.props.name == "mask") {
							comp.mask = tChild;
						} else {
							(
								tChild instanceof laya.display.Sprite) && comp.addChild(tChild);
						}
					}
				}
			};
			var props = uiView.props;
			for (var prop in props) {
				var value = props[prop];
				if (View.eventDic[prop]) {
					if (value && view) {
						(comp).on(prop, view, view.onEvent, [value]);
					}
				} else
					View.setCompValue(comp, prop, value, view, dataMap);
			}
			if (Laya.__typeof(comp, 'laya.ui.IItem')) (comp).initItems();
			if (uiView.compId && view && view._idMap) {
				view._idMap[uiView.compId] = comp;
			}
			return comp;
		}

		View.setCompValue = function (comp, prop, value, view, dataMap) {
			if ((typeof value == 'string') && value.indexOf("${") > -1) {
				View._sheet || (View._sheet = ClassUtils.getClass("laya.data.Table"));
				if (!View._sheet) {
					console.warn("Can not find class Sheet");
					return;
				}
				if (dataMap) {
					dataMap.push(comp, prop, value);
				} else if (view) {
					if (value.indexOf("].") == -1) {
						value = value.replace(".", "[0].");
					};
					var watcher = new DataWatcher(comp, prop, value);
					watcher.exe(view);
					var one, temp;
					var str = value.replace(/\[.*?\]\./g, ".");
					while ((one = View._parseWatchData.exec(str)) != null) {
						var key1 = one[1];
						while ((temp = View._parseKeyWord.exec(key1)) != null) {
							var key2 = temp[0];
							var arr = (view._watchMap[key2] || (view._watchMap[key2] = []));
							arr.push(watcher);
							View._sheet.I.notifer.on(key2, view, view.changeData, [key2]);
						}
						arr = (view._watchMap[key1] || (view._watchMap[key1] = []));
						arr.push(watcher);
						View._sheet.I.notifer.on(key1, view, view.changeData, [key1]);
					}
				}
				return;
			}
			if (prop === "var" && view) {
				view[value] = comp;
			} else if (prop == "onClick") {
				var fun = Browser.window.eval("(function(){" + value + "})");
				comp.on(/*laya.events.Event.CLICK*/"click", view, fun);
			} else {
				comp[prop] = (value === "true" ? true : (value === "false" ? false : value));
			}
		}

		View.getCompInstance = function (json) {
			var runtime = json.props ? json.props.runtime : null;
			var compClass;
			compClass = runtime ? (View.viewClassMap[runtime] || View.uiClassMap[runtime] || Laya["__classmap"][runtime]) : View.uiClassMap[json.type];
			if (json.props && json.props.hasOwnProperty("renderType") && json.props["renderType"] == "instance") return compClass["instance"];
			return compClass ? new compClass() : null;
		}

		View.regComponent = function (key, compClass) {
			View.uiClassMap[key] = compClass;
			ClassUtils.regClass(key, compClass);
		}

		View.regViewRuntime = function (key, compClass) {
			View.viewClassMap[key] = compClass;
		}

		View.uiMap = {};
		View.viewClassMap = {};
		View._sheet = null;
		__static(View,
			['uiClassMap', function () { return this.uiClassMap = { "ViewStack": ViewStack, "LinkButton": Button, "TextArea": TextArea, "ColorPicker": ColorPicker, "Box": Box, "Button": Button, "CheckBox": CheckBox, "Clip": Clip, "ComboBox": ComboBox, "Component": Component, "HScrollBar": HScrollBar, "HSlider": HSlider, "Image": Image, "Label": Label, "List": List, "Panel": Panel, "ProgressBar": ProgressBar, "Radio": Radio, "RadioGroup": RadioGroup, "ScrollBar": ScrollBar, "Slider": Slider, "Tab": Tab, "TextInput": TextInput, "View": View, "VScrollBar": VScrollBar, "VSlider": VSlider, "Tree": Tree, "HBox": HBox, "VBox": VBox, "Sprite": Sprite, "Animation": Animation, "Text": Text, "FontClip": FontClip }; }, 'eventDic', function () { return this.eventDic = { "mousedown": true, "mouseup": true, "mousemove": true, "mouseover": true, "mouseout": true, "click": true, "doubleclick": true, "rightmousedown": true, "rightmouseup": true, "rightclick": true }; }, '_parseWatchData', function () { return this._parseWatchData = /\${(.*?)}/g; }, '_parseKeyWord', function () { return this._parseKeyWord = /[a-zA-Z_][a-zA-Z0-9_]*(?:(?:\.[a-zA-Z_][a-zA-Z0-9_]*)+)/g; }
			]);
		View.__init$ = function () {
			View._regs()
			//class DataWatcher
			DataWatcher = (function () {
				function DataWatcher(comp, prop, value) {
					this.comp = null;
					this.prop = null;
					this.value = null;
					this.comp = comp;
					this.prop = prop;
					this.value = value;
				}
				__class(DataWatcher, '');
				var __proto = DataWatcher.prototype;
				__proto.exe = function (view) {
					var fun = UIUtils.getBindFun(this.value);
					this.comp[this.prop] = fun.call(this, view);
				}
				return DataWatcher;
			})()
		}

		return View;
	})(Box)


	/**
	*<code>CheckBox</code> 组件显示一个小方框，该方框内可以有选中标记。
	*<code>CheckBox</code> 组件还可以显示可选的文本标签，默认该标签位于 CheckBox 右侧。
	*<p><code>CheckBox</code> 使用 <code>dataSource</code>赋值时的的默认属性是：<code>selected</code>。</p>
	*
	*@example <caption>以下示例代码，创建了一个 <code>CheckBox</code> 实例。</caption>
	*package
	*{
		*import laya.ui.CheckBox;
		*import laya.utils.Handler;
		*public class CheckBox_Example
		*{
			*public function CheckBox_Example()
			*{
				*Laya.init(640,800);//设置游戏画布宽高。
				*Laya.stage.bgColor="#efefef";//设置画布的背景颜色。
				*Laya.loader.load("resource/ui/check.png",Handler.create(this,onLoadComplete));//加载资源。
				*}
			*private function onLoadComplete():void
			*{
				*trace("资源加载完成！");
				*var checkBox:CheckBox=new CheckBox("resource/ui/check.png","这个是一个CheckBox组件。");//创建一个 CheckBox 类的实例对象 checkBox ,传入它的皮肤skin和标签label。
				*checkBox.x=100;//设置 checkBox 对象的属性 x 的值，用于控制 checkBox 对象的显示位置。
				*checkBox.y=100;//设置 checkBox 对象的属性 y 的值，用于控制 checkBox 对象的显示位置。
				*checkBox.clickHandler=new Handler(this,onClick,[checkBox]);//设置 checkBox 的点击事件处理器。
				*Laya.stage.addChild(checkBox);//将此 checkBox 对象添加到显示列表。
				*}
			*private function onClick(checkBox:CheckBox):void
			*{
				*trace("输出选中状态: checkBox.selected = "+checkBox.selected);
				*}
			*}
		*}
	*@example
	*Laya.init(640,800);//设置游戏画布宽高
	*Laya.stage.bgColor="#efefef";//设置画布的背景颜色
	*Laya.loader.load("resource/ui/check.png",laya.utils.Handler.create(this,loadComplete));//加载资源
	*function loadComplete()
	*{
		*console.log("资源加载完成！");
		*var checkBox:laya.ui.CheckBox=new laya.ui.CheckBox("resource/ui/check.png","这个是一个CheckBox组件。");//创建一个 CheckBox 类的类的实例对象 checkBox ,传入它的皮肤skin和标签label。
		*checkBox.x=100;//设置 checkBox 对象的属性 x 的值，用于控制 checkBox 对象的显示位置。
		*checkBox.y=100;//设置 checkBox 对象的属性 y 的值，用于控制 checkBox 对象的显示位置。
		*checkBox.clickHandler=new laya.utils.Handler(this,this.onClick,[checkBox],false);//设置 checkBox 的点击事件处理器。
		*Laya.stage.addChild(checkBox);//将此 checkBox 对象添加到显示列表。
		*}
	*function onClick(checkBox)
	*{
		*console.log("checkBox.selected = ",checkBox.selected);
		*}
	*@example
	*import CheckBox=laya.ui.CheckBox;
	*import Handler=laya.utils.Handler;
	*class CheckBox_Example{
		*constructor()
		*{
			*Laya.init(640,800);
			*Laya.stage.bgColor="#efefef";//设置画布的背景颜色。
			*Laya.loader.load("resource/ui/check.png",Handler.create(this,this.onLoadComplete));//加载资源。
			*}
		*private onLoadComplete()
		*{
			*var checkBox:CheckBox=new CheckBox("resource/ui/check.png","这个是一个CheckBox组件。");//创建一个 CheckBox 类的实例对象 checkBox ,传入它的皮肤skin和标签label。
			*checkBox.x=100;//设置 checkBox 对象的属性 x 的值，用于控制 checkBox 对象的显示位置。
			*checkBox.y=100;//设置 checkBox 对象的属性 y 的值，用于控制 checkBox 对象的显示位置。
			*checkBox.clickHandler=new Handler(this,this.onClick,[checkBox]);//设置 checkBox 的点击事件处理器。
			*Laya.stage.addChild(checkBox);//将此 checkBox 对象添加到显示列表。
			*}
		*private onClick(checkBox:CheckBox):void
		*{
			*console.log("输出选中状态: checkBox.selected = "+checkBox.selected);
			*}
		*}
	*/
	//class laya.ui.CheckBox extends laya.ui.Button
	var CheckBox = (function (_super) {
		/**
		*创建一个新的 <code>CheckBox</code> 组件实例。
		*@param skin 皮肤资源地址。
		*@param label 文本标签的内容。
		*/
		function CheckBox(skin, label) {
			(label === void 0) && (label = "");
			CheckBox.__super.call(this, skin, label);
		}

		__class(CheckBox, 'laya.ui.CheckBox', _super);
		var __proto = CheckBox.prototype;
		/**@inheritDoc */
		__proto.preinitialize = function () {
			laya.ui.Component.prototype.preinitialize.call(this);
			this.toggle = true;
			this._autoSize = false;
		}

		/**@inheritDoc */
		__proto.initialize = function () {
			_super.prototype.initialize.call(this);
			this.createText();
			this._text.align = "left";
			this._text.valign = "top";
			this._text.width = 0;
		}

		/**@inheritDoc */
		__getset(0, __proto, 'dataSource', _super.prototype._$get_dataSource, function (value) {
			this._dataSource = value;
			if ((typeof value == 'boolean')) this.selected = value;
			else if ((typeof value == 'string')) this.selected = value === "true";
			else Laya.superSet(Button, this, 'dataSource', value);
		});

		return CheckBox;
	})(Button)


	/**
	*<code>LayoutBox</code> 是一个布局容器类。
	*/
	//class laya.ui.LayoutBox extends laya.ui.Box
	var LayoutBox = (function (_super) {
		function LayoutBox() {
			/**@private */
			this._space = 0;
			/**@private */
			this._align = "none";
			/**@private */
			this._itemChanged = false;
			LayoutBox.__super.call(this);
		}

		__class(LayoutBox, 'laya.ui.LayoutBox', _super);
		var __proto = LayoutBox.prototype;
		/**@inheritDoc */
		__proto.addChild = function (child) {
			child.on(/*laya.events.Event.RESIZE*/"resize", this, this.onResize);
			this._setItemChanged();
			return laya.display.Node.prototype.addChild.call(this, child);
		}

		__proto.onResize = function (e) {
			this._setItemChanged();
		}

		/**@inheritDoc */
		__proto.addChildAt = function (child, index) {
			child.on(/*laya.events.Event.RESIZE*/"resize", this, this.onResize);
			this._setItemChanged();
			return laya.display.Node.prototype.addChildAt.call(this, child, index);
		}

		/**@inheritDoc */
		__proto.removeChild = function (child) {
			child.off(/*laya.events.Event.RESIZE*/"resize", this, this.onResize);
			this._setItemChanged();
			return laya.display.Node.prototype.removeChild.call(this, child);
		}

		/**@inheritDoc */
		__proto.removeChildAt = function (index) {
			this.getChildAt(index).off(/*laya.events.Event.RESIZE*/"resize", this, this.onResize);
			this._setItemChanged();
			return laya.display.Node.prototype.removeChildAt.call(this, index);
		}

		/**刷新。*/
		__proto.refresh = function () {
			this._setItemChanged();
		}

		/**
		*改变子对象的布局。
		*/
		__proto.changeItems = function () {
			this._itemChanged = false;
		}

		/**
		*排序项目列表。可通过重写改变默认排序规则。
		*@param items 项目列表。
		*/
		__proto.sortItem = function (items) {
			if (items) items.sort(function (a, b) { return a.y - b.y; });
		}

		__proto._setItemChanged = function () {
			if (!this._itemChanged) {
				this._itemChanged = true;
				this.callLater(this.changeItems);
			}
		}

		/**子对象的间隔。*/
		__getset(0, __proto, 'space', function () {
			return this._space;
		}, function (value) {
			this._space = value;
			this._setItemChanged();
		});

		/**子对象对齐方式。*/
		__getset(0, __proto, 'align', function () {
			return this._align;
		}, function (value) {
			this._align = value;
			this._setItemChanged();
		});

		return LayoutBox;
	})(Box)


	/**
	*字体切片，简化版的位图字体，只需设置一个切片图片和文字内容即可使用，效果同位图字体
	*使用方式：设置位图字体皮肤skin，设置皮肤对应的字体内容sheet（如果多行，可以使用空格换行），示例：
	*fontClip.skin="font1.png";//设置皮肤
	*fontClip.sheet="abc123 456";//设置皮肤对应的内容，空格换行。此皮肤为2行5列（显示时skin会被等分为2行5列），第一行对应的文字为"abc123"，第二行为"456"
	*fontClip.value="a1326";//显示"a1326"文字
	*/
	//class laya.ui.FontClip extends laya.ui.Clip
	var FontClip = (function (_super) {
		function FontClip(skin, sheet) {
			/**数值*/
			this._valueArr = null;
			/**文字内容数组**/
			this._indexMap = null;
			/**位图字体内容**/
			this._sheet = null;
			/**@private */
			this._direction = "horizontal";
			/**X方向间隙*/
			this._spaceX = 0;
			/**Y方向间隙*/
			this._spaceY = 0;
			/**@private 水平对齐方式*/
			this._align = "left";
			/**@private 显示文字宽*/
			this._wordsW = 0;
			/**@private 显示文字高*/
			this._wordsH = 0;
			FontClip.__super.call(this);
			if (skin) this.skin = skin;
			if (sheet) this.sheet = sheet;
		}

		__class(FontClip, 'laya.ui.FontClip', _super);
		var __proto = FontClip.prototype;
		__proto.createChildren = function () {
			this._bitmap = new AutoBitmap();
			this.on(/*laya.events.Event.LOADED*/"loaded", this, this._onClipLoaded);
		}

		/**
		*资源加载完毕
		*/
		__proto._onClipLoaded = function () {
			this.callLater(this.changeValue);
		}

		/**渲染数值*/
		__proto.changeValue = function () {
			if (!this._sources) return;
			if (!this._valueArr) return;
			this.graphics.clear(true);
			var texture;
			texture = this._sources[0];
			if (!texture) return;
			var isHorizontal = (this._direction === "horizontal");
			if (isHorizontal) {
				this._wordsW = this._valueArr.length * (texture.sourceWidth + this.spaceX);
				this._wordsH = texture.sourceHeight;
			} else {
				this._wordsW = texture.sourceWidth;
				this._wordsH = (texture.sourceHeight + this.spaceY) * this._valueArr.length;
			};
			var dX = 0;
			if (this._width) {
				switch (this._align) {
					case "center":
						dX = 0.5 * (this._width - this._wordsW);
						break;
					case "right":
						dX = this._width - this._wordsW;
						break;
					default:
						dX = 0;
				}
			}
			for (var i = 0, sz = this._valueArr.length; i < sz; i++) {
				var index = this._indexMap[this._valueArr.charAt(i)];
				if (!this.sources[index]) continue;
				texture = this.sources[index];
				if (isHorizontal) this.graphics.drawTexture(texture, dX + i * (texture.sourceWidth + this.spaceX), 0, texture.sourceWidth, texture.sourceHeight);
				else this.graphics.drawTexture(texture, 0 + dX, i * (texture.sourceHeight + this.spaceY), texture.sourceWidth, texture.sourceHeight);
			}
			if (!this._width) {
				this.resetLayoutX();
				this.callLater(this.changeSize);
			}
			if (!this._height) {
				this.resetLayoutY();
				this.callLater(this.changeSize);
			}
		}

		__proto.destroy = function (destroyChild) {
			(destroyChild === void 0) && (destroyChild = true);
			this._valueArr = null;
			this._indexMap = null;
			this.graphics.clear(true);
			this.removeSelf();
			this.off(/*laya.events.Event.LOADED*/"loaded", this, this._onClipLoaded);
			_super.prototype.destroy.call(this, destroyChild);
		}

		/**
		*设置位图字体内容，空格代表换行。比如"abc123 456"，代表第一行对应的文字为"abc123"，第二行为"456"
		*/
		__getset(0, __proto, 'sheet', function () {
			return this._sheet;
		}, function (value) {
			value += "";
			this._sheet = value;
			var arr = value.split(" ");
			this._clipX = String(arr[0]).length;
			this.clipY = arr.length;
			this._indexMap = {};
			for (var i = 0; i < this._clipY; i++) {
				var line = arr[i].split("");
				for (var j = 0, n = line.length; j < n; j++) {
					this._indexMap[line[j]] = i * this._clipX + j;
				}
			}
		});

		__getset(0, __proto, 'height', _super.prototype._$get_height, function (value) {
			Laya.superSet(Clip, this, 'height', value);
			this.callLater(this.changeValue);
		});

		/**
		*布局方向。
		*<p>默认值为"horizontal"。</p>
		*<p><b>取值：</b>
		*<li>"horizontal"：表示水平布局。</li>
		*<li>"vertical"：表示垂直布局。</li>
		*</p>
		*/
		__getset(0, __proto, 'direction', function () {
			return this._direction;
		}, function (value) {
			this._direction = value;
			this.callLater(this.changeValue);
		});

		/**
		*设置位图字体的显示内容
		*/
		__getset(0, __proto, 'value', function () {
			if (!this._valueArr) return "";
			return this._valueArr;
		}, function (value) {
			value += "";
			this._valueArr = value;
			this.callLater(this.changeValue);
		});

		__getset(0, __proto, 'width', _super.prototype._$get_width, function (value) {
			Laya.superSet(Clip, this, 'width', value);
			this.callLater(this.changeValue);
		});

		/**X方向文字间隙*/
		__getset(0, __proto, 'spaceX', function () {
			return this._spaceX;
		}, function (value) {
			this._spaceX = value;
			if (this._direction === "horizontal") this.callLater(this.changeValue);
		});

		/**Y方向文字间隙*/
		__getset(0, __proto, 'spaceY', function () {
			return this._spaceY;
		}, function (value) {
			this._spaceY = value;
			if (!(this._direction === "horizontal")) this.callLater(this.changeValue);
		});

		/**水平对齐方式*/
		__getset(0, __proto, 'align', function () {
			return this._align;
		}, function (v) {
			this._align = v;
			this.callLater(this.changeValue);
		});

		__getset(0, __proto, 'measureWidth', function () {
			return this._wordsW;
		});

		__getset(0, __proto, 'measureHeight', function () {
			return this._wordsH;
		});

		return FontClip;
	})(Clip)


	/**
	*<code>List</code> 控件可显示项目列表。默认为垂直方向列表。可通过UI编辑器自定义列表。
	*
	*@example <caption>以下示例代码，创建了一个 <code>List</code> 实例。</caption>
	*package
	*{
		*import laya.ui.List;
		*import laya.utils.Handler;
		*public class List_Example
		*{
			*public function List_Example()
			*{
				*Laya.init(640,800,"false");//设置游戏画布宽高、渲染模式。
				*Laya.stage.bgColor="#efefef";//设置画布的背景颜色。
				*Laya.loader.load(["resource/ui/vscroll.png","resource/ui/vscroll$bar.png","resource/ui/vscroll$down.png","resource/ui/vscroll$up.png"],Handler.create(this,onLoadComplete));
				*}
			*private function onLoadComplete():void
			*{
				*var arr:Array=[];//创建一个数组，用于存贮列表的数据信息。
				*for (var i:int=0;i &lt;20;i++)
				*{
					*arr.push({label:"item"+i});
					*}
				*var list:List=new List();//创建一个 List 类的实例对象 list 。
				*list.itemRender=Item;//设置 list 的单元格渲染器。
				*list.repeatX=1;//设置 list 的水平方向单元格数量。
				*list.repeatY=10;//设置 list 的垂直方向单元格数量。
				*list.vScrollBarSkin="resource/ui/vscroll.png";//设置 list 的垂直方向滚动条皮肤。
				*list.array=arr;//设置 list 的列表数据源。
				*list.pos(100,100);//设置 list 的位置。
				*list.selectEnable=true;//设置 list 可选。
				*list.selectHandler=new Handler(this,onSelect);//设置 list 改变选择项执行的处理器。
				*Laya.stage.addChild(list);//将 list 添加到显示列表。
				*}
			*private function onSelect(index:int):void
			*{
				*trace("当前选择的项目索引： index= ",index);
				*}
			*}
		*}
	*import laya.ui.Box;
	*import laya.ui.Label;
	*class Item extends Box
	*{
		*public function Item()
		*{
			*graphics.drawRect(0,0,100,20,null,"#ff0000");
			*var label:Label=new Label();
			*label.text="100000";
			*label.name="label";//设置 label 的name属性值。
			*label.size(100,20);
			*addChild(label);
			*}
		*}
	*@example
	*(function (_super){
		*function Item(){
			*Item.__super.call(this);//初始化父类
			*this.graphics.drawRect(0,0,100,20,"#ff0000");
			*var label=new laya.ui.Label();//创建一个 Label 类的实例对象 label 。
			*label.text="100000";//设置 label 的文本内容。
			*label.name="label";//设置 label 的name属性值。
			*label.size(100,20);//设置 label 的宽度、高度。
			*this.addChild(label);//将 label 添加到显示列表。
			*};
		*Laya.class(Item,"mypackage.listExample.Item",_super);//注册类 Item 。
		*})(laya.ui.Box);
	*Laya.init(640,800);//设置游戏画布宽高、渲染模式。
	*Laya.stage.bgColor="#efefef";//设置画布的背景颜色。
	*var res=["resource/ui/vscroll.png","resource/ui/vscroll$bar.png","resource/ui/vscroll$down.png","resource/ui/vscroll$up.png"];
	*Laya.loader.load(res,new laya.utils.Handler(this,onLoadComplete));//加载资源。
	*function onLoadComplete(){
		*var arr=[];//创建一个数组，用于存贮列表的数据信息。
		*for (var i=0;i &lt;20;i++){
			*arr.push({label:"item"+i});
			*}
		*var list=new laya.ui.List();//创建一个 List 类的实例对象 list 。
		*list.itemRender=mypackage.listExample.Item;//设置 list 的单元格渲染器。
		*list.repeatX=1;//设置 list 的水平方向单元格数量。
		*list.repeatY=10;//设置 list 的垂直方向单元格数量。
		*list.vScrollBarSkin="resource/ui/vscroll.png";//设置 list 的垂直方向滚动条皮肤。
		*list.array=arr;//设置 list 的列表数据源。
		*list.pos(100,100);//设置 list 的位置。
		*list.selectEnable=true;//设置 list 可选。
		*list.selectHandler=new laya.utils.Handler(this,onSelect);//设置 list 改变选择项执行的处理器。
		*Laya.stage.addChild(list);//将 list 添加到显示列表。
		*}
	*function onSelect(index)
	*{
		*console.log("当前选择的项目索引： index= ",index);
		*}
	*
	*@example
	*import List=laya.ui.List;
	*import Handler=laya.utils.Handler;
	*public class List_Example {
		*public List_Example(){
			*Laya.init(640,800);//设置游戏画布宽高。
			*Laya.stage.bgColor="#efefef";//设置画布的背景颜色。
			*Laya.loader.load(["resource/ui/vscroll.png","resource/ui/vscroll$bar.png","resource/ui/vscroll$down.png","resource/ui/vscroll$up.png"],Handler.create(this,this.onLoadComplete));
			*}
		*private onLoadComplete():void {
			*var arr=[];//创建一个数组，用于存贮列表的数据信息。
			*for (var i:number=0;i &lt;20;i++)
			*{
				*arr.push({label:"item"+i });
				*}
			*var list:List=new List();//创建一个 List 类的实例对象 list 。
			*list.itemRender=Item;//设置 list 的单元格渲染器。
			*list.repeatX=1;//设置 list 的水平方向单元格数量。
			*list.repeatY=10;//设置 list 的垂直方向单元格数量。
			*list.vScrollBarSkin="resource/ui/vscroll.png";//设置 list 的垂直方向滚动条皮肤。
			*list.array=arr;//设置 list 的列表数据源。
			*list.pos(100,100);//设置 list 的位置。
			*list.selectEnable=true;//设置 list 可选。
			*list.selectHandler=new Handler(this,this.onSelect);//设置 list 改变选择项执行的处理器。
			*Laya.stage.addChild(list);//将 list 添加到显示列表。
			*}
		*private onSelect(index:number):void {
			*console.log("当前选择的项目索引： index= ",index);
			*}
		*}
	*import Box=laya.ui.Box;
	*import Label=laya.ui.Label;
	*class Item extends Box {
		*constructor(){
			*this.graphics.drawRect(0,0,100,20,null,"#ff0000");
			*var label:Label=new Label();
			*label.text="100000";
			*label.name="label";//设置 label 的name属性值。
			*label.size(100,20);
			*this.addChild(label);
			*}
		*}
	*/
	//class laya.ui.List extends laya.ui.Box
	var List = (function (_super) {
		function List() {
			/**改变 <code>List</code> 的选择项时执行的处理器，(默认返回参数： 项索引（index:int）)。*/
			this.selectHandler = null;
			/**单元格渲染处理器(默认返回参数cell:Box,index:int)。*/
			this.renderHandler = null;
			/**单元格鼠标事件处理器(默认返回参数e:Event,index:int)。*/
			this.mouseHandler = null;
			/**指定是否可以选择，若值为true则可以选择，否则不可以选择。 @default false*/
			this.selectEnable = false;
			/**最大分页数。*/
			this.totalPage = 0;
			/**@private */
			this._content = null;
			/**@private */
			this._scrollBar = null;
			/**@private */
			this._itemRender = null;
			/**@private */
			this._repeatX = 0;
			/**@private */
			this._repeatY = 0;
			/**@private */
			this._repeatX2 = 0;
			/**@private */
			this._repeatY2 = 0;
			/**@private */
			this._spaceX = 0;
			/**@private */
			this._spaceY = 0;
			/**@private */
			this._array = null;
			/**@private */
			this._startIndex = 0;
			/**@private */
			this._selectedIndex = -1;
			/**@private */
			this._page = 0;
			/**@private */
			this._isVertical = true;
			/**@private */
			this._cellSize = 20;
			/**@private */
			this._cellOffset = 0;
			/**@private */
			this._isMoved = false;
			/**是否缓存内容，如果数据源较少，并且list内无动画，设置此属性为true能大大提高性能 */
			this.cacheContent = false;
			/**@private */
			this._createdLine = 0;
			/**@private */
			this._cellChanged = false;
			List.__super.call(this);
			this._cells = [];
			this._offset = new Point();
		}

		__class(List, 'laya.ui.List', _super);
		var __proto = List.prototype;
		Laya.imps(__proto, { "laya.ui.IRender": true, "laya.ui.IItem": true })
		/**@inheritDoc */
		__proto.destroy = function (destroyChild) {
			(destroyChild === void 0) && (destroyChild = true);
			this._content && this._content.destroy(destroyChild);
			this._scrollBar && this._scrollBar.destroy(destroyChild);
			laya.ui.Component.prototype.destroy.call(this, destroyChild);
			this._content = null;
			this._scrollBar = null;
			this._itemRender = null;
			this._cells = null;
			this._array = null;
			this.selectHandler = this.renderHandler = this.mouseHandler = null;
		}

		/**@inheritDoc */
		__proto.createChildren = function () {
			this.addChild(this._content = new Box());
		}

		__proto.onScrollStart = function () {
			this._$P.cacheAs || (this._$P.cacheAs = Laya.superGet(Box, this, 'cacheAs'));
			Laya.superSet(Box, this, 'cacheAs', "none");
			this._scrollBar.once(/*laya.events.Event.END*/"end", this, this.onScrollEnd);
		}

		__proto.onScrollEnd = function () {
			Laya.superSet(Box, this, 'cacheAs', this._$P.cacheAs);
		}

		__proto._removePreScrollBar = function () {
			var preNode = this.removeChildByName("scrollBar");
			if (preNode) preNode.destroy(true);
		}

		/**
		*@private
		*更改单元格的信息。
		*@internal 在此销毁、创建单元格，并设置单元格的位置等属性。相当于此列表内容发送改变时调用此函数。
		*/
		__proto.changeCells = function () {
			this._cellChanged = false;
			if (this._itemRender) {
				this.scrollBar = this.getChildByName("scrollBar");
				var cell = this._getOneCell();
				var cellWidth = (cell.width + this._spaceX) || 1;
				var cellHeight = (cell.height + this._spaceY) || 1;
				if (this._width > 0) this._repeatX2 = this._isVertical ? Math.round(this._width / cellWidth) : Math.ceil(this._width / cellWidth);
				if (this._height > 0) this._repeatY2 = this._isVertical ? Math.ceil(this._height / cellHeight) : Math.round(this._height / cellHeight);
				var listWidth = this._width ? this._width : (cellWidth * this.repeatX - this._spaceX);
				var listHeight = this._height ? this._height : (cellHeight * this.repeatY - this._spaceY);
				this._cellSize = this._isVertical ? cellHeight : cellWidth;
				this._cellOffset = this._isVertical ? (cellHeight * Math.max(this._repeatY2, this._repeatY) - listHeight - this._spaceY) : (cellWidth * Math.max(this._repeatX2, this._repeatX) - listWidth - this._spaceX);
				if (this._isVertical && this._scrollBar) this._scrollBar.height = listHeight;
				else if (!this._isVertical && this._scrollBar) this._scrollBar.width = listWidth;
				this.setContentSize(listWidth, listHeight);
				var numX = this._isVertical ? this.repeatX : this.repeatY;
				var numY = (this._isVertical ? this.repeatY : this.repeatX) + (this._scrollBar ? 1 : 0);
				this._createItems(0, numX, numY);
				this._createdLine = numY;
				if (this._array) {
					this.array = this._array;
					this.runCallLater(this.renderItems);
				}
			}
		}

		__proto._getOneCell = function () {
			if (this._cells.length === 0) {
				var item = this.createItem();
				this._offset.setTo(item.x, item.y);
				if (this.cacheContent) return item;
				this._cells.push(item);
			}
			return this._cells[0];
		}

		__proto._createItems = function (startY, numX, numY) {
			var box = this._content;
			var cell = this._getOneCell();
			var cellWidth = cell.width + this._spaceX;
			var cellHeight = cell.height + this._spaceY;
			if (this.cacheContent) {
				var cacheBox = new Box();
				cacheBox.cacheAsBitmap = true;
				cacheBox.pos((this._isVertical ? 0 : startY) * cellWidth, (this._isVertical ? startY : 0) * cellHeight);
				this._content.addChild(cacheBox);
				this._content.optimizeScrollRect = true;
				box = cacheBox;
			} else {
				var arr = [];
				for (var i = this._cells.length - 1; i > -1; i--) {
					var item = this._cells[i];
					item.removeSelf();
					arr.push(item);
				}
				this._cells.length = 0;
			}
			for (var k = startY; k < numY; k++) {
				for (var l = 0; l < numX; l++) {
					if (arr && arr.length) {
						cell = arr.pop();
					} else {
						cell = this.createItem();
					}
					cell.x = (this._isVertical ? l : k) * cellWidth - box.x;
					cell.y = (this._isVertical ? k : l) * cellHeight - box.y;
					cell.name = "item" + (k * numX + l);
					box.addChild(cell);
					this.addCell(cell);
				}
			}
		}

		__proto.createItem = function () {
			var arr = [];
			if ((typeof this._itemRender == 'function')) {
				var box = new this._itemRender();
			} else {
				box = View.createComp(this._itemRender, null, null, arr)
			}
			if (arr.length == 0 && box._watchMap) {
				var watchMap = box._watchMap;
				for (var name in watchMap) {
					var a = watchMap[name];
					for (var i = 0; i < a.length; i++) {
						var watcher = a[i];
						arr.push(watcher.comp, watcher.prop, watcher.value)
					}
				}
			}
			if (arr.length) box["_$bindData"] = arr;
			return box;
		}

		/**
		*@private
		*添加单元格。
		*@param cell 需要添加的单元格对象。
		*/
		__proto.addCell = function (cell) {
			cell.on(/*laya.events.Event.CLICK*/"click", this, this.onCellMouse);
			cell.on(/*laya.events.Event.RIGHT_CLICK*/"rightclick", this, this.onCellMouse);
			cell.on(/*laya.events.Event.MOUSE_OVER*/"mouseover", this, this.onCellMouse);
			cell.on(/*laya.events.Event.MOUSE_OUT*/"mouseout", this, this.onCellMouse);
			cell.on(/*laya.events.Event.MOUSE_DOWN*/"mousedown", this, this.onCellMouse);
			cell.on(/*laya.events.Event.MOUSE_UP*/"mouseup", this, this.onCellMouse);
			this._cells.push(cell);
		}

		/**
		*初始化单元格信息。
		*/
		__proto.initItems = function () {
			if (!this._itemRender && this.getChildByName("item0") != null) {
				this.repeatX = 1;
				var count = 0;
				count = 0;
				for (var i = 0; i < 10000; i++) {
					var cell = this.getChildByName("item" + i);
					if (cell) {
						this.addCell(cell);
						count++;
						continue;
					}
					break;
				}
				this.repeatY = count;
			}
		}

		/**
		*设置可视区域大小。
		*<p>以（0，0，width参数，height参数）组成的矩形区域为可视区域。</p>
		*@param width 可视区域宽度。
		*@param height 可视区域高度。
		*/
		__proto.setContentSize = function (width, height) {
			this._content.width = width;
			this._content.height = height;
			if (this._scrollBar || this._offset.x != 0 || this._offset.y != 0) {
				this._content.scrollRect || (this._content.scrollRect = new Rectangle());
				this._content.scrollRect.setTo(-this._offset.x, -this._offset.y, width, height);
				this._content.scrollRect = this._content.scrollRect;
			}
			this.event(/*laya.events.Event.RESIZE*/"resize");
		}

		/**
		*@private
		*单元格的鼠标事件侦听处理函数。
		*/
		__proto.onCellMouse = function (e) {
			if (e.type ===/*laya.events.Event.MOUSE_DOWN*/"mousedown") this._isMoved = false;
			var cell = e.currentTarget;
			var index = this._startIndex + this._cells.indexOf(cell);
			if (index < 0) return;
			if (e.type ===/*laya.events.Event.CLICK*/"click" || e.type ===/*laya.events.Event.RIGHT_CLICK*/"rightclick") {
				if (this.selectEnable && !this._isMoved) this.selectedIndex = index;
				else this.changeCellState(cell, true, 0);
			} else if ((e.type ===/*laya.events.Event.MOUSE_OVER*/"mouseover" || e.type ===/*laya.events.Event.MOUSE_OUT*/"mouseout") && this._selectedIndex !== index) {
				this.changeCellState(cell, e.type ===/*laya.events.Event.MOUSE_OVER*/"mouseover", 0);
			}
			this.mouseHandler && this.mouseHandler.runWith([e, index]);
		}

		/**
		*@private
		*改变单元格的可视状态。
		*@param cell 单元格对象。
		*@param visable 是否显示。
		*@param index 单元格的属性 <code>index</code> 值。
		*/
		__proto.changeCellState = function (cell, visable, index) {
			var selectBox = cell.getChildByName("selectBox");
			if (selectBox) {
				this.selectEnable = true;
				selectBox.visible = visable;
				selectBox.index = index;
			}
		}

		/**@inheritDoc */
		__proto.changeSize = function () {
			laya.ui.Component.prototype.changeSize.call(this);
			this.setContentSize(this.width, this.height);
			if (this._scrollBar) this.callLater(this.onScrollBarChange);
		}

		/**
		*@private
		*滚动条的 <code>Event.CHANGE</code> 事件侦听处理函数。
		*/
		__proto.onScrollBarChange = function (e) {
			this.runCallLater(this.changeCells);
			var scrollValue = this._scrollBar.value;
			var lineX = (this._isVertical ? this.repeatX : this.repeatY);
			var lineY = (this._isVertical ? this.repeatY : this.repeatX);
			var scrollLine = Math.floor(scrollValue / this._cellSize);
			if (!this.cacheContent) {
				var index = scrollLine * lineX;
				var num = 0;
				if (index > this._startIndex) {
					num = index - this._startIndex;
					var down = true;
					var toIndex = this._startIndex + lineX * (lineY + 1);
					this._isMoved = true;
				} else if (index < this._startIndex) {
					num = this._startIndex - index;
					down = false;
					toIndex = this._startIndex - 1;
					this._isMoved = true;
				}
				for (var i = 0; i < num; i++) {
					if (down) {
						var cell = this._cells.shift();
						this._cells[this._cells.length] = cell;
						var cellIndex = toIndex + i;
					} else {
						cell = this._cells.pop();
						this._cells.unshift(cell);
						cellIndex = toIndex - i;
					};
					var pos = Math.floor(cellIndex / lineX) * this._cellSize;
					this._isVertical ? cell.y = pos : cell.x = pos;
					this.renderItem(cell, cellIndex);
				}
				this._startIndex = index;
				this.changeSelectStatus();
			} else {
				num = (lineY + 1);
				if (this._createdLine - scrollLine < num) {
					this._createItems(this._createdLine, lineX, this._createdLine + num);
					this.renderItems(this._createdLine * lineX, 0);
					this._createdLine += num;
				}
			};
			var r = this._content.scrollRect;
			if (this._isVertical) {
				r.y = scrollValue - this._offset.y;
				r.x = -this._offset.x;
			} else {
				r.y = -this._offset.y;
				r.x = scrollValue - this._offset.x;
			}
			this._content.scrollRect = r;
		}

		__proto.posCell = function (cell, cellIndex) {
			if (!this._scrollBar) return;
			var lineX = (this._isVertical ? this.repeatX : this.repeatY);
			var lineY = (this._isVertical ? this.repeatY : this.repeatX);
			var pos = Math.floor(cellIndex / lineX) * this._cellSize;
			this._isVertical ? cell.y = pos : cell.x = pos;
		}

		/**
		*@private
		*改变单元格的选择状态。
		*/
		__proto.changeSelectStatus = function () {
			for (var i = 0, n = this._cells.length; i < n; i++) {
				this.changeCellState(this._cells[i], this._selectedIndex === this._startIndex + i, 1);
			}
		}

		/**
		*@private
		*渲染单元格列表。
		*/
		__proto.renderItems = function (from, to) {
			(from === void 0) && (from = 0);
			(to === void 0) && (to = 0);
			for (var i = from, n = to || this._cells.length; i < n; i++) {
				this.renderItem(this._cells[i], this._startIndex + i);
			}
			this.changeSelectStatus();
		}

		/**
		*渲染一个单元格。
		*@param cell 需要渲染的单元格对象。
		*@param index 单元格索引。
		*/
		__proto.renderItem = function (cell, index) {
			if (this._array && index >= 0 && index < this._array.length) {
				cell.visible = true;
				if (cell._$bindData) {
					cell._dataSource = this._array[index];
					this._bindData(cell, this._array[index]);
				} else cell.dataSource = this._array[index];
				if (!this.cacheContent) {
					this.posCell(cell, index);
				}
				if (this.hasListener(/*laya.events.Event.RENDER*/"render")) this.event(/*laya.events.Event.RENDER*/"render", [cell, index]);
				if (this.renderHandler) this.renderHandler.runWith([cell, index]);
			} else {
				cell.visible = false;
				cell.dataSource = null;
			}
		}

		__proto._bindData = function (cell, data) {
			var arr = cell._$bindData;
			for (var i = 0, n = arr.length; i < n; i++) {
				var ele = arr[i++];
				var prop = arr[i++];
				var value = arr[i];
				var fun = UIUtils.getBindFun(value);
				ele[prop] = fun.call(this, data);
			}
		}

		/**
		*刷新列表数据源。
		*/
		__proto.refresh = function () {
			this.array = this._array;
		}

		/**
		*获取单元格数据源。
		*@param index 单元格索引。
		*/
		__proto.getItem = function (index) {
			if (index > -1 && index < this._array.length) {
				return this._array[index];
			}
			return null;
		}

		/**
		*修改单元格数据源。
		*@param index 单元格索引。
		*@param source 单元格数据源。
		*/
		__proto.changeItem = function (index, source) {
			if (index > -1 && index < this._array.length) {
				this._array[index] = source;
				if (index >= this._startIndex && index < this._startIndex + this._cells.length) {
					this.renderItem(this.getCell(index), index);
				}
			}
		}

		/**
		*设置单元格数据源。
		*@param index 单元格索引。
		*@param source 单元格数据源。
		*/
		__proto.setItem = function (index, source) {
			this.changeItem(index, source);
		}

		/**
		*添加单元格数据源。
		*@param souce 数据源。
		*/
		__proto.addItem = function (souce) {
			this._array.push(souce);
			this.array = this._array;
		}

		/**
		*添加单元格数据源到对应的数据索引处。
		*@param souce 单元格数据源。
		*@param index 索引。
		*/
		__proto.addItemAt = function (souce, index) {
			this._array.splice(index, 0, souce);
			this.array = this._array;
		}

		/**
		*通过数据源索引删除单元格数据源。
		*@param index 需要删除的数据源索引值。
		*/
		__proto.deleteItem = function (index) {
			this._array.splice(index, 1);
			this.array = this._array;
		}

		/**
		*通过可视单元格索引，获取单元格。
		*@param index 可视单元格索引。
		*@return 单元格对象。
		*/
		__proto.getCell = function (index) {
			this.runCallLater(this.changeCells);
			if (index > -1 && this._cells) {
				return this._cells[(index - this._startIndex) % this._cells.length];
			}
			return null;
		}

		/**
		*<p>滚动列表，以设定的数据索引对应的单元格为当前可视列表的第一项。</p>
		*@param index 单元格在数据列表中的索引。
		*/
		__proto.scrollTo = function (index) {
			if (this._scrollBar) {
				var numX = this._isVertical ? this.repeatX : this.repeatY;
				this._scrollBar.value = Math.floor(index / numX) * this._cellSize;
			} else {
				this.startIndex = index;
			}
		}

		/**
		*<p>缓动滚动列表，以设定的数据索引对应的单元格为当前可视列表的第一项。</p>
		*@param index 单元格在数据列表中的索引。
		*@param time 缓动时间。
		*@param complete 缓动结束回掉
		*/
		__proto.tweenTo = function (index, time, complete) {
			(time === void 0) && (time = 200);
			if (this._scrollBar) {
				var numX = this._isVertical ? this.repeatX : this.repeatY;
				Tween.to(this._scrollBar, { value: Math.floor(index / numX) * this._cellSize }, time, null, complete, 0, true);
			} else {
				this.startIndex = index;
				if (complete) complete.run();
			}
		}

		/**@private */
		__proto._setCellChanged = function () {
			if (!this._cellChanged) {
				this._cellChanged = true;
				this.callLater(this.changeCells);
			}
		}

		__proto.commitMeasure = function () {
			this.runCallLater(this.changeCells);
		}

		/**@inheritDoc */
		__getset(0, __proto, 'cacheAs', _super.prototype._$get_cacheAs, function (value) {
			Laya.superSet(Box, this, 'cacheAs', value);
			if (this._scrollBar) {
				this._$P.cacheAs = null;
				if (value !== "none") this._scrollBar.on(/*laya.events.Event.START*/"start", this, this.onScrollStart);
				else this._scrollBar.off(/*laya.events.Event.START*/"start", this, this.onScrollStart);
			}
		});

		/**
		*获取对 <code>List</code> 组件所包含的内容容器 <code>Box</code> 组件的引用。
		*/
		__getset(0, __proto, 'content', function () {
			return this._content;
		});

		/**@inheritDoc */
		__getset(0, __proto, 'height', _super.prototype._$get_height, function (value) {
			if (value != this._height) {
				Laya.superSet(Box, this, 'height', value);
				this._setCellChanged();
			}
		});

		/**
		*单元格渲染器。
		*<p><b>取值：</b>
		*<ol>
		*<li>单元格类对象。</li>
		*<li> UI 的 JSON 描述。</li>
		*</ol></p>
		*/
		__getset(0, __proto, 'itemRender', function () {
			return this._itemRender;
		}, function (value) {
			if (this._itemRender != value) {
				this._itemRender = value;
				for (var i = this._cells.length - 1; i > -1; i--) {
					this._cells[i].destroy();
				}
				this._cells.length = 0;
				this._setCellChanged();
			}
		});

		/**
		*垂直方向滚动条皮肤。
		*/
		__getset(0, __proto, 'vScrollBarSkin', function () {
			return this._scrollBar ? this._scrollBar.skin : null;
		}, function (value) {
			this._removePreScrollBar();
			var scrollBar = new VScrollBar();
			scrollBar.name = "scrollBar";
			scrollBar.right = 0;
			if (value && value != " ")
				scrollBar.skin = value;
			this.scrollBar = scrollBar;
			this.addChild(scrollBar);
			this._setCellChanged();
		});

		/**
		*列表的当前页码。
		*/
		__getset(0, __proto, 'page', function () {
			return this._page;
		}, function (value) {
			this._page = value
			if (this._array) {
				this._page = value > 0 ? value : 0;
				this._page = this._page < this.totalPage ? this._page : this.totalPage - 1;
				this.startIndex = this._page * this.repeatX * this.repeatY;
			}
		});

		/**
		*水平方向滚动条皮肤。
		*/
		__getset(0, __proto, 'hScrollBarSkin', function () {
			return this._scrollBar ? this._scrollBar.skin : null;
		}, function (value) {
			this._removePreScrollBar();
			var scrollBar = new HScrollBar();
			scrollBar.name = "scrollBar";
			scrollBar.bottom = 0;
			if (value && value != " ")
				scrollBar.skin = value;
			this.scrollBar = scrollBar;
			this.addChild(scrollBar);
			this._setCellChanged();
		});

		/**
		*水平方向显示的单元格数量。
		*/
		__getset(0, __proto, 'repeatX', function () {
			return this._repeatX > 0 ? this._repeatX : this._repeatX2 > 0 ? this._repeatX2 : 1;
		}, function (value) {
			this._repeatX = value;
			this._setCellChanged();
		});

		/**
		*获取对 <code>List</code> 组件所包含的滚动条 <code>ScrollBar</code> 组件的引用。
		*/
		__getset(0, __proto, 'scrollBar', function () {
			return this._scrollBar;
		}, function (value) {
			if (this._scrollBar != value) {
				this._scrollBar = value;
				if (value) {
					this._isVertical = this._scrollBar.isVertical;
					this.addChild(this._scrollBar);
					this._scrollBar.on(/*laya.events.Event.CHANGE*/"change", this, this.onScrollBarChange);
				}
			}
		});

		/**@inheritDoc */
		__getset(0, __proto, 'width', _super.prototype._$get_width, function (value) {
			if (value != this._width) {
				Laya.superSet(Box, this, 'width', value);
				this._setCellChanged();
			}
		});

		/**
		*垂直方向显示的单元格数量。
		*/
		__getset(0, __proto, 'repeatY', function () {
			return this._repeatY > 0 ? this._repeatY : this._repeatY2 > 0 ? this._repeatY2 : 1;
		}, function (value) {
			this._repeatY = value;
			this._setCellChanged();
		});

		/**
		*水平方向显示的单元格之间的间距（以像素为单位）。
		*/
		__getset(0, __proto, 'spaceX', function () {
			return this._spaceX;
		}, function (value) {
			this._spaceX = value;
			this._setCellChanged();
		});

		/**
		*垂直方向显示的单元格之间的间距（以像素为单位）。
		*/
		__getset(0, __proto, 'spaceY', function () {
			return this._spaceY;
		}, function (value) {
			this._spaceY = value;
			this._setCellChanged();
		});

		/**
		*表示当前选择的项索引。selectedIndex值更改会引起list重新渲染
		*/
		__getset(0, __proto, 'selectedIndex', function () {
			return this._selectedIndex;
		}, function (value) {
			if (this._selectedIndex != value) {
				this._selectedIndex = value;
				this.changeSelectStatus();
				this.event(/*laya.events.Event.CHANGE*/"change");
				this.selectHandler && this.selectHandler.runWith(value);
				this.startIndex = this._startIndex;
			}
		});

		/**
		*当前选中的单元格数据源。
		*/
		__getset(0, __proto, 'selectedItem', function () {
			return this._selectedIndex != -1 ? this._array[this._selectedIndex] : null;
		}, function (value) {
			this.selectedIndex = this._array.indexOf(value);
		});

		/**
		*列表的数据总个数。
		*/
		__getset(0, __proto, 'length', function () {
			return this._array ? this._array.length : 0;
		});

		/**
		*获取或设置当前选择的单元格对象。
		*/
		__getset(0, __proto, 'selection', function () {
			return this.getCell(this._selectedIndex);
		}, function (value) {
			this.selectedIndex = this._startIndex + this._cells.indexOf(value);
		});

		/**
		*当前显示的单元格列表的开始索引。
		*/
		__getset(0, __proto, 'startIndex', function () {
			return this._startIndex;
		}, function (value) {
			this._startIndex = value > 0 ? value : 0;
			this.callLater(this.renderItems);
		});

		/**
		*列表数据源。
		*/
		__getset(0, __proto, 'array', function () {
			return this._array;
		}, function (value) {
			this.runCallLater(this.changeCells);
			this._array = value || [];
			var length = this._array.length;
			this.totalPage = Math.ceil(length / (this.repeatX * this.repeatY));
			this._selectedIndex = this._selectedIndex < length ? this._selectedIndex : length - 1;
			this.startIndex = this._startIndex;
			if (this._scrollBar) {
				this._scrollBar.stopScroll();
				var numX = this._isVertical ? this.repeatX : this.repeatY;
				var numY = this._isVertical ? this.repeatY : this.repeatX;
				var lineCount = Math.ceil(length / numX);
				var total = this._cellOffset > 0 ? this.totalPage + 1 : this.totalPage;
				if (total > 1) {
					this._scrollBar.scrollSize = this._cellSize;
					this._scrollBar.thumbPercent = numY / lineCount;
					this._scrollBar.setScroll(0, (lineCount - numY) * this._cellSize + this._cellOffset, this._scrollBar.value);
					this._scrollBar.target = this._content;
				} else {
					this._scrollBar.setScroll(0, 0, 0);
					this._scrollBar.target = this._content;
				}
			}
		});

		/**@inheritDoc */
		__getset(0, __proto, 'dataSource', _super.prototype._$get_dataSource, function (value) {
			this._dataSource = value;
			if (((typeof value == 'number') && Math.floor(value) == value) || (typeof value == 'string')) this.selectedIndex = parseInt(value);
			else if ((value instanceof Array)) this.array = value
			else Laya.superSet(Box, this, 'dataSource', value);
		});

		/**
		*单元格集合。
		*/
		__getset(0, __proto, 'cells', function () {
			this.runCallLater(this.changeCells);
			return this._cells;
		});

		return List;
	})(Box)


	/**
	*使用 <code>HScrollBar</code> （水平 <code>ScrollBar</code> ）控件，可以在因数据太多而不能在显示区域完全显示时控制显示的数据部分。
	*@example <caption>以下示例代码，创建了一个 <code>HScrollBar</code> 实例。</caption>
	*package
	*{
		*import laya.ui.HScrollBar;
		*import laya.utils.Handler;
		*public class HScrollBar_Example
		*{
			*private var hScrollBar:HScrollBar;
			*public function HScrollBar_Example()
			*{
				*Laya.init(640,800);//设置游戏画布宽高。
				*Laya.stage.bgColor="#efefef";//设置画布的背景颜色。
				*Laya.loader.load(["resource/ui/hscroll.png","resource/ui/hscroll$bar.png","resource/ui/hscroll$down.png","resource/ui/hscroll$up.png"],Handler.create(this,onLoadComplete));//加载资源。
				*}
			*private function onLoadComplete():void
			*{
				*hScrollBar=new HScrollBar();//创建一个 HScrollBar 类的实例对象 hScrollBar 。
				*hScrollBar.skin="resource/ui/hscroll.png";//设置 hScrollBar 的皮肤。
				*hScrollBar.x=100;//设置 hScrollBar 对象的属性 x 的值，用于控制 hScrollBar 对象的显示位置。
				*hScrollBar.y=100;//设置 hScrollBar 对象的属性 y 的值，用于控制 hScrollBar 对象的显示位置。
				*hScrollBar.changeHandler=new Handler(this,onChange);//设置 hScrollBar 的滚动变化处理器。
				*Laya.stage.addChild(hScrollBar);//将此 hScrollBar 对象添加到显示列表。
				*}
			*private function onChange(value:Number):void
			*{
				*trace("滚动条的位置： value="+value);
				*}
			*}
		*}
	*@example
	*Laya.init(640,800);//设置游戏画布宽高
	*Laya.stage.bgColor="#efefef";//设置画布的背景颜色
	*var hScrollBar;
	*var res=["resource/ui/hscroll.png","resource/ui/hscroll$bar.png","resource/ui/hscroll$down.png","resource/ui/hscroll$up.png"];
	*Laya.loader.load(res,laya.utils.Handler.create(this,onLoadComplete));//加载资源。
	*function onLoadComplete(){
		*console.log("资源加载完成！");
		*hScrollBar=new laya.ui.HScrollBar();//创建一个 HScrollBar 类的实例对象 hScrollBar 。
		*hScrollBar.skin="resource/ui/hscroll.png";//设置 hScrollBar 的皮肤。
		*hScrollBar.x=100;//设置 hScrollBar 对象的属性 x 的值，用于控制 hScrollBar 对象的显示位置。
		*hScrollBar.y=100;//设置 hScrollBar 对象的属性 y 的值，用于控制 hScrollBar 对象的显示位置。
		*hScrollBar.changeHandler=new laya.utils.Handler(this,onChange);//设置 hScrollBar 的滚动变化处理器。
		*Laya.stage.addChild(hScrollBar);//将此 hScrollBar 对象添加到显示列表。
		*}
	*function onChange(value)
	*{
		*console.log("滚动条的位置： value="+value);
		*}
	*@example
	*import HScrollBar=laya.ui.HScrollBar;
	*import Handler=laya.utils.Handler;
	*class HScrollBar_Example {
		*private hScrollBar:HScrollBar;
		*constructor(){
			*Laya.init(640,800);//设置游戏画布宽高。
			*Laya.stage.bgColor="#efefef";//设置画布的背景颜色。
			*Laya.loader.load(["resource/ui/hscroll.png","resource/ui/hscroll$bar.png","resource/ui/hscroll$down.png","resource/ui/hscroll$up.png"],Handler.create(this,this.onLoadComplete));//加载资源。
			*}
		*private onLoadComplete():void {
			*this.hScrollBar=new HScrollBar();//创建一个 HScrollBar 类的实例对象 hScrollBar 。
			*this.hScrollBar.skin="resource/ui/hscroll.png";//设置 hScrollBar 的皮肤。
			*this.hScrollBar.x=100;//设置 hScrollBar 对象的属性 x 的值，用于控制 hScrollBar 对象的显示位置。
			*this.hScrollBar.y=100;//设置 hScrollBar 对象的属性 y 的值，用于控制 hScrollBar 对象的显示位置。
			*this.hScrollBar.changeHandler=new Handler(this,this.onChange);//设置 hScrollBar 的滚动变化处理器。
			*Laya.stage.addChild(this.hScrollBar);//将此 hScrollBar 对象添加到显示列表。
			*}
		*private onChange(value:number):void {
			*console.log("滚动条的位置： value="+value);
			*}
		*}
	*/
	//class laya.ui.HScrollBar extends laya.ui.ScrollBar
	var HScrollBar = (function (_super) {
		function HScrollBar() {
			HScrollBar.__super.call(this);;
		}

		__class(HScrollBar, 'laya.ui.HScrollBar', _super);
		var __proto = HScrollBar.prototype;
		/**@inheritDoc */
		__proto.initialize = function () {
			_super.prototype.initialize.call(this);
			this.slider.isVertical = false;
		}

		return HScrollBar;
	})(ScrollBar)


	/**
	*<code>Panel</code> 是一个面板容器类。
	*/
	//class laya.ui.Panel extends laya.ui.Box
	var Panel = (function (_super) {
		function Panel() {
			/**@private */
			this._content = null;
			/**@private */
			this._vScrollBar = null;
			/**@private */
			this._hScrollBar = null;
			/**@private */
			this._scrollChanged = false;
			Panel.__super.call(this);
			this.width = this.height = 100;
		}

		__class(Panel, 'laya.ui.Panel', _super);
		var __proto = Panel.prototype;
		/**@inheritDoc */
		__proto.destroy = function (destroyChild) {
			(destroyChild === void 0) && (destroyChild = true);
			laya.ui.Component.prototype.destroy.call(this, destroyChild);
			this._content && this._content.destroy(destroyChild);
			this._vScrollBar && this._vScrollBar.destroy(destroyChild);
			this._hScrollBar && this._hScrollBar.destroy(destroyChild);
			this._vScrollBar = null;
			this._hScrollBar = null;
			this._content = null;
		}

		/**@inheritDoc */
		__proto.destroyChildren = function () {
			this._content.destroyChildren();
		}

		/**@inheritDoc */
		__proto.createChildren = function () {
			laya.display.Node.prototype.addChild.call(this, this._content = new Box());
		}

		/**@inheritDoc */
		__proto.addChild = function (child) {
			child.on(/*laya.events.Event.RESIZE*/"resize", this, this.onResize);
			this._setScrollChanged();
			return this._content.addChild(child);
		}

		/**
		*@private
		*子对象的 <code>Event.RESIZE</code> 事件侦听处理函数。
		*/
		__proto.onResize = function () {
			this._setScrollChanged();
		}

		/**@inheritDoc */
		__proto.addChildAt = function (child, index) {
			child.on(/*laya.events.Event.RESIZE*/"resize", this, this.onResize);
			this._setScrollChanged();
			return this._content.addChildAt(child, index);
		}

		/**@inheritDoc */
		__proto.removeChild = function (child) {
			child.off(/*laya.events.Event.RESIZE*/"resize", this, this.onResize);
			this._setScrollChanged();
			return this._content.removeChild(child);
		}

		/**@inheritDoc */
		__proto.removeChildAt = function (index) {
			this.getChildAt(index).off(/*laya.events.Event.RESIZE*/"resize", this, this.onResize);
			this._setScrollChanged();
			return this._content.removeChildAt(index);
		}

		/**@inheritDoc */
		__proto.removeChildren = function (beginIndex, endIndex) {
			(beginIndex === void 0) && (beginIndex = 0);
			(endIndex === void 0) && (endIndex = 0x7fffffff);
			for (var i = this._content.numChildren - 1; i > -1; i--) {
				this._content.removeChildAt(i);
			}
			this._setScrollChanged();
			return this;
		}

		/**@inheritDoc */
		__proto.getChildAt = function (index) {
			return this._content.getChildAt(index);
		}

		/**@inheritDoc */
		__proto.getChildByName = function (name) {
			return this._content.getChildByName(name);
		}

		/**@inheritDoc */
		__proto.getChildIndex = function (child) {
			return this._content.getChildIndex(child);
		}

		/**@private */
		__proto.changeScroll = function () {
			this._scrollChanged = false;
			var contentW = this.contentWidth || 1;
			var contentH = this.contentHeight || 1;
			var vscroll = this._vScrollBar;
			var hscroll = this._hScrollBar;
			var vShow = vscroll && contentH > this._height;
			var hShow = hscroll && contentW > this._width;
			var showWidth = vShow ? this._width - vscroll.width : this._width;
			var showHeight = hShow ? this._height - hscroll.height : this._height;
			if (vscroll) {
				vscroll.x = this._width - vscroll.width;
				vscroll.y = 0;
				vscroll.height = this._height - (hShow ? hscroll.height : 0);
				vscroll.scrollSize = Math.max(this._height * 0.033, 1);
				vscroll.thumbPercent = showHeight / contentH;
				vscroll.setScroll(0, contentH - showHeight, vscroll.value);
			}
			if (hscroll) {
				hscroll.x = 0;
				hscroll.y = this._height - hscroll.height;
				hscroll.width = this._width - (vShow ? vscroll.width : 0);
				hscroll.scrollSize = Math.max(this._width * 0.033, 1);
				hscroll.thumbPercent = showWidth / contentW;
				hscroll.setScroll(0, contentW - showWidth, hscroll.value);
			}
		}

		/**@inheritDoc */
		__proto.changeSize = function () {
			laya.ui.Component.prototype.changeSize.call(this);
			this.setContentSize(this._width, this._height);
		}

		/**
		*@private
		*设置内容的宽度、高度（以像素为单位）。
		*@param width 宽度。
		*@param height 高度。
		*/
		__proto.setContentSize = function (width, height) {
			var content = this._content;
			content.width = width;
			content.height = height;
			content.scrollRect || (content.scrollRect = new Rectangle());
			content.scrollRect.setTo(0, 0, width, height);
			content.scrollRect = content.scrollRect;
		}

		/**
		*@private
		*滚动条的<code><code>Event.MOUSE_DOWN</code>事件侦听处理函数。</code>事件侦听处理函数。
		*@param scrollBar 滚动条对象。
		*@param e Event 对象。
		*/
		__proto.onScrollBarChange = function (scrollBar) {
			var rect = this._content.scrollRect;
			if (rect) {
				var start = Math.round(scrollBar.value);
				scrollBar.isVertical ? rect.y = start : rect.x = start;
				this._content.scrollRect = rect;
			}
		}

		/**
		*<p>滚动内容容器至设定的垂直、水平方向滚动条位置。</p>
		*@param x 水平方向滚动条属性value值。滚动条位置数字。
		*@param y 垂直方向滚动条属性value值。滚动条位置数字。
		*/
		__proto.scrollTo = function (x, y) {
			(x === void 0) && (x = 0);
			(y === void 0) && (y = 0);
			if (this.vScrollBar) this.vScrollBar.value = y;
			if (this.hScrollBar) this.hScrollBar.value = x;
		}

		/**
		*刷新滚动内容。
		*/
		__proto.refresh = function () {
			this.changeScroll();
		}

		__proto.onScrollStart = function () {
			this._$P.cacheAs || (this._$P.cacheAs = Laya.superGet(Box, this, 'cacheAs'));
			Laya.superSet(Box, this, 'cacheAs', "none");
			this._hScrollBar && this._hScrollBar.once(/*laya.events.Event.END*/"end", this, this.onScrollEnd);
			this._vScrollBar && this._vScrollBar.once(/*laya.events.Event.END*/"end", this, this.onScrollEnd);
		}

		__proto.onScrollEnd = function () {
			Laya.superSet(Box, this, 'cacheAs', this._$P.cacheAs);
		}

		/**@private */
		__proto._setScrollChanged = function () {
			if (!this._scrollChanged) {
				this._scrollChanged = true;
				this.callLater(this.changeScroll);
			}
		}

		/**@inheritDoc */
		__getset(0, __proto, 'numChildren', function () {
			return this._content.numChildren;
		});

		/**
		*水平方向滚动条皮肤。
		*/
		__getset(0, __proto, 'hScrollBarSkin', function () {
			return this._hScrollBar ? this._hScrollBar.skin : null;
		}, function (value) {
			if (this._hScrollBar == null) {
				laya.display.Node.prototype.addChild.call(this, this._hScrollBar = new HScrollBar());
				this._hScrollBar.on(/*laya.events.Event.CHANGE*/"change", this, this.onScrollBarChange, [this._hScrollBar]);
				this._hScrollBar.target = this._content;
				this._setScrollChanged();
			}
			this._hScrollBar.skin = value;
		});

		/**
		*@private
		*获取内容宽度（以像素为单位）。
		*/
		__getset(0, __proto, 'contentWidth', function () {
			var max = 0;
			for (var i = this._content.numChildren - 1; i > -1; i--) {
				var comp = this._content.getChildAt(i);
				max = Math.max(comp.x + comp.width * comp.scaleX, max);
			}
			return max;
		});

		/**
		*@private
		*获取内容高度（以像素为单位）。
		*/
		__getset(0, __proto, 'contentHeight', function () {
			var max = 0;
			for (var i = this._content.numChildren - 1; i > -1; i--) {
				var comp = this._content.getChildAt(i);
				max = Math.max(comp.y + comp.height * comp.scaleY, max);
			}
			return max;
		});

		/**
		*@inheritDoc
		*/
		__getset(0, __proto, 'width', _super.prototype._$get_width, function (value) {
			Laya.superSet(Box, this, 'width', value);
			this._setScrollChanged();
		});

		/**
		*水平方向滚动条对象。
		*/
		__getset(0, __proto, 'hScrollBar', function () {
			return this._hScrollBar;
		});

		/**
		*获取内容容器对象。
		*/
		__getset(0, __proto, 'content', function () {
			return this._content;
		});

		/**@inheritDoc */
		__getset(0, __proto, 'height', _super.prototype._$get_height, function (value) {
			Laya.superSet(Box, this, 'height', value);
			this._setScrollChanged();
		});

		/**
		*垂直方向滚动条皮肤。
		*/
		__getset(0, __proto, 'vScrollBarSkin', function () {
			return this._vScrollBar ? this._vScrollBar.skin : null;
		}, function (value) {
			if (this._vScrollBar == null) {
				laya.display.Node.prototype.addChild.call(this, this._vScrollBar = new VScrollBar());
				this._vScrollBar.on(/*laya.events.Event.CHANGE*/"change", this, this.onScrollBarChange, [this._vScrollBar]);
				this._vScrollBar.target = this._content;
				this._setScrollChanged();
			}
			this._vScrollBar.skin = value;
		});

		/**
		*垂直方向滚动条对象。
		*/
		__getset(0, __proto, 'vScrollBar', function () {
			return this._vScrollBar;
		});

		/**@inheritDoc */
		__getset(0, __proto, 'cacheAs', _super.prototype._$get_cacheAs, function (value) {
			Laya.superSet(Box, this, 'cacheAs', value);
			this._$P.cacheAs = null;
			if (value !== "none") {
				this._hScrollBar && this._hScrollBar.on(/*laya.events.Event.START*/"start", this, this.onScrollStart);
				this._vScrollBar && this._vScrollBar.on(/*laya.events.Event.START*/"start", this, this.onScrollStart);
			} else {
				this._hScrollBar && this._hScrollBar.off(/*laya.events.Event.START*/"start", this, this.onScrollStart);
				this._vScrollBar && this._vScrollBar.off(/*laya.events.Event.START*/"start", this, this.onScrollStart);
			}
		});

		return Panel;
	})(Box)


	/**
	*<code>Group</code> 是一个可以自动布局的项集合控件。
	*<p> <code>Group</code> 的默认项对象为 <code>Button</code> 类实例。
	*<code>Group</code> 是 <code>Tab</code> 和 <code>RadioGroup</code> 的基类。</p>
	*/
	//class laya.ui.UIGroup extends laya.ui.Box
	var UIGroup = (function (_super) {
		function UIGroup(labels, skin) {
			/**
			*改变 <code>Group</code> 的选择项时执行的处理器，(默认返回参数： 项索引（index:int）)。
			*/
			this.selectHandler = null;
			/**@private */
			this._items = null;
			/**@private */
			this._selectedIndex = -1;
			/**@private */
			this._skin = null;
			/**@private */
			this._direction = "horizontal";
			/**@private */
			this._space = 0;
			/**@private */
			this._labels = null;
			/**@private */
			this._labelColors = null;
			/**@private */
			this._labelFont = null;
			/**@private */
			this._labelStrokeColor = null;
			/**@private */
			this._strokeColors = null;
			/**@private */
			this._labelStroke = NaN;
			/**@private */
			this._labelSize = 0;
			/**@private */
			this._labelBold = false;
			/**@private */
			this._labelPadding = null;
			/**@private */
			this._labelAlign = null;
			/**@private */
			this._stateNum = 0;
			/**@private */
			this._labelChanged = false;
			UIGroup.__super.call(this);
			this.skin = skin;
			this.labels = labels;
		}

		__class(UIGroup, 'laya.ui.UIGroup', _super);
		var __proto = UIGroup.prototype;
		Laya.imps(__proto, { "laya.ui.IItem": true })
		/**@inheritDoc */
		__proto.preinitialize = function () {
			this.mouseEnabled = true;
		}

		/**@inheritDoc */
		__proto.destroy = function (destroyChild) {
			(destroyChild === void 0) && (destroyChild = true);
			laya.ui.Component.prototype.destroy.call(this, destroyChild);
			this._items && (this._items.length = 0);
			this._items = null;
			this.selectHandler = null;
		}

		/**
		*添加一个项对象，返回此项对象的索引id。
		*
		*@param item 需要添加的项对象。
		*@param autoLayOut 是否自动布局，如果为true，会根据 <code>direction</code> 和 <code>space</code> 属性计算item的位置。
		*@return
		*/
		__proto.addItem = function (item, autoLayOut) {
			(autoLayOut === void 0) && (autoLayOut = true);
			var display = item;
			var index = this._items.length;
			display.name = "item" + index;
			this.addChild(display);
			this.initItems();
			if (autoLayOut && index > 0) {
				var preItem = this._items[index - 1];
				if (this._direction == "horizontal") {
					display.x = preItem.x + preItem.width + this._space;
				} else {
					display.y = preItem.y + preItem.height + this._space;
				}
			} else {
				if (autoLayOut) {
					display.x = 0;
					display.y = 0;
				}
			}
			return index;
		}

		/**
		*删除一个项对象。
		*@param item 需要删除的项对象。
		*@param autoLayOut 是否自动布局，如果为true，会根据 <code>direction</code> 和 <code>space</code> 属性计算item的位置。
		*/
		__proto.delItem = function (item, autoLayOut) {
			(autoLayOut === void 0) && (autoLayOut = true);
			var index = this._items.indexOf(item);
			if (index != -1) {
				var display = item;
				this.removeChild(display);
				for (var i = index + 1, n = this._items.length; i < n; i++) {
					var child = this._items[i];
					child.name = "item" + (i - 1);
					if (autoLayOut) {
						if (this._direction == "horizontal") {
							child.x -= display.width + this._space;
						} else {
							child.y -= display.height + this._space;
						}
					}
				}
				this.initItems();
				if (this._selectedIndex > -1) {
					var newIndex = 0;
					newIndex = this._selectedIndex < this._items.length ? this._selectedIndex : (this._selectedIndex - 1);
					this._selectedIndex = -1;
					this.selectedIndex = newIndex;
				}
			}
		}

		/**
		*初始化项对象们。
		*/
		__proto.initItems = function () {
			this._items || (this._items = []);
			this._items.length = 0;
			for (var i = 0; i < 10000; i++) {
				var item = this.getChildByName("item" + i);
				if (item == null) break;
				this._items.push(item);
				item.selected = (i === this._selectedIndex);
				item.clickHandler = Handler.create(this, this.itemClick, [i], false);
			}
		}

		/**
		*@private
		*项对象的点击事件侦听处理函数。
		*@param index 项索引。
		*/
		__proto.itemClick = function (index) {
			this.selectedIndex = index;
		}

		/**
		*@private
		*通过对象的索引设置项对象的 <code>selected</code> 属性值。
		*@param index 需要设置的项对象的索引。
		*@param selected 表示项对象的选中状态。
		*/
		__proto.setSelect = function (index, selected) {
			if (this._items && index > -1 && index < this._items.length) this._items[index].selected = selected;
		}

		/**
		*@private
		*创建一个项显示对象。
		*@param skin 项对象的皮肤。
		*@param label 项对象标签。
		*/
		__proto.createItem = function (skin, label) {
			return null;
		}

		/**
		*@private
		*更改项对象的属性值。
		*/
		__proto.changeLabels = function () {
			this._labelChanged = false;
			if (this._items) {
				var left = 0
				for (var i = 0, n = this._items.length; i < n; i++) {
					var btn = this._items[i];
					this._skin && (btn.skin = this._skin);
					this._labelColors && (btn.labelColors = this._labelColors);
					this._labelSize && (btn.labelSize = this._labelSize);
					this._labelStroke && (btn.labelStroke = this._labelStroke);
					this._labelStrokeColor && (btn.labelStrokeColor = this._labelStrokeColor);
					this._strokeColors && (btn.strokeColors = this._strokeColors);
					this._labelBold && (btn.labelBold = this._labelBold);
					this._labelPadding && (btn.labelPadding = this._labelPadding);
					this._labelAlign && (btn.labelAlign = this._labelAlign);
					this._stateNum && (btn.stateNum = this._stateNum);
					this._labelFont && (btn.labelFont = this._labelFont);
					if (this._direction === "horizontal") {
						btn.y = 0;
						btn.x = left;
						left += btn.width + this._space;
					} else {
						btn.x = 0;
						btn.y = left;
						left += btn.height + this._space;
					}
				}
			}
			this.changeSize();
		}

		/**@inheritDoc */
		__proto.commitMeasure = function () {
			this.runCallLater(this.changeLabels);
		}

		/**@private */
		__proto._setLabelChanged = function () {
			if (!this._labelChanged) {
				this._labelChanged = true;
				this.callLater(this.changeLabels);
			}
		}

		/**
		*<p>描边颜色，以字符串表示。</p>
		*默认值为 "#000000"（黑色）;
		*@see laya.display.Text.strokeColor()
		*/
		__getset(0, __proto, 'labelStrokeColor', function () {
			return this._labelStrokeColor;
		}, function (value) {
			if (this._labelStrokeColor != value) {
				this._labelStrokeColor = value;
				this._setLabelChanged();
			}
		});

		/**
		*@copy laya.ui.Image#skin
		*/
		__getset(0, __proto, 'skin', function () {
			return this._skin;
		}, function (value) {
			if (this._skin != value) {
				this._skin = value;
				this._setLabelChanged();
			}
		});

		/**
		*表示当前选择的项索引。默认值为-1。
		*/
		__getset(0, __proto, 'selectedIndex', function () {
			return this._selectedIndex;
		}, function (value) {
			if (this._selectedIndex != value) {
				this.setSelect(this._selectedIndex, false);
				this._selectedIndex = value;
				this.setSelect(value, true);
				this.event(/*laya.events.Event.CHANGE*/"change");
				this.selectHandler && this.selectHandler.runWith(this._selectedIndex);
			}
		});

		/**
		*标签集合字符串。以逗号做分割，如"item0,item1,item2,item3,item4,item5"。
		*/
		__getset(0, __proto, 'labels', function () {
			return this._labels;
		}, function (value) {
			if (this._labels != value) {
				this._labels = value;
				this.removeChildren();
				this._setLabelChanged();
				if (this._labels) {
					var a = this._labels.split(",");
					for (var i = 0, n = a.length; i < n; i++) {
						var item = this.createItem(this._skin, a[i]);
						item.name = "item" + i;
						this.addChild(item);
					}
				}
				this.initItems();
			}
		});

		/**
		*<p>表示各个状态下的描边颜色。</p>
		*@see laya.display.Text.strokeColor()
		*/
		__getset(0, __proto, 'strokeColors', function () {
			return this._strokeColors;
		}, function (value) {
			if (this._strokeColors != value) {
				this._strokeColors = value;
				this._setLabelChanged();
			}
		});

		/**
		*@copy laya.ui.Button#labelColors()
		*/
		__getset(0, __proto, 'labelColors', function () {
			return this._labelColors;
		}, function (value) {
			if (this._labelColors != value) {
				this._labelColors = value;
				this._setLabelChanged();
			}
		});

		/**
		*<p>描边宽度（以像素为单位）。</p>
		*默认值0，表示不描边。
		*@see laya.display.Text.stroke()
		*/
		__getset(0, __proto, 'labelStroke', function () {
			return this._labelStroke;
		}, function (value) {
			if (this._labelStroke != value) {
				this._labelStroke = value;
				this._setLabelChanged();
			}
		});

		/**
		*表示按钮文本标签的字体大小。
		*/
		__getset(0, __proto, 'labelSize', function () {
			return this._labelSize;
		}, function (value) {
			if (this._labelSize != value) {
				this._labelSize = value;
				this._setLabelChanged();
			}
		});

		/**
		*表示按钮的状态值，以数字表示，默认为3态。
		*@see laya.ui.Button#stateNum
		*/
		__getset(0, __proto, 'stateNum', function () {
			return this._stateNum;
		}, function (value) {
			if (this._stateNum != value) {
				this._stateNum = value;
				this._setLabelChanged();
			}
		});

		/**
		*表示按钮文本标签是否为粗体字。
		*/
		__getset(0, __proto, 'labelBold', function () {
			return this._labelBold;
		}, function (value) {
			if (this._labelBold != value) {
				this._labelBold = value;
				this._setLabelChanged();
			}
		});

		/**
		*表示按钮文本标签的字体名称，以字符串形式表示。
		*@see laya.display.Text.font()
		*/
		__getset(0, __proto, 'labelFont', function () {
			return this._labelFont;
		}, function (value) {
			if (this._labelFont != value) {
				this._labelFont = value;
				this._setLabelChanged();
			}
		});

		/**
		*表示按钮文本标签的边距。
		*<p><b>格式：</b>"上边距,右边距,下边距,左边距"。</p>
		*/
		__getset(0, __proto, 'labelPadding', function () {
			return this._labelPadding;
		}, function (value) {
			if (this._labelPadding != value) {
				this._labelPadding = value;
				this._setLabelChanged();
			}
		});

		/**
		*布局方向。
		*<p>默认值为"horizontal"。</p>
		*<p><b>取值：</b>
		*<li>"horizontal"：表示水平布局。</li>
		*<li>"vertical"：表示垂直布局。</li>
		*</p>
		*/
		__getset(0, __proto, 'direction', function () {
			return this._direction;
		}, function (value) {
			this._direction = value;
			this._setLabelChanged();
		});

		/**
		*项对象们之间的间隔（以像素为单位）。
		*/
		__getset(0, __proto, 'space', function () {
			return this._space;
		}, function (value) {
			this._space = value;
			this._setLabelChanged();
		});

		/**
		*项对象们的存放数组。
		*/
		__getset(0, __proto, 'items', function () {
			return this._items;
		});

		/**
		*获取或设置当前选择的项对象。
		*/
		__getset(0, __proto, 'selection', function () {
			return this._selectedIndex > -1 && this._selectedIndex < this._items.length ? this._items[this._selectedIndex] : null;
		}, function (value) {
			this.selectedIndex = this._items.indexOf(value);
		});

		/**@inheritDoc */
		__getset(0, __proto, 'dataSource', _super.prototype._$get_dataSource, function (value) {
			this._dataSource = value;
			if (((typeof value == 'number') && Math.floor(value) == value) || (typeof value == 'string')) this.selectedIndex = parseInt(value);
			else if ((value instanceof Array)) this.labels = (value).join(",");
			else Laya.superSet(Box, this, 'dataSource', value);
		});

		return UIGroup;
	})(Box)


	/**
	*使用 <code>HSlider</code> 控件，用户可以通过在滑块轨道的终点之间移动滑块来选择值。
	*<p> <code>HSlider</code> 控件采用水平方向。滑块轨道从左向右扩展，而标签位于轨道的顶部或底部。</p>
	*
	*@example <caption>以下示例代码，创建了一个 <code>HSlider</code> 实例。</caption>
	*package
	*{
		*import laya.ui.HSlider;
		*import laya.utils.Handler;
		*public class HSlider_Example
		*{
			*private var hSlider:HSlider;
			*public function HSlider_Example()
			*{
				*Laya.init(640,800);//设置游戏画布宽高。
				*Laya.stage.bgColor="#efefef";//设置画布的背景颜色。
				*Laya.loader.load(["resource/ui/hslider.png","resource/ui/hslider$bar.png"],Handler.create(this,onLoadComplete));//加载资源。
				*}
			*private function onLoadComplete():void
			*{
				*hSlider=new HSlider();//创建一个 HSlider 类的实例对象 hSlider 。
				*hSlider.skin="resource/ui/hslider.png";//设置 hSlider 的皮肤。
				*hSlider.min=0;//设置 hSlider 最低位置值。
				*hSlider.max=10;//设置 hSlider 最高位置值。
				*hSlider.value=2;//设置 hSlider 当前位置值。
				*hSlider.tick=1;//设置 hSlider 刻度值。
				*hSlider.x=100;//设置 hSlider 对象的属性 x 的值，用于控制 hSlider 对象的显示位置。
				*hSlider.y=100;//设置 hSlider 对象的属性 y 的值，用于控制 hSlider 对象的显示位置。
				*hSlider.changeHandler=new Handler(this,onChange);//设置 hSlider 位置变化处理器。
				*Laya.stage.addChild(hSlider);//把 hSlider 添加到显示列表。
				*}
			*private function onChange(value:Number):void
			*{
				*trace("滑块的位置： value="+value);
				*}
			*}
		*}
	*@example
	*Laya.init(640,800,"canvas");//设置游戏画布宽高、渲染模式
	*Laya.stage.bgColor="#efefef";//设置画布的背景颜色
	*var hSlider;
	*var res=["resource/ui/hslider.png","resource/ui/hslider$bar.png"];
	*Laya.loader.load(res,laya.utils.Handler.create(this,onLoadComplete));
	*function onLoadComplete(){
		*console.log("资源加载完成！");
		*hSlider=new laya.ui.HSlider();//创建一个 HSlider 类的实例对象 hSlider 。
		*hSlider.skin="resource/ui/hslider.png";//设置 hSlider 的皮肤。
		*hSlider.min=0;//设置 hSlider 最低位置值。
		*hSlider.max=10;//设置 hSlider 最高位置值。
		*hSlider.value=2;//设置 hSlider 当前位置值。
		*hSlider.tick=1;//设置 hSlider 刻度值。
		*hSlider.x=100;//设置 hSlider 对象的属性 x 的值，用于控制 hSlider 对象的显示位置。
		*hSlider.y=100;//设置 hSlider 对象的属性 y 的值，用于控制 hSlider 对象的显示位置。
		*hSlider.changeHandler=new laya.utils.Handler(this,onChange);//设置 hSlider 位置变化处理器。
		*Laya.stage.addChild(hSlider);//把 hSlider 添加到显示列表。
		*}
	*function onChange(value)
	*{
		*console.log("滑块的位置： value="+value);
		*}
	*@example
	*import Handler=laya.utils.Handler;
	*import HSlider=laya.ui.HSlider;
	*class HSlider_Example {
		*private hSlider:HSlider;
		*constructor(){
			*Laya.init(640,800);//设置游戏画布宽高。
			*Laya.stage.bgColor="#efefef";//设置画布的背景颜色。
			*Laya.loader.load(["resource/ui/hslider.png","resource/ui/hslider$bar.png"],Handler.create(this,this.onLoadComplete));//加载资源。
			*}
		*private onLoadComplete():void {
			*this.hSlider=new HSlider();//创建一个 HSlider 类的实例对象 hSlider 。
			*this.hSlider.skin="resource/ui/hslider.png";//设置 hSlider 的皮肤。
			*this.hSlider.min=0;//设置 hSlider 最低位置值。
			*this.hSlider.max=10;//设置 hSlider 最高位置值。
			*this.hSlider.value=2;//设置 hSlider 当前位置值。
			*this.hSlider.tick=1;//设置 hSlider 刻度值。
			*this.hSlider.x=100;//设置 hSlider 对象的属性 x 的值，用于控制 hSlider 对象的显示位置。
			*this.hSlider.y=100;//设置 hSlider 对象的属性 y 的值，用于控制 hSlider 对象的显示位置。
			*this.hSlider.changeHandler=new Handler(this,this.onChange);//设置 hSlider 位置变化处理器。
			*Laya.stage.addChild(this.hSlider);//把 hSlider 添加到显示列表。
			*}
		*private onChange(value:number):void {
			*console.log("滑块的位置： value="+value);
			*}
		*}
	*
	*@see laya.ui.Slider
	*/
	//class laya.ui.HSlider extends laya.ui.Slider
	var HSlider = (function (_super) {
		/**
		*创建一个 <code>HSlider</code> 类实例。
		*@param skin 皮肤。
		*/
		function HSlider(skin) {
			HSlider.__super.call(this, skin);
			this.isVertical = false;
		}

		__class(HSlider, 'laya.ui.HSlider', _super);
		return HSlider;
	})(Slider)


	/**
	*<code>Radio</code> 控件使用户可在一组互相排斥的选择中做出一种选择。
	*用户一次只能选择 <code>Radio</code> 组中的一个成员。选择未选中的组成员将取消选择该组中当前所选的 <code>Radio</code> 控件。
	*@see laya.ui.RadioGroup
	*/
	//class laya.ui.Radio extends laya.ui.Button
	var Radio = (function (_super) {
		function Radio(skin, label) {
			/**@private */
			this._value = null;
			(label === void 0) && (label = "");
			Radio.__super.call(this, skin, label);
		}

		__class(Radio, 'laya.ui.Radio', _super);
		var __proto = Radio.prototype;
		/**@inheritDoc */
		__proto.destroy = function (destroyChild) {
			(destroyChild === void 0) && (destroyChild = true);
			_super.prototype.destroy.call(this, destroyChild);
			this._value = null;
		}

		/**@inheritDoc */
		__proto.preinitialize = function () {
			laya.ui.Component.prototype.preinitialize.call(this);
			this.toggle = false;
			this._autoSize = false;
		}

		/**@inheritDoc */
		__proto.initialize = function () {
			_super.prototype.initialize.call(this);
			this.createText();
			this._text.align = "left";
			this._text.valign = "top";
			this._text.width = 0;
			this.on(/*laya.events.Event.CLICK*/"click", this, this.onClick);
		}

		/**
		*@private
		*对象的<code>Event.CLICK</code>事件侦听处理函数。
		*/
		__proto.onClick = function (e) {
			this.selected = true;
		}

		/**
		*获取或设置 <code>Radio</code> 关联的可选用户定义值。
		*/
		__getset(0, __proto, 'value', function () {
			return this._value != null ? this._value : this.label;
		}, function (obj) {
			this._value = obj;
		});

		return Radio;
	})(Button)


	/**
	*<code>Tree</code> 控件使用户可以查看排列为可扩展树的层次结构数据。
	*
	*@example
	*package
	*{
		*import laya.ui.Tree;
		*import laya.utils.Browser;
		*import laya.utils.Handler;
		*public class Tree_Example
		*{
			*public function Tree_Example()
			*{
				*Laya.init(640,800);
				*Laya.stage.bgColor="#efefef";//设置画布的背景颜色。
				*Laya.loader.load(["resource/ui/vscroll.png","resource/ui/vscroll$bar.png","resource/ui/vscroll$down.png","resource/ui/vscroll$up.png","resource/ui/clip_selectBox.png","resource/ui/clip_tree_folder.png","resource/ui/clip_tree_arrow.png"],Handler.create(this,onLoadComplete));
				*}
			*private function onLoadComplete():void
			*{
				*var xmlString:String;//创建一个xml字符串，用于存储树结构数据。
				*xmlString="&lt;root&gt;&lt;item label='box1'&gt;&lt;abc label='child1'/&gt;&lt;abc label='child2'/&gt;&lt;abc label='child3'/&gt;&lt;abc label='child4'/&gt;&lt;abc label='child5'/&gt;&lt;/item&gt;&lt;item label='box2'&gt;&lt;abc label='child1'/&gt;&lt;abc label='child2'/&gt;&lt;abc label='child3'/&gt;&lt;abc label='child4'/&gt;&lt;/item&gt;&lt;/root&gt;";
				*var domParser:*=new Browser.window.DOMParser();//创建一个DOMParser实例domParser。
				*var xml:*=domParser.parseFromString(xmlString,"text/xml");//解析xml字符。
				*var tree:Tree=new Tree();//创建一个 Tree 类的实例对象 tree 。
				*tree.scrollBarSkin="resource/ui/vscroll.png";//设置 tree 的皮肤。
				*tree.itemRender=Item;//设置 tree 的项渲染器。
				*tree.xml=xml;//设置 tree 的树结构数据。
				*tree.x=100;//设置 tree 对象的属性 x 的值，用于控制 tree 对象的显示位置。
				*tree.y=100;//设置 tree 对象的属性 y 的值，用于控制 tree 对象的显示位置。
				*tree.width=200;//设置 tree 的宽度。
				*tree.height=100;//设置 tree 的高度。
				*Laya.stage.addChild(tree);//将 tree 添加到显示列表。
				*}
			*}
		*}
	*import laya.ui.Box;
	*import laya.ui.Clip;
	*import laya.ui.Label;
	*class Item extends Box
	*{
		*public function Item()
		*{
			*this.name="render";
			*this.right=0;
			*this.left=0;
			*var selectBox:Clip=new Clip("resource/ui/clip_selectBox.png",1,2);
			*selectBox.name="selectBox";
			*selectBox.height=24;
			*selectBox.x=13;
			*selectBox.y=0;
			*selectBox.left=12;
			*addChild(selectBox);
			*var folder:Clip=new Clip("resource/ui/clip_tree_folder.png",1,3);
			*folder.name="folder";
			*folder.x=14;
			*folder.y=4;
			*addChild(folder);
			*var label:Label=new Label("treeItem");
			*label.name="label";
			*label.color="#ffff00";
			*label.width=150;
			*label.height=22;
			*label.x=33;
			*label.y=1;
			*label.left=33;
			*label.right=0;
			*addChild(label);
			*var arrow:Clip=new Clip("resource/ui/clip_tree_arrow.png",1,2);
			*arrow.name="arrow";
			*arrow.x=0;
			*arrow.y=5;
			*addChild(arrow);
			*}
		*}
	*@example
	*Laya.init(640,800);//设置游戏画布宽高、渲染模式
	*Laya.stage.bgColor="#efefef";//设置画布的背景颜色
	*var res=["resource/ui/vscroll.png","resource/ui/vscroll$bar.png","resource/ui/vscroll$down.png","resource/ui/vscroll$up.png","resource/ui/clip_selectBox.png","resource/ui/clip_tree_folder.png","resource/ui/clip_tree_arrow.png"];
	*Laya.loader.load(res,new laya.utils.Handler(this,onLoadComplete));
	*function onLoadComplete(){
		*var xmlString;//创建一个xml字符串，用于存储树结构数据。
		*xmlString="&lt;root&gt;&lt;item label='box1'&gt;&lt;abc label='child1'/&gt;&lt;abc label='child2'/&gt;&lt;abc label='child3'/&gt;&lt;abc label='child4'/&gt;&lt;abc label='child5'/&gt;&lt;/item&gt;&lt;item label='box2'&gt;&lt;abc label='child1'/&gt;&lt;abc label='child2'/&gt;&lt;abc label='child3'/&gt;&lt;abc label='child4'/&gt;&lt;/item&gt;&lt;/root&gt;";
		*var domParser=new laya.utils.Browser.window.DOMParser();//创建一个DOMParser实例domParser。
		*var xml=domParser.parseFromString(xmlString,"text/xml");//解析xml字符。
		*var tree=new laya.ui.Tree();//创建一个 Tree 类的实例对象 tree 。
		*tree.scrollBarSkin="resource/ui/vscroll.png";//设置 tree 的皮肤。
		*tree.itemRender=mypackage.treeExample.Item;//设置 tree 的项渲染器。
		*tree.xml=xml;//设置 tree 的树结构数据。
		*tree.x=100;//设置 tree 对象的属性 x 的值，用于控制 tree 对象的显示位置。
		*tree.y=100;//设置 tree 对象的属性 y 的值，用于控制 tree 对象的显示位置。
		*tree.width=200;//设置 tree 的宽度。
		*tree.height=100;//设置 tree 的高度。
		*Laya.stage.addChild(tree);//将 tree 添加到显示列表。
		*}
	*(function (_super){
		*function Item(){
			*Item.__super.call(this);//初始化父类。
			*this.right=0;
			*this.left=0;
			*var selectBox=new laya.ui.Clip("resource/ui/clip_selectBox.png",1,2);
			*selectBox.name="selectBox";//设置 selectBox 的name 为“selectBox”时，将被识别为树结构的项的背景。2帧：悬停时背景、选中时背景。
			*selectBox.height=24;
			*selectBox.x=13;
			*selectBox.y=0;
			*selectBox.left=12;
			*this.addChild(selectBox);//需要使用this.访问父类的属性或方法。
			*var folder=new laya.ui.Clip("resource/ui/clip_tree_folder.png",1,3);
			*folder.name="folder";//设置 folder 的name 为“folder”时，将被识别为树结构的文件夹开启状态图表。2帧：折叠状态、打开状态。
			*folder.x=14;
			*folder.y=4;
			*this.addChild(folder);
			*var label=new laya.ui.Label("treeItem");
			*label.name="label";//设置 label 的name 为“label”时，此值将用于树结构数据赋值。
			*label.color="#ffff00";
			*label.width=150;
			*label.height=22;
			*label.x=33;
			*label.y=1;
			*label.left=33;
			*label.right=0;
			*this.addChild(label);
			*var arrow=new laya.ui.Clip("resource/ui/clip_tree_arrow.png",1,2);
			*arrow.name="arrow";//设置 arrow 的name 为“arrow”时，将被识别为树结构的文件夹开启状态图表。2帧：折叠状态、打开状态。
			*arrow.x=0;
			*arrow.y=5;
			*this.addChild(arrow);
			*};
		*Laya.class(Item,"mypackage.treeExample.Item",_super);//注册类 Item 。
		*})(laya.ui.Box);
	*@example
	*import Tree=laya.ui.Tree;
	*import Browser=laya.utils.Browser;
	*import Handler=laya.utils.Handler;
	*class Tree_Example {
		*constructor(){
			*Laya.init(640,800);
			*Laya.stage.bgColor="#efefef";//设置画布的背景颜色。
			*Laya.loader.load(["resource/ui/vscroll.png","resource/ui/vscroll$bar.png","resource/ui/vscroll$down.png","resource/ui/vscroll$up.png","resource/ui/vscroll$up.png","resource/ui/clip_selectBox.png","resource/ui/clip_tree_folder * . * png","resource/ui/clip_tree_arrow.png"],Handler.create(this,this.onLoadComplete));
			*}
		*private onLoadComplete():void {
			*var xmlString:String;//创建一个xml字符串，用于存储树结构数据。
			*xmlString="&lt;root&gt;&lt;item label='box1'&gt;&lt;abc label='child1'/&gt;&lt;abc label='child2'/&gt;&lt;abc label='child3'/&gt;&lt;abc label='child4'/&gt;&lt;abc label='child5'/&gt;&lt;/item&gt;&lt;item label='box2'&gt;&lt;abc  * label='child1'/&gt;&lt;abc label='child2'/&gt;&lt;abc label='child3'/&gt;&lt;abc label='child4'/&gt;&lt;/item&gt;&lt;/root&gt;";
			*var domParser:any=new Browser.window.DOMParser();//创建一个DOMParser实例domParser。
			*var xml:any=domParser.parseFromString(xmlString,"text/xml");//解析xml字符。
			*var tree:Tree=new Tree();//创建一个 Tree 类的实例对象 tree 。
			*tree.scrollBarSkin="resource/ui/vscroll.png";//设置 tree 的皮肤。
			*tree.itemRender=Item;//设置 tree 的项渲染器。
			*tree.xml=xml;//设置 tree 的树结构数据。
			*tree.x=100;//设置 tree 对象的属性 x 的值，用于控制 tree 对象的显示位置。
			*tree.y=100;//设置 tree 对象的属性 y 的值，用于控制 tree 对象的显示位置。
			*tree.width=200;//设置 tree 的宽度。
			*tree.height=100;//设置 tree 的高度。
			*Laya.stage.addChild(tree);//将 tree 添加到显示列表。
			*}
		*}
	*import Box=laya.ui.Box;
	*import Clip=laya.ui.Clip;
	*import Label=laya.ui.Label;
	*class Item extends Box {
		*constructor(){
			*super();
			*this.name="render";
			*this.right=0;
			*this.left=0;
			*var selectBox:Clip=new Clip("resource/ui/clip_selectBox.png",1,2);
			*selectBox.name="selectBox";
			*selectBox.height=24;
			*selectBox.x=13;
			*selectBox.y=0;
			*selectBox.left=12;
			*this.addChild(selectBox);
			*var folder:Clip=new Clip("resource/ui/clip_tree_folder.png",1,3);
			*folder.name="folder";
			*folder.x=14;
			*folder.y=4;
			*this.addChild(folder);
			*var label:Label=new Label("treeItem");
			*label.name="label";
			*label.color="#ffff00";
			*label.width=150;
			*label.height=22;
			*label.x=33;
			*label.y=1;
			*label.left=33;
			*label.right=0;
			*this.addChild(label);
			*var arrow:Clip=new Clip("resource/ui/clip_tree_arrow.png",1,2);
			*arrow.name="arrow";
			*arrow.x=0;
			*arrow.y=5;
			*this.addChild(arrow);
			*}
		*}
	*/
	//class laya.ui.Tree extends laya.ui.Box
	var Tree = (function (_super) {
		function Tree() {
			/**@private */
			this._list = null;
			/**@private */
			this._source = null;
			/**@private */
			this._renderHandler = null;
			/**@private */
			this._spaceLeft = 10;
			/**@private */
			this._spaceBottom = 0;
			/**@private */
			this._keepStatus = true;
			Tree.__super.call(this);
			this.width = this.height = 200;
		}

		__class(Tree, 'laya.ui.Tree', _super);
		var __proto = Tree.prototype;
		Laya.imps(__proto, { "laya.ui.IRender": true })
		/**@inheritDoc */
		__proto.destroy = function (destroyChild) {
			(destroyChild === void 0) && (destroyChild = true);
			laya.ui.Component.prototype.destroy.call(this, destroyChild);
			this._list && this._list.destroy(destroyChild);
			this._list = null;
			this._source = null;
			this._renderHandler = null;
		}

		/**@inheritDoc */
		__proto.createChildren = function () {
			this.addChild(this._list = new List());
			this._list.renderHandler = Handler.create(this, this.renderItem, null, false);
			this._list.repeatX = 1;
			this._list.on(/*laya.events.Event.CHANGE*/"change", this, this.onListChange);
		}

		/**
		*@private
		*此对象包含的<code>List</code>实例的<code>Event.CHANGE</code>事件侦听处理函数。
		*/
		__proto.onListChange = function (e) {
			this.event(/*laya.events.Event.CHANGE*/"change");
		}

		/**
		*@private
		*获取数据源集合。
		*/
		__proto.getArray = function () {
			var arr = [];
			var item;
		/*for each*/for (var $each_item in this._source) {
				item = this._source[$each_item];
				if (this.getParentOpenStatus(item)) {
					item.x = this._spaceLeft * this.getDepth(item);
					arr.push(item);
				}
			}
			return arr;
		}

		/**
		*@private
		*获取项对象的深度。
		*/
		__proto.getDepth = function (item, num) {
			(num === void 0) && (num = 0);
			if (item.nodeParent == null) return num;
			else return this.getDepth(item.nodeParent, num + 1);
		}

		/**
		*@private
		*获取项对象的上一级的打开状态。
		*/
		__proto.getParentOpenStatus = function (item) {
			var parent = item.nodeParent;
			if (parent == null) {
				return true;
			} else {
				if (parent.isOpen) {
					if (parent.nodeParent != null) return this.getParentOpenStatus(parent);
					else return true;
				} else {
					return false;
				}
			}
		}

		/**
		*@private
		*渲染一个项对象。
		*@param cell 一个项对象。
		*@param index 项的索引。
		*/
		__proto.renderItem = function (cell, index) {
			var item = cell.dataSource;
			if (item) {
				cell.left = item.x;
				var arrow = cell.getChildByName("arrow");
				if (arrow) {
					if (item.hasChild) {
						arrow.visible = true;
						arrow.index = item.isOpen ? 1 : 0;
						arrow.tag = index;
						arrow.off(/*laya.events.Event.CLICK*/"click", this, this.onArrowClick);
						arrow.on(/*laya.events.Event.CLICK*/"click", this, this.onArrowClick);
					} else {
						arrow.visible = false;
					}
				};
				var folder = cell.getChildByName("folder");
				if (folder) {
					if (folder.clipY == 2) {
						folder.index = item.isDirectory ? 0 : 1;
					} else {
						folder.index = item.isDirectory ? item.isOpen ? 1 : 0 : 2;
					}
				}
				this._renderHandler && this._renderHandler.runWith([cell, index]);
			}
		}

		/**
		*@private
		*/
		__proto.onArrowClick = function (e) {
			var arrow = e.currentTarget;
			var index = arrow.tag;
			this._list.array[index].isOpen = !this._list.array[index].isOpen;
			this.event(/*laya.events.Event.OPEN*/"open");
			this._list.array = this.getArray();
		}

		/**
		*设置指定项索引的项对象的打开状态。
		*@param index 项索引。
		*@param isOpen 是否处于打开状态。
		*/
		__proto.setItemState = function (index, isOpen) {
			if (!this._list.array[index]) return;
			this._list.array[index].isOpen = isOpen;
			this._list.array = this.getArray();
		}

		/**
		*刷新项列表。
		*/
		__proto.fresh = function () {
			this._list.array = this.getArray();
			this.repaint();
		}

		/**
		*@private
		*解析并处理XML类型的数据源。
		*/
		__proto.parseXml = function (xml, source, nodeParent, isRoot) {
			var obj;
			var list = xml.childNodes;
			var childCount = list.length;
			if (!isRoot) {
				obj = {};
				var list2 = xml.attributes;
				var attrs;
			/*for each*/for (var $each_attrs in list2) {
					attrs = list2[$each_attrs];
					var prop = attrs.nodeName;
					var value = attrs.nodeValue;
					obj[prop] = value == "true" ? true : value == "false" ? false : value;
				}
				obj.nodeParent = nodeParent;
				if (childCount > 0) obj.isDirectory = true;
				obj.hasChild = childCount > 0;
				source.push(obj);
			}
			for (var i = 0; i < childCount; i++) {
				var node = list[i];
				this.parseXml(node, source, obj, false);
			}
		}

		/**
		*@private
		*处理数据项的打开状态。
		*/
		__proto.parseOpenStatus = function (oldSource, newSource) {
			for (var i = 0, n = newSource.length; i < n; i++) {
				var newItem = newSource[i];
				if (newItem.isDirectory) {
					for (var j = 0, m = oldSource.length; j < m; j++) {
						var oldItem = oldSource[j];
						if (oldItem.isDirectory && this.isSameParent(oldItem, newItem) && newItem.label == oldItem.label) {
							newItem.isOpen = oldItem.isOpen;
							break;
						}
					}
				}
			}
		}

		/**
		*@private
		*判断两个项对象在树结构中的父节点是否相同。
		*@param item1 项对象。
		*@param item2 项对象。
		*@return 如果父节点相同值为true，否则值为false。
		*/
		__proto.isSameParent = function (item1, item2) {
			if (item1.nodeParent == null && item2.nodeParent == null) return true;
			else if (item1.nodeParent == null || item2.nodeParent == null) return false
			else {
				if (item1.nodeParent.label == item2.nodeParent.label) return this.isSameParent(item1.nodeParent, item2.nodeParent);
				else return false;
			}
		}

		/**
		*更新项列表，显示指定键名的数据项。
		*@param key 键名。
		*/
		__proto.filter = function (key) {
			if (Boolean(key)) {
				var result = [];
				this.getFilterSource(this._source, result, key);
				this._list.array = result;
			} else {
				this._list.array = this.getArray();
			}
		}

		/**
		*@private
		*获取数据源中指定键名的值。
		*/
		__proto.getFilterSource = function (array, result, key) {
			key = key.toLocaleLowerCase();
			var item;
		/*for each*/for (var $each_item in array) {
				item = array[$each_item];
				if (!item.isDirectory && String(item.label).toLowerCase().indexOf(key) > -1) {
					item.x = 0;
					result.push(item);
				}
				if (item.child && item.child.length > 0) {
					this.getFilterSource(item.child, result, key);
				}
			}
		}

		/**
		*每一项之间的间隔距离（以像素为单位）。
		*/
		__getset(0, __proto, 'spaceBottom', function () {
			return this._list.spaceY;
		}, function (value) {
			this._list.spaceY = value;
		});

		/**
		*数据源发生变化后，是否保持之前打开状态，默认为true。
		*<p><b>取值：</b>
		*<li>true：保持之前打开状态。</li>
		*<li>false：不保持之前打开状态。</li>
		*</p>
		*/
		__getset(0, __proto, 'keepStatus', function () {
			return this._keepStatus;
		}, function (value) {
			this._keepStatus = value;
		});

		/**
		*此对象包含的<code>List</code>实例的单元格渲染器。
		*<p><b>取值：</b>
		*<ol>
		*<li>单元格类对象。</li>
		*<li> UI 的 JSON 描述。</li>
		*</ol></p>
		*/
		__getset(0, __proto, 'itemRender', function () {
			return this._list.itemRender;
		}, function (value) {
			this._list.itemRender = value;
		});

		/**
		*列表数据源，只包含当前可视节点数据。
		*/
		__getset(0, __proto, 'array', function () {
			return this._list.array;
		}, function (value) {
			if (this._keepStatus && this._list.array && value) {
				this.parseOpenStatus(this._list.array, value);
			}
			this._source = value;
			this._list.array = this.getArray();
		});

		/**
		*单元格鼠标事件处理器。
		*<p>默认返回参数（e:Event,index:int）。</p>
		*/
		__getset(0, __proto, 'mouseHandler', function () {
			return this._list.mouseHandler;
		}, function (value) {
			this._list.mouseHandler = value;
		});

		/**@inheritDoc */
		__getset(0, __proto, 'dataSource', _super.prototype._$get_dataSource, function (value) {
			this._dataSource = value;
			Laya.superSet(Box, this, 'dataSource', value);
		});

		/**
		*数据源，全部节点数据。
		*/
		__getset(0, __proto, 'source', function () {
			return this._source;
		});

		/**滚动条*/
		__getset(0, __proto, 'scrollBar', function () {
			return this._list.scrollBar;
		});

		/**
		*此对象包含的<code>List</code>实例对象。
		*/
		__getset(0, __proto, 'list', function () {
			return this._list;
		});

		/**
		*滚动条皮肤。
		*/
		__getset(0, __proto, 'scrollBarSkin', function () {
			return this._list.vScrollBarSkin;
		}, function (value) {
			this._list.vScrollBarSkin = value;
		});

		/**
		*<code>Tree</code> 实例的渲染处理器。
		*/
		__getset(0, __proto, 'renderHandler', function () {
			return this._renderHandler;
		}, function (value) {
			this._renderHandler = value;
		});

		/**
		*表示当前选择的项索引。
		*/
		__getset(0, __proto, 'selectedIndex', function () {
			return this._list.selectedIndex;
		}, function (value) {
			this._list.selectedIndex = value;
		});

		/**
		*左侧缩进距离（以像素为单位）。
		*/
		__getset(0, __proto, 'spaceLeft', function () {
			return this._spaceLeft;
		}, function (value) {
			this._spaceLeft = value;
		});

		/**
		*当前选中的项对象的数据源。
		*/
		__getset(0, __proto, 'selectedItem', function () {
			return this._list.selectedItem;
		}, function (value) {
			this._list.selectedItem = value;
		});

		/**
		*@inheritDoc
		*/
		__getset(0, __proto, 'width', _super.prototype._$get_width, function (value) {
			Laya.superSet(Box, this, 'width', value);
			this._list.width = value;
		});

		/**@inheritDoc */
		__getset(0, __proto, 'height', _super.prototype._$get_height, function (value) {
			Laya.superSet(Box, this, 'height', value);
			this._list.height = value;
		});

		/**
		*xml结构的数据源。
		*/
		__getset(0, __proto, 'xml', null, function (value) {
			var arr = [];
			this.parseXml(value.childNodes[0], arr, null, true);
			this.array = arr;
		});

		/**
		*表示选择的树节点项的<code>path</code>属性值。
		*/
		__getset(0, __proto, 'selectedPath', function () {
			if (this._list.selectedItem) {
				return this._list.selectedItem.path;
			}
			return null;
		});

		return Tree;
	})(Box)


	/**
	*<code>ViewStack</code> 类用于视图堆栈类，用于视图的显示等设置处理。
	*/
	//class laya.ui.ViewStack extends laya.ui.Box
	var ViewStack = (function (_super) {
		function ViewStack() {
			/**@private */
			this._items = null;
			/**@private */
			this._selectedIndex = 0;
			ViewStack.__super.call(this);
			this._setIndexHandler = Handler.create(this, this.setIndex, null, false);
		}

		__class(ViewStack, 'laya.ui.ViewStack', _super);
		var __proto = ViewStack.prototype;
		Laya.imps(__proto, { "laya.ui.IItem": true })
		/**
		*批量设置视图对象。
		*@param views 视图对象数组。
		*/
		__proto.setItems = function (views) {
			this.removeChildren();
			var index = 0;
			for (var i = 0, n = views.length; i < n; i++) {
				var item = views[i];
				if (item) {
					item.name = "item" + index;
					this.addChild(item);
					index++;
				}
			}
			this.initItems();
		}

		/**
		*添加视图。
		*@internal 添加视图对象，并设置此视图对象的<code>name</code> 属性。
		*@param view 需要添加的视图对象。
		*/
		__proto.addItem = function (view) {
			view.name = "item" + this._items.length;
			this.addChild(view);
			this.initItems();
		}

		/**
		*初始化视图对象集合。
		*/
		__proto.initItems = function () {
			this._items = [];
			for (var i = 0; i < 10000; i++) {
				var item = this.getChildByName("item" + i);
				if (item == null) {
					break;
				}
				this._items.push(item);
				item.visible = (i == this._selectedIndex);
			}
		}

		/**
		*@private
		*通过对象的索引设置项对象的 <code>selected</code> 属性值。
		*@param index 需要设置的对象的索引。
		*@param selected 表示对象的选中状态。
		*/
		__proto.setSelect = function (index, selected) {
			if (this._items && index > -1 && index < this._items.length) {
				this._items[index].visible = selected;
			}
		}

		/**
		*@private
		*设置属性<code>selectedIndex</code>的值。
		*@param index 选中项索引值。
		*/
		__proto.setIndex = function (index) {
			this.selectedIndex = index;
		}

		/**@inheritDoc */
		__getset(0, __proto, 'dataSource', _super.prototype._$get_dataSource, function (value) {
			this._dataSource = value;
			if (((typeof value == 'number') && Math.floor(value) == value) || (typeof value == 'string')) {
				this.selectedIndex = parseInt(value);
			} else {
				for (var prop in this._dataSource) {
					if (this.hasOwnProperty(prop)) {
						this[prop] = this._dataSource[prop];
					}
				}
			}
		});

		/**
		*表示当前视图索引。
		*/
		__getset(0, __proto, 'selectedIndex', function () {
			return this._selectedIndex;
		}, function (value) {
			if (this._selectedIndex != value) {
				this.setSelect(this._selectedIndex, false);
				this._selectedIndex = value;
				this.setSelect(this._selectedIndex, true);
			}
		});

		/**
		*获取或设置当前选择的项对象。
		*/
		__getset(0, __proto, 'selection', function () {
			return this._selectedIndex > -1 && this._selectedIndex < this._items.length ? this._items[this._selectedIndex] : null;
		}, function (value) {
			this.selectedIndex = this._items.indexOf(value);
		});

		/**
		*视图集合数组。
		*/
		__getset(0, __proto, 'items', function () {
			return this._items;
		});

		/**
		*索引设置处理器。
		*<p>默认回调参数：index:int</p>
		*/
		__getset(0, __proto, 'setIndexHandler', function () {
			return this._setIndexHandler;
		}, function (value) {
			this._setIndexHandler = value;
		});

		return ViewStack;
	})(Box)


	/**
	*
	*使用 <code>VScrollBar</code> （垂直 <code>ScrollBar</code> ）控件，可以在因数据太多而不能在显示区域完全显示时控制显示的数据部分。
	*
	*@example <caption>以下示例代码，创建了一个 <code>VScrollBar</code> 实例。</caption>
	*package
	*{
		*import laya.ui.vScrollBar;
		*import laya.ui.VScrollBar;
		*import laya.utils.Handler;
		*public class VScrollBar_Example
		*{
			*private var vScrollBar:VScrollBar;
			*public function VScrollBar_Example()
			*{
				*Laya.init(640,800);//设置游戏画布宽高、渲染模式。
				*Laya.stage.bgColor="#efefef";//设置画布的背景颜色。
				*Laya.loader.load(["resource/ui/vscroll.png","resource/ui/vscroll$bar.png","resource/ui/vscroll$down.png","resource/ui/vscroll$up.png"],Handler.create(this,onLoadComplete));
				*}
			*private function onLoadComplete():void
			*{
				*vScrollBar=new VScrollBar();//创建一个 vScrollBar 类的实例对象 hScrollBar 。
				*vScrollBar.skin="resource/ui/vscroll.png";//设置 vScrollBar 的皮肤。
				*vScrollBar.x=100;//设置 vScrollBar 对象的属性 x 的值，用于控制 vScrollBar 对象的显示位置。
				*vScrollBar.y=100;//设置 vScrollBar 对象的属性 y 的值，用于控制 vScrollBar 对象的显示位置。
				*vScrollBar.changeHandler=new Handler(this,onChange);//设置 vScrollBar 的滚动变化处理器。
				*Laya.stage.addChild(vScrollBar);//将此 vScrollBar 对象添加到显示列表。
				*}
			*private function onChange(value:Number):void
			*{
				*trace("滚动条的位置： value="+value);
				*}
			*}
		*}
	*@example
	*Laya.init(640,800);//设置游戏画布宽高
	*Laya.stage.bgColor="#efefef";//设置画布的背景颜色
	*var vScrollBar;
	*var res=["resource/ui/vscroll.png","resource/ui/vscroll$bar.png","resource/ui/vscroll$down.png","resource/ui/vscroll$up.png"];
	*Laya.loader.load(res,laya.utils.Handler.create(this,onLoadComplete));//加载资源。
	*function onLoadComplete(){
		*vScrollBar=new laya.ui.VScrollBar();//创建一个 vScrollBar 类的实例对象 hScrollBar 。
		*vScrollBar.skin="resource/ui/vscroll.png";//设置 vScrollBar 的皮肤。
		*vScrollBar.x=100;//设置 vScrollBar 对象的属性 x 的值，用于控制 vScrollBar 对象的显示位置。
		*vScrollBar.y=100;//设置 vScrollBar 对象的属性 y 的值，用于控制 vScrollBar 对象的显示位置。
		*vScrollBar.changeHandler=new laya.utils.Handler(this,onChange);//设置 vScrollBar 的滚动变化处理器。
		*Laya.stage.addChild(vScrollBar);//将此 vScrollBar 对象添加到显示列表。
		*}
	*function onChange(value){
		*console.log("滚动条的位置： value="+value);
		*}
	*@example
	*import VScrollBar=laya.ui.VScrollBar;
	*import Handler=laya.utils.Handler;
	*class VScrollBar_Example {
		*private vScrollBar:VScrollBar;
		*constructor(){
			*Laya.init(640,800);//设置游戏画布宽高、渲染模式。
			*Laya.stage.bgColor="#efefef";//设置画布的背景颜色。
			*Laya.loader.load(["resource/ui/vscroll.png","resource/ui/vscroll$bar.png","resource/ui/vscroll$down.png","resource/ui/vscroll$up.png"],Handler.create(this,this.onLoadComplete));
			*}
		*private onLoadComplete():void {
			*this.vScrollBar=new VScrollBar();//创建一个 vScrollBar 类的实例对象 hScrollBar 。
			*this.vScrollBar.skin="resource/ui/vscroll.png";//设置 vScrollBar 的皮肤。
			*this.vScrollBar.x=100;//设置 vScrollBar 对象的属性 x 的值，用于控制 vScrollBar 对象的显示位置。
			*this.vScrollBar.y=100;//设置 vScrollBar 对象的属性 y 的值，用于控制 vScrollBar 对象的显示位置。
			*this.vScrollBar.changeHandler=new Handler(this,this.onChange);//设置 vScrollBar 的滚动变化处理器。
			*Laya.stage.addChild(this.vScrollBar);//将此 vScrollBar 对象添加到显示列表。
			*}
		*private onChange(value:number):void {
			*console.log("滚动条的位置： value="+value);
			*}
		*}
	*/
	//class laya.ui.VScrollBar extends laya.ui.ScrollBar
	var VScrollBar = (function (_super) {
		function VScrollBar() {
			VScrollBar.__super.call(this);;
		}

		__class(VScrollBar, 'laya.ui.VScrollBar', _super);
		return VScrollBar;
	})(ScrollBar)


	/**
	*<code>TextInput</code> 类用于创建显示对象以显示和输入文本。
	*
	*@example <caption>以下示例代码，创建了一个 <code>TextInput</code> 实例。</caption>
	*package
	*{
		*import laya.display.Stage;
		*import laya.ui.TextInput;
		*import laya.utils.Handler;
		*public class TextInput_Example
		*{
			*public function TextInput_Example()
			*{
				*Laya.init(640,800);//设置游戏画布宽高、渲染模式。
				*Laya.stage.bgColor="#efefef";//设置画布的背景颜色。
				*Laya.loader.load(["resource/ui/input.png"],Handler.create(this,onLoadComplete));//加载资源。
				*}
			*private function onLoadComplete():void
			*{
				*var textInput:TextInput=new TextInput("这是一个TextInput实例。");//创建一个 TextInput 类的实例对象 textInput 。
				*textInput.skin="resource/ui/input.png";//设置 textInput 的皮肤。
				*textInput.sizeGrid="4,4,4,4";//设置 textInput 的网格信息。
				*textInput.color="#008fff";//设置 textInput 的文本颜色。
				*textInput.font="Arial";//设置 textInput 的文本字体。
				*textInput.bold=true;//设置 textInput 的文本显示为粗体。
				*textInput.fontSize=30;//设置 textInput 的字体大小。
				*textInput.wordWrap=true;//设置 textInput 的文本自动换行。
				*textInput.x=100;//设置 textInput 对象的属性 x 的值，用于控制 textInput 对象的显示位置。
				*textInput.y=100;//设置 textInput 对象的属性 y 的值，用于控制 textInput 对象的显示位置。
				*textInput.width=300;//设置 textInput 的宽度。
				*textInput.height=200;//设置 textInput 的高度。
				*Laya.stage.addChild(textInput);//将 textInput 添加到显示列表。
				*}
			*}
		*}
	*@example
	*Laya.init(640,800);//设置游戏画布宽高
	*Laya.stage.bgColor="#efefef";//设置画布的背景颜色
	*Laya.loader.load(["resource/ui/input.png"],laya.utils.Handler.create(this,onLoadComplete));//加载资源。
	*function onLoadComplete(){
		*var textInput=new laya.ui.TextInput("这是一个TextInput实例。");//创建一个 TextInput 类的实例对象 textInput 。
		*textInput.skin="resource/ui/input.png";//设置 textInput 的皮肤。
		*textInput.sizeGrid="4,4,4,4";//设置 textInput 的网格信息。
		*textInput.color="#008fff";//设置 textInput 的文本颜色。
		*textInput.font="Arial";//设置 textInput 的文本字体。
		*textInput.bold=true;//设置 textInput 的文本显示为粗体。
		*textInput.fontSize=30;//设置 textInput 的字体大小。
		*textInput.wordWrap=true;//设置 textInput 的文本自动换行。
		*textInput.x=100;//设置 textInput 对象的属性 x 的值，用于控制 textInput 对象的显示位置。
		*textInput.y=100;//设置 textInput 对象的属性 y 的值，用于控制 textInput 对象的显示位置。
		*textInput.width=300;//设置 textInput 的宽度。
		*textInput.height=200;//设置 textInput 的高度。
		*Laya.stage.addChild(textInput);//将 textInput 添加到显示列表。
		*}
	*@example
	*import Stage=laya.display.Stage;
	*import TextInput=laya.ui.TextInput;
	*import Handler=laya.utils.Handler;
	*class TextInput_Example {
		*constructor(){
			*Laya.init(640,800);//设置游戏画布宽高、渲染模式。
			*Laya.stage.bgColor="#efefef";//设置画布的背景颜色。
			*Laya.loader.load(["resource/ui/input.png"],Handler.create(this,this.onLoadComplete));//加载资源。
			*}
		*private onLoadComplete():void {
			*var textInput:TextInput=new TextInput("这是一个TextInput实例。");//创建一个 TextInput 类的实例对象 textInput 。
			*textInput.skin="resource/ui/input.png";//设置 textInput 的皮肤。
			*textInput.sizeGrid="4,4,4,4";//设置 textInput 的网格信息。
			*textInput.color="#008fff";//设置 textInput 的文本颜色。
			*textInput.font="Arial";//设置 textInput 的文本字体。
			*textInput.bold=true;//设置 textInput 的文本显示为粗体。
			*textInput.fontSize=30;//设置 textInput 的字体大小。
			*textInput.wordWrap=true;//设置 textInput 的文本自动换行。
			*textInput.x=100;//设置 textInput 对象的属性 x 的值，用于控制 textInput 对象的显示位置。
			*textInput.y=100;//设置 textInput 对象的属性 y 的值，用于控制 textInput 对象的显示位置。
			*textInput.width=300;//设置 textInput 的宽度。
			*textInput.height=200;//设置 textInput 的高度。
			*Laya.stage.addChild(textInput);//将 textInput 添加到显示列表。
			*}
		*}
	*/
	//class laya.ui.TextInput extends laya.ui.Label
	var TextInput = (function (_super) {
		function TextInput(text) {
			/**@private */
			this._bg = null;
			/**@private */
			this._skin = null;
			TextInput.__super.call(this);
			(text === void 0) && (text = "");
			this.text = text;
			this.skin = this.skin;
		}

		__class(TextInput, 'laya.ui.TextInput', _super);
		var __proto = TextInput.prototype;
		/**@inheritDoc */
		__proto.preinitialize = function () {
			this.mouseEnabled = true;
		}

		/**@inheritDoc */
		__proto.destroy = function (destroyChild) {
			(destroyChild === void 0) && (destroyChild = true);
			_super.prototype.destroy.call(this, destroyChild);
			this._bg && this._bg.destroy();
			this._bg = null;
		}

		/**@inheritDoc */
		__proto.createChildren = function () {
			this.addChild(this._tf = new Input());
			this._tf.padding = Styles.inputLabelPadding;
			this._tf.on(/*laya.events.Event.INPUT*/"input", this, this._onInput);
			this._tf.on(/*laya.events.Event.ENTER*/"enter", this, this._onEnter);
			this._tf.on(/*laya.events.Event.BLUR*/"blur", this, this._onBlur);
			this._tf.on(/*laya.events.Event.FOCUS*/"focus", this, this._onFocus);
		}

		/**
		*@private
		*/
		__proto._onFocus = function () {
			this.event(/*laya.events.Event.FOCUS*/"focus", this);
		}

		/**
		*@private
		*/
		__proto._onBlur = function () {
			this.event(/*laya.events.Event.BLUR*/"blur", this);
		}

		/**
		*@private
		*/
		__proto._onInput = function () {
			this.event(/*laya.events.Event.INPUT*/"input", this);
		}

		/**
		*@private
		*/
		__proto._onEnter = function () {
			this.event(/*laya.events.Event.ENTER*/"enter", this);
		}

		/**@inheritDoc */
		__proto.initialize = function () {
			this.width = 128;
			this.height = 22;
		}

		/**选中输入框内的文本。*/
		__proto.select = function () {
			(this._tf).select();
		}

		__proto.setSelection = function (startIndex, endIndex) {
			(this._tf).setSelection(startIndex, endIndex);
		}

		/**
		*当前文本内容字符串。
		*@see laya.display.Text.text
		*/
		__getset(0, __proto, 'text', _super.prototype._$get_text, function (value) {
			if (this._tf.text != value) {
				value = value + "";
				this._tf.text = value;
				this.event(/*laya.events.Event.CHANGE*/"change");
			}
		});

		/**
		*表示此对象包含的文本背景 <code>AutoBitmap</code> 组件实例。
		*/
		__getset(0, __proto, 'bg', function () {
			return this._bg;
		}, function (value) {
			this.graphics = this._bg = value;
		});

		/**
		*设置原生input输入框的y坐标偏移。
		*/
		__getset(0, __proto, 'inputElementYAdjuster', function () {
			return (this._tf).inputElementYAdjuster;
		}, function (value) {
			(this._tf).inputElementYAdjuster = value;
		});

		/**
		*<p>指示当前是否是文本域。</p>
		*值为true表示当前是文本域，否则不是文本域。
		*/
		__getset(0, __proto, 'multiline', function () {
			return (this._tf).multiline;
		}, function (value) {
			(this._tf).multiline = value;
		});

		/**
		*@copy laya.ui.Image#skin
		*/
		__getset(0, __proto, 'skin', function () {
			return this._skin;
		}, function (value) {
			if (this._skin != value) {
				this._skin = value;
				this._bg || (this.graphics = this._bg = new AutoBitmap());
				this._bg.source = Loader.getRes(this._skin);
				this._width && (this._bg.width = this._width);
				this._height && (this._bg.height = this._height);
			}
		});

		/**
		*<p>当前实例的背景图（ <code>AutoBitmap</code> ）实例的有效缩放网格数据。</p>
		*<p>数据格式："上边距,右边距,下边距,左边距,是否重复填充(值为0：不重复填充，1：重复填充)"，以逗号分隔。
		*<ul><li>例如："4,4,4,4,1"</li></ul></p>
		*@see laya.ui.AutoBitmap.sizeGrid
		*/
		__getset(0, __proto, 'sizeGrid', function () {
			return this._bg && this._bg.sizeGrid ? this._bg.sizeGrid.join(",") : null;
		}, function (value) {
			this._bg || (this.graphics = this._bg = new AutoBitmap());
			this._bg.sizeGrid = UIUtils.fillArray(Styles.defaultSizeGrid, value, Number);
		});

		/**
		*设置原生input输入框的x坐标偏移。
		*/
		__getset(0, __proto, 'inputElementXAdjuster', function () {
			return (this._tf).inputElementXAdjuster;
		}, function (value) {
			(this._tf).inputElementXAdjuster = value;
		});

		/**@inheritDoc */
		__getset(0, __proto, 'width', _super.prototype._$get_width, function (value) {
			Laya.superSet(Label, this, 'width', value);
			this._bg && (this._bg.width = value);
		});

		/**@inheritDoc */
		__getset(0, __proto, 'height', _super.prototype._$get_height, function (value) {
			Laya.superSet(Label, this, 'height', value);
			this._bg && (this._bg.height = value);
		});

		/**
		*设置可编辑状态。
		*/
		__getset(0, __proto, 'editable', function () {
			return (this._tf).editable;
		}, function (value) {
			(this._tf).editable = value;
		});

		/**限制输入的字符。*/
		__getset(0, __proto, 'restrict', function () {
			return (this._tf).restrict;
		}, function (pattern) {
			(this._tf).restrict = pattern;
		});

		/**
		*@copy laya.display.Input#prompt
		*/
		__getset(0, __proto, 'prompt', function () {
			return (this._tf).prompt;
		}, function (value) {
			(this._tf).prompt = value;
		});

		/**
		*@copy laya.display.Input#promptColor
		*/
		__getset(0, __proto, 'promptColor', function () {
			return (this._tf).promptColor;
		}, function (value) {
			(this._tf).promptColor = value;
		});

		/**
		*@copy laya.display.Input#maxChars
		*/
		__getset(0, __proto, 'maxChars', function () {
			return (this._tf).maxChars;
		}, function (value) {
			(this._tf).maxChars = value;
		});

		/**
		*@copy laya.display.Input#focus
		*/
		__getset(0, __proto, 'focus', function () {
			return (this._tf).focus;
		}, function (value) {
			(this._tf).focus = value;
		});

		/**
		*@copy laya.display.Input#type
		*/
		__getset(0, __proto, 'type', function () {
			return (this._tf).type;
		}, function (value) {
			(this._tf).type = value;
		});

		/**
		*@copy laya.display.Input#asPassword
		*/
		__getset(0, __proto, 'asPassword', function () {
			return (this._tf).asPassword;
		}, function (value) {
			(this._tf).asPassword = value;
		});

		return TextInput;
	})(Label)


	/**
	*使用 <code>VSlider</code> 控件，用户可以通过在滑块轨道的终点之间移动滑块来选择值。
	*<p> <code>VSlider</code> 控件采用垂直方向。滑块轨道从下往上扩展，而标签位于轨道的左右两侧。</p>
	*
	*@example <caption>以下示例代码，创建了一个 <code>VSlider</code> 实例。</caption>
	*package
	*{
		*import laya.ui.HSlider;
		*import laya.ui.VSlider;
		*import laya.utils.Handler;
		*public class VSlider_Example
		*{
			*private var vSlider:VSlider;
			*public function VSlider_Example()
			*{
				*Laya.init(640,800);//设置游戏画布宽高。
				*Laya.stage.bgColor="#efefef";//设置画布的背景颜色。
				*Laya.loader.load(["resource/ui/vslider.png","resource/ui/vslider$bar.png"],Handler.create(this,onLoadComplete));//加载资源。
				*}
			*private function onLoadComplete():void
			*{
				*vSlider=new VSlider();//创建一个 VSlider 类的实例对象 vSlider 。
				*vSlider.skin="resource/ui/vslider.png";//设置 vSlider 的皮肤。
				*vSlider.min=0;//设置 vSlider 最低位置值。
				*vSlider.max=10;//设置 vSlider 最高位置值。
				*vSlider.value=2;//设置 vSlider 当前位置值。
				*vSlider.tick=1;//设置 vSlider 刻度值。
				*vSlider.x=100;//设置 vSlider 对象的属性 x 的值，用于控制 vSlider 对象的显示位置。
				*vSlider.y=100;//设置 vSlider 对象的属性 y 的值，用于控制 vSlider 对象的显示位置。
				*vSlider.changeHandler=new Handler(this,onChange);//设置 vSlider 位置变化处理器。
				*Laya.stage.addChild(vSlider);//把 vSlider 添加到显示列表。
				*}
			*private function onChange(value:Number):void
			*{
				*trace("滑块的位置： value="+value);
				*}
			*}
		*}
	*@example
	*Laya.init(640,800);//设置游戏画布宽高
	*Laya.stage.bgColor="#efefef";//设置画布的背景颜色
	*var vSlider;
	*Laya.loader.load(["resource/ui/vslider.png","resource/ui/vslider$bar.png"],laya.utils.Handler.create(this,onLoadComplete));//加载资源。
	*function onLoadComplete(){
		*vSlider=new laya.ui.VSlider();//创建一个 VSlider 类的实例对象 vSlider 。
		*vSlider.skin="resource/ui/vslider.png";//设置 vSlider 的皮肤。
		*vSlider.min=0;//设置 vSlider 最低位置值。
		*vSlider.max=10;//设置 vSlider 最高位置值。
		*vSlider.value=2;//设置 vSlider 当前位置值。
		*vSlider.tick=1;//设置 vSlider 刻度值。
		*vSlider.x=100;//设置 vSlider 对象的属性 x 的值，用于控制 vSlider 对象的显示位置。
		*vSlider.y=100;//设置 vSlider 对象的属性 y 的值，用于控制 vSlider 对象的显示位置。
		*vSlider.changeHandler=new laya.utils.Handler(this,onChange);//设置 vSlider 位置变化处理器。
		*Laya.stage.addChild(vSlider);//把 vSlider 添加到显示列表。
		*}
	*function onChange(value){
		*console.log("滑块的位置： value="+value);
		*}
	*@example
	*import HSlider=laya.ui.HSlider;
	*import VSlider=laya.ui.VSlider;
	*import Handler=laya.utils.Handler;
	*class VSlider_Example {
		*private vSlider:VSlider;
		*constructor(){
			*Laya.init(640,800);//设置游戏画布宽高。
			*Laya.stage.bgColor="#efefef";//设置画布的背景颜色。
			*Laya.loader.load(["resource/ui/vslider.png","resource/ui/vslider$bar.png"],Handler.create(this,this.onLoadComplete));//加载资源。
			*}
		*private onLoadComplete():void {
			*this.vSlider=new VSlider();//创建一个 VSlider 类的实例对象 vSlider 。
			*this.vSlider.skin="resource/ui/vslider.png";//设置 vSlider 的皮肤。
			*this.vSlider.min=0;//设置 vSlider 最低位置值。
			*this.vSlider.max=10;//设置 vSlider 最高位置值。
			*this.vSlider.value=2;//设置 vSlider 当前位置值。
			*this.vSlider.tick=1;//设置 vSlider 刻度值。
			*this.vSlider.x=100;//设置 vSlider 对象的属性 x 的值，用于控制 vSlider 对象的显示位置。
			*this.vSlider.y=100;//设置 vSlider 对象的属性 y 的值，用于控制 vSlider 对象的显示位置。
			*this.vSlider.changeHandler=new Handler(this,this.onChange);//设置 vSlider 位置变化处理器。
			*Laya.stage.addChild(this.vSlider);//把 vSlider 添加到显示列表。
			*}
		*private onChange(value:number):void {
			*console.log("滑块的位置： value="+value);
			*}
		*}
	*@see laya.ui.Slider
	*/
	//class laya.ui.VSlider extends laya.ui.Slider
	var VSlider = (function (_super) {
		function VSlider() {
			VSlider.__super.call(this);;
		}

		__class(VSlider, 'laya.ui.VSlider', _super);
		return VSlider;
	})(Slider)


	/**
	*<code>Dialog</code> 组件是一个弹出对话框，实现对话框弹出，拖动，模式窗口功能。
	*可以通过UIConfig设置弹出框背景透明度，模式窗口点击边缘是否关闭等
	*通过设置zOrder属性，可以更改弹出的层次
	*通过设置popupEffect和closeEffect可以设置弹出效果和关闭效果，如果不想有任何弹出关闭效果，可以设置前述属性为空
	*
	*@example <caption>以下示例代码，创建了一个 <code>Dialog</code> 实例。</caption>
	*package
	*{
		*import laya.ui.Dialog;
		*import laya.utils.Handler;
		*public class Dialog_Example
		*{
			*private var dialog:Dialog_Instance;
			*public function Dialog_Example()
			*{
				*Laya.init(640,800);//设置游戏画布宽高、渲染模式。
				*Laya.stage.bgColor="#efefef";//设置画布的背景颜色。
				*Laya.loader.load("resource/ui/btn_close.png",Handler.create(this,onLoadComplete));//加载资源。
				*}
			*private function onLoadComplete():void
			*{
				*dialog=new Dialog_Instance();//创建一个 Dialog_Instance 类的实例对象 dialog。
				*dialog.dragArea="0,0,150,50";//设置 dialog 的拖拽区域。
				*dialog.show();//显示 dialog。
				*dialog.closeHandler=new Handler(this,onClose);//设置 dialog 的关闭函数处理器。
				*}
			*private function onClose(name:String):void
			*{
				*if (name==Dialog.CLOSE)
				*{
					*trace("通过点击 name 为"+name+"的组件，关闭了dialog。");
					*}
				*}
			*}
		*}
	*import laya.ui.Button;
	*import laya.ui.Dialog;
	*import laya.ui.Image;
	*class Dialog_Instance extends Dialog
	*{
		*function Dialog_Instance():void
		*{
			*var bg:Image=new Image("resource/ui/bg.png");
			*bg.sizeGrid="40,10,5,10";
			*bg.width=150;
			*bg.height=250;
			*addChild(bg);
			*var image:Image=new Image("resource/ui/image.png");
			*addChild(image);
			*var button:Button=new Button("resource/ui/btn_close.png");
			*button.name=Dialog.CLOSE;//设置button的name属性值。
			*button.x=0;
			*button.y=0;
			*addChild(button);
			*}
		*}
	*@example
	*Laya.init(640,800);//设置游戏画布宽高、渲染模式
	*Laya.stage.bgColor="#efefef";//设置画布的背景颜色
	*var dialog;
	*Laya.loader.load("resource/ui/btn_close.png",laya.utils.Handler.create(this,loadComplete));//加载资源
	*(function (_super){//新建一个类Dialog_Instance继承自laya.ui.Dialog。
		*function Dialog_Instance(){
			*Dialog_Instance.__super.call(this);//初始化父类
			*var bg=new laya.ui.Image("resource/ui/bg.png");//新建一个 Image 类的实例 bg 。
			*bg.sizeGrid="10,40,10,5";//设置 bg 的网格信息。
			*bg.width=150;//设置 bg 的宽度。
			*bg.height=250;//设置 bg 的高度。
			*this.addChild(bg);//将 bg 添加到显示列表。
			*var image=new laya.ui.Image("resource/ui/image.png");//新建一个 Image 类的实例 image 。
			*this.addChild(image);//将 image 添加到显示列表。
			*var button=new laya.ui.Button("resource/ui/btn_close.png");//新建一个 Button 类的实例 bg 。
			*button.name=laya.ui.Dialog.CLOSE;//设置 button 的 name 属性值。
			*button.x=0;//设置 button 对象的属性 x 的值，用于控制 button 对象的显示位置。
			*button.y=0;//设置 button 对象的属性 y 的值，用于控制 button 对象的显示位置。
			*this.addChild(button);//将 button 添加到显示列表。
			*};
		*Laya.class(Dialog_Instance,"mypackage.dialogExample.Dialog_Instance",_super);//注册类Dialog_Instance。
		*})(laya.ui.Dialog);
	*function loadComplete(){
		*console.log("资源加载完成！");
		*dialog=new mypackage.dialogExample.Dialog_Instance();//创建一个 Dialog_Instance 类的实例对象 dialog。
		*dialog.dragArea="0,0,150,50";//设置 dialog 的拖拽区域。
		*dialog.show();//显示 dialog。
		*dialog.closeHandler=new laya.utils.Handler(this,onClose);//设置 dialog 的关闭函数处理器。
		*}
	*function onClose(name){
		*if (name==laya.ui.Dialog.CLOSE){
			*console.log("通过点击 name 为"+name+"的组件，关闭了dialog。");
			*}
		*}
	*@example
	*import Dialog=laya.ui.Dialog;
	*import Handler=laya.utils.Handler;
	*class Dialog_Example {
		*private dialog:Dialog_Instance;
		*constructor(){
			*Laya.init(640,800);//设置游戏画布宽高。
			*Laya.stage.bgColor="#efefef";//设置画布的背景颜色。
			*Laya.loader.load("resource/ui/btn_close.png",Handler.create(this,this.onLoadComplete));//加载资源。
			*}
		*private onLoadComplete():void {
			*this.dialog=new Dialog_Instance();//创建一个 Dialog_Instance 类的实例对象 dialog。
			*this.dialog.dragArea="0,0,150,50";//设置 dialog 的拖拽区域。
			*this.dialog.show();//显示 dialog。
			*this.dialog.closeHandler=new Handler(this,this.onClose);//设置 dialog 的关闭函数处理器。
			*}
		*private onClose(name:string):void {
			*if (name==Dialog.CLOSE){
				*console.log("通过点击 name 为"+name+"的组件，关闭了dialog。");
				*}
			*}
		*}
	*import Button=laya.ui.Button;
	*class Dialog_Instance extends Dialog {
		*Dialog_Instance():void {
			*var bg:laya.ui.Image=new laya.ui.Image("resource/ui/bg.png");
			*bg.sizeGrid="40,10,5,10";
			*bg.width=150;
			*bg.height=250;
			*this.addChild(bg);
			*var image:laya.ui.Image=new laya.ui.Image("resource/ui/image.png");
			*this.addChild(image);
			*var button:Button=new Button("resource/ui/btn_close.png");
			*button.name=Dialog.CLOSE;//设置button的name属性值。
			*button.x=0;
			*button.y=0;
			*this.addChild(button);
			*}
		*}
	*/
	//class laya.ui.Dialog extends laya.ui.View
	var Dialog = (function (_super) {
		function Dialog() {
			/**
			*一个布尔值，指定对话框是否居中弹。
			*<p>如果值为true，则居中弹出，否则，则根据对象坐标显示，默认为true。</p>
			*/
			this.popupCenter = true;
			/**
			*对话框被关闭时会触发的回调函数处理器。
			*<p>回调函数参数为用户点击的按钮名字name:String。</p>
			*/
			this.closeHandler = null;
			/**
			*弹出对话框效果，可以设置一个效果代替默认的弹出效果，如果不想有任何效果，可以赋值为null
			*全局默认弹出效果可以通过manager.popupEffect修改
			*/
			this.popupEffect = null;
			/**
			*关闭对话框效果，可以设置一个效果代替默认的关闭效果，如果不想有任何效果，可以赋值为null
			*全局默认关闭效果可以通过manager.closeEffect修改
			*/
			this.closeEffect = null;
			/**组名称*/
			this.group = null;
			/**是否是模式窗口*/
			this.isModal = false;
			/**@private */
			this._dragArea = null;
			Dialog.__super.call(this);
		}

		__class(Dialog, 'laya.ui.Dialog', _super);
		var __proto = Dialog.prototype;
		/**@inheritDoc */
		__proto.initialize = function () {
			this.popupEffect = Dialog.manager.popupEffectHandler;
			this.closeEffect = Dialog.manager.closeEffectHandler;
			this._dealDragArea();
			this.on(/*laya.events.Event.CLICK*/"click", this, this._onClick);
		}

		/**@private */
		__proto._dealDragArea = function () {
			var dragTarget = this.getChildByName("drag");
			if (dragTarget) {
				this.dragArea = dragTarget.x + "," + dragTarget.y + "," + dragTarget.width + "," + dragTarget.height;
				dragTarget.removeSelf();
			}
		}

		/**
		*@private (protected)
		*对象的 <code>Event.CLICK</code> 点击事件侦听处理函数。
		*/
		__proto._onClick = function (e) {
			var btn = e.target;
			if (btn) {
				switch (btn.name) {
					case "close":
					case "cancel":
					case "sure":
					case "no":
					case "ok":
					case "yes":
						this.close(btn.name);
						break;
				}
			}
		}

		/**
		*显示对话框（以非模式窗口方式显示）。
		*@param closeOther 是否关闭其它的对话框。若值为true则关闭其它对话框。
		*@param showEffect 是否显示弹出效果
		*/
		__proto.show = function (closeOther, showEffect) {
			(closeOther === void 0) && (closeOther = false);
			(showEffect === void 0) && (showEffect = true);
			this._open(false, closeOther, showEffect);
		}

		/**
		*显示对话框（以模式窗口方式显示）。
		*@param closeOther 是否关闭其它的对话框。若值为true则关闭其它对话框。
		*@param showEffect 是否显示弹出效果
		*/
		__proto.popup = function (closeOther, showEffect) {
			(closeOther === void 0) && (closeOther = false);
			(showEffect === void 0) && (showEffect = true);
			this._open(true, closeOther, showEffect);
		}

		/**@private */
		__proto._open = function (modal, closeOther, showEffect) {
			Dialog.manager.lock(false);
			this.isModal = modal;
			Dialog.manager.open(this, closeOther, showEffect);
		}

		/**打开完成后，调用此方法（如果有弹出动画，则在动画完成后执行）*/
		__proto.onOpened = function () { }
		/**
		*关闭对话框。
		*@param type 如果是点击默认关闭按钮触发，则传入关闭按钮的名字(name)，否则为null。
		*@param showEffect 是否显示关闭效果
		*/
		__proto.close = function (type, showEffect) {
			(showEffect === void 0) && (showEffect = true);
			Dialog.manager.close(this, type, showEffect);
		}

		/**关闭完成后，调用此方法（如果有关闭动画，则在动画完成后执行）
		*@param type 如果是点击默认关闭按钮触发，则传入关闭按钮的名字(name)，否则为null。
		*/
		__proto.onClosed = function (type) { }
		/**@private */
		__proto._onMouseDown = function (e) {
			var point = this.getMousePoint();
			if (this._dragArea.contains(point.x, point.y)) this.startDrag();
			else this.stopDrag();
		}

		/**
		*用来指定对话框的拖拽区域。默认值为"0,0,0,0"。
		*<p><b>格式：</b>构成一个矩形所需的 x,y,width,heith 值，用逗号连接为字符串。
		*例如："0,0,100,200"。
		*</p>
		*
		*@see #includeExamplesSummary 请参考示例
		*/
		__getset(0, __proto, 'dragArea', function () {
			if (this._dragArea) return this._dragArea.toString();
			return null;
		}, function (value) {
			if (value) {
				var a = UIUtils.fillArray([0, 0, 0, 0], value, Number);
				this._dragArea = new Rectangle(a[0], a[1], a[2], a[3]);
				this.on(/*laya.events.Event.MOUSE_DOWN*/"mousedown", this, this._onMouseDown);
			} else {
				this._dragArea = null;
				this.off(/*laya.events.Event.MOUSE_DOWN*/"mousedown", this, this._onMouseDown);
			}
		});

		/**
		*弹出框的显示状态；如果弹框处于显示中，则为true，否则为false;
		*/
		__getset(0, __proto, 'isPopup', function () {
			return this.parent != null;
		});

		__getset(0, __proto, 'zOrder', _super.prototype._$get_zOrder, function (value) {
			Laya.superSet(View, this, 'zOrder', value);
			Dialog.manager._checkMask();
		});

		/**对话框管理容器，所有的对话框都在该容器内，并且受管理器管，可以自定义自己的管理器，来更改窗口管理的流程。
		*任意对话框打开和关闭，都会触发管理类的open和close事件*/
		__getset(1, Dialog, 'manager', function () {
			return Dialog._manager = Dialog._manager || new DialogManager();
		}, function (value) {
			Dialog._manager = value;
		});

		Dialog.setLockView = function (view) {
			Dialog.manager.setLockView(view);
		}

		Dialog.lock = function (value) {
			Dialog.manager.lock(value);
		}

		Dialog.closeAll = function () {
			Dialog.manager.closeAll();
		}

		Dialog.getDialogsByGroup = function (group) {
			return Dialog.manager.getDialogsByGroup(group);
		}

		Dialog.closeByGroup = function (group) {
			return Dialog.manager.closeByGroup(group);
		}

		Dialog.CLOSE = "close";
		Dialog.CANCEL = "cancel";
		Dialog.SURE = "sure";
		Dialog.NO = "no";
		Dialog.OK = "ok";
		Dialog.YES = "yes";
		Dialog._manager = null;
		return Dialog;
	})(View)


	/**
	*<code>HBox</code> 是一个水平布局容器类。
	*/
	//class laya.ui.HBox extends laya.ui.LayoutBox
	var HBox = (function (_super) {
		function HBox() {
			HBox.__super.call(this);;
		}

		__class(HBox, 'laya.ui.HBox', _super);
		var __proto = HBox.prototype;
		/**@inheritDoc */
		__proto.sortItem = function (items) {
			if (items) items.sort(function (a, b) { return a.x - b.x; });
		}

		/**@inheritDoc */
		__proto.changeItems = function () {
			this._itemChanged = false;
			var items = [];
			var maxHeight = 0;
			for (var i = 0, n = this.numChildren; i < n; i++) {
				var item = this.getChildAt(i);
				if (item && item.layoutEnabled) {
					items.push(item);
					maxHeight = this._height ? this._height : Math.max(maxHeight, item.height * item.scaleY);
				}
			}
			this.sortItem(items);
			var left = 0;
			for (i = 0, n = items.length; i < n; i++) {
				item = items[i];
				item.x = left;
				left += item.width * item.scaleX + this._space;
				if (this._align == "top") {
					item.y = 0;
				} else if (this._align == "middle") {
					item.y = (maxHeight - item.height * item.scaleY) * 0.5;
				} else if (this._align == "bottom") {
					item.y = maxHeight - item.height * item.scaleY;
				}
			}
			this.changeSize();
		}

		__getset(0, __proto, 'height', _super.prototype._$get_height, function (value) {
			if (this._height != value) {
				Laya.superSet(LayoutBox, this, 'height', value);
				this.callLater(this.changeItems);
			}
		});

		HBox.NONE = "none";
		HBox.TOP = "top";
		HBox.MIDDLE = "middle";
		HBox.BOTTOM = "bottom";
		return HBox;
	})(LayoutBox)


	/**
	*<code>VBox</code> 是一个垂直布局容器类。
	*/
	//class laya.ui.VBox extends laya.ui.LayoutBox
	var VBox = (function (_super) {
		function VBox() {
			VBox.__super.call(this);;
		}

		__class(VBox, 'laya.ui.VBox', _super);
		var __proto = VBox.prototype;
		/**@inheritDoc */
		__proto.changeItems = function () {
			this._itemChanged = false;
			var items = [];
			var maxWidth = 0;
			for (var i = 0, n = this.numChildren; i < n; i++) {
				var item = this.getChildAt(i);
				if (item && item.layoutEnabled) {
					items.push(item);
					maxWidth = this._width ? this._width : Math.max(maxWidth, item.width * item.scaleX);
				}
			}
			this.sortItem(items);
			var top = 0;
			for (i = 0, n = items.length; i < n; i++) {
				item = items[i];
				item.y = top;
				top += item.height * item.scaleY + this._space;
				if (this._align == "left") {
					item.x = 0;
				} else if (this._align == "center") {
					item.x = (maxWidth - item.width * item.scaleX) * 0.5;
				} else if (this._align == "right") {
					item.x = maxWidth - item.width * item.scaleX;
				}
			}
			this.changeSize();
		}

		__getset(0, __proto, 'width', _super.prototype._$get_width, function (value) {
			if (this._width != value) {
				Laya.superSet(LayoutBox, this, 'width', value);
				this.callLater(this.changeItems);
			}
		});

		VBox.NONE = "none";
		VBox.LEFT = "left";
		VBox.CENTER = "center";
		VBox.RIGHT = "right";
		return VBox;
	})(LayoutBox)


	/**
	*<code>RadioGroup</code> 控件定义一组 <code>Radio</code> 控件，这些控件相互排斥；
	*因此，用户每次只能选择一个 <code>Radio</code> 控件。
	*
	*@example <caption>以下示例代码，创建了一个 <code>RadioGroup</code> 实例。</caption>
	*package
	*{
		*import laya.ui.Radio;
		*import laya.ui.RadioGroup;
		*import laya.utils.Handler;
		*public class RadioGroup_Example
		*{
			*public function RadioGroup_Example()
			*{
				*Laya.init(640,800);//设置游戏画布宽高。
				*Laya.stage.bgColor="#efefef";//设置画布的背景颜色。
				*Laya.loader.load(["resource/ui/radio.png"],Handler.create(this,onLoadComplete));//加载资源。
				*}
			*private function onLoadComplete():void
			*{
				*var radioGroup:RadioGroup=new RadioGroup();//创建一个 RadioGroup 类的实例对象 radioGroup 。
				*radioGroup.pos(100,100);//设置 radioGroup 的位置信息。
				*radioGroup.labels="item0,item1,item2";//设置 radioGroup 的标签集。
				*radioGroup.skin="resource/ui/radio.png";//设置 radioGroup 的皮肤。
				*radioGroup.space=10;//设置 radioGroup 的项间隔距离。
				*radioGroup.selectHandler=new Handler(this,onSelect);//设置 radioGroup 的选择项发生改变时执行的处理器。
				*Laya.stage.addChild(radioGroup);//将 radioGroup 添加到显示列表。
				*}
			*private function onSelect(index:int):void
			*{
				*trace("当前选择的单选按钮索引: index= ",index);
				*}
			*}
		*}
	*@example
	*Laya.init(640,800);//设置游戏画布宽高、渲染模式
	*Laya.stage.bgColor="#efefef";//设置画布的背景颜色
	*Laya.loader.load(["resource/ui/radio.png"],laya.utils.Handler.create(this,onLoadComplete));
	*function onLoadComplete(){
		*var radioGroup=new laya.ui.RadioGroup();//创建一个 RadioGroup 类的实例对象 radioGroup 。
		*radioGroup.pos(100,100);//设置 radioGroup 的位置信息。
		*radioGroup.labels="item0,item1,item2";//设置 radioGroup 的标签集。
		*radioGroup.skin="resource/ui/radio.png";//设置 radioGroup 的皮肤。
		*radioGroup.space=10;//设置 radioGroup 的项间隔距离。
		*radioGroup.selectHandler=new laya.utils.Handler(this,onSelect);//设置 radioGroup 的选择项发生改变时执行的处理器。
		*Laya.stage.addChild(radioGroup);//将 radioGroup 添加到显示列表。
		*}
	*function onSelect(index){
		*console.log("当前选择的单选按钮索引: index= ",index);
		*}
	*@example
	*import Radio=laya.ui.Radio;
	*import RadioGroup=laya.ui.RadioGroup;
	*import Handler=laya.utils.Handler;
	*class RadioGroup_Example {
		*constructor(){
			*Laya.init(640,800);//设置游戏画布宽高。
			*Laya.stage.bgColor="#efefef";//设置画布的背景颜色。
			*Laya.loader.load(["resource/ui/radio.png"],Handler.create(this,this.onLoadComplete));//加载资源。
			*}
		*private onLoadComplete():void {
			*var radioGroup:RadioGroup=new RadioGroup();//创建一个 RadioGroup 类的实例对象 radioGroup 。
			*radioGroup.pos(100,100);//设置 radioGroup 的位置信息。
			*radioGroup.labels="item0,item1,item2";//设置 radioGroup 的标签集。
			*radioGroup.skin="resource/ui/radio.png";//设置 radioGroup 的皮肤。
			*radioGroup.space=10;//设置 radioGroup 的项间隔距离。
			*radioGroup.selectHandler=new Handler(this,this.onSelect);//设置 radioGroup 的选择项发生改变时执行的处理器。
			*Laya.stage.addChild(radioGroup);//将 radioGroup 添加到显示列表。
			*}
		*private onSelect(index:number):void {
			*console.log("当前选择的单选按钮索引: index= ",index);
			*}
		*}
	*/
	//class laya.ui.RadioGroup extends laya.ui.UIGroup
	var RadioGroup = (function (_super) {
		function RadioGroup() {
			RadioGroup.__super.call(this);;
		}

		__class(RadioGroup, 'laya.ui.RadioGroup', _super);
		var __proto = RadioGroup.prototype;
		/**@inheritDoc */
		__proto.createItem = function (skin, label) {
			return new Radio(skin, label);
		}

		return RadioGroup;
	})(UIGroup)


	/**
	*<code>Tab</code> 组件用来定义选项卡按钮组。 *
	*@internal <p>属性：<code>selectedIndex</code> 的默认值为-1。</p>
	*
	*@example <caption>以下示例代码，创建了一个 <code>Tab</code> 实例。</caption>
	*package
	*{
		*import laya.ui.Tab;
		*import laya.utils.Handler;
		*public class Tab_Example
		*{
			*public function Tab_Example()
			*{
				*Laya.init(640,800);//设置游戏画布宽高。
				*Laya.stage.bgColor="#efefef";//设置画布的背景颜色。
				*Laya.loader.load(["resource/ui/tab.png"],Handler.create(this,onLoadComplete));//加载资源。
				*}
			*private function onLoadComplete():void
			*{
				*var tab:Tab=new Tab();//创建一个 Tab 类的实例对象 tab 。
				*tab.skin="resource/ui/tab.png";//设置 tab 的皮肤。
				*tab.labels="item0,item1,item2";//设置 tab 的标签集。
				*tab.x=100;//设置 tab 对象的属性 x 的值，用于控制 tab 对象的显示位置。
				*tab.y=100;//设置 tab 对象的属性 y 的值，用于控制 tab 对象的显示位置。
				*tab.selectHandler=new Handler(this,onSelect);//设置 tab 的选择项发生改变时执行的处理器。
				*Laya.stage.addChild(tab);//将 tab 添到显示列表。
				*}
			*private function onSelect(index:int):void
			*{
				*trace("当前选择的表情页索引: index= ",index);
				*}
			*}
		*}
	*@example
	*Laya.init(640,800);//设置游戏画布宽高
	*Laya.stage.bgColor="#efefef";//设置画布的背景颜色
	*Laya.loader.load(["resource/ui/tab.png"],laya.utils.Handler.create(this,onLoadComplete));
	*function onLoadComplete(){
		*var tab=new laya.ui.Tab();//创建一个 Tab 类的实例对象 tab 。
		*tab.skin="resource/ui/tab.png";//设置 tab 的皮肤。
		*tab.labels="item0,item1,item2";//设置 tab 的标签集。
		*tab.x=100;//设置 tab 对象的属性 x 的值，用于控制 tab 对象的显示位置。
		*tab.y=100;//设置 tab 对象的属性 y 的值，用于控制 tab 对象的显示位置。
		*tab.selectHandler=new laya.utils.Handler(this,onSelect);//设置 tab 的选择项发生改变时执行的处理器。
		*Laya.stage.addChild(tab);//将 tab 添到显示列表。
		*}
	*function onSelect(index){
		*console.log("当前选择的标签页索引: index= ",index);
		*}
	*@example
	*import Tab=laya.ui.Tab;
	*import Handler=laya.utils.Handler;
	*class Tab_Example {
		*constructor(){
			*Laya.init(640,800);//设置游戏画布宽高。
			*Laya.stage.bgColor="#efefef";//设置画布的背景颜色。
			*Laya.loader.load(["resource/ui/tab.png"],Handler.create(this,this.onLoadComplete));//加载资源。
			*}
		*private onLoadComplete():void {
			*var tab:Tab=new Tab();//创建一个 Tab 类的实例对象 tab 。
			*tab.skin="resource/ui/tab.png";//设置 tab 的皮肤。
			*tab.labels="item0,item1,item2";//设置 tab 的标签集。
			*tab.x=100;//设置 tab 对象的属性 x 的值，用于控制 tab 对象的显示位置。
			*tab.y=100;//设置 tab 对象的属性 y 的值，用于控制 tab 对象的显示位置。
			*tab.selectHandler=new Handler(this,this.onSelect);//设置 tab 的选择项发生改变时执行的处理器。
			*Laya.stage.addChild(tab);//将 tab 添到显示列表。
			*}
		*private onSelect(index:number):void {
			*console.log("当前选择的表情页索引: index= ",index);
			*}
		*}
	*/
	//class laya.ui.Tab extends laya.ui.UIGroup
	var Tab = (function (_super) {
		function Tab() {
			Tab.__super.call(this);;
		}

		__class(Tab, 'laya.ui.Tab', _super);
		var __proto = Tab.prototype;
		/**
		*@private
		*@inheritDoc
		*/
		__proto.createItem = function (skin, label) {
			return new Button(skin, label);
		}

		return Tab;
	})(UIGroup)


	/**
	*<code>TextArea</code> 类用于创建显示对象以显示和输入文本。
	*@example <caption>以下示例代码，创建了一个 <code>TextArea</code> 实例。</caption>
	*package
	*{
		*import laya.ui.TextArea;
		*import laya.utils.Handler;
		*public class TextArea_Example
		*{
			*public function TextArea_Example()
			*{
				*Laya.init(640,800);//设置游戏画布宽高。
				*Laya.stage.bgColor="#efefef";//设置画布的背景颜色。
				*Laya.loader.load(["resource/ui/input.png"],Handler.create(this,onLoadComplete));//加载资源。
				*}
			*private function onLoadComplete():void
			*{
				*var textArea:TextArea=new TextArea("这个一个TextArea实例。");//创建一个 TextArea 类的实例对象 textArea 。
				*textArea.skin="resource/ui/input.png";//设置 textArea 的皮肤。
				*textArea.sizeGrid="4,4,4,4";//设置 textArea 的网格信息。
				*textArea.color="#008fff";//设置 textArea 的文本颜色。
				*textArea.font="Arial";//设置 textArea 的字体。
				*textArea.bold=true;//设置 textArea 的文本显示为粗体。
				*textArea.fontSize=20;//设置 textArea 的文本字体大小。
				*textArea.wordWrap=true;//设置 textArea 的文本自动换行。
				*textArea.x=100;//设置 textArea 对象的属性 x 的值，用于控制 textArea 对象的显示位置。
				*textArea.y=100;//设置 textArea 对象的属性 y 的值，用于控制 textArea 对象的显示位置。
				*textArea.width=300;//设置 textArea 的宽度。
				*textArea.height=200;//设置 textArea 的高度。
				*Laya.stage.addChild(textArea);//将 textArea 添加到显示列表。
				*}
			*}
		*}
	*@example
	*Laya.init(640,800);//设置游戏画布宽高、渲染模式
	*Laya.stage.bgColor="#efefef";//设置画布的背景颜色
	*Laya.loader.load(["resource/ui/input.png"],laya.utils.Handler.create(this,onLoadComplete));//加载资源。
	*function onLoadComplete(){
		*var textArea=new laya.ui.TextArea("这个一个TextArea实例。");//创建一个 TextArea 类的实例对象 textArea 。
		*textArea.skin="resource/ui/input.png";//设置 textArea 的皮肤。
		*textArea.sizeGrid="4,4,4,4";//设置 textArea 的网格信息。
		*textArea.color="#008fff";//设置 textArea 的文本颜色。
		*textArea.font="Arial";//设置 textArea 的字体。
		*textArea.bold=true;//设置 textArea 的文本显示为粗体。
		*textArea.fontSize=20;//设置 textArea 的文本字体大小。
		*textArea.wordWrap=true;//设置 textArea 的文本自动换行。
		*textArea.x=100;//设置 textArea 对象的属性 x 的值，用于控制 textArea 对象的显示位置。
		*textArea.y=100;//设置 textArea 对象的属性 y 的值，用于控制 textArea 对象的显示位置。
		*textArea.width=300;//设置 textArea 的宽度。
		*textArea.height=200;//设置 textArea 的高度。
		*Laya.stage.addChild(textArea);//将 textArea 添加到显示列表。
		*}
	*@example
	*import TextArea=laya.ui.TextArea;
	*import Handler=laya.utils.Handler;
	*class TextArea_Example {
		*constructor(){
			*Laya.init(640,800);//设置游戏画布宽高、渲染模式。
			*Laya.stage.bgColor="#efefef";//设置画布的背景颜色。
			*Laya.loader.load(["resource/ui/input.png"],Handler.create(this,this.onLoadComplete));//加载资源。
			*}
		*private onLoadComplete():void {
			*var textArea:TextArea=new TextArea("这个一个TextArea实例。");//创建一个 TextArea 类的实例对象 textArea 。
			*textArea.skin="resource/ui/input.png";//设置 textArea 的皮肤。
			*textArea.sizeGrid="4,4,4,4";//设置 textArea 的网格信息。
			*textArea.color="#008fff";//设置 textArea 的文本颜色。
			*textArea.font="Arial";//设置 textArea 的字体。
			*textArea.bold=true;//设置 textArea 的文本显示为粗体。
			*textArea.fontSize=20;//设置 textArea 的文本字体大小。
			*textArea.wordWrap=true;//设置 textArea 的文本自动换行。
			*textArea.x=100;//设置 textArea 对象的属性 x 的值，用于控制 textArea 对象的显示位置。
			*textArea.y=100;//设置 textArea 对象的属性 y 的值，用于控制 textArea 对象的显示位置。
			*textArea.width=300;//设置 textArea 的宽度。
			*textArea.height=200;//设置 textArea 的高度。
			*Laya.stage.addChild(textArea);//将 textArea 添加到显示列表。
			*}
		*}
	*/
	//class laya.ui.TextArea extends laya.ui.TextInput
	var TextArea = (function (_super) {
		function TextArea(text) {
			/**@private */
			this._vScrollBar = null;
			/**@private */
			this._hScrollBar = null;
			(text === void 0) && (text = "");
			TextArea.__super.call(this, text);
		}

		__class(TextArea, 'laya.ui.TextArea', _super);
		var __proto = TextArea.prototype;
		__proto.destroy = function (destroyChild) {
			(destroyChild === void 0) && (destroyChild = true);
			_super.prototype.destroy.call(this, destroyChild);
			this._vScrollBar && this._vScrollBar.destroy();
			this._hScrollBar && this._hScrollBar.destroy();
			this._vScrollBar = null;
			this._hScrollBar = null;
		}

		__proto.initialize = function () {
			this.width = 180;
			this.height = 150;
			this._tf.wordWrap = true;
			this.multiline = true;
		}

		__proto.onVBarChanged = function (e) {
			if (this._tf.scrollY != this._vScrollBar.value) {
				this._tf.scrollY = this._vScrollBar.value;
			}
		}

		__proto.onHBarChanged = function (e) {
			if (this._tf.scrollX != this._hScrollBar.value) {
				this._tf.scrollX = this._hScrollBar.value;
			}
		}

		__proto.changeScroll = function () {
			var vShow = this._vScrollBar && this._tf.maxScrollY > 0;
			var hShow = this._hScrollBar && this._tf.maxScrollX > 0;
			var showWidth = vShow ? this._width - this._vScrollBar.width : this._width;
			var showHeight = hShow ? this._height - this._hScrollBar.height : this._height;
			var padding = this._tf.padding || Styles.labelPadding;
			this._tf.width = showWidth;
			this._tf.height = showHeight;
			if (this._vScrollBar) {
				this._vScrollBar.x = this._width - this._vScrollBar.width - padding[2];
				this._vScrollBar.y = padding[1];
				this._vScrollBar.height = this._height - (hShow ? this._hScrollBar.height : 0) - padding[1] - padding[3];
				this._vScrollBar.scrollSize = 1;
				this._vScrollBar.thumbPercent = showHeight / Math.max(this._tf.textHeight, showHeight);
				this._vScrollBar.setScroll(1, this._tf.maxScrollY, this._tf.scrollY);
				this._vScrollBar.visible = vShow;
			}
			if (this._hScrollBar) {
				this._hScrollBar.x = padding[0];
				this._hScrollBar.y = this._height - this._hScrollBar.height - padding[3];
				this._hScrollBar.width = this._width - (vShow ? this._vScrollBar.width : 0) - padding[0] - padding[2];
				this._hScrollBar.scrollSize = Math.max(showWidth * 0.033, 1);
				this._hScrollBar.thumbPercent = showWidth / Math.max(this._tf.textWidth, showWidth);
				this._hScrollBar.setScroll(0, this.maxScrollX, this.scrollX);
				this._hScrollBar.visible = hShow;
			}
		}

		/**滚动到某个位置*/
		__proto.scrollTo = function (y) {
			this.commitMeasure();
			this._tf.scrollY = y;
		}

		/**垂直滚动值*/
		__getset(0, __proto, 'scrollY', function () {
			return this._tf.scrollY;
		});

		__getset(0, __proto, 'width', _super.prototype._$get_width, function (value) {
			Laya.superSet(TextInput, this, 'width', value);
			this.callLater(this.changeScroll);
		});

		/**水平滚动条实体*/
		__getset(0, __proto, 'hScrollBar', function () {
			return this._hScrollBar;
		});

		__getset(0, __proto, 'height', _super.prototype._$get_height, function (value) {
			Laya.superSet(TextInput, this, 'height', value);
			this.callLater(this.changeScroll);
		});

		/**水平滚动最大值*/
		__getset(0, __proto, 'maxScrollX', function () {
			return this._tf.maxScrollX;
		});

		/**垂直滚动条皮肤*/
		__getset(0, __proto, 'vScrollBarSkin', function () {
			return this._vScrollBar ? this._vScrollBar.skin : null;
		}, function (value) {
			if (this._vScrollBar == null) {
				this.addChild(this._vScrollBar = new VScrollBar());
				this._vScrollBar.on(/*laya.events.Event.CHANGE*/"change", this, this.onVBarChanged);
				this._vScrollBar.target = this._tf;
				this.callLater(this.changeScroll);
			}
			this._vScrollBar.skin = value;
		});

		/**水平滚动条皮肤*/
		__getset(0, __proto, 'hScrollBarSkin', function () {
			return this._hScrollBar ? this._hScrollBar.skin : null;
		}, function (value) {
			if (this._hScrollBar == null) {
				this.addChild(this._hScrollBar = new HScrollBar());
				this._hScrollBar.on(/*laya.events.Event.CHANGE*/"change", this, this.onHBarChanged);
				this._hScrollBar.mouseWheelEnable = false;
				this._hScrollBar.target = this._tf;
				this.callLater(this.changeScroll);
			}
			this._hScrollBar.skin = value;
		});

		/**垂直滚动条实体*/
		__getset(0, __proto, 'vScrollBar', function () {
			return this._vScrollBar;
		});

		/**垂直滚动最大值*/
		__getset(0, __proto, 'maxScrollY', function () {
			return this._tf.maxScrollY;
		});

		/**水平滚动值*/
		__getset(0, __proto, 'scrollX', function () {
			return this._tf.scrollX;
		});

		return TextArea;
	})(TextInput)


	/**
	*异步Dialog的生命周期:show或者popup > onCreate(如果没有创建过)> onOpen > onClose > onDestroy(如果销毁)
	*onCreate在页面未创建时执行一次，再次打开页面不会再执行，适合写一些只执行一次的逻辑，比如资源加载，节点事件监听
	*onOpen在页面每次打开都会执行，适合做一些每次都需要处理的事情，比如消息请求，根据数据初始化页面
	*onClose在每次关闭的时候调用，适合关闭时停止动画，网络消息监听等逻辑
	*onDestroy在页面被销毁的时候调用，适合置空引用对象
	*/
	//class laya.ui.AsynDialog extends laya.ui.Dialog
	var AsynDialog = (function (_super) {
		function AsynDialog() {
			/**@private */
			this._uiView = null;
			/**打开时是否关闭其他页面*/
			this.isCloseOther = false;
			AsynDialog.__super.call(this);
		}

		__class(AsynDialog, 'laya.ui.AsynDialog', _super);
		var __proto = AsynDialog.prototype;
		/**@private */
		__proto.createView = function (uiView) {
			this._uiView = uiView;
		}

		__proto._open = function (modal, closeOther, showEffect) {
			this.isModal = modal;
			this.isCloseOther = closeOther;
			Dialog.manager.lock(true);
			if (this._uiView) this.onCreated();
			else this.onOpen();
		}

		/**
		*在页面未创建时执行一次，再次打开页面不会再执行，适合写一些只执行一次的逻辑，比如资源加载，节点事件监听
		*/
		__proto.onCreated = function () {
			this.createUI();
			this.onOpen();
		}

		/**根据节点数据创建UI*/
		__proto.createUI = function () {
			laya.ui.View.prototype.createView.call(this, this._uiView);
			this._uiView = null;
			this._dealDragArea();
		}

		/**
		*在页面每次打开都会执行，适合做一些每次都需要处理的事情，比如消息请求，根据数据初始化页面
		*/
		__proto.onOpen = function () {
			Dialog.manager.open(this, this.isCloseOther);
			Dialog.manager.lock(false);
		}

		__proto.close = function (type, showEffect) {
			(showEffect === void 0) && (showEffect = true);
			Dialog.manager.close(this);
			this.onClose();
		}

		/**
		*在每次关闭的时候调用，适合关闭时停止动画，网络消息监听等逻辑
		*/
		__proto.onClose = function () { }
		__proto.destroy = function (destroyChild) {
			(destroyChild === void 0) && (destroyChild = true);
			laya.ui.View.prototype.destroy.call(this, destroyChild);
			this._uiView = null;
			this.onDestroy();
		}

		/**
		*在页面被销毁的时候调用，适合置空引用对象
		*/
		__proto.onDestroy = function () { }
		return AsynDialog;
	})(Dialog)


	Laya.__init([View]);
})(window, document, Laya);

if (typeof define === 'function' && define.amd) {
	define('laya.core', ['require', "exports"], function (require, exports) {
		'use strict';
		Object.defineProperty(exports, '__esModule', { value: true });
		for (var i in Laya) {
			var o = Laya[i];
			o && o.__isclass && (exports[i] = o);
		}
	});
}


(function (window, document, Laya) {
	var __un = Laya.un, __uns = Laya.uns, __static = Laya.static, __class = Laya.class, __getset = Laya.getset, __newvec = Laya.__newvec;

	var Browser = laya.utils.Browser, Color = laya.utils.Color, ColorFilterAction = laya.filters.ColorFilterAction;
	var ColorFilterActionGL = laya.filters.webgl.ColorFilterActionGL, Filter = laya.filters.Filter, FilterActionGL = laya.filters.webgl.FilterActionGL;
	var Matrix = laya.maths.Matrix, Rectangle = laya.maths.Rectangle, Render = laya.renders.Render, RenderContext = laya.renders.RenderContext;
	var RenderTarget2D = laya.webgl.resource.RenderTarget2D, RunDriver = laya.utils.RunDriver, ShaderDefines2D = laya.webgl.shader.d2.ShaderDefines2D;
	var Sprite = laya.display.Sprite, Texture = laya.resource.Texture, Value2D = laya.webgl.shader.d2.value.Value2D;
	/**
	*默认的FILTER,什么都不做
	*@private
	*/
	//class laya.filters.FilterAction
	var FilterAction = (function () {
		function FilterAction() {
			this.data = null;
		}

		__class(FilterAction, 'laya.filters.FilterAction');
		var __proto = FilterAction.prototype;
		Laya.imps(__proto, { "laya.filters.IFilterAction": true })
		__proto.apply = function (data) {
			return null;
		}

		return FilterAction;
	})()


	/**
	*@private
	*/
	//class laya.filters.WebGLFilter
	var WebGLFilter = (function () {
		function WebGLFilter() { }
		__class(WebGLFilter, 'laya.filters.WebGLFilter');
		WebGLFilter.enable = function () {
			if (WebGLFilter.isInit) return;
			WebGLFilter.isInit = true;
			if (!Render.isWebGL) return;
			RunDriver.createFilterAction = function (type) {
				var action;
				switch (type) {
					case /*laya.filters.Filter.COLOR*/0x20:
						action = new ColorFilterActionGL();
						break;
					case /*laya.filters.Filter.BLUR*/0x10:
						action = new BlurFilterActionGL();
						break;
					case /*laya.filters.Filter.GLOW*/0x08:
						action = new GlowFilterActionGL();
						break;
				}
				return action;
			}
		}

		WebGLFilter.isInit = false;
		WebGLFilter.__init$ = function () {
			BlurFilterActionGL;
			ColorFilterActionGL;
			GlowFilterActionGL;
			Render;
			RunDriver; {
				RunDriver.createFilterAction = function (type) {
					var action;
					switch (type) {
						case /*laya.filters.Filter.BLUR*/0x10:
							action = new FilterAction();
							break;
						case /*laya.filters.Filter.GLOW*/0x08:
							action = new FilterAction();
							break;
						case /*laya.filters.Filter.COLOR*/0x20:
							action = new ColorFilterAction();
							break;
					}
					return action;
				}
			}
		}

		return WebGLFilter;
	})()


	/**
	*模糊滤镜
	*/
	//class laya.filters.BlurFilter extends laya.filters.Filter
	var BlurFilter = (function (_super) {
		function BlurFilter(strength) {
			/**模糊滤镜的强度(值越大，越不清晰 */
			this.strength = NaN;
			this.strength_sig2_2sig2_gauss1 = [];
			BlurFilter.__super.call(this);
			(strength === void 0) && (strength = 4);
			if (Render.isWebGL) WebGLFilter.enable();
			this.strength = strength;
			this._action = RunDriver.createFilterAction(0x10);
			this._action.data = this;
		}

		__class(BlurFilter, 'laya.filters.BlurFilter', _super);
		var __proto = BlurFilter.prototype;
		/**
		*@private 通知微端
		*/
		__proto.callNative = function (sp) {
			sp.conchModel && sp.conchModel.blurFilter && sp.conchModel.blurFilter(this.strength);
		}

		/**
		*@private
		*当前滤镜对应的操作器
		*/
		__getset(0, __proto, 'action', function () {
			return this._action;
		});

		/**
		*@private
		*当前滤镜的类型
		*/
		__getset(0, __proto, 'type', function () {
			return 0x10;
		});

		return BlurFilter;
	})(Filter)


	/**
	*发光滤镜(也可以当成阴影滤使用）
	*/
	//class laya.filters.GlowFilter extends laya.filters.Filter
	var GlowFilter = (function (_super) {
		function GlowFilter(color, blur, offX, offY) {
			/**滤镜的颜色*/
			this._color = null;
			GlowFilter.__super.call(this);
			this._elements = new Float32Array(9);
			(blur === void 0) && (blur = 4);
			(offX === void 0) && (offX = 6);
			(offY === void 0) && (offY = 6);
			if (Render.isWebGL) {
				WebGLFilter.enable();
			}
			this._color = new Color(color);
			this.blur = Math.min(blur, 20);
			this.offX = offX;
			this.offY = offY;
			this._action = RunDriver.createFilterAction(0x08);
			this._action.data = this;
		}

		__class(GlowFilter, 'laya.filters.GlowFilter', _super);
		var __proto = GlowFilter.prototype;
		/**@private */
		__proto.getColor = function () {
			return this._color._color;
		}

		/**
		*@private 通知微端
		*/
		__proto.callNative = function (sp) {
			sp.conchModel && sp.conchModel.glowFilter && sp.conchModel.glowFilter(this._color.strColor, this._elements[4], this._elements[5], this._elements[6]);
		}

		/**
		*@private
		*滤镜类型
		*/
		__getset(0, __proto, 'type', function () {
			return 0x08;
		});

		/**@private */
		__getset(0, __proto, 'action', function () {
			return this._action;
		});

		/**@private */
		/**@private */
		__getset(0, __proto, 'offY', function () {
			return this._elements[6];
		}, function (value) {
			this._elements[6] = value;
		});

		/**@private */
		/**@private */
		__getset(0, __proto, 'offX', function () {
			return this._elements[5];
		}, function (value) {
			this._elements[5] = value;
		});

		/**@private */
		/**@private */
		__getset(0, __proto, 'blur', function () {
			return this._elements[4];
		}, function (value) {
			this._elements[4] = value;
		});

		return GlowFilter;
	})(Filter)


	/**
	*@private
	*/
	//class laya.filters.webgl.BlurFilterActionGL extends laya.filters.webgl.FilterActionGL
	var BlurFilterActionGL = (function (_super) {
		function BlurFilterActionGL() {
			this.data = null;
			BlurFilterActionGL.__super.call(this);
		}

		__class(BlurFilterActionGL, 'laya.filters.webgl.BlurFilterActionGL', _super);
		var __proto = BlurFilterActionGL.prototype;
		__proto.setValueMix = function (shader) {
			shader.defines.add(this.data.type);
			var o = shader;
		}

		__proto.apply3d = function (scope, sprite, context, x, y) {
			var b = scope.getValue("bounds");
			var shaderValue = Value2D.create(/*laya.webgl.shader.d2.ShaderDefines2D.TEXTURE2D*/0x01, 0);
			shaderValue.setFilters([this.data]);
			var tMatrix = Matrix.EMPTY;
			tMatrix.identity();
			context.ctx.drawTarget(scope, 0, 0, b.width, b.height, Matrix.EMPTY, "src", shaderValue);
			shaderValue.setFilters(null);
		}

		__proto.setValue = function (shader) {
			shader.strength = this.data.strength;
			var sigma = this.data.strength / 3.0;
			var sigma2 = sigma * sigma;
			this.data.strength_sig2_2sig2_gauss1[0] = this.data.strength;
			this.data.strength_sig2_2sig2_gauss1[1] = sigma2;
			this.data.strength_sig2_2sig2_gauss1[2] = 2.0 * sigma2;
			this.data.strength_sig2_2sig2_gauss1[3] = 1.0 / (2.0 * Math.PI * sigma2);
			shader.strength_sig2_2sig2_gauss1 = this.data.strength_sig2_2sig2_gauss1;
		}

		__getset(0, __proto, 'typeMix', function () { return /*laya.filters.Filter.BLUR*/0x10; });
		return BlurFilterActionGL;
	})(FilterActionGL)


	/**
	*@private
	*/
	//class laya.filters.webgl.GlowFilterActionGL extends laya.filters.webgl.FilterActionGL
	var GlowFilterActionGL = (function (_super) {
		function GlowFilterActionGL() {
			this.data = null;
			this._initKey = false;
			this._textureWidth = 0;
			this._textureHeight = 0;
			GlowFilterActionGL.__super.call(this);
		}

		__class(GlowFilterActionGL, 'laya.filters.webgl.GlowFilterActionGL', _super);
		var __proto = GlowFilterActionGL.prototype;
		Laya.imps(__proto, { "laya.filters.IFilterActionGL": true })
		__proto.setValueMix = function (shader) { }
		__proto.apply3d = function (scope, sprite, context, x, y) {
			var b = scope.getValue("bounds");
			scope.addValue("color", this.data.getColor());
			var w = b.width, h = b.height;
			this._textureWidth = w;
			this._textureHeight = h;
			var shaderValue;
			var mat = Matrix.TEMP;
			mat.identity();
			shaderValue = Value2D.create(/*laya.webgl.shader.d2.ShaderDefines2D.TEXTURE2D*/0x01, 0);
			shaderValue.setFilters([this.data]);
			context.ctx.drawTarget(scope, 0, 0, this._textureWidth, this._textureHeight, mat, "src", shaderValue, null);
			shaderValue = Value2D.create(/*laya.webgl.shader.d2.ShaderDefines2D.TEXTURE2D*/0x01, 0);
			context.ctx.drawTarget(scope, 0, 0, this._textureWidth, this._textureHeight, mat, "src", shaderValue);
			return null;
		}

		__proto.setSpriteWH = function (sprite) {
			this._textureWidth = sprite.width;
			this._textureHeight = sprite.height;
		}

		__proto.setValue = function (shader) {
			shader.u_offsetX = this.data.offX;
			shader.u_offsetY = -this.data.offY;
			shader.u_strength = 1.0;
			shader.u_blurX = this.data.blur;
			shader.u_blurY = this.data.blur;
			shader.u_textW = this._textureWidth;
			shader.u_textH = this._textureHeight;
			shader.u_color = this.data.getColor();
		}

		__getset(0, __proto, 'typeMix', function () { return /*laya.filters.Filter.GLOW*/0x08; });
		GlowFilterActionGL.tmpTarget = function (scope, sprite, context, x, y) {
			var b = scope.getValue("bounds");
			var out = scope.getValue("out");
			out.end();
			var tmpTarget = RenderTarget2D.create(b.width, b.height);
			tmpTarget.start();
			var color = scope.getValue("color");
			if (color) {
				tmpTarget.clear(color[0], color[1], color[2], 0);
			}
			scope.addValue("tmpTarget", tmpTarget);
		}

		GlowFilterActionGL.startOut = function (scope, sprite, context, x, y) {
			var tmpTarget = scope.getValue("tmpTarget");
			tmpTarget.end();
			var out = scope.getValue("out");
			out.start();
			var color = scope.getValue("color");
			if (color) {
				out.clear(color[0], color[1], color[2], 0);
			}
		}

		GlowFilterActionGL.recycleTarget = function (scope, sprite, context, x, y) {
			var src = scope.getValue("src");
			var tmpTarget = scope.getValue("tmpTarget");
			tmpTarget.recycle();
		}

		return GlowFilterActionGL;
	})(FilterActionGL)


	Laya.__init([WebGLFilter]);
})(window, document, Laya);

if (typeof define === 'function' && define.amd) {
	define('laya.core', ['require', "exports"], function (require, exports) {
		'use strict';
		Object.defineProperty(exports, '__esModule', { value: true });
		for (var i in Laya) {
			var o = Laya[i];
			o && o.__isclass && (exports[i] = o);
		}
	});
}

(function (window, document, Laya) {
	var __un = Laya.un, __uns = Laya.uns, __static = Laya.static, __class = Laya.class, __getset = Laya.getset, __newvec = Laya.__newvec;
	var Browser = laya.utils.Browser, CSSStyle = laya.display.css.CSSStyle, ClassUtils = laya.utils.ClassUtils;
	var Event = laya.events.Event, HTMLChar = laya.utils.HTMLChar, Loader = laya.net.Loader, Node = laya.display.Node, Rectangle = laya.maths.Rectangle;
	var Render = laya.renders.Render, RenderContext = laya.renders.RenderContext, RenderSprite = laya.renders.RenderSprite;
	var Sprite = laya.display.Sprite, Stat = laya.utils.Stat, Text = laya.display.Text, Texture = laya.resource.Texture;
	var URL = laya.net.URL, Utils = laya.utils.Utils;
	//------------------------------------------------------------------------------------------------------
	// Html格式解析
	//------------------------------------------------------------------------------------------------------
	var HTMLParse = (function () {
		function HTMLParse() { }
		__class(HTMLParse, 'laya.html.utils.HTMLParse');
		HTMLParse.parse = function (ower, xmlString, url) {
			xmlString = xmlString.replace(/<br>/g, "<br/>");
			xmlString = "<root>" + xmlString + "</root>";
			xmlString = xmlString.replace(HTMLParse.spacePattern, HTMLParse.char255);
			var xml = Utils.parseXMLFromString(xmlString);
			HTMLParse._parseXML(ower, xml.childNodes[0].childNodes, url);
		}

		HTMLParse._parseXML = function (parent, xml, url, href) {
			var i = 0, n = 0;
			if (xml.join || xml.item) {
				for (i = 0, n = xml.length; i < n; ++i) {
					HTMLParse._parseXML(parent, xml[i], url, href);
				}
			} else {
				var node;
				var nodeName;
				if (xml.nodeType == 3) {
					var txt;
					if ((parent instanceof laya.html.dom.HTMLDivElement)) {
						if (xml.nodeName == null) {
							xml.nodeName = "#text";
						}
						nodeName = xml.nodeName.toLowerCase();
						txt = xml.textContent.replace(/^\s+|\s+$/g, '');
						if (txt.length > 0) {
							node = ClassUtils.getInstance(nodeName);
							if (node) {
								parent.addChild(node);
								((node).innerTEXT = txt.replace(HTMLParse.char255AndOneSpacePattern, " "));
							}
						}
					} else {
						txt = xml.textContent.replace(/^\s+|\s+$/g, '');
						if (txt.length > 0) {
							((parent).innerTEXT = txt.replace(HTMLParse.char255AndOneSpacePattern, " "));
						}
					}
					return;
				} else {
					nodeName = xml.nodeName.toLowerCase();
					if (nodeName == "#comment") return;
					node = ClassUtils.getInstance(nodeName);
					if (node) {
						node = parent.addChild(node);
						(node).URI = url;
						(node).href = href;
						var attributes = xml.attributes;
						if (attributes && attributes.length > 0) {
							for (i = 0, n = attributes.length; i < n; ++i) {
								var attribute = attributes[i];
								var attrName = attribute.nodeName;
								var value = attribute.value;
								node._setAttributes(attrName, value);
							}
						}
						HTMLParse._parseXML(node, xml.childNodes, url, (node).href);
					} else {
						HTMLParse._parseXML(parent, xml.childNodes, url, href);
					}
				}
			}
		}

		HTMLParse.char255 = String.fromCharCode(255);
		HTMLParse.spacePattern = /&nbsp;|&#160;/g;
		HTMLParse.char255AndOneSpacePattern = new RegExp(String.fromCharCode(255) + "|(\\s+)", "g");
		return HTMLParse;
	})()
	//------------------------------------------------------------------------------------------------------
	// HTML的布局类(对HTML的显示对象进行排版)
	//------------------------------------------------------------------------------------------------------
	//class laya.html.utils.Layout
	var Layout = (function () {
		function Layout() { }
		__class(Layout, 'laya.html.utils.Layout');
		Layout.later = function (element) {
			if (Layout._will == null) {
				Layout._will = [];
				Laya.stage.frameLoop(1, null, function () {
					if (Layout._will.length < 1)
						return;
					for (var i = 0; i < Layout._will.length; i++) {
						laya.html.utils.Layout.layout(Layout._will[i]);
					}
					Layout._will.length = 0;
				});
			}
			Layout._will.push(element);
		}

		Layout.layout = function (element) {
			if (!element || !element._style) return null;
			if ((element._style._type & /*laya.display.css.CSSStyle.ADDLAYOUTED*/0x200) === 0)
				return null;
			element.getStyle()._type &= ~ /*laya.display.css.CSSStyle.ADDLAYOUTED*/0x200;
			var arr = Layout._multiLineLayout(element);
			if (Render.isConchApp && element["the3outCallNative"]) {
				(element).the3outCallNative();
			}
			return arr;
		}

		Layout._multiLineLayout = function (element) {
			if (Text.RightToLeft) return Layout._multiLineLayout2(element);
			var elements = new Array;
			element._addChildsToLayout(elements);
			var i = 0, n = elements.length, j = 0;
			var style = element._getCSSStyle();
			var letterSpacing = style.letterSpacing;
			var leading = style.leading;
			var lineHeight = style.lineHeight;
			var widthAuto = style._widthAuto() || !style.wordWrap;
			var width = widthAuto ? 999999 : element.width;
			var height = element.height;
			var maxWidth = 0;
			var exWidth = style.italic ? style.fontSize / 3 : 0;
			var align = style._getAlign();
			var valign = style._getValign();
			var endAdjust = valign !== 0 || align !== 0 || lineHeight != 0;
			var oneLayout;
			var x = 0;
			var y = 0;
			var w = 0;
			var h = 0;
			var tBottom = 0;
			var lines = new Array;
			var curStyle;
			var curPadding;
			var curLine = lines[0] = new LayoutLine();
			var newLine = false, nextNewline = false;
			var htmlWord;
			var sprite;
			curLine.h = 0;
			if (style.italic)
				width -= style.fontSize / 3;
			var tWordWidth = 0;
			var tLineFirstKey = true;
			function addLine() {
				curLine.y = y;
				y += curLine.h + leading;
				if (curLine.h == 0) y += lineHeight;
				curLine.mWidth = tWordWidth;
				tWordWidth = 0;
				curLine = new LayoutLine();
				lines.push(curLine);
				curLine.h = 0;
				x = 0;
				tLineFirstKey = true;
				newLine = false;
			}
			for (i = 0; i < n; i++) {
				oneLayout = elements[i];
				if (oneLayout == null) {
					if (!tLineFirstKey) {
						x += Layout.DIV_ELEMENT_PADDING;
					}
					curLine.wordStartIndex = curLine.elements.length;
					continue;
				}
				tLineFirstKey = false;
				if ((oneLayout instanceof laya.html.dom.HTMLBrElement)) {
					addLine();
					curLine.y = y;
					continue;
				} else if (oneLayout._isChar()) {
					htmlWord = oneLayout;
					if (!htmlWord.isWord) {
						if (lines.length > 0 && (x + w) > width && curLine.wordStartIndex > 0) {
							var tLineWord = 0;
							tLineWord = curLine.elements.length - curLine.wordStartIndex + 1;
							curLine.elements.length = curLine.wordStartIndex;
							i -= tLineWord;
							addLine();
							continue;
						}
						newLine = false;
						tWordWidth += htmlWord.width;
					} else {
						newLine = nextNewline || (htmlWord.char === '\n');
						curLine.wordStartIndex = curLine.elements.length;
					}
					w = htmlWord.width + letterSpacing;
					h = htmlWord.height;
					nextNewline = false;
					newLine = newLine || ((x + w) > width);
					newLine && addLine();
					curLine.minTextHeight = Math.min(curLine.minTextHeight, oneLayout.height);
				} else {
					curStyle = oneLayout._getCSSStyle();
					sprite = oneLayout;
					curPadding = curStyle.padding;
					curStyle._getCssFloat() === 0 || (endAdjust = true);
					newLine = nextNewline || curStyle.lineElement;
					w = sprite.width * sprite._style._tf.scaleX + curPadding[1] + curPadding[3] + letterSpacing;
					h = sprite.height * sprite._style._tf.scaleY + curPadding[0] + curPadding[2];
					nextNewline = curStyle.lineElement;
					newLine = newLine || ((x + w) > width && curStyle.wordWrap);
					newLine && addLine();
				}
				curLine.elements.push(oneLayout);
				curLine.h = Math.max(curLine.h, h);
				oneLayout.x = x;
				oneLayout.y = y;
				x += w;
				curLine.w = x - letterSpacing;
				curLine.y = y;
				maxWidth = Math.max(x + exWidth, maxWidth);
			}
			y = curLine.y + curLine.h;
			if (endAdjust) {
				var tY = 0;
				var tWidth = width;
				if (widthAuto && element.width > 0) {
					tWidth = element.width;
				}
				for (i = 0, n = lines.length; i < n; i++) {
					lines[i].updatePos(0, tWidth, i, tY, align, valign, lineHeight);
					tY += Math.max(lineHeight, lines[i].h + leading);
				}
				y = tY;
			}
			widthAuto && (element.width = maxWidth);
			(y > element.height) && (element.height = y);
			return [maxWidth, y];
		}

		Layout._multiLineLayout2 = function (element) {
			var elements = new Array;
			element._addChildsToLayout(elements);
			var i = 0, n = elements.length, j = 0;
			var style = element._getCSSStyle();
			var letterSpacing = style.letterSpacing;
			var leading = style.leading;
			var lineHeight = style.lineHeight;
			var widthAuto = style._widthAuto() || !style.wordWrap;
			var width = widthAuto ? 999999 : element.width;
			var height = element.height;
			var maxWidth = 0;
			var exWidth = style.italic ? style.fontSize / 3 : 0;
			var align = 2 - style._getAlign();
			var valign = style._getValign();
			var endAdjust = valign !== 0 || align !== 0 || lineHeight != 0;
			var oneLayout;
			var x = 0;
			var y = 0;
			var w = 0;
			var h = 0;
			var tBottom = 0;
			var lines = new Array;
			var curStyle;
			var curPadding;
			var curLine = lines[0] = new LayoutLine();
			var newLine = false, nextNewline = false;
			var htmlWord;
			var sprite;
			curLine.h = 0;
			if (style.italic)
				width -= style.fontSize / 3;
			var tWordWidth = 0;
			var tLineFirstKey = true;
			function addLine() {
				curLine.y = y;
				y += curLine.h + leading;
				if (curLine.h == 0) y += lineHeight;
				curLine.mWidth = tWordWidth;
				tWordWidth = 0;
				curLine = new LayoutLine();
				lines.push(curLine);
				curLine.h = 0;
				x = 0;
				tLineFirstKey = true;
				newLine = false;
			}
			for (i = 0; i < n; i++) {
				oneLayout = elements[i];
				if (oneLayout == null) {
					if (!tLineFirstKey) {
						x += Layout.DIV_ELEMENT_PADDING;
					}
					curLine.wordStartIndex = curLine.elements.length;
					continue;
				}
				tLineFirstKey = false;
				if ((oneLayout instanceof laya.html.dom.HTMLBrElement)) {
					addLine();
					curLine.y = y;
					continue;
				} else if (oneLayout._isChar()) {
					htmlWord = oneLayout;
					if (!htmlWord.isWord) {
						if (lines.length > 0 && (x + w) > width && curLine.wordStartIndex > 0) {
							var tLineWord = 0;
							tLineWord = curLine.elements.length - curLine.wordStartIndex + 1;
							curLine.elements.length = curLine.wordStartIndex;
							i -= tLineWord;
							addLine();
							continue;
						}
						newLine = false;
						tWordWidth += htmlWord.width;
					} else {
						newLine = nextNewline || (htmlWord.char === '\n');
						curLine.wordStartIndex = curLine.elements.length;
					}
					w = htmlWord.width + letterSpacing;
					h = htmlWord.height;
					nextNewline = false;
					newLine = newLine || ((x + w) > width);
					newLine && addLine();
					curLine.minTextHeight = Math.min(curLine.minTextHeight, oneLayout.height);
				} else {
					curStyle = oneLayout._getCSSStyle();
					sprite = oneLayout;
					curPadding = curStyle.padding;
					curStyle._getCssFloat() === 0 || (endAdjust = true);
					newLine = nextNewline || curStyle.lineElement;
					w = sprite.width * sprite._style._tf.scaleX + curPadding[1] + curPadding[3] + letterSpacing;
					h = sprite.height * sprite._style._tf.scaleY + curPadding[0] + curPadding[2];
					nextNewline = curStyle.lineElement;
					newLine = newLine || ((x + w) > width && curStyle.wordWrap);
					newLine && addLine();
				}
				curLine.elements.push(oneLayout);
				curLine.h = Math.max(curLine.h, h);
				oneLayout.x = x;
				oneLayout.y = y;
				x += w;
				curLine.w = x - letterSpacing;
				curLine.y = y;
				maxWidth = Math.max(x + exWidth, maxWidth);
			}
			y = curLine.y + curLine.h;
			if (endAdjust) {
				var tY = 0;
				var tWidth = width;
				for (i = 0, n = lines.length; i < n; i++) {
					lines[i].updatePos(0, tWidth, i, tY, align, valign, lineHeight);
					tY += Math.max(lineHeight, lines[i].h + leading);
				}
				y = tY;
			}
			widthAuto && (element.width = maxWidth);
			(y > element.height) && (element.height = y);
			for (i = 0, n = lines.length; i < n; i++) {
				lines[i].revertOrder(width);
			}
			return [maxWidth, y];
		}

		Layout._will = null;
		Layout.DIV_ELEMENT_PADDING = 0;
		return Layout;
	})()

	//class laya.html.utils.LayoutLine
	var LayoutLine = (function () {
		function LayoutLine() {
			this.x = 0;
			this.y = 0;
			this.w = 0;
			this.h = 0;
			this.wordStartIndex = 0;
			this.minTextHeight = 99999;
			this.mWidth = 0;
			this.elements = new Array;
		}

		__class(LayoutLine, 'laya.html.utils.LayoutLine');
		var __proto = LayoutLine.prototype;
		/**
		*底对齐（默认）
		*@param left
		*@param width
		*@param dy
		*@param align 水平
		*@param valign 垂直
		*@param lineHeight 行高
		*/
		__proto.updatePos = function (left, width, lineNum, dy, align, valign, lineHeight) {
			var w = 0;
			var one
			if (this.elements.length > 0) {
				one = this.elements[this.elements.length - 1];
				w = one.x + one.width - this.elements[0].x;
			};
			var dx = 0, ddy = NaN;
			align ===/*laya.display.css.CSSStyle.ALIGN_CENTER*/1 && (dx = (width - w) / 2);
			align ===/*laya.display.css.CSSStyle.ALIGN_RIGHT*/2 && (dx = (width - w));
			lineHeight === 0 || valign != 0 || (valign = 1);
			for (var i = 0, n = this.elements.length; i < n; i++) {
				one = this.elements[i];
				var tCSSStyle = one._getCSSStyle();
				dx !== 0 && (one.x += dx);
				switch (tCSSStyle._getValign()) {
					case 0:
						one.y = dy;
						break;
					case /*laya.display.css.CSSStyle.VALIGN_MIDDLE*/1: ;
						var tMinTextHeight = 0;
						if (this.minTextHeight != 99999) {
							tMinTextHeight = this.minTextHeight;
						};
						var tBottomLineY = (tMinTextHeight + lineHeight) / 2;
						tBottomLineY = Math.max(tBottomLineY, this.h);
						if ((one instanceof laya.html.dom.HTMLImageElement)) {
							ddy = dy + tBottomLineY - one.height;
						} else {
							ddy = dy + tBottomLineY - one.height;
						}
						one.y = ddy;
						break;
					case /*laya.display.css.CSSStyle.VALIGN_BOTTOM*/2:
						one.y = dy + (lineHeight - one.height);
						break;
				}
			}
		}

		/**
		*布局反向,目前用于将ltr模式布局转为rtl模式布局
		*/
		__proto.revertOrder = function (width) {
			var one
			if (this.elements.length > 0) {
				var i = 0, len = 0;
				len = this.elements.length;
				for (i = 0; i < len; i++) {
					one = this.elements[i];
					one.x = width - one.x - one.width;
				}
			}
		}

		return LayoutLine;
	})()
	//------------------------------------------------------------------------------------------------------
	// 标签
	//------------------------------------------------------------------------------------------------------
	//class laya.html.dom.HTMLElement extends laya.display.Sprite
	var HTMLElement = (function (_super) {
		function HTMLElement() {
			this.URI = null;
			this._href = null;
			HTMLElement.__super.call(this);
			this._text = HTMLElement._EMPTYTEXT;
			this.setStyle(new CSSStyle(this));
			this._getCSSStyle().valign = "middle";
			this.mouseEnabled = true;
		}

		__class(HTMLElement, 'laya.html.dom.HTMLElement', _super);
		var __proto = HTMLElement.prototype;
		/**
		*@private
		*/
		__proto.the3outCallNative = function () {
			var n = 0;
			if (this._childs && (n = this._childs.length) > 0) {
				for (var i = 0; i < n; i++) {
					this._childs[i].the3outCallNative && this._childs[i].the3outCallNative();
				}
			};
			var word = this._getWords();
			word ? laya.html.dom.HTMLElement.fillWords(this, word, 0, 0, this.style.font, this.style.color, this.style.underLine) : this.graphics.clear();
		}

		__proto.appendChild = function (c) {
			return this.addChild(c);
		}

		/**
		*rtl模式的getWords函數
		*/
		__proto._getWords2 = function () {
			var txt = this._text.text;
			if (!txt || txt.length === 0)
				return null;
			var i = 0, n = 0;
			var realWords;
			var drawWords;
			if (!this._text.drawWords) {
				realWords = txt.split(" ");
				n = realWords.length - 1;
				drawWords = [];
				for (i = 0; i < n; i++) {
					drawWords.push(realWords[i], " ")
				}
				if (n >= 0)
					drawWords.push(realWords[n]);
				this._text.drawWords = drawWords;
			} else {
				drawWords = this._text.drawWords;
			};
			var words = this._text.words;
			if (words && words.length === drawWords.length)
				return words;
			words === null && (this._text.words = words = []);
			words.length = drawWords.length;
			var size;
			var style = this.style;
			var fontStr = style.font;
			for (i = 0, n = drawWords.length; i < n; i++) {
				size = Utils.measureText(drawWords[i], fontStr);
				var tHTMLChar = words[i] = new HTMLChar(drawWords[i], size.width, size.height || style.fontSize, style);
				if (tHTMLChar.char.length > 1) {
					tHTMLChar.charNum = tHTMLChar.char;
				}
				if (this.href) {
					var tSprite = new Sprite();
					this.addChild(tSprite);
					tHTMLChar.setSprite(tSprite);
				}
			}
			return words;
		}

		__proto._getWords = function () {
			if (!Text.CharacterCache) return this._getWords2();
			var txt = this._text.text;
			if (!txt || txt.length === 0)
				return null;
			var words = this._text.words;
			if (words && words.length === txt.length)
				return words;
			words === null && (this._text.words = words = []);
			words.length = txt.length;
			var size;
			var style = this.style;
			var fontStr = style.font;
			var startX = 0;
			for (var i = 0, n = txt.length; i < n; i++) {
				size = Utils.measureText(txt.charAt(i), fontStr);
				var tHTMLChar = words[i] = new HTMLChar(txt.charAt(i), size.width, size.height || style.fontSize, style);
				if (this.href) {
					var tSprite = new Sprite();
					this.addChild(tSprite);
					tHTMLChar.setSprite(tSprite);
				}
			}
			return words;
		}

		__proto.showLinkSprite = function () {
			var words = this._text.words;
			if (words) {
				var tLinkSpriteList = [];
				var tSprite;
				var tHtmlChar;
				for (var i = 0; i < words.length; i++) {
					tHtmlChar = words[i];
					tSprite = new Sprite();
					tSprite.graphics.drawRect(0, 0, tHtmlChar.width, tHtmlChar.height, "#ff0000");
					tSprite.width = tHtmlChar.width;
					tSprite.height = tHtmlChar.height;
					this.addChild(tSprite);
					tLinkSpriteList.push(tSprite);
				}
			}
		}

		__proto._layoutLater = function () {
			var style = this.style;
			if ((style._type & /*laya.display.css.CSSStyle.ADDLAYOUTED*/0x200)) return;
			if (style.widthed(this) && (this._childs.length > 0 || this._getWords() != null) && style.block) {
				Layout.later(this);
				style._type |=/*laya.display.css.CSSStyle.ADDLAYOUTED*/0x200;
			}
			else {
				this.parent && (this.parent)._layoutLater();
			}
		}

		__proto._setAttributes = function (name, value) {
			switch (name) {
				case 'style':
					this.style.cssText(value);
					return;
				case 'class':
					this.className = value;
					return;
			}
			_super.prototype._setAttributes.call(this, name, value);
		}

		__proto.updateHref = function () {
			if (this._href != null) {
				var words = this._getWords();
				if (words) {
					var tHTMLChar;
					var tSprite;
					for (var i = 0; i < words.length; i++) {
						tHTMLChar = words[i];
						tSprite = tHTMLChar.getSprite();
						if (tSprite) {
							tSprite.size(tHTMLChar.width, tHTMLChar.height);
							tSprite.on(/*laya.events.Event.CLICK*/"click", this, this.onLinkHandler);
						}
					}
				}
			}
		}

		__proto.onLinkHandler = function (e) {
			switch (e.type) {
				case /*laya.events.Event.CLICK*/"click": ;
					var target = this;
					while (target) {
						target.event(/*laya.events.Event.LINK*/"link", [this.href]);
						target = target.parent;
					}
					break;
			}
		}

		__proto.formatURL = function (url) {
			if (!this.URI) return url;
			return URL.formatURL(url, this.URI ? this.URI.path : null);
		}

		__getset(0, __proto, 'href', function () {
			return this._href;
		}, function (url) {
			this._href = url;
			if (url != null) {
				this._getCSSStyle().underLine = 1;
				this.updateHref();
			}
		});

		__getset(0, __proto, 'color', null, function (value) {
			this.style.color = value;
		});

		__getset(0, __proto, 'onClick', null, function (value) {
			var fn;
			Laya._runScript("fn=function(event){" + value + ";}");
			this.on(/*laya.events.Event.CLICK*/"click", this, fn);
		});

		__getset(0, __proto, 'id', null, function (value) {
			HTMLDocument.document.setElementById(value, this);
		});

		__getset(0, __proto, 'innerTEXT', function () {
			return this._text.text;
		}, function (value) {
			this.text = value;
		});

		__getset(0, __proto, 'style', function () {
			return this._style;
		});

		__getset(0, __proto, 'text', function () {
			return this._text.text;
		}, function (value) {
			if (this._text == HTMLElement._EMPTYTEXT) {
				this._text = { text: value, words: null };
			}
			else {
				this._text.text = value;
				this._text.words && (this._text.words.length = 0);
			}
			Render.isConchApp && this.the3outCallNative();
			this._renderType |=/*laya.renders.RenderSprite.CHILDS*/0x800;
			this.repaint();
			this.updateHref();
		});

		__getset(0, __proto, 'parent', _super.prototype._$get_parent, function (value) {
			if ((value instanceof laya.html.dom.HTMLElement)) {
				var p = value;
				this.URI || (this.URI = p.URI);
				this.style.inherit(p.style);
			}
			Laya.superSet(Sprite, this, 'parent', value);
		});

		__getset(0, __proto, 'className', null, function (value) {
			this.style.attrs(HTMLDocument.document.styleSheets['.' + value]);
		});

		HTMLElement.fillWords = function (ele, words, x, y, font, color, underLine) {
			ele.graphics.clear();
			for (var i = 0, n = words.length; i < n; i++) {
				var a = words[i];
				ele.graphics.fillText(a.char, a.x + x, a.y + y, font, color, 'left', underLine);
			}
		}

		HTMLElement._EMPTYTEXT = { text: null, words: null };
		return HTMLElement;
	})(Sprite)

	//class laya.html.dom.HTMLBrElement extends laya.html.dom.HTMLElement
	var HTMLBrElement = (function (_super) {
		function HTMLBrElement() {
			HTMLBrElement.__super.call(this);
			this.style.lineElement = true;
			this.style.block = true;
		}

		__class(HTMLBrElement, 'laya.html.dom.HTMLBrElement', _super);
		return HTMLBrElement;
	})(HTMLElement)
	//------------------------------------------------------------------------------------------------------
	// Div标签
	//------------------------------------------------------------------------------------------------------
	//class laya.html.dom.HTMLDivElement extends laya.html.dom.HTMLElement
	var HTMLDivElement = (function (_super) {
		function HTMLDivElement() {
			/**实际内容的高 */
			this.contextHeight = NaN;
			/**实际内容的宽 */
			this.contextWidth = NaN;
			HTMLDivElement.__super.call(this);
			this.style.block = true;
			this.style.lineElement = true;
			this.style.width = 200;
			this.style.height = 200;
			HTMLStyleElement;
		}

		__class(HTMLDivElement, 'laya.html.dom.HTMLDivElement', _super);
		var __proto = HTMLDivElement.prototype;
		/**
		*追加内容，解析并对显示对象排版
		*@param text
		*/
		__proto.appendHTML = function (text) {
			HTMLParse.parse(this, text, this.URI);
			this.layout();
		}

		/**
		*@private
		*@param out
		*@return
		*/
		__proto._addChildsToLayout = function (out) {
			var words = this._getWords();
			if (words == null && this._childs.length == 0) return false;
			words && words.forEach(function (o) {
				out.push(o);
			});
			var tFirstKey = true;
			for (var i = 0, len = this._childs.length; i < len; i++) {
				var o = this._childs[i];
				if (tFirstKey) {
					tFirstKey = false;
				} else {
					out.push(null);
				}
				o._addToLayout(out)
			}
			return true;
		}

		/**
		*@private
		*@param out
		*/
		__proto._addToLayout = function (out) {
			this.layout();
		}

		/**
		*@private
		*对显示内容进行排版
		*/
		__proto.layout = function () {
			if (!this.style) return;
			this.style._type |=/*laya.display.css.CSSStyle.ADDLAYOUTED*/0x200;
			var tArray = Layout.layout(this);
			if (tArray) {
				if (!this._$P.mHtmlBounds) this._set$P("mHtmlBounds", new Rectangle());
				var tRectangle = this._$P.mHtmlBounds;
				tRectangle.x = tRectangle.y = 0;
				tRectangle.width = this.contextWidth = tArray[0];
				tRectangle.height = this.contextHeight = tArray[1];
				this.setBounds(tRectangle);
			}
		}

		/**
		*获取对象的高
		*/
		__getset(0, __proto, 'height', function () {
			if (this._height) return this._height;
			return this.contextHeight;
		}, _super.prototype._$set_height);

		/**
		*设置标签内容
		*/
		__getset(0, __proto, 'innerHTML', null, function (text) {
			this.destroyChildren();
			this.appendHTML(text);
		});

		/**
		*获取对象的宽
		*/
		__getset(0, __proto, 'width', function () {
			if (this._width) return this._width;
			return this.contextWidth;
		}, function (value) {
			var changed = false;
			if (value === 0) {
				changed = value != this._width;
			} else {
				changed = value != this.width;
			}
			Laya.superSet(HTMLElement, this, 'width', value);
			if (changed)
				this.layout();
		});

		return HTMLDivElement;
	})(HTMLElement)

	//class laya.html.dom.HTMLImageElement extends laya.html.dom.HTMLElement
	var HTMLImageElement = (function (_super) {
		function HTMLImageElement() {
			this._tex = null;
			this._url = null;
			this._renderArgs = [];
			HTMLImageElement.__super.call(this);
			this.style.block = true;
		}

		__class(HTMLImageElement, 'laya.html.dom.HTMLImageElement', _super);
		var __proto = HTMLImageElement.prototype;
		__proto._addToLayout = function (out) {
			!this._style.absolute && out.push(this);
		}

		__proto.render = function (context, x, y) {
			if (!this._tex || !this._tex.loaded || !this._tex.loaded || this._width < 1 || this._height < 1) return;
			Stat.spriteCount++;
			this._renderArgs[0] = this._tex;
			this._renderArgs[1] = this.x;
			this._renderArgs[2] = this.y;
			this._renderArgs[3] = this.width || this._tex.width;
			this._renderArgs[4] = this.height || this._tex.height;
			context.ctx.drawTexture2(x, y, this.style.translateX, this.style.translateY, this.transform, this.style.alpha, this.style.blendMode, this._renderArgs);
		}

		/**
		*@private
		*/
		__proto.the3outCallNative = function () {
			var n = 0;
			if (this._childs && (n = this._childs.length) > 0) {
				for (var i = 0; i < n; i++) {
					this._childs[i].the3outCallNative && this._childs[i].the3outCallNative();
				}
			}
		}

		__getset(0, __proto, 'src', null, function (url) {
			var _$this = this;
			url = this.formatURL(url);
			if (this._url == url) return;
			this._url = url;
			var tex = this._tex = Loader.getRes(url);
			if (!tex) {
				this._tex = tex = new Texture();
				tex.load(url);
				Loader.cacheRes(url, tex);
			}
			function onloaded() {
				var style = _$this._style;
				var w = style.widthed(_$this) ? -1 : _$this._tex.width;
				var h = style.heighted(_$this) ? -1 : _$this._tex.height;
				if (!style.widthed(_$this) && _$this._width != _$this._tex.width) {
					_$this.width = _$this._tex.width;
					_$this.parent && (_$this.parent)._layoutLater();
				}
				if (!style.heighted(_$this) && _$this._height != _$this._tex.height) {
					_$this.height = _$this._tex.height;
					_$this.parent && (_$this.parent)._layoutLater();
				}
				if (Render.isConchApp) {
					_$this._renderArgs[0] = _$this._tex;
					_$this._renderArgs[1] = _$this.x;
					_$this._renderArgs[2] = _$this.y;
					_$this._renderArgs[3] = _$this.width || _$this._tex.width;
					_$this._renderArgs[4] = _$this.height || _$this._tex.height;
					_$this.graphics.drawTexture(_$this._tex, 0, 0, _$this._renderArgs[3], _$this._renderArgs[4]);
				}
				_$this.repaint();
				_$this.parentRepaint();
			}
			tex.loaded ? onloaded() : tex.on(/*laya.events.Event.LOADED*/"loaded", null, onloaded);
		});

		return HTMLImageElement;
	})(HTMLElement)

})(window, document, Laya);

if (typeof define === 'function' && define.amd) {
	define('laya.core', ['require', "exports"], function (require, exports) {
		'use strict';
		Object.defineProperty(exports, '__esModule', { value: true });
		for (var i in Laya) {
			var o = Laya[i];
			o && o.__isclass && (exports[i] = o);
		}
	});
}

(function (window, document, Laya) {
	var __un = Laya.un, __uns = Laya.uns, __static = Laya.static, __class = Laya.class, __getset = Laya.getset, __newvec = Laya.__newvec;
	/**
	*...
	*@author dongketao
	*/
	//class PathFinding.core.DiagonalMovement
	var DiagonalMovement = (function () {
		function DiagonalMovement() { }
		__class(DiagonalMovement, 'PathFinding.core.DiagonalMovement');
		DiagonalMovement.Always = 1;
		DiagonalMovement.Never = 2;
		DiagonalMovement.IfAtMostOneObstacle = 3;
		DiagonalMovement.OnlyWhenNoObstacles = 4;
		return DiagonalMovement;
	})()


	/**
	*...
	*@author dongketao
	*/
	//class PathFinding.core.Grid
	var Grid = (function () {
		function Grid(width_or_matrix, height, matrix) {
			this.width = 0;
			this.height = 0;
			this.nodes = null;
			var width = 0;
			if ((typeof width_or_matrix == 'number')) {
				width = width_or_matrix;
			}
			else {
				height = width_or_matrix.length;
				width = width_or_matrix[0].length;
				matrix = width_or_matrix;
			}
			this.width = width;
			this.height = height;
			this.nodes = this._buildNodes(width, height, matrix);
		}

		__class(Grid, 'PathFinding.core.Grid');
		var __proto = Grid.prototype;
		/**
		*Build and return the nodes.
		*@private
		*@param {number}width
		*@param {number}height
		*@param {Array<Array<number|boolean>>}[matrix]-A 0-1 matrix representing
		*the walkable status of the nodes.
		*@see Grid
		*/
		__proto._buildNodes = function (width, height, matrix) {
			var i = 0, j = 0, nodes = [];
			for (i = 0; i < height; ++i) {
				nodes[i] = [];
				for (j = 0; j < width; ++j) {
					nodes[i][j] = new Node$1(j, i);
				}
			}
			if (matrix == null) {
				return nodes;
			}
			if (matrix.length != height || matrix[0].length != width) {
				throw new Error('Matrix size does not fit');
			}
			for (i = 0; i < height; ++i) {
				for (j = 0; j < width; ++j) {
					if (matrix[i][j]) {
						nodes[i][j].walkable = false;
					}
				}
			}
			return nodes;
		}

		__proto.getNodeAt = function (x, y) {
			return this.nodes[y][x];
		}

		/**
		*Determine whether the node at the given position is walkable.
		*(Also returns false if the position is outside the grid.)
		*@param {number}x-The x coordinate of the node.
		*@param {number}y-The y coordinate of the node.
		*@return {boolean}-The walkability of the node.
		*/
		__proto.isWalkableAt = function (x, y) {
			return this.isInside(x, y) && this.nodes[y][x].walkable;
		}

		/**
		*Determine whether the position is inside the grid.
		*XXX:`grid.isInside(x,y)` is wierd to read.
		*It should be `(x,y)is inside grid`,but I failed to find a better
		*name for this method.
		*@param {number}x
		*@param {number}y
		*@return {boolean}
		*/
		__proto.isInside = function (x, y) {
			return (x >= 0 && x < this.width) && (y >= 0 && y < this.height);
		}

		/**
		*Set whether the node on the given position is walkable.
		*NOTE:throws exception if the coordinate is not inside the grid.
		*@param {number}x-The x coordinate of the node.
		*@param {number}y-The y coordinate of the node.
		*@param {boolean}walkable-Whether the position is walkable.
		*/
		__proto.setWalkableAt = function (x, y, walkable) {
			this.nodes[y][x].walkable = walkable;
		}

		/**
		*Get the neighbors of the given node.
		*
		*offsets diagonalOffsets:
		*+---+---+---++---+---+---+
		*| | 0 | | | 0 | | 1 |
		*+---+---+---++---+---+---+
		*| 3 | | 1 | | | | |
		*+---+---+---++---+---+---+
		*| | 2 | | | 3 | | 2 |
		*+---+---+---++---+---+---+
		*
		*When allowDiagonal is true,if offsets[i] is valid,then
		*diagonalOffsets[i] and
		*diagonalOffsets[(i+1)% 4] is valid.
		*@param {Node}node
		*@param {diagonalMovement}diagonalMovement
		*/
		__proto.getNeighbors = function (node, diagonalMovement) {
			var x = node.x, y = node.y, neighbors = [], s0 = false, d0 = false, s1 = false, d1 = false, s2 = false, d2 = false, s3 = false, d3 = false, nodes = this.nodes;
			if (this.isWalkableAt(x, y - 1)) {
				neighbors.push(nodes[y - 1][x]);
				s0 = true;
			}
			if (this.isWalkableAt(x + 1, y)) {
				neighbors.push(nodes[y][x + 1]);
				s1 = true;
			}
			if (this.isWalkableAt(x, y + 1)) {
				neighbors.push(nodes[y + 1][x]);
				s2 = true;
			}
			if (this.isWalkableAt(x - 1, y)) {
				neighbors.push(nodes[y][x - 1]);
				s3 = true;
			}
			if (diagonalMovement == DiagonalMovement.Never) {
				return neighbors;
			}
			if (diagonalMovement == DiagonalMovement.OnlyWhenNoObstacles) {
				d0 = s3 && s0;
				d1 = s0 && s1;
				d2 = s1 && s2;
				d3 = s2 && s3;
			}
			else if (diagonalMovement == DiagonalMovement.IfAtMostOneObstacle) {
				d0 = s3 || s0;
				d1 = s0 || s1;
				d2 = s1 || s2;
				d3 = s2 || s3;
			}
			else if (diagonalMovement == DiagonalMovement.Always) {
				d0 = true;
				d1 = true;
				d2 = true;
				d3 = true;
			}
			else {
				throw new Error('Incorrect value of diagonalMovement');
			}
			if (d0 && this.isWalkableAt(x - 1, y - 1)) {
				neighbors.push(nodes[y - 1][x - 1]);
			}
			if (d1 && this.isWalkableAt(x + 1, y - 1)) {
				neighbors.push(nodes[y - 1][x + 1]);
			}
			if (d2 && this.isWalkableAt(x + 1, y + 1)) {
				neighbors.push(nodes[y + 1][x + 1]);
			}
			if (d3 && this.isWalkableAt(x - 1, y + 1)) {
				neighbors.push(nodes[y + 1][x - 1]);
			}
			return neighbors;
		}

		/**
		*Get a clone of this grid.
		*@return {Grid}Cloned grid.
		*/
		__proto.clone = function () {
			var i = 0, j = 0,
				width = this.width, height = this.height, thisNodes = this.nodes,
				newGrid = new Grid(width, height), newNodes = [];
			for (i = 0; i < height; ++i) {
				newNodes[i] = [];
				for (j = 0; j < width; ++j) {
					newNodes[i][j] = new Node$1(j, i, thisNodes[i][j].walkable);
				}
			}
			newGrid.nodes = newNodes;
			return newGrid;
		}

		__proto.reset = function () {
			var _node;
			for (var i = 0; i < this.height; ++i) {
				for (var j = 0; j < this.width; ++j) {
					_node = this.nodes[i][j];
					_node.g = 0;
					_node.f = 0;
					_node.h = 0;
					_node.by = 0;
					_node.parent = null;
					_node.opened = null;
					_node.closed = null;
					_node.tested = null;
				}
			}
		}

		Grid.createGridFromAStarMap = function (texture) {
			var textureWidth = texture.width;
			var textureHeight = texture.height;
			var pixelsInfo = texture.getPixels();
			var aStarArr = [];
			var index = 0;
			for (var w = 0; w < textureWidth; w++) {
				var colaStarArr = aStarArr[w] = [];
				for (var h = 0; h < textureHeight; h++) {
					var r = pixelsInfo[index++];
					var g = pixelsInfo[index++];
					var b = pixelsInfo[index++];
					var a = pixelsInfo[index++];
					if (r == 255 && g == 255 && b == 255 && a == 255)
						colaStarArr[h] = 1;
					else {
						colaStarArr[h] = 0;
					}
				}
			};
			var gird = new Grid(textureWidth, textureHeight, aStarArr);
			return gird;
		}

		return Grid;
	})()


	/**
	*...
	*@author dongketao
	*/
	//class PathFinding.core.Heuristic
	var Heuristic = (function () {
		function Heuristic() { }
		__class(Heuristic, 'PathFinding.core.Heuristic');
		Heuristic.manhattan = function (dx, dy) {
			return dx + dy;
		}

		Heuristic.euclidean = function (dx, dy) {
			return Math.sqrt(dx * dx + dy * dy);
		}

		Heuristic.octile = function (dx, dy) {
			var F = Math.SQRT2 - 1;
			return (dx < dy) ? F * dx + dy : F * dy + dx;
		}

		Heuristic.chebyshev = function (dx, dy) {
			return Math.max(dx, dy);
		}

		return Heuristic;
	})()


	/**
	*...
	*@author dongketao
	*/
	//class PathFinding.core.Node
	var Node$1 = (function () {
		function Node(x, y, walkable) {
			this.x = 0;
			this.y = 0;
			this.g = 0;
			this.f = 0;
			this.h = 0;
			this.by = 0;
			this.parent = null;
			this.opened = null;
			this.closed = null;
			this.tested = null;
			this.retainCount = null;
			this.walkable = false;
			(walkable === void 0) && (walkable = true);
			this.x = x;
			this.y = y;
			this.walkable = walkable;
		}

		__class(Node, 'PathFinding.core.Node', null, 'Node$1');
		return Node;
	})()


	/**
	*...
	*@author dongketao
	*/
	//class PathFinding.core.Util
	var Util = (function () {
		function Util() { }
		__class(Util, 'PathFinding.core.Util');
		Util.backtrace = function (node) {
			var path = [[node.x, node.y]];
			while (node.parent) {
				node = node.parent;
				path.push([node.x, node.y]);
			}
			return path.reverse();
		}

		Util.biBacktrace = function (nodeA, nodeB) {
			var pathA = Util.backtrace(nodeA), pathB = Util.backtrace(nodeB);
			return pathA.concat(pathB.reverse());
		}

		Util.pathLength = function (path) {
			var i = 0, sum = 0, a = 0, b = 0, dx = 0, dy = 0;
			for (i = 1; i < path.length; ++i) {
				a = path[i - 1];
				b = path[i];
				dx = a[0] - b[0];
				dy = a[1] - b[1];
				sum += Math.sqrt(dx * dx + dy * dy);
			}
			return sum;
		}

		Util.interpolate = function (x0, y0, x1, y1) {
			var abs = Math.abs, line = [], sx = 0, sy = 0, dx = 0, dy = 0, err = 0, e2 = 0;
			dx = abs(x1 - x0);
			dy = abs(y1 - y0);
			sx = (x0 < x1) ? 1 : -1;
			sy = (y0 < y1) ? 1 : -1;
			err = dx - dy;
			while (true) {
				line.push([x0, y0]);
				if (x0 == x1 && y0 == y1) {
					break;
				}
				e2 = 2 * err;
				if (e2 > -dy) {
					err = err - dy;
					x0 = x0 + sx;
				}
				if (e2 < dx) {
					err = err + dx;
					y0 = y0 + sy;
				}
			}
			return line;
		}

		Util.expandPath = function (path) {
			var expanded = [], len = path.length, coord0, coord1, interpolated, interpolatedLen = 0, i = 0, j = 0;
			if (len < 2) {
				return expanded;
			}
			for (i = 0; i < len - 1; ++i) {
				coord0 = path[i];
				coord1 = path[i + 1];
				interpolated = Util.interpolate(coord0[0], coord0[1], coord1[0], coord1[1]);
				interpolatedLen = interpolated.length;
				for (j = 0; j < interpolatedLen - 1; ++j) {
					expanded.push(interpolated[j]);
				}
			}
			expanded.push(path[len - 1]);
			return expanded;
		}

		Util.smoothenPath = function (grid, path) {
			var len = path.length, x0 = path[0][0],
				y0 = path[0][1],
				x1 = path[len - 1][0],
				y1 = path[len - 1][1],
				sx = 0, sy = 0,
				ex = 0, ey = 0,
				newPath, i = 0, j = 0, coord, line, testCoord, blocked = false, lastValidCoord;
			sx = x0;
			sy = y0;
			newPath = [[sx, sy]];
			for (i = 2; i < len; ++i) {
				coord = path[i];
				ex = coord[0];
				ey = coord[1];
				line = Util.interpolate(sx, sy, ex, ey);
				blocked = false;
				for (j = 1; j < line.length; ++j) {
					testCoord = line[j];
					if (!grid.isWalkableAt(testCoord[0], testCoord[1])) {
						blocked = true;
						break;
					}
				}
				if (blocked) {
					lastValidCoord = path[i - 1];
					newPath.push(lastValidCoord);
					sx = lastValidCoord[0];
					sy = lastValidCoord[1];
				}
			}
			newPath.push([x1, y1]);
			return newPath;
		}

		Util.compressPath = function (path) {
			if (path.length < 3) {
				return path;
			};
			var compressed = [], sx = path[0][0],
				sy = path[0][1],
				px = path[1][0],
				py = path[1][1],
				dx = px - sx,
				dy = py - sy,
				lx = 0, ly = 0, ldx = 0, ldy = 0, sq = NaN, i = 0;
			sq = Math.sqrt(dx * dx + dy * dy);
			dx /= sq;
			dy /= sq;
			compressed.push([sx, sy]);
			for (i = 2; i < path.length; i++) {
				lx = px;
				ly = py;
				ldx = dx;
				ldy = dy;
				px = path[i][0];
				py = path[i][1];
				dx = px - lx;
				dy = py - ly;
				sq = Math.sqrt(dx * dx + dy * dy);
				dx /= sq;
				dy /= sq;
				if (dx !== ldx || dy !== ldy) {
					compressed.push([lx, ly]);
				}
			}
			compressed.push([px, py]);
			return compressed;
		}

		return Util;
	})()


	/**
	*...
	*@author dongketao
	*/
	//class PathFinding.finders.AStarFinder
	var AStarFinder = (function () {
		function AStarFinder(opt) {
			this.allowDiagonal = false;
			this.dontCrossCorners = false;
			this.heuristic = null;
			this.weight = 0;
			this.diagonalMovement = 0;
			opt = opt || {};
			this.allowDiagonal = opt.allowDiagonal;
			this.dontCrossCorners = opt.dontCrossCorners;
			this.heuristic = opt.heuristic || Heuristic.manhattan;
			this.weight = opt.weight || 1;
			this.diagonalMovement = opt.diagonalMovement;
			if (!this.diagonalMovement) {
				if (!this.allowDiagonal) {
					this.diagonalMovement = DiagonalMovement.Never;
				}
				else {
					if (this.dontCrossCorners) {
						this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;
					}
					else {
						this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;
					}
				}
			}
			if (this.diagonalMovement === DiagonalMovement.Never) {
				this.heuristic = opt.heuristic || Heuristic.manhattan;
			}
			else {
				this.heuristic = opt.heuristic || Heuristic.octile;
			}
		}

		__class(AStarFinder, 'PathFinding.finders.AStarFinder');
		var __proto = AStarFinder.prototype;
		/**
		*Find and return the the path.
		*@return {Array<Array<number>>}The path,including both start and
		*end positions.
		*/
		__proto.findPath = function (startX, startY, endX, endY, grid) {
			var openList = new Heap(function (nodeA, nodeB) {
				return nodeA.f - nodeB.f;
			}), startNode = grid.getNodeAt(startX, startY), endNode = grid.getNodeAt(endX, endY), heuristic = this.heuristic, diagonalMovement = this.diagonalMovement, weight = this.weight, abs = Math.abs, SQRT2 = Math.SQRT2, node, neighbors, neighbor, i = 0, l = 0, x = 0, y = 0, ng = 0;
			startNode.g = 0;
			startNode.f = 0;
			openList.push(startNode);
			startNode.opened = true;
			while (!openList.empty()) {
				node = openList.pop();
				node.closed = true;
				if (node === endNode) {
					return Util.backtrace(endNode);
				}
				neighbors = grid.getNeighbors(node, diagonalMovement);
				for (i = 0, l = neighbors.length; i < l; ++i) {
					neighbor = neighbors[i];
					if (neighbor.closed) {
						continue;
					}
					x = neighbor.x;
					y = neighbor.y;
					ng = node.g + ((x - node.x === 0 || y - node.y === 0) ? 1 : SQRT2);
					if (!neighbor.opened || ng < neighbor.g) {
						neighbor.g = ng;
						neighbor.h = neighbor.h || weight * heuristic(abs(x - endX), abs(y - endY));
						neighbor.f = neighbor.g + neighbor.h;
						neighbor.parent = node;
						if (!neighbor.opened) {
							openList.push(neighbor);
							neighbor.opened = true;
						}
						else {
							openList.updateItem(neighbor);
						}
					}
				}
			}
			return [];
		}

		return AStarFinder;
	})()


	/**
	*...
	*@author ...
	*/
	//class PathFinding.finders.BiAStarFinder
	var BiAStarFinder = (function () {
		function BiAStarFinder(opt) {
			this.allowDiagonal = false;
			this.dontCrossCorners = false;
			this.diagonalMovement = 0;
			this.heuristic = null;
			this.weight = 0;
			opt = opt || {};
			this.allowDiagonal = opt.allowDiagonal;
			this.dontCrossCorners = opt.dontCrossCorners;
			this.diagonalMovement = opt.diagonalMovement;
			this.heuristic = opt.heuristic || Heuristic.manhattan;
			this.weight = opt.weight || 1;
			if (!this.diagonalMovement) {
				if (!this.allowDiagonal) {
					this.diagonalMovement = DiagonalMovement.Never;
				}
				else {
					if (this.dontCrossCorners) {
						this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;
					}
					else {
						this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;
					}
				}
			}
			if (this.diagonalMovement == DiagonalMovement.Never) {
				this.heuristic = opt.heuristic || Heuristic.manhattan;
			}
			else {
				this.heuristic = opt.heuristic || Heuristic.octile;
			}
		}

		__class(BiAStarFinder, 'PathFinding.finders.BiAStarFinder');
		var __proto = BiAStarFinder.prototype;
		/**
		*Find and return the the path.
		*@return {Array<Array<number>>}The path,including both start and
		*end positions.
		*/
		__proto.findPath = function (startX, startY, endX, endY, grid) {
			var cmp = function (nodeA, nodeB) {
				return nodeA.f - nodeB.f;
			};
			var startOpenList = new Heap(cmp), endOpenList = new Heap(cmp), startNode = grid.getNodeAt(startX, startY), endNode = grid.getNodeAt(endX, endY), heuristic = this.heuristic, diagonalMovement = this.diagonalMovement, weight = this.weight, abs = Math.abs, SQRT2 = Math.SQRT2, node, neighbors, neighbor, i = 0, l = 0, x = 0, y = 0, ng = 0, BY_START = 1, BY_END = 2;
			startNode.g = 0;
			startNode.f = 0;
			startOpenList.push(startNode);
			startNode.opened = BY_START;
			endNode.g = 0;
			endNode.f = 0;
			endOpenList.push(endNode);
			endNode.opened = BY_END;
			while (!startOpenList.empty() && !endOpenList.empty()) {
				node = startOpenList.pop();
				node.closed = true;
				neighbors = grid.getNeighbors(node, diagonalMovement);
				for (i = 0, l = neighbors.length; i < l; ++i) {
					neighbor = neighbors[i];
					if (neighbor.closed) {
						continue;
					}
					if (neighbor.opened === BY_END) {
						return Util.biBacktrace(node, neighbor);
					}
					x = neighbor.x;
					y = neighbor.y;
					ng = node.g + ((x - node.x === 0 || y - node.y === 0) ? 1 : SQRT2);
					if (!neighbor.opened || ng < neighbor.g) {
						neighbor.g = ng;
						neighbor.h = neighbor.h || weight * heuristic(abs(x - endX), abs(y - endY));
						neighbor.f = neighbor.g + neighbor.h;
						neighbor.parent = node;
						if (!neighbor.opened) {
							startOpenList.push(neighbor);
							neighbor.opened = BY_START;
						}
						else {
							startOpenList.updateItem(neighbor);
						}
					}
				}
				node = endOpenList.pop();
				node.closed = true;
				neighbors = grid.getNeighbors(node, diagonalMovement);
				for (i = 0, l = neighbors.length; i < l; ++i) {
					neighbor = neighbors[i];
					if (neighbor.closed) {
						continue;
					}
					if (neighbor.opened === BY_START) {
						return Util.biBacktrace(neighbor, node);
					}
					x = neighbor.x;
					y = neighbor.y;
					ng = node.g + ((x - node.x === 0 || y - node.y === 0) ? 1 : SQRT2);
					if (!neighbor.opened || ng < neighbor.g) {
						neighbor.g = ng;
						neighbor.h = neighbor.h || weight * heuristic(abs(x - startX), abs(y - startY));
						neighbor.f = neighbor.g + neighbor.h;
						neighbor.parent = node;
						if (!neighbor.opened) {
							endOpenList.push(neighbor);
							neighbor.opened = BY_END;
						}
						else {
							endOpenList.updateItem(neighbor);
						}
					}
				}
			}
			return [];
		}

		return BiAStarFinder;
	})()


	/**
	*...
	*@author dongketao
	*/
	//class PathFinding.finders.BiBreadthFirstFinder
	var BiBreadthFirstFinder = (function () {
		function BiBreadthFirstFinder(opt) {
			this.allowDiagonal = false;
			this.dontCrossCorners = false;
			this.heuristic = null;
			this.weight = 0;
			this.diagonalMovement = 0;
			opt = opt || {};
			this.allowDiagonal = opt.allowDiagonal;
			this.dontCrossCorners = opt.dontCrossCorners;
			this.diagonalMovement = opt.diagonalMovement;
			if (!this.diagonalMovement) {
				if (!this.allowDiagonal) {
					this.diagonalMovement = DiagonalMovement.Never;
				}
				else {
					if (this.dontCrossCorners) {
						this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;
					}
					else {
						this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;
					}
				}
			}
		}

		__class(BiBreadthFirstFinder, 'PathFinding.finders.BiBreadthFirstFinder');
		var __proto = BiBreadthFirstFinder.prototype;
		/**
		*Find and return the the path.
		*@return {Array<Array<number>>}The path,including both start and
		*end positions.
		*/
		__proto.findPath = function (startX, startY, endX, endY, grid) {
			var startNode = grid.getNodeAt(startX, startY), endNode = grid.getNodeAt(endX, endY), startOpenList = [], endOpenList = [], neighbors, neighbor, node, diagonalMovement = this.diagonalMovement, BY_START = 0, BY_END = 1, i = 0, l = 0;
			startOpenList.push(startNode);
			startNode.opened = true;
			startNode.by = BY_START;
			endOpenList.push(endNode);
			endNode.opened = true;
			endNode.by = BY_END;
			while (startOpenList.length && endOpenList.length) {
				node = startOpenList.shift();
				node.closed = true;
				neighbors = grid.getNeighbors(node, diagonalMovement);
				for (i = 0, l = neighbors.length; i < l; ++i) {
					neighbor = neighbors[i];
					if (neighbor.closed) {
						continue;
					}
					if (neighbor.opened) {
						if (neighbor.by === BY_END) {
							return Util.biBacktrace(node, neighbor);
						}
						continue;
					}
					startOpenList.push(neighbor);
					neighbor.parent = node;
					neighbor.opened = true;
					neighbor.by = BY_START;
				}
				node = endOpenList.shift();
				node.closed = true;
				neighbors = grid.getNeighbors(node, diagonalMovement);
				for (i = 0, l = neighbors.length; i < l; ++i) {
					neighbor = neighbors[i];
					if (neighbor.closed) {
						continue;
					}
					if (neighbor.opened) {
						if (neighbor.by === BY_START) {
							return Util.biBacktrace(neighbor, node);
						}
						continue;
					}
					endOpenList.push(neighbor);
					neighbor.parent = node;
					neighbor.opened = true;
					neighbor.by = BY_END;
				}
			}
			return [];
		}

		return BiBreadthFirstFinder;
	})()


	/**
	*...
	*@author dongketao
	*/
	//class PathFinding.finders.BreadthFirstFinder
	var BreadthFirstFinder = (function () {
		function BreadthFirstFinder(opt) {
			this.allowDiagonal = false;
			this.dontCrossCorners = false;
			this.heuristic = null;
			this.weight = 0;
			this.diagonalMovement = 0;
			opt = opt || {};
			this.allowDiagonal = opt.allowDiagonal;
			this.dontCrossCorners = opt.dontCrossCorners;
			this.diagonalMovement = opt.diagonalMovement;
			if (!this.diagonalMovement) {
				if (!this.allowDiagonal) {
					this.diagonalMovement = DiagonalMovement.Never;
				}
				else {
					if (this.dontCrossCorners) {
						this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;
					}
					else {
						this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;
					}
				}
			}
		}

		__class(BreadthFirstFinder, 'PathFinding.finders.BreadthFirstFinder');
		var __proto = BreadthFirstFinder.prototype;
		/**
		*Find and return the the path.
		*@return {Array<Array<number>>}The path,including both start and
		*end positions.
		*/
		__proto.findPath = function (startX, startY, endX, endY, grid) {
			var openList = [], diagonalMovement = this.diagonalMovement, startNode = grid.getNodeAt(startX, startY), endNode = grid.getNodeAt(endX, endY), neighbors, neighbor, node, i = 0, l = 0;
			openList.push(startNode);
			startNode.opened = true;
			while (openList.length) {
				node = openList.shift();
				node.closed = true;
				if (node === endNode) {
					return Util.backtrace(endNode);
				}
				neighbors = grid.getNeighbors(node, diagonalMovement);
				for (i = 0, l = neighbors.length; i < l; ++i) {
					neighbor = neighbors[i];
					if (neighbor.closed || neighbor.opened) {
						continue;
					}
					openList.push(neighbor);
					neighbor.opened = true;
					neighbor.parent = node;
				}
			}
			return [];
		}

		return BreadthFirstFinder;
	})()


	/**
	*...
	*@author dongketao
	*/
	//class PathFinding.finders.IDAStarFinder
	var IDAStarFinder = (function () {
		function IDAStarFinder(opt) {
			this.allowDiagonal = false;
			this.dontCrossCorners = false;
			this.heuristic = null;
			this.weight = 0;
			this.diagonalMovement = 0;
			this.trackRecursion = false;
			this.timeLimit = NaN;
			opt = opt || {};
			this.allowDiagonal = opt.allowDiagonal;
			this.dontCrossCorners = opt.dontCrossCorners;
			this.diagonalMovement = opt.diagonalMovement;
			this.heuristic = opt.heuristic || Heuristic.manhattan;
			this.weight = opt.weight || 1;
			this.trackRecursion = opt.trackRecursion || false;
			this.timeLimit = opt.timeLimit || Infinity;
			if (!this.diagonalMovement) {
				if (!this.allowDiagonal) {
					this.diagonalMovement = DiagonalMovement.Never;
				}
				else {
					if (this.dontCrossCorners) {
						this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;
					}
					else {
						this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;
					}
				}
			}
			if (this.diagonalMovement === DiagonalMovement.Never) {
				this.heuristic = opt.heuristic || Heuristic.manhattan;
			}
			else {
				this.heuristic = opt.heuristic || Heuristic.octile;
			}
		}

		__class(IDAStarFinder, 'PathFinding.finders.IDAStarFinder');
		var __proto = IDAStarFinder.prototype;
		/**
		*Find and return the the path. When an empty array is returned,either
		*no path is possible,or the maximum execution time is reached.
		*
		*@return {Array<Array<number>>}The path,including both start and
		*end positions.
		*/
		__proto.findPath = function (startX, startY, endX, endY, grid) {
			var _$this = this;
			var nodesVisited = 0;
			var startTime = new Date().getTime();
			var h = function (a, b) {
				return _$this.heuristic(Math.abs(b.x - a.x), Math.abs(b.y - a.y));
			};
			var cost = function (a, b) {
				return (a.x === b.x || a.y === b.y) ? 1 : Math.SQRT2;
			};
			var search = function (node, g, cutoff, route, depth) {
				nodesVisited++;
				if (_$this.timeLimit > 0 && new Date().getTime() - startTime > _$this.timeLimit * 1000) {
					return Infinity;
				};
				var f = g + h(node, end) * _$this.weight;
				if (f > cutoff) {
					return f;
				}
				if (node == end) {
					route[depth] = [node.x, node.y];
					return node;
				};
				var min = 0, t = 0, k = 0, neighbour;
				var neighbours = grid.getNeighbors(node, _$this.diagonalMovement);
				for (k = 0, min = Infinity; neighbour = neighbours[k]; ++k) {
					if (_$this.trackRecursion) {
						neighbour.retainCount = neighbour.retainCount + 1 || 1;
						if (neighbour.tested != true) {
							neighbour.tested = true;
						}
					}
					t = search(neighbour, g + cost(node, neighbour), cutoff, route, depth + 1);
					if ((t instanceof PathFinding.core.Node)) {
						route[depth] = [node.x, node.y];
						return t;
					}
					if (_$this.trackRecursion && (--neighbour.retainCount) === 0) {
						neighbour.tested = false;
					}
					if (t < min) {
						min = t;
					}
				}
				return min;
			};
			var start = grid.getNodeAt(startX, startY);
			var end = grid.getNodeAt(endX, endY);
			var cutOff = h(start, end);
			var j = 0, route, t = 0;
			for (j = 0; true; ++j) {
				route = [];
				t = search(start, 0, cutOff, route, 0);
				if (t == Infinity) {
					route = [];
					break;
				}
				if ((t instanceof PathFinding.core.Node)) {
					break;
				}
				cutOff = t;
			}
			return route;
		}

		return IDAStarFinder;
	})()


	/**
	*...
	*@author ...
	*/
	//class PathFinding.finders.JumpPointFinderBase
	var JumpPointFinderBase = (function () {
		function JumpPointFinderBase(opt) {
			this.grid = null;
			this.openList = null;
			this.startNode = null;
			this.endNode = null;
			this.heuristic = null;
			this.trackJumpRecursion = false;
			opt = opt || {};
			this.heuristic = opt.heuristic || Heuristic.manhattan;
			this.trackJumpRecursion = opt.trackJumpRecursion || false;
		}

		__class(JumpPointFinderBase, 'PathFinding.finders.JumpPointFinderBase');
		var __proto = JumpPointFinderBase.prototype;
		/**
		*Find and return the path.
		*@return {Array<Array<number>>}The path,including both start and
		*end positions.
		*/
		__proto.findPath = function (startX, startY, endX, endY, grid) {
			var openList = this.openList = new Heap(function (nodeA, nodeB) {
				return nodeA.f - nodeB.f;
			}), startNode = this.startNode = grid.getNodeAt(startX, startY), endNode = this.endNode = grid.getNodeAt(endX, endY), node;
			this.grid = grid;
			startNode.g = 0;
			startNode.f = 0;
			openList.push(startNode);
			startNode.opened = true;
			while (!openList.empty()) {
				node = openList.pop();
				node.closed = true;
				if (node == endNode) {
					return Util.expandPath(Util.backtrace(endNode));
				}
				this._identifySuccessors(node);
			}
			return [];
		}

		/**
		*Identify successors for the given node. Runs a jump point search in the
		*direction of each available neighbor,adding any points found to the open
		*list.
		*@protected
		*/
		__proto._identifySuccessors = function (node) {
			var grid = this.grid, heuristic = this.heuristic, openList = this.openList, endX = this.endNode.x, endY = this.endNode.y, neighbors, neighbor, jumpPoint, i = 0, l = 0, x = node.x, y = node.y, jx = 0, jy = 0, dx = 0, dy = 0, d = 0, ng = 0, jumpNode, abs = Math.abs, max = Math.max;
			neighbors = this._findNeighbors(node);
			for (i = 0, l = neighbors.length; i < l; ++i) {
				neighbor = neighbors[i];
				jumpPoint = this._jump(neighbor[0], neighbor[1], x, y);
				if (jumpPoint) {
					jx = jumpPoint[0];
					jy = jumpPoint[1];
					jumpNode = grid.getNodeAt(jx, jy);
					if (jumpNode.closed) {
						continue;
					}
					d = Heuristic.octile(abs(jx - x), abs(jy - y));
					ng = node.g + d;
					if (!jumpNode.opened || ng < jumpNode.g) {
						jumpNode.g = ng;
						jumpNode.h = jumpNode.h || heuristic(abs(jx - endX), abs(jy - endY));
						jumpNode.f = jumpNode.g + jumpNode.h;
						jumpNode.parent = node;
						if (!jumpNode.opened) {
							openList.push(jumpNode);
							jumpNode.opened = true;
						}
						else {
							openList.updateItem(jumpNode);
						}
					}
				}
			}
		}

		__proto._jump = function (x, y, px, py) {
			return [];
		}

		__proto._findNeighbors = function (node) {
			return [];
		}

		return JumpPointFinderBase;
	})()


	/**
	*...
	*@author ...
	*/
	//class PathFinding.finders.JumpPointFinder
	var JumpPointFinder = (function () {
		/**
		*Path finder using the Jump Point Search algorithm
		*@param {Object}opt
		*@param {function}opt.heuristic Heuristic function to estimate the distance
		*(defaults to manhattan).
		*@param {DiagonalMovement}opt.diagonalMovement Condition under which diagonal
		*movement will be allowed.
		*/
		function JumpPointFinder(opt) { }
		__class(JumpPointFinder, 'PathFinding.finders.JumpPointFinder');
		return JumpPointFinder;
	})()


	/**
	*...
	*@author dongketao
	*/
	//class PathFinding.finders.TraceFinder
	var TraceFinder = (function () {
		function TraceFinder(opt) {
			this.allowDiagonal = false;
			this.dontCrossCorners = false;
			this.diagonalMovement = 0;
			this.heuristic = null;
			opt = opt || {};
			this.allowDiagonal = opt.allowDiagonal;
			this.dontCrossCorners = opt.dontCrossCorners;
			this.heuristic = opt.heuristic || Heuristic.manhattan;
			this.diagonalMovement = opt.diagonalMovement;
			if (!this.diagonalMovement) {
				if (!this.allowDiagonal) {
					this.diagonalMovement = DiagonalMovement.Never;
				}
				else {
					if (this.dontCrossCorners) {
						this.diagonalMovement = DiagonalMovement.OnlyWhenNoObstacles;
					}
					else {
						this.diagonalMovement = DiagonalMovement.IfAtMostOneObstacle;
					}
				}
			}
			if (this.diagonalMovement == DiagonalMovement.Never) {
				this.heuristic = opt.heuristic || Heuristic.manhattan;
			}
			else {
				this.heuristic = opt.heuristic || Heuristic.octile;
			}
		}

		__class(TraceFinder, 'PathFinding.finders.TraceFinder');
		var __proto = TraceFinder.prototype;
		__proto.findPath = function (startX, startY, endX, endY, grid) {
			var openList = new Heap(function (nodeA, nodeB) {
				return nodeA.f - nodeB.f;
			}), startNode = grid.getNodeAt(startX, startY), endNode = grid.getNodeAt(endX, endY), heuristic = this.heuristic, allowDiagonal = this.allowDiagonal, dontCrossCorners = this.dontCrossCorners, abs = Math.abs, SQRT2 = Math.SQRT2, node, neighbors, neighbor, i = 0, l = 0, x = 0, y = 0, ng = 0;
			startNode.g = 0;
			startNode.f = 0;
			openList.push(startNode);
			startNode.opened = true;
			while (!openList.empty()) {
				node = openList.pop();
				node.closed = true;
				if (node === endNode) {
					return Util.backtrace(endNode);
				}
				neighbors = grid.getNeighbors(node, this.diagonalMovement);
				for (i = 0, l = neighbors.length; i < l; ++i) {
					neighbor = neighbors[i];
					if (neighbor.closed) {
						continue;
					}
					x = neighbor.x;
					y = neighbor.y;
					ng = node.g + ((x - node.x === 0 || y - node.y === 0) ? 1 : SQRT2);
					if (!neighbor.opened || ng < neighbor.g) {
						neighbor.g = ng * l / 9;
						neighbor.h = neighbor.h || heuristic(abs(x - endX), abs(y - endY));
						neighbor.f = neighbor.g + neighbor.h;
						neighbor.parent = node;
						if (!neighbor.opened) {
							openList.push(neighbor);
							neighbor.opened = true;
						}
						else {
							openList.updateItem(neighbor);
						}
					}
				}
			}
			return [];
		}

		return TraceFinder;
	})()


	/**
	*...
	*@author dongketao
	*/
	//class PathFinding.libs.Heap
	var Heap = (function () {
		function Heap(cmp) {
			this.cmp = null;
			this.nodes = null;
			this.heapFunction = new HeapFunction();
			this.cmp = cmp != null ? cmp : this.heapFunction.defaultCmp;
			this.nodes = [];
		}

		__class(Heap, 'PathFinding.libs.Heap');
		var __proto = Heap.prototype;
		__proto.push = function (x) {
			return this.heapFunction.heappush(this.nodes, x, this.cmp);
		}

		__proto.pop = function () {
			return this.heapFunction.heappop(this.nodes, this.cmp);
		}

		__proto.peek = function () {
			return this.nodes[0];
		}

		__proto.contains = function (x) {
			return this.nodes.indexOf(x) !== -1;
		}

		__proto.replace = function (x) {
			return this.heapFunction.heapreplace(this.nodes, x, this.cmp);
		}

		__proto.pushpop = function (x) {
			return this.heapFunction.heappushpop(this.nodes, x, this.cmp);
		}

		__proto.heapify = function () {
			return this.heapFunction.heapify(this.nodes, this.cmp);
		}

		__proto.updateItem = function (x) {
			return this.heapFunction.updateItem(this.nodes, x, this.cmp);
		}

		__proto.clear = function () {
			return this.nodes = [];
		}

		__proto.empty = function () {
			return this.nodes.length === 0;
		}

		__proto.size = function () {
			return this.nodes.length;
		}

		__proto.clone = function () {
			var heap = new Heap();
			heap.nodes = this.nodes.slice(0);
			return heap;
		}

		__proto.toArray = function () {
			return this.nodes.slice(0);
		}

		return Heap;
	})()


	/**
	*...
	*@author dongketao
	*/
	//class PathFinding.libs.HeapFunction
	var HeapFunction = (function () {
		function HeapFunction() {
			//};
			this.defaultCmp = function (x, y) {
				if (x < y) {
					return -1;
				}
				if (x > y) {
					return 1;
				}
				return 0;
			}
		}

		__class(HeapFunction, 'PathFinding.libs.HeapFunction');
		var __proto = HeapFunction.prototype;
		//};
		__proto.insort = function (a, x, lo, hi, cmp) {
			var mid = NaN;
			if (lo == null) {
				lo = 0;
			}
			if (cmp == null) {
				cmp = this.defaultCmp;
			}
			if (lo < 0) {
				throw new Error('lo must be non-negative');
			}
			if (hi == null) {
				hi = a.length;
			}
			while (lo < hi) {
				mid = Math.floor((lo + hi) / 2);
				if (cmp(x, a[mid]) < 0) {
					hi = mid;
				}
				else {
					lo = mid + 1;
				}
			}
			return ([].splice.apply(a, [lo, lo - lo].concat(x)), x);
		}

		//};
		__proto.heappush = function (array, item, cmp) {
			if (cmp == null) {
				cmp = this.defaultCmp;
			}
			array.push(item);
			return this._siftdown(array, 0, array.length - 1, cmp);
		}

		//};
		__proto.heappop = function (array, cmp) {
			var lastelt, returnitem;
			if (cmp == null) {
				cmp = this.defaultCmp;
			}
			lastelt = array.pop();
			if (array.length) {
				returnitem = array[0];
				array[0] = lastelt;
				this._siftup(array, 0, cmp);
			}
			else {
				returnitem = lastelt;
			}
			return returnitem;
		}

		//};
		__proto.heapreplace = function (array, item, cmp) {
			var returnitem;
			if (cmp == null) {
				cmp = this.defaultCmp;
			}
			returnitem = array[0];
			array[0] = item;
			this._siftup(array, 0, cmp);
			return returnitem;
		}

		//};
		__proto.heappushpop = function (array, item, cmp) {
			var _ref;
			if (cmp == null) {
				cmp = this.defaultCmp;
			}
			if (array.length && cmp(array[0], item) < 0) {
				_ref = [array[0], item], item = _ref[0], array[0] = _ref[1];
				this._siftup(array, 0, cmp);
			}
			return item;
		}

		//};
		__proto.heapify = function (array, cmp) {
			var i = 0, _i = 0, _j = 0, _len = 0, _ref, _ref1, _results, _results1;
			if (cmp == null) {
				cmp = this.defaultCmp;
			}
			_ref1 = (function () {
				_results1 = [];
				for (_j = 0, _ref = Math.floor(array.length / 2); 0 <= _ref ? _j < _ref : _j > _ref; 0 <= _ref ? _j++ : _j--) {
					_results1.push(_j);
				}
				return _results1;
			}).apply(this).reverse();
			_results = [];
			for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
				i = _ref1[_i];
				_results.push(this._siftup(array, i, cmp));
			}
			return _results;
		}

		//};
		__proto.updateItem = function (array, item, cmp) {
			var pos = 0;
			if (cmp == null) {
				cmp = this.defaultCmp;
			}
			pos = array.indexOf(item);
			if (pos === -1) {
				return null;
			}
			this._siftdown(array, 0, pos, cmp);
			return this._siftup(array, pos, cmp);
		}

		//};
		__proto.nlargest = function (array, n, cmp) {
			var elem, result, _i = 0, _len = 0, _ref;
			if (cmp == null) {
				cmp = this.defaultCmp;
			}
			result = array.slice(0, n);
			if (!result.length) {
				return result;
			}
			this.heapify(result, cmp);
			_ref = array.slice(n);
			for (_i = 0, _len = _ref.length; _i < _len; _i++) {
				elem = _ref[_i];
				this.heappushpop(result, elem, cmp);
			}
			return result.sort(cmp).reverse();
		}

		//};
		__proto.nsmallest = function (array, n, cmp) {
			var elem, i, los, result, _i = 0, _j = 0, _len, _ref, _ref1, _results;
			if (cmp == null) {
				cmp = this.defaultCmp;
			}
			if (n * 10 <= array.length) {
				result = array.slice(0, n).sort(cmp);
				if (!result.length) {
					return result;
				}
				los = result[result.length - 1];
				_ref = array.slice(n);
				for (_i = 0, _len = _ref.length; _i < _len; _i++) {
					elem = _ref[_i];
					if (cmp(elem, los) < 0) {
						this.insort(result, elem, 0, null, cmp);
						result.pop();
						los = result[result.length - 1];
					}
				}
				return result;
			}
			this.heapify(array, cmp);
			_results = [];
			for (i = _j = 0, _ref1 = Math.min(n, array.length); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
				_results.push(this.heappop(array, cmp));
			}
			return _results;
		}

		//};
		__proto._siftdown = function (array, startpos, pos, cmp) {
			var newitem, parent, parentpos = 0;
			if (cmp == null) {
				cmp = this.defaultCmp;
			}
			newitem = array[pos];
			while (pos > startpos) {
				parentpos = (pos - 1) >> 1;
				parent = array[parentpos];
				if (cmp(newitem, parent) < 0) {
					array[pos] = parent;
					pos = parentpos;
					continue;
				}
				break;
			}
			return array[pos] = newitem;
		}

		//};
		__proto._siftup = function (array, pos, cmp) {
			var childpos = 0, endpos = 0, newitem, rightpos = 0, startpos = 0;
			if (cmp == null) {
				cmp = this.defaultCmp;
			}
			endpos = array.length;
			startpos = pos;
			newitem = array[pos];
			childpos = 2 * pos + 1;
			while (childpos < endpos) {
				rightpos = childpos + 1;
				if (rightpos < endpos && !(cmp(array[childpos], array[rightpos]) < 0)) {
					childpos = rightpos;
				}
				array[pos] = array[childpos];
				pos = childpos;
				childpos = 2 * pos + 1;
			}
			array[pos] = newitem;
			return this._siftdown(array, startpos, pos, cmp);
		}

		return HeapFunction;
	})()


	/**
	*...
	*@author ...
	*/
	//class PathFinding.finders.BestFirstFinder extends PathFinding.finders.AStarFinder
	var BestFirstFinder = (function (_super) {
		function BestFirstFinder(opt) {
			BestFirstFinder.__super.call(this, opt);
			var orig = this.heuristic;
			this.heuristic = function (dx, dy) {
				return orig(dx, dy) * 1000000;
			};
		}

		__class(BestFirstFinder, 'PathFinding.finders.BestFirstFinder', _super);
		return BestFirstFinder;
	})(AStarFinder)


	/**
	*...
	*@author ...
	*/
	//class PathFinding.finders.BiBestFirstFinder extends PathFinding.finders.BiAStarFinder
	var BiBestFirstFinder = (function (_super) {
		function BiBestFirstFinder(opt) {
			BiBestFirstFinder.__super.call(this, opt);
			var orig = this.heuristic;
			this.heuristic = function (dx, dy) {
				return orig(dx, dy) * 1000000;
			};
		}

		__class(BiBestFirstFinder, 'PathFinding.finders.BiBestFirstFinder', _super);
		return BiBestFirstFinder;
	})(BiAStarFinder)


	/**
	*...
	*@author ...
	*/
	//class PathFinding.finders.BiDijkstraFinder extends PathFinding.finders.BiAStarFinder
	var BiDijkstraFinder = (function (_super) {
		function BiDijkstraFinder(opt) {
			BiDijkstraFinder.__super.call(this, opt);
			this.heuristic = function (dx, dy) {
				return 0;
			};
		}

		__class(BiDijkstraFinder, 'PathFinding.finders.BiDijkstraFinder', _super);
		return BiDijkstraFinder;
	})(BiAStarFinder)


	/**
	*...
	*@author ...
	*/
	//class PathFinding.finders.DijkstraFinder extends PathFinding.finders.AStarFinder
	var DijkstraFinder = (function (_super) {
		function DijkstraFinder(opt) {
			DijkstraFinder.__super.call(this, opt);
			this.heuristic = function (dx, dy) {
				return 0;
			};
		}

		__class(DijkstraFinder, 'PathFinding.finders.DijkstraFinder', _super);
		return DijkstraFinder;
	})(AStarFinder)


	/**
	*...
	*@author ...
	*/
	//class PathFinding.finders.JPFAlwaysMoveDiagonally extends PathFinding.finders.JumpPointFinderBase
	var JPFAlwaysMoveDiagonally = (function (_super) {
		function JPFAlwaysMoveDiagonally(opt) {
			JPFAlwaysMoveDiagonally.__super.call(this, opt);
		}

		__class(JPFAlwaysMoveDiagonally, 'PathFinding.finders.JPFAlwaysMoveDiagonally', _super);
		var __proto = JPFAlwaysMoveDiagonally.prototype;
		/**
		*Search recursively in the direction (parent-> child),stopping only when a
		*jump point is found.
		*@protected
		*@return {Array<Array<number>>}The x,y coordinate of the jump point
		*found,or null if not found
		*/
		__proto._jump = function (x, y, px, py) {
			var grid = this.grid, dx = x - px, dy = y - py;
			if (!grid.isWalkableAt(x, y)) {
				return null;
			}
			if (this.trackJumpRecursion == true) {
				grid.getNodeAt(x, y).tested = true;
			}
			if (grid.getNodeAt(x, y) == this.endNode) {
				return [x, y];
			}
			if (dx !== 0 && dy !== 0) {
				if ((grid.isWalkableAt(x - dx, y + dy) && !grid.isWalkableAt(x - dx, y)) || (grid.isWalkableAt(x + dx, y - dy) && !grid.isWalkableAt(x, y - dy))) {
					return [x, y];
				}
				if (this._jump(x + dx, y, x, y) || this._jump(x, y + dy, x, y)) {
					return [x, y];
				}
			}
			else {
				if (dx !== 0) {
					if ((grid.isWalkableAt(x + dx, y + 1) && !grid.isWalkableAt(x, y + 1)) || (grid.isWalkableAt(x + dx, y - 1) && !grid.isWalkableAt(x, y - 1))) {
						return [x, y];
					}
				}
				else {
					if ((grid.isWalkableAt(x + 1, y + dy) && !grid.isWalkableAt(x + 1, y)) || (grid.isWalkableAt(x - 1, y + dy) && !grid.isWalkableAt(x - 1, y))) {
						return [x, y];
					}
				}
			}
			return this._jump(x + dx, y + dy, x, y);
		}

		/**
		*Find the neighbors for the given node. If the node has a parent,
		*prune the neighbors based on the jump point search algorithm,otherwise
		*return all available neighbors.
		*@return {Array<Array<number>>}The neighbors found.
		*/
		__proto._findNeighbors = function (node) {
			var parent = node.parent, x = node.x, y = node.y, grid = this.grid, px = 0, py = 0, nx = 0, ny = 0, dx = 0, dy = 0, neighbors = [], neighborNodes, neighborNode, i = 0, l = 0;
			if (parent) {
				px = parent.x;
				py = parent.y;
				dx = (x - px) / Math.max(Math.abs(x - px), 1);
				dy = (y - py) / Math.max(Math.abs(y - py), 1);
				if (dx !== 0 && dy !== 0) {
					if (grid.isWalkableAt(x, y + dy)) {
						neighbors.push([x, y + dy]);
					}
					if (grid.isWalkableAt(x + dx, y)) {
						neighbors.push([x + dx, y]);
					}
					if (grid.isWalkableAt(x + dx, y + dy)) {
						neighbors.push([x + dx, y + dy]);
					}
					if (!grid.isWalkableAt(x - dx, y)) {
						neighbors.push([x - dx, y + dy]);
					}
					if (!grid.isWalkableAt(x, y - dy)) {
						neighbors.push([x + dx, y - dy]);
					}
				}
				else {
					if (dx === 0) {
						if (grid.isWalkableAt(x, y + dy)) {
							neighbors.push([x, y + dy]);
						}
						if (!grid.isWalkableAt(x + 1, y)) {
							neighbors.push([x + 1, y + dy]);
						}
						if (!grid.isWalkableAt(x - 1, y)) {
							neighbors.push([x - 1, y + dy]);
						}
					}
					else {
						if (grid.isWalkableAt(x + dx, y)) {
							neighbors.push([x + dx, y]);
						}
						if (!grid.isWalkableAt(x, y + 1)) {
							neighbors.push([x + dx, y + 1]);
						}
						if (!grid.isWalkableAt(x, y - 1)) {
							neighbors.push([x + dx, y - 1]);
						}
					}
				}
			}
			else {
				neighborNodes = grid.getNeighbors(node, DiagonalMovement.Always);
				for (i = 0, l = neighborNodes.length; i < l; ++i) {
					neighborNode = neighborNodes[i];
					neighbors.push([neighborNode.x, neighborNode.y]);
				}
			}
			return neighbors;
		}

		return JPFAlwaysMoveDiagonally;
	})(JumpPointFinderBase)


	/**
	*...
	*@author ...
	*/
	//class PathFinding.finders.JPFMoveDiagonallyIfAtMostOneObstacle extends PathFinding.finders.JumpPointFinderBase
	var JPFMoveDiagonallyIfAtMostOneObstacle = (function (_super) {
		function JPFMoveDiagonallyIfAtMostOneObstacle(opt) {
			JPFMoveDiagonallyIfAtMostOneObstacle.__super.call(this, opt);
		}

		__class(JPFMoveDiagonallyIfAtMostOneObstacle, 'PathFinding.finders.JPFMoveDiagonallyIfAtMostOneObstacle', _super);
		var __proto = JPFMoveDiagonallyIfAtMostOneObstacle.prototype;
		/**
		*Search recursively in the direction (parent-> child),stopping only when a
		*jump point is found.
		*@protected
		*@return {Array<Array<number>>}The x,y coordinate of the jump point
		*found,or null if not found
		*/
		__proto._jump = function (x, y, px, py) {
			var grid = this.grid, dx = x - px, dy = y - py;
			if (!grid.isWalkableAt(x, y)) {
				return null;
			}
			if (this.trackJumpRecursion === true) {
				grid.getNodeAt(x, y).tested = true;
			}
			if (grid.getNodeAt(x, y) == this.endNode) {
				return [x, y];
			}
			if (dx !== 0 && dy !== 0) {
				if ((grid.isWalkableAt(x - dx, y + dy) && !grid.isWalkableAt(x - dx, y)) || (grid.isWalkableAt(x + dx, y - dy) && !grid.isWalkableAt(x, y - dy))) {
					return [x, y];
				}
				if (this._jump(x + dx, y, x, y) || this._jump(x, y + dy, x, y)) {
					return [x, y];
				}
			}
			else {
				if (dx !== 0) {
					if ((grid.isWalkableAt(x + dx, y + 1) && !grid.isWalkableAt(x, y + 1)) || (grid.isWalkableAt(x + dx, y - 1) && !grid.isWalkableAt(x, y - 1))) {
						return [x, y];
					}
				}
				else {
					if ((grid.isWalkableAt(x + 1, y + dy) && !grid.isWalkableAt(x + 1, y)) || (grid.isWalkableAt(x - 1, y + dy) && !grid.isWalkableAt(x - 1, y))) {
						return [x, y];
					}
				}
			}
			if (grid.isWalkableAt(x + dx, y) || grid.isWalkableAt(x, y + dy)) {
				return this._jump(x + dx, y + dy, x, y);
			}
			else {
				return null;
			}
		}

		/**
		*Find the neighbors for the given node. If the node has a parent,
		*prune the neighbors based on the jump point search algorithm,otherwise
		*return all available neighbors.
		*@return {Array<Array<number>>}The neighbors found.
		*/
		__proto._findNeighbors = function (node) {
			var parent = node.parent, x = node.x, y = node.y, grid = this.grid, px = 0, py = 0, nx = 0, ny = 0, dx = 0, dy = 0, neighbors = [], neighborNodes, neighborNode, i = 0, l = 0;
			if (parent) {
				px = parent.x;
				py = parent.y;
				dx = (x - px) / Math.max(Math.abs(x - px), 1);
				dy = (y - py) / Math.max(Math.abs(y - py), 1);
				if (dx !== 0 && dy !== 0) {
					if (grid.isWalkableAt(x, y + dy)) {
						neighbors.push([x, y + dy]);
					}
					if (grid.isWalkableAt(x + dx, y)) {
						neighbors.push([x + dx, y]);
					}
					if (grid.isWalkableAt(x, y + dy) || grid.isWalkableAt(x + dx, y)) {
						neighbors.push([x + dx, y + dy]);
					}
					if (!grid.isWalkableAt(x - dx, y) && grid.isWalkableAt(x, y + dy)) {
						neighbors.push([x - dx, y + dy]);
					}
					if (!grid.isWalkableAt(x, y - dy) && grid.isWalkableAt(x + dx, y)) {
						neighbors.push([x + dx, y - dy]);
					}
				}
				else {
					if (dx === 0) {
						if (grid.isWalkableAt(x, y + dy)) {
							neighbors.push([x, y + dy]);
							if (!grid.isWalkableAt(x + 1, y)) {
								neighbors.push([x + 1, y + dy]);
							}
							if (!grid.isWalkableAt(x - 1, y)) {
								neighbors.push([x - 1, y + dy]);
							}
						}
					}
					else {
						if (grid.isWalkableAt(x + dx, y)) {
							neighbors.push([x + dx, y]);
							if (!grid.isWalkableAt(x, y + 1)) {
								neighbors.push([x + dx, y + 1]);
							}
							if (!grid.isWalkableAt(x, y - 1)) {
								neighbors.push([x + dx, y - 1]);
							}
						}
					}
				}
			}
			else {
				neighborNodes = grid.getNeighbors(node, DiagonalMovement.IfAtMostOneObstacle);
				for (i = 0, l = neighborNodes.length; i < l; ++i) {
					neighborNode = neighborNodes[i];
					neighbors.push([neighborNode.x, neighborNode.y]);
				}
			}
			return neighbors;
		}

		return JPFMoveDiagonallyIfAtMostOneObstacle;
	})(JumpPointFinderBase)


	/**
	*...
	*@author ...
	*/
	//class PathFinding.finders.JPFMoveDiagonallyIfNoObstacles extends PathFinding.finders.JumpPointFinderBase
	var JPFMoveDiagonallyIfNoObstacles = (function (_super) {
		function JPFMoveDiagonallyIfNoObstacles(opt) {
			JPFMoveDiagonallyIfNoObstacles.__super.call(this, opt);
		}

		__class(JPFMoveDiagonallyIfNoObstacles, 'PathFinding.finders.JPFMoveDiagonallyIfNoObstacles', _super);
		var __proto = JPFMoveDiagonallyIfNoObstacles.prototype;
		/**
		*Search recursively in the direction (parent-> child),stopping only when a
		*jump point is found.
		*@protected
		*@return {Array<Array<number>>}The x,y coordinate of the jump point
		*found,or null if not found
		*/
		__proto._jump = function (x, y, px, py) {
			var grid = this.grid, dx = x - px, dy = y - py;
			if (!grid.isWalkableAt(x, y)) {
				return null;
			}
			if (this.trackJumpRecursion === true) {
				grid.getNodeAt(x, y).tested = true;
			}
			if (grid.getNodeAt(x, y) === this.endNode) {
				return [x, y];
			}
			if (dx !== 0 && dy !== 0) {
				if (this._jump(x + dx, y, x, y) || this._jump(x, y + dy, x, y)) {
					return [x, y];
				}
			}
			else {
				if (dx !== 0) {
					if ((grid.isWalkableAt(x, y - 1) && !grid.isWalkableAt(x - dx, y - 1)) || (grid.isWalkableAt(x, y + 1) && !grid.isWalkableAt(x - dx, y + 1))) {
						return [x, y];
					}
				}
				else if (dy !== 0) {
					if ((grid.isWalkableAt(x - 1, y) && !grid.isWalkableAt(x - 1, y - dy)) || (grid.isWalkableAt(x + 1, y) && !grid.isWalkableAt(x + 1, y - dy))) {
						return [x, y];
					}
				}
			}
			if (grid.isWalkableAt(x + dx, y) && grid.isWalkableAt(x, y + dy)) {
				return this._jump(x + dx, y + dy, x, y);
			}
			else {
				return null;
			}
		}

		/**
		*Find the neighbors for the given node. If the node has a parent,
		*prune the neighbors based on the jump point search algorithm,otherwise
		*return all available neighbors.
		*@return {Array<Array<number>>}The neighbors found.
		*/
		__proto._findNeighbors = function (node) {
			var parent = node.parent, x = node.x, y = node.y, grid = this.grid, px = 0, py = 0, nx = 0, ny = 0, dx = 0, dy = 0, neighbors = [], neighborNodes, neighborNode, i = 0, l = 0;
			if (parent) {
				px = parent.x;
				py = parent.y;
				dx = (x - px) / Math.max(Math.abs(x - px), 1);
				dy = (y - py) / Math.max(Math.abs(y - py), 1);
				if (dx !== 0 && dy !== 0) {
					if (grid.isWalkableAt(x, y + dy)) {
						neighbors.push([x, y + dy]);
					}
					if (grid.isWalkableAt(x + dx, y)) {
						neighbors.push([x + dx, y]);
					}
					if (grid.isWalkableAt(x, y + dy) && grid.isWalkableAt(x + dx, y)) {
						neighbors.push([x + dx, y + dy]);
					}
				}
				else {
					var isNextWalkable = false;
					if (dx !== 0) {
						isNextWalkable = grid.isWalkableAt(x + dx, y);
						var isTopWalkable = grid.isWalkableAt(x, y + 1);
						var isBottomWalkable = grid.isWalkableAt(x, y - 1);
						if (isNextWalkable) {
							neighbors.push([x + dx, y]);
							if (isTopWalkable) {
								neighbors.push([x + dx, y + 1]);
							}
							if (isBottomWalkable) {
								neighbors.push([x + dx, y - 1]);
							}
						}
						if (isTopWalkable) {
							neighbors.push([x, y + 1]);
						}
						if (isBottomWalkable) {
							neighbors.push([x, y - 1]);
						}
					}
					else if (dy !== 0) {
						isNextWalkable = grid.isWalkableAt(x, y + dy);
						var isRightWalkable = grid.isWalkableAt(x + 1, y);
						var isLeftWalkable = grid.isWalkableAt(x - 1, y);
						if (isNextWalkable) {
							neighbors.push([x, y + dy]);
							if (isRightWalkable) {
								neighbors.push([x + 1, y + dy]);
							}
							if (isLeftWalkable) {
								neighbors.push([x - 1, y + dy]);
							}
						}
						if (isRightWalkable) {
							neighbors.push([x + 1, y]);
						}
						if (isLeftWalkable) {
							neighbors.push([x - 1, y]);
						}
					}
				}
			}
			else {
				neighborNodes = grid.getNeighbors(node, DiagonalMovement.OnlyWhenNoObstacles);
				for (i = 0, l = neighborNodes.length; i < l; ++i) {
					neighborNode = neighborNodes[i];
					neighbors.push([neighborNode.x, neighborNode.y]);
				}
			}
			return neighbors;
		}

		return JPFMoveDiagonallyIfNoObstacles;
	})(JumpPointFinderBase)


	/**
	*...
	*@author ...
	*/
	//class PathFinding.finders.JPFNeverMoveDiagonally extends PathFinding.finders.JumpPointFinderBase
	var JPFNeverMoveDiagonally = (function (_super) {
		function JPFNeverMoveDiagonally(opt) {
			JPFNeverMoveDiagonally.__super.call(this, opt);
		}

		__class(JPFNeverMoveDiagonally, 'PathFinding.finders.JPFNeverMoveDiagonally', _super);
		var __proto = JPFNeverMoveDiagonally.prototype;
		/**
		*Search recursively in the direction (parent-> child),stopping only when a
		*jump point is found.
		*@protected
		*@return {Array<Array<number>>}The x,y coordinate of the jump point
		*found,or null if not found
		*/
		__proto._jump = function (x, y, px, py) {
			var grid = this.grid, dx = x - px, dy = y - py;
			if (!grid.isWalkableAt(x, y)) {
				return null;
			}
			if (this.trackJumpRecursion === true) {
				grid.getNodeAt(x, y).tested = true;
			}
			if (grid.getNodeAt(x, y) == this.endNode) {
				return [x, y];
			}
			if (dx !== 0) {
				if ((grid.isWalkableAt(x, y - 1) && !grid.isWalkableAt(x - dx, y - 1)) || (grid.isWalkableAt(x, y + 1) && !grid.isWalkableAt(x - dx, y + 1))) {
					return [x, y];
				}
			}
			else if (dy !== 0) {
				if ((grid.isWalkableAt(x - 1, y) && !grid.isWalkableAt(x - 1, y - dy)) || (grid.isWalkableAt(x + 1, y) && !grid.isWalkableAt(x + 1, y - dy))) {
					return [x, y];
				}
				if (this._jump(x + 1, y, x, y) || this._jump(x - 1, y, x, y)) {
					return [x, y];
				}
			}
			else {
				throw new Error("Only horizontal and vertical movements are allowed");
			}
			return this._jump(x + dx, y + dy, x, y);
		}

		/**
		*Find the neighbors for the given node. If the node has a parent,
		*prune the neighbors based on the jump point search algorithm,otherwise
		*return all available neighbors.
		*@return {Array<Array<number>>}The neighbors found.
		*/
		__proto._findNeighbors = function (node) {
			var parent = node.parent, x = node.x, y = node.y, grid = this.grid, px = 0, py = 0, nx = 0, ny = 0, dx = 0, dy = 0, neighbors = [], neighborNodes, neighborNode, i = 0, l = 0;
			if (parent) {
				px = parent.x;
				py = parent.y;
				dx = (x - px) / Math.max(Math.abs(x - px), 1);
				dy = (y - py) / Math.max(Math.abs(y - py), 1);
				if (dx !== 0) {
					if (grid.isWalkableAt(x, y - 1)) {
						neighbors.push([x, y - 1]);
					}
					if (grid.isWalkableAt(x, y + 1)) {
						neighbors.push([x, y + 1]);
					}
					if (grid.isWalkableAt(x + dx, y)) {
						neighbors.push([x + dx, y]);
					}
				}
				else if (dy !== 0) {
					if (grid.isWalkableAt(x - 1, y)) {
						neighbors.push([x - 1, y]);
					}
					if (grid.isWalkableAt(x + 1, y)) {
						neighbors.push([x + 1, y]);
					}
					if (grid.isWalkableAt(x, y + dy)) {
						neighbors.push([x, y + dy]);
					}
				}
			}
			else {
				neighborNodes = grid.getNeighbors(node, DiagonalMovement.Never);
				for (i = 0, l = neighborNodes.length; i < l; ++i) {
					neighborNode = neighborNodes[i];
					neighbors.push([neighborNode.x, neighborNode.y]);
				}
			}
			return neighbors;
		}

		return JPFNeverMoveDiagonally;
	})(JumpPointFinderBase)



})(window, document, Laya);

if (typeof define === 'function' && define.amd) {
	define('laya.core', ['require', "exports"], function (require, exports) {
		'use strict';
		Object.defineProperty(exports, '__esModule', { value: true });
		for (var i in Laya) {
			var o = Laya[i];
			o && o.__isclass && (exports[i] = o);
		}
	});
}

(function (window, document, Laya) {
	var __un = Laya.un, __uns = Laya.uns, __static = Laya.static, __class = Laya.class, __getset = Laya.getset, __newvec = Laya.__newvec;

	var Bezier = laya.maths.Bezier, Browser = laya.utils.Browser, Byte = laya.utils.Byte, Event = laya.events.Event;
	var EventDispatcher = laya.events.EventDispatcher, Graphics = laya.display.Graphics, HTMLCanvas = laya.resource.HTMLCanvas;
	var Handler = laya.utils.Handler, Loader = laya.net.Loader, MathUtil = laya.maths.MathUtil, Matrix = laya.maths.Matrix;
	var Node = laya.display.Node, Point = laya.maths.Point, Rectangle = laya.maths.Rectangle, Render = laya.renders.Render;
	var RenderContext = laya.renders.RenderContext, Resource = laya.resource.Resource, RunDriver = laya.utils.RunDriver;
	var Sprite = laya.display.Sprite, Stat = laya.utils.Stat, Texture = laya.resource.Texture, URL = laya.net.URL, Utils = laya.utils.Utils;
	/**
	*@private
	*@author ...
	*/
	//class laya.ani.AnimationContent
	var AnimationContent = (function () {
		function AnimationContent() {
			this.nodes = null;
			this.name = null;
			this.playTime = NaN;
			this.bone3DMap = null;
			this.totalKeyframeDatasLength = 0;
		}

		__class(AnimationContent, 'laya.ani.AnimationContent');
		return AnimationContent;
	})()


	/**
	*@private
	*@author ...
	*/
	//class laya.ani.AnimationNodeContent
	var AnimationNodeContent = (function () {
		function AnimationNodeContent() {
			this.name = null;
			this.parentIndex = 0;
			this.parent = null;
			this.keyframeWidth = 0;
			this.lerpType = 0;
			this.interpolationMethod = null;
			this.childs = null;
			this.keyFrame = null;
			//=new Vector.<KeyFramesContent>;
			this.playTime = NaN;
			this.extenData = null;
			this.dataOffset = 0;
		}

		__class(AnimationNodeContent, 'laya.ani.AnimationNodeContent');
		return AnimationNodeContent;
	})()


	/**
	*@private
	*/
	//class laya.ani.AnimationParser01
	var AnimationParser01 = (function () {
		function AnimationParser01() { }
		__class(AnimationParser01, 'laya.ani.AnimationParser01');
		AnimationParser01.parse = function (templet, reader) {
			var data = reader.__getBuffer();
			var i = 0, j = 0, k = 0, n = 0, l = 0, m = 0, o = 0;
			var aniClassName = reader.readUTFString();
			templet._aniClassName = aniClassName;
			var strList = reader.readUTFString().split("\n");
			var aniCount = reader.getUint8();
			var publicDataPos = reader.getUint32();
			var publicExtDataPos = reader.getUint32();
			var publicData;
			if (publicDataPos > 0)
				publicData = data.slice(publicDataPos, publicExtDataPos);
			var publicRead = new Byte(publicData);
			if (publicExtDataPos > 0)
				templet._publicExtData = data.slice(publicExtDataPos, data.byteLength);
			templet._useParent = !!reader.getUint8();
			templet._anis.length = aniCount;
			for (i = 0; i < aniCount; i++) {
				var ani = templet._anis[i] = new AnimationContent();
				{ };
				ani.nodes = new Array;
				var name = ani.name = strList[reader.getUint16()];
				templet._aniMap[name] = i;
				ani.bone3DMap = {};
				ani.playTime = reader.getFloat32();
				var boneCount = ani.nodes.length = reader.getUint8();
				ani.totalKeyframeDatasLength = 0;
				for (j = 0; j < boneCount; j++) {
					var node = ani.nodes[j] = new AnimationNodeContent();
					{ };
					node.childs = [];
					var nameIndex = reader.getInt16();
					if (nameIndex >= 0) {
						node.name = strList[nameIndex];
						ani.bone3DMap[node.name] = j;
					}
					node.keyFrame = new Array;
					node.parentIndex = reader.getInt16();
					node.parentIndex == -1 ? node.parent = null : node.parent = ani.nodes[node.parentIndex]
					node.lerpType = reader.getUint8();
					var keyframeParamsOffset = reader.getUint32();
					publicRead.pos = keyframeParamsOffset;
					var keyframeDataCount = node.keyframeWidth = publicRead.getUint16();
					ani.totalKeyframeDatasLength += keyframeDataCount;
					if (node.lerpType === 0 || node.lerpType === 1) {
						node.interpolationMethod = [];
						node.interpolationMethod.length = keyframeDataCount;
						for (k = 0; k < keyframeDataCount; k++)
							node.interpolationMethod[k] = AnimationTemplet.interpolation[publicRead.getUint8()];
					}
					if (node.parent != null)
						node.parent.childs.push(node);
					var privateDataLen = reader.getUint16();
					if (privateDataLen > 0) {
						node.extenData = data.slice(reader.pos, reader.pos + privateDataLen);
						reader.pos += privateDataLen;
					};
					var keyframeCount = reader.getUint16();
					node.keyFrame.length = keyframeCount;
					var startTime = 0;
					var keyFrame;
					for (k = 0, n = keyframeCount; k < n; k++) {
						keyFrame = node.keyFrame[k] = new KeyFramesContent();
						{ };
						keyFrame.duration = reader.getFloat32();
						keyFrame.startTime = startTime;
						if (node.lerpType === 2) {
							keyFrame.interpolationData = [];
							var interDataLength = reader.getUint8();
							var lerpType = 0;
							lerpType = reader.getFloat32();
							switch (lerpType) {
								case 254:
									keyFrame.interpolationData.length = keyframeDataCount;
									for (o = 0; o < keyframeDataCount; o++)
										keyFrame.interpolationData[o] = 0;
									break;
								case 255:
									keyFrame.interpolationData.length = keyframeDataCount;
									for (o = 0; o < keyframeDataCount; o++)
										keyFrame.interpolationData[o] = 5;
									break;
								default:
									keyFrame.interpolationData.push(lerpType);
									for (m = 1; m < interDataLength; m++) {
										keyFrame.interpolationData.push(reader.getFloat32());
									}
							}
						}
						keyFrame.data = new Float32Array(keyframeDataCount);
						for (l = 0; l < keyframeDataCount; l++) {
							keyFrame.data[l] = reader.getFloat32();
							if (keyFrame.data[l] > -0.00000001 && keyFrame.data[l] < 0.00000001) keyFrame.data[l] = 0;
						}
						startTime += keyFrame.duration;
					}
					keyFrame.startTime = ani.playTime;
					node.playTime = ani.playTime;
					templet._calculateKeyFrame(node, keyframeCount, keyframeDataCount);
				}
			}
		}

		return AnimationParser01;
	})()


	/**
	*@private
	*/
	//class laya.ani.AnimationParser02
	var AnimationParser02 = (function () {
		function AnimationParser02() { }
		__class(AnimationParser02, 'laya.ani.AnimationParser02');
		AnimationParser02.READ_DATA = function () {
			AnimationParser02._DATA.offset = AnimationParser02._reader.getUint32();
			AnimationParser02._DATA.size = AnimationParser02._reader.getUint32();
		}

		AnimationParser02.READ_BLOCK = function () {
			var count = AnimationParser02._BLOCK.count = AnimationParser02._reader.getUint16();
			var blockStarts = AnimationParser02._BLOCK.blockStarts = [];
			var blockLengths = AnimationParser02._BLOCK.blockLengths = [];
			for (var i = 0; i < count; i++) {
				blockStarts.push(AnimationParser02._reader.getUint32());
				blockLengths.push(AnimationParser02._reader.getUint32());
			}
		}

		AnimationParser02.READ_STRINGS = function () {
			var offset = AnimationParser02._reader.getUint32();
			var count = AnimationParser02._reader.getUint16();
			var prePos = AnimationParser02._reader.pos;
			AnimationParser02._reader.pos = offset + AnimationParser02._DATA.offset;
			for (var i = 0; i < count; i++)
				AnimationParser02._strings[i] = AnimationParser02._reader.readUTFString();
			AnimationParser02._reader.pos = prePos;
		}

		AnimationParser02.parse = function (templet, reader) {
			AnimationParser02._templet = templet;
			AnimationParser02._reader = reader;
			var arrayBuffer = reader.__getBuffer();
			AnimationParser02.READ_DATA();
			AnimationParser02.READ_BLOCK();
			AnimationParser02.READ_STRINGS();
			for (var i = 0, n = AnimationParser02._BLOCK.count; i < n; i++) {
				var index = reader.getUint16();
				var blockName = AnimationParser02._strings[index];
				var fn = AnimationParser02["READ_" + blockName];
				if (fn == null)
					throw new Error("model file err,no this function:" + index + " " + blockName);
				else
					fn.call();
			}
		}

		AnimationParser02.READ_ANIMATIONS = function () {
			var reader = AnimationParser02._reader;
			var arrayBuffer = reader.__getBuffer();
			var i = 0, j = 0, k = 0, n = 0, l = 0;
			var keyframeWidth = reader.getUint16();
			var interpolationMethod = [];
			interpolationMethod.length = keyframeWidth;
			for (i = 0; i < keyframeWidth; i++)
				interpolationMethod[i] = AnimationTemplet.interpolation[reader.getByte()];
			var aniCount = reader.getUint8();
			AnimationParser02._templet._anis.length = aniCount;
			for (i = 0; i < aniCount; i++) {
				var ani = AnimationParser02._templet._anis[i] =
					{};
				ani.nodes = new Array;
				var aniName = ani.name = AnimationParser02._strings[reader.getUint16()];
				AnimationParser02._templet._aniMap[aniName] = i;
				ani.bone3DMap = {};
				ani.playTime = reader.getFloat32();
				var boneCount = ani.nodes.length = reader.getInt16();
				ani.totalKeyframeDatasLength = 0;
				for (j = 0; j < boneCount; j++) {
					var node = ani.nodes[j] =
						{};
					node.keyframeWidth = keyframeWidth;
					node.childs = [];
					var nameIndex = reader.getUint16();
					if (nameIndex >= 0) {
						node.name = AnimationParser02._strings[nameIndex];
						ani.bone3DMap[node.name] = j;
					}
					node.keyFrame = new Array;
					node.parentIndex = reader.getInt16();
					node.parentIndex == -1 ? node.parent = null : node.parent = ani.nodes[node.parentIndex]
					ani.totalKeyframeDatasLength += keyframeWidth;
					node.interpolationMethod = interpolationMethod;
					if (node.parent != null)
						node.parent.childs.push(node);
					var keyframeCount = reader.getUint16();
					node.keyFrame.length = keyframeCount;
					var keyFrame = null, lastKeyFrame = null;
					for (k = 0, n = keyframeCount; k < n; k++) {
						keyFrame = node.keyFrame[k] =
							{};
						keyFrame.startTime = reader.getFloat32();
						(lastKeyFrame) && (lastKeyFrame.duration = keyFrame.startTime - lastKeyFrame.startTime);
						var offset = AnimationParser02._DATA.offset;
						var keyframeDataOffset = reader.getUint32();
						var keyframeDataLength = keyframeWidth * 4;
						var keyframeArrayBuffer = arrayBuffer.slice(offset + keyframeDataOffset, offset + keyframeDataOffset + keyframeDataLength);
						keyFrame.data = new Float32Array(keyframeArrayBuffer);
						lastKeyFrame = keyFrame;
					}
					keyFrame.duration = 0;
					node.playTime = ani.playTime;
					AnimationParser02._templet._calculateKeyFrame(node, keyframeCount, keyframeWidth);
				}
			}
		}

		AnimationParser02._templet = null;
		AnimationParser02._reader = null;
		AnimationParser02._strings = [];
		__static(AnimationParser02,
			['_BLOCK', function () { return this._BLOCK = { count: 0 }; }, '_DATA', function () { return this._DATA = { offset: 0, size: 0 }; }
			]);
		return AnimationParser02;
	})()


	/**
	*@private
	*/
	//class laya.ani.AnimationState
	var AnimationState = (function () {
		function AnimationState() { }
		__class(AnimationState, 'laya.ani.AnimationState');
		AnimationState.stopped = 0;
		AnimationState.paused = 1;
		AnimationState.playing = 2;
		return AnimationState;
	})()


	/**
	*@private
	*/
	//class laya.ani.bone.Bone
	var Bone = (function () {
		function Bone() {
			this.name = null;
			this.root = null;
			this.parentBone = null;
			this.length = 10;
			this.transform = null;
			this.inheritScale = true;
			this.inheritRotation = true;
			this.rotation = NaN;
			this.resultRotation = NaN;
			this.d = -1;
			this._tempMatrix = null;
			this._sprite = null;
			this.resultTransform = new Transform();
			this.resultMatrix = new Matrix();
			this._children = [];
		}

		__class(Bone, 'laya.ani.bone.Bone');
		var __proto = Bone.prototype;
		__proto.setTempMatrix = function (matrix) {
			this._tempMatrix = matrix;
			var i = 0, n = 0;
			var tBone;
			for (i = 0, n = this._children.length; i < n; i++) {
				tBone = this._children[i];
				tBone.setTempMatrix(this._tempMatrix);
			}
		}

		__proto.update = function (pMatrix) {
			this.rotation = this.transform.skX;
			var tResultMatrix;
			if (pMatrix) {
				tResultMatrix = this.resultTransform.getMatrix();
				Matrix.mul(tResultMatrix, pMatrix, this.resultMatrix);
				this.resultRotation = this.rotation;
			}
			else {
				this.resultRotation = this.rotation + this.parentBone.resultRotation;
				if (this.parentBone) {
					if (this.inheritRotation && this.inheritScale) {
						tResultMatrix = this.resultTransform.getMatrix();
						Matrix.mul(tResultMatrix, this.parentBone.resultMatrix, this.resultMatrix);
					}
					else {
						var temp = 0;
						var parent = this.parentBone;
						var tAngle = NaN;
						var cos = NaN;
						var sin = NaN;
						var tParentMatrix = this.parentBone.resultMatrix;
						tResultMatrix = this.resultTransform.getMatrix();
						var worldX = tParentMatrix.a * tResultMatrix.tx + tParentMatrix.c * tResultMatrix.ty + tParentMatrix.tx;
						var worldY = tParentMatrix.b * tResultMatrix.tx + tParentMatrix.d * tResultMatrix.ty + tParentMatrix.ty;
						var tTestMatrix = new Matrix();
						if (this.inheritRotation) {
							tAngle = Math.atan2(parent.resultMatrix.b, parent.resultMatrix.a);
							cos = Math.cos(tAngle), sin = Math.sin(tAngle);
							tTestMatrix.setTo(cos, sin, -sin, cos, 0, 0);
							Matrix.mul(this._tempMatrix, tTestMatrix, Matrix.TEMP);
							Matrix.TEMP.copyTo(tTestMatrix);
							tResultMatrix = this.resultTransform.getMatrix();
							Matrix.mul(tResultMatrix, tTestMatrix, this.resultMatrix);
							if (this.resultTransform.scX * this.resultTransform.scY < 0) {
								this.resultMatrix.rotate(Math.PI * 0.5);
							}
							this.resultMatrix.tx = worldX;
							this.resultMatrix.ty = worldY;
						}
						else if (this.inheritScale) {
							tResultMatrix = this.resultTransform.getMatrix();
							Matrix.TEMP.identity();
							Matrix.TEMP.d = this.d;
							Matrix.mul(tResultMatrix, Matrix.TEMP, this.resultMatrix);
							this.resultMatrix.tx = worldX;
							this.resultMatrix.ty = worldY;
						}
						else {
							tResultMatrix = this.resultTransform.getMatrix();
							Matrix.TEMP.identity();
							Matrix.TEMP.d = this.d;
							Matrix.mul(tResultMatrix, Matrix.TEMP, this.resultMatrix);
							this.resultMatrix.tx = worldX;
							this.resultMatrix.ty = worldY;
						}
					}
				}
				else {
					tResultMatrix = this.resultTransform.getMatrix();
					tResultMatrix.copyTo(this.resultMatrix);
				}
			};
			var i = 0, n = 0;
			var tBone;
			for (i = 0, n = this._children.length; i < n; i++) {
				tBone = this._children[i];
				tBone.update();
			}
		}

		__proto.updateChild = function () {
			var i = 0, n = 0;
			var tBone;
			for (i = 0, n = this._children.length; i < n; i++) {
				tBone = this._children[i];
				tBone.update();
			}
		}

		__proto.setRotation = function (rd) {
			if (this._sprite) {
				this._sprite.rotation = rd * 180 / Math.PI;
			}
		}

		__proto.updateDraw = function (x, y) {
			if (!Bone.ShowBones || Bone.ShowBones[this.name]) {
				if (this._sprite) {
					this._sprite.x = x + this.resultMatrix.tx;
					this._sprite.y = y + this.resultMatrix.ty;
				}
				else {
					this._sprite = new Sprite();
					this._sprite.graphics.drawCircle(0, 0, 5, "#ff0000");
					this._sprite.graphics.drawLine(0, 0, this.length, 0, "#00ff00");
					this._sprite.graphics.fillText(this.name, 0, 0, "20px Arial", "#00ff00", "center");
					Laya.stage.addChild(this._sprite);
					this._sprite.x = x + this.resultMatrix.tx;
					this._sprite.y = y + this.resultMatrix.ty;
				}
			};
			var i = 0, n = 0;
			var tBone;
			for (i = 0, n = this._children.length; i < n; i++) {
				tBone = this._children[i];
				tBone.updateDraw(x, y);
			}
		}

		__proto.addChild = function (bone) {
			this._children.push(bone);
			bone.parentBone = this;
		}

		__proto.findBone = function (boneName) {
			if (this.name == boneName) {
				return this;
			}
			else {
				var i = 0, n = 0;
				var tBone;
				var tResult;
				for (i = 0, n = this._children.length; i < n; i++) {
					tBone = this._children[i];
					tResult = tBone.findBone(boneName);
					if (tResult) {
						return tResult;
					}
				}
			}
			return null;
		}

		__proto.localToWorld = function (local) {
			var localX = local[0];
			var localY = local[1];
			local[0] = localX * this.resultMatrix.a + localY * this.resultMatrix.c + this.resultMatrix.tx;
			local[1] = localX * this.resultMatrix.b + localY * this.resultMatrix.d + this.resultMatrix.ty;
		}

		Bone.ShowBones = {};
		return Bone;
	})()


	/**
	*@private
	*/
	//class laya.ani.bone.BoneSlot
	var BoneSlot = (function () {
		function BoneSlot() {
			/**插槽名称 */
			this.name = null;
			/**插槽绑定的骨骼名称 */
			this.parent = null;
			/**插糟显示数据数据的名称 */
			this.attachmentName = null;
			/**原始数据的索引 */
			this.srcDisplayIndex = -1;
			/**判断对象是否是原对象 */
			this.type = "src";
			/**模板的指针 */
			this.templet = null;
			/**当前插槽对应的数据 */
			this.currSlotData = null;
			/**当前插槽显示的纹理 */
			this.currTexture = null;
			/**显示对象对应的数据 */
			this.currDisplayData = null;
			/**显示皮肤的索引 */
			this.displayIndex = -1;
			/**用户自定义的皮肤 */
			this._diyTexture = null;
			this._parentMatrix = null;
			this._resultMatrix = null;
			/**索引替换表 */
			this._replaceDic = {};
			/**当前diyTexture的动画纹理 */
			this._curDiyUV = null;
			this._curDiyVS = null;
			/**实时模式下，复用使用 */
			this._skinSprite = null;
			/**@private 变形动画数据 */
			this.deformData = null;
			this._mVerticleArr = null;
		}

		__class(BoneSlot, 'laya.ani.bone.BoneSlot');
		var __proto = BoneSlot.prototype;
		/**
		*设置要显示的插槽数据
		*@param slotData
		*@param disIndex
		*@param freshIndex 是否重置纹理
		*/
		__proto.showSlotData = function (slotData, freshIndex) {
			(freshIndex === void 0) && (freshIndex = true);
			this.currSlotData = slotData;
			if (freshIndex)
				this.displayIndex = this.srcDisplayIndex;
			this.currDisplayData = null;
			this.currTexture = null;
		}

		/**
		*通过名字显示指定对象
		*@param name
		*/
		__proto.showDisplayByName = function (name) {
			if (this.currSlotData) {
				this.showDisplayByIndex(this.currSlotData.getDisplayByName(name));
			}
		}

		/**
		*替换贴图名
		*@param tarName 要替换的贴图名
		*@param newName 替换后的贴图名
		*/
		__proto.replaceDisplayByName = function (tarName, newName) {
			if (!this.currSlotData) return;
			var preIndex = 0;
			preIndex = this.currSlotData.getDisplayByName(tarName);
			var newIndex = 0;
			newIndex = this.currSlotData.getDisplayByName(newName);
			this.replaceDisplayByIndex(preIndex, newIndex);
		}

		/**
		*替换贴图索引
		*@param tarIndex 要替换的索引
		*@param newIndex 替换后的索引
		*/
		__proto.replaceDisplayByIndex = function (tarIndex, newIndex) {
			if (!this.currSlotData) return;
			this._replaceDic[tarIndex] = newIndex;
			if (this.displayIndex == tarIndex) {
				this.showDisplayByIndex(tarIndex);
			}
		}

		/**
		*指定显示对象
		*@param index
		*/
		__proto.showDisplayByIndex = function (index) {
			if (this._replaceDic[index] != null) index = this._replaceDic[index];
			if (this.currSlotData && index > -1 && index < this.currSlotData.displayArr.length) {
				this.displayIndex = index;
				this.currDisplayData = this.currSlotData.displayArr[index];
				if (this.currDisplayData) {
					var tName = this.currDisplayData.name;
					this.currTexture = this.templet.getTexture(tName);
					if (this.currTexture && !Render.isConchApp && this.currDisplayData.type == 0 && this.currDisplayData.uvs) {
						this.currTexture = this.currDisplayData.createTexture(this.currTexture);
					}
				}
			} else {
				this.displayIndex = -1;
				this.currDisplayData = null;
				this.currTexture = null;
			}
		}

		/**
		*替换皮肤
		*@param _texture
		*/
		__proto.replaceSkin = function (_texture) {
			this._diyTexture = _texture;
			if (this._curDiyUV) this._curDiyUV.length = 0;
			if (this.currDisplayData && this._diyTexture == this.currDisplayData.texture) {
				this._diyTexture = null;
			}
		}

		/**
		*保存父矩阵的索引
		*@param parentMatrix
		*/
		__proto.setParentMatrix = function (parentMatrix) {
			this._parentMatrix = parentMatrix;
		}

		/**
		*把纹理画到Graphics上
		*@param graphics
		*@param noUseSave
		*/
		__proto.draw = function (graphics, boneMatrixArray, noUseSave, alpha) {
			(noUseSave === void 0) && (noUseSave = false);
			(alpha === void 0) && (alpha = 1);
			if ((this._diyTexture == null && this.currTexture == null) || this.currDisplayData == null) {
				if (!(this.currDisplayData && this.currDisplayData.type == 3)) {
					return;
				}
			};
			var tTexture = this.currTexture;
			if (this._diyTexture) tTexture = this._diyTexture;
			var tSkinSprite;
			switch (this.currDisplayData.type) {
				case 0:
					if (graphics) {
						var tCurrentMatrix = this.getDisplayMatrix();
						if (this._parentMatrix) {
							var tRotateKey = false;
							if (tCurrentMatrix) {
								Matrix.mul(tCurrentMatrix, this._parentMatrix, Matrix.TEMP);
								var tResultMatrix;
								if (noUseSave) {
									if (this._resultMatrix == null) this._resultMatrix = new Matrix();
									tResultMatrix = this._resultMatrix;
								} else {
									tResultMatrix = new Matrix();
								}
								if ((!Render.isWebGL && this.currDisplayData.uvs) || (Render.isWebGL && this._diyTexture && this.currDisplayData.uvs)) {
									var tTestMatrix = BoneSlot._tempMatrix;
									tTestMatrix.identity();
									if (this.currDisplayData.uvs[1] > this.currDisplayData.uvs[5]) {
										tTestMatrix.d = -1;
									}
									if (this.currDisplayData.uvs[0] > this.currDisplayData.uvs[4]
										&& this.currDisplayData.uvs[1] > this.currDisplayData.uvs[5]) {
										tRotateKey = true;
										tTestMatrix.rotate(-Math.PI / 2);
									}
									Matrix.mul(tTestMatrix, Matrix.TEMP, tResultMatrix);
								} else {
									Matrix.TEMP.copyTo(tResultMatrix);
								}
								if (tRotateKey) {
									graphics.drawTexture(tTexture, -this.currDisplayData.height / 2, -this.currDisplayData.width / 2, this.currDisplayData.height, this.currDisplayData.width, tResultMatrix);
								} else {
									graphics.drawTexture(tTexture, -this.currDisplayData.width / 2, -this.currDisplayData.height / 2, this.currDisplayData.width, this.currDisplayData.height, tResultMatrix);
								}
							}
						}
					}
					break;
				case 1:
					if (noUseSave) {
						if (this._skinSprite == null) {
							this._skinSprite = BoneSlot.createSkinMesh();
						}
						tSkinSprite = this._skinSprite;
					} else {
						tSkinSprite = BoneSlot.createSkinMesh();
					}
					if (tSkinSprite == null) {
						return;
					};
					var tIBArray;
					var tRed = 1;
					var tGreed = 1;
					var tBlue = 1;
					var tAlpha = 1;
					if (this.currDisplayData.bones == null) {
						var tVertices = this.currDisplayData.weights;
						if (this.deformData) {
							tVertices = this.deformData;
						};
						var tUVs;
						if (this._diyTexture) {
							if (!this._curDiyUV) {
								this._curDiyUV = [];
							}
							if (this._curDiyUV.length == 0) {
								this._curDiyUV = UVTools.getRelativeUV(this.currTexture.uv, this.currDisplayData.uvs, this._curDiyUV);
								this._curDiyUV = UVTools.getAbsoluteUV(this._diyTexture.uv, this._curDiyUV, this._curDiyUV);
							}
							tUVs = this._curDiyUV;
						} else {
							tUVs = this.currDisplayData.uvs;
						}
						this._mVerticleArr = tVertices;
						var tTriangleNum = this.currDisplayData.triangles.length / 3;
						tIBArray = this.currDisplayData.triangles;
						tSkinSprite.init2(tTexture, null, tIBArray, this._mVerticleArr, tUVs);
						var tCurrentMatrix2 = this.getDisplayMatrix();
						if (this._parentMatrix) {
							if (tCurrentMatrix2) {
								Matrix.mul(tCurrentMatrix2, this._parentMatrix, Matrix.TEMP);
								var tResultMatrix2;
								if (noUseSave) {
									if (this._resultMatrix == null) this._resultMatrix = new Matrix();
									tResultMatrix2 = this._resultMatrix;
								} else {
									tResultMatrix2 = new Matrix();
								}
								Matrix.TEMP.copyTo(tResultMatrix2);
								tSkinSprite.transform = tResultMatrix2;
							}
						}
					} else {
						this.skinMesh(boneMatrixArray, tSkinSprite, alpha);
					}
					graphics.drawSkin(tSkinSprite);
					break;
				case 2:
					if (noUseSave) {
						if (this._skinSprite == null) {
							this._skinSprite = BoneSlot.createSkinMesh();
						}
						tSkinSprite = this._skinSprite;
					} else {
						tSkinSprite = BoneSlot.createSkinMesh();
					}
					if (tSkinSprite == null) {
						return;
					}
					this.skinMesh(boneMatrixArray, tSkinSprite, alpha);
					graphics.drawSkin(tSkinSprite);
					break;
				case 3:
					break;
			}
		}

		/**
		*显示蒙皮动画
		*@param boneMatrixArray 当前帧的骨骼矩阵
		*/
		__proto.skinMesh = function (boneMatrixArray, skinSprite, alpha) {
			var tTexture = this.currTexture;
			var tBones = this.currDisplayData.bones;
			var tUvs;
			if (this._diyTexture) {
				tTexture = this._diyTexture;
				if (!this._curDiyUV) {
					this._curDiyUV = [];
				}
				if (this._curDiyUV.length == 0) {
					this._curDiyUV = UVTools.getRelativeUV(this.currTexture.uv, this.currDisplayData.uvs, this._curDiyUV);
					this._curDiyUV = UVTools.getAbsoluteUV(this._diyTexture.uv, this._curDiyUV, this._curDiyUV);
				}
				tUvs = this._curDiyUV;
			} else {
				tUvs = this.currDisplayData.uvs;
			};
			var tWeights = this.currDisplayData.weights;
			var tTriangles = this.currDisplayData.triangles;
			var tIBArray;
			var tRx = 0;
			var tRy = 0;
			var nn = 0;
			var tMatrix;
			var tX = NaN;
			var tY = NaN;
			var tB = 0;
			var tWeight = 0;
			var tVertices = [];
			var i = 0, j = 0, n = 0;
			var tRed = 1;
			var tGreed = 1;
			var tBlue = 1;
			var tAlpha = alpha;
			if (this.deformData && this.deformData.length > 0) {
				var f = 0;
				for (i = 0, n = tBones.length; i < n;) {
					nn = tBones[i++] + i;
					tRx = 0, tRy = 0;
					for (; i < nn; i++) {
						tMatrix = boneMatrixArray[tBones[i]]
						tX = tWeights[tB] + this.deformData[f++];
						tY = tWeights[tB + 1] + this.deformData[f++];
						tWeight = tWeights[tB + 2];
						tRx += (tX * tMatrix.a + tY * tMatrix.c + tMatrix.tx) * tWeight;
						tRy += (tX * tMatrix.b + tY * tMatrix.d + tMatrix.ty) * tWeight;
						tB += 3;
					}
					tVertices.push(tRx, tRy);
				}
			} else {
				for (i = 0, n = tBones.length; i < n;) {
					nn = tBones[i++] + i;
					tRx = 0, tRy = 0;
					for (; i < nn; i++) {
						tMatrix = boneMatrixArray[tBones[i]]
						tX = tWeights[tB];
						tY = tWeights[tB + 1];
						tWeight = tWeights[tB + 2];
						tRx += (tX * tMatrix.a + tY * tMatrix.c + tMatrix.tx) * tWeight;
						tRy += (tX * tMatrix.b + tY * tMatrix.d + tMatrix.ty) * tWeight;
						tB += 3;
					}
					tVertices.push(tRx, tRy);
				}
			}
			this._mVerticleArr = tVertices;
			tIBArray = tTriangles;
			skinSprite.init2(tTexture, null, tIBArray, this._mVerticleArr, tUvs);
		}

		/**
		*画骨骼的起始点，方便调试
		*@param graphics
		*/
		__proto.drawBonePoint = function (graphics) {
			if (graphics && this._parentMatrix) {
				graphics.drawCircle(this._parentMatrix.tx, this._parentMatrix.ty, 5, "#ff0000");
			}
		}

		/**
		*得到显示对象的矩阵
		*@return
		*/
		__proto.getDisplayMatrix = function () {
			if (this.currDisplayData) {
				return this.currDisplayData.transform.getMatrix();
			}
			return null;
		}

		/**
		*得到插糟的矩阵
		*@return
		*/
		__proto.getMatrix = function () {
			return this._resultMatrix;
		}

		/**
		*用原始数据拷贝出一个
		*@return
		*/
		__proto.copy = function () {
			var tBoneSlot = new BoneSlot();
			tBoneSlot.type = "copy";
			tBoneSlot.name = this.name;
			tBoneSlot.attachmentName = this.attachmentName;
			tBoneSlot.srcDisplayIndex = this.srcDisplayIndex;
			tBoneSlot.parent = this.parent;
			tBoneSlot.displayIndex = this.displayIndex;
			tBoneSlot.templet = this.templet;
			tBoneSlot.currSlotData = this.currSlotData;
			tBoneSlot.currTexture = this.currTexture;
			tBoneSlot.currDisplayData = this.currDisplayData;
			return tBoneSlot;
		}

		BoneSlot.createSkinMesh = function () {
			if (Render.isWebGL || Render.isConchApp) {
				return RunDriver.skinAniSprite();
			} else {
				if (!Render.isWebGL) {
					if (Skeleton.useSimpleMeshInCanvas) {
						return new SimpleSkinMeshCanvas();
					} else {
						return new SkinMeshCanvas();
					}
				}
			}
			return null;
		}

		__static(BoneSlot,
			['_tempMatrix', function () { return this._tempMatrix = new Matrix(); }
			]);
		return BoneSlot;
	})()


	/**
	*@private
	*canvas mesh渲染器
	*/
	//class laya.ani.bone.canvasmesh.CanvasMeshRender
	var CanvasMeshRender = (function () {
		function CanvasMeshRender() {
			/**
			*mesh数据
			*/
			this.mesh = null;
			/**
			*矩阵
			*/
			this.transform = null;
			/**
			*绘图环境
			*/
			this.context = null;
			/**
			*绘制mesh的模式 0:顶点索引模式 1：无顶点索引模式
			*/
			this.mode = 0;
		}

		__class(CanvasMeshRender, 'laya.ani.bone.canvasmesh.CanvasMeshRender');
		var __proto = CanvasMeshRender.prototype;
		/**
		*将mesh数据渲染到context上面
		*@param context
		*
		*/
		__proto.renderToContext = function (context) {
			this.context = context.ctx || context;
			if (this.mesh) {
				if (this.mode == 0) {
					this._renderWithIndexes(this.mesh);
				} else {
					this._renderNoIndexes(this.mesh);
				}
			}
		}

		/**
		*无顶点索引的模式
		*@param mesh
		*
		*/
		__proto._renderNoIndexes = function (mesh) {
			var i = 0, len = mesh.vertices.length / 2;
			var index = 0;
			for (i = 0; i < len - 2; i++) {
				index = i * 2;
				this._renderDrawTriangle(mesh, index, (index + 2), (index + 4));
			}
		}

		/**
		*使用顶点索引模式绘制
		*@param mesh
		*
		*/
		__proto._renderWithIndexes = function (mesh) {
			var indexes = mesh.indexes;
			var i = 0, len = indexes.length;
			for (i = 0; i < len; i += 3) {
				var index0 = indexes[i] * 2;
				var index1 = indexes[i + 1] * 2;
				var index2 = indexes[i + 2] * 2;
				this._renderDrawTriangle(mesh, index0, index1, index2);
			}
		}

		/**
		*绘制三角形
		*@param mesh mesh
		*@param index0 顶点0
		*@param index1 顶点1
		*@param index2 顶点2
		*
		*/
		__proto._renderDrawTriangle = function (mesh, index0, index1, index2) {
			var context = this.context;
			var uvs = mesh.uvs;
			var vertices = mesh.vertices;
			var texture = mesh.texture;
			var source = texture.bitmap;
			var textureSource = source.source;
			var textureWidth = texture.width;
			var textureHeight = texture.height;
			var sourceWidth = source.width;
			var sourceHeight = source.height;
			var u0 = NaN;
			var u1 = NaN;
			var u2 = NaN;
			var v0 = NaN;
			var v1 = NaN;
			var v2 = NaN;
			if (mesh.useUvTransform) {
				var ut = mesh.uvTransform;
				u0 = ((uvs[index0] * ut.a) + (uvs[index0 + 1] * ut.c) + ut.tx) * sourceWidth;
				u1 = ((uvs[index1] * ut.a) + (uvs[index1 + 1] * ut.c) + ut.tx) * sourceWidth;
				u2 = ((uvs[index2] * ut.a) + (uvs[index2 + 1] * ut.c) + ut.tx) * sourceWidth;
				v0 = ((uvs[index0] * ut.b) + (uvs[index0 + 1] * ut.d) + ut.ty) * sourceHeight;
				v1 = ((uvs[index1] * ut.b) + (uvs[index1 + 1] * ut.d) + ut.ty) * sourceHeight;
				v2 = ((uvs[index2] * ut.b) + (uvs[index2 + 1] * ut.d) + ut.ty) * sourceHeight;
			}
			else {
				u0 = uvs[index0] * sourceWidth;
				u1 = uvs[index1] * sourceWidth;
				u2 = uvs[index2] * sourceWidth;
				v0 = uvs[index0 + 1] * sourceHeight;
				v1 = uvs[index1 + 1] * sourceHeight;
				v2 = uvs[index2 + 1] * sourceHeight;
			};
			var x0 = vertices[index0];
			var x1 = vertices[index1];
			var x2 = vertices[index2];
			var y0 = vertices[index0 + 1];
			var y1 = vertices[index1 + 1];
			var y2 = vertices[index2 + 1];
			if (mesh.canvasPadding > 0) {
				var paddingX = mesh.canvasPadding;
				var paddingY = mesh.canvasPadding;
				var centerX = (x0 + x1 + x2) / 3;
				var centerY = (y0 + y1 + y2) / 3;
				var normX = x0 - centerX;
				var normY = y0 - centerY;
				var dist = Math.sqrt((normX * normX) + (normY * normY));
				x0 = centerX + ((normX / dist) * (dist + paddingX));
				y0 = centerY + ((normY / dist) * (dist + paddingY));
				normX = x1 - centerX;
				normY = y1 - centerY;
				dist = Math.sqrt((normX * normX) + (normY * normY));
				x1 = centerX + ((normX / dist) * (dist + paddingX));
				y1 = centerY + ((normY / dist) * (dist + paddingY));
				normX = x2 - centerX;
				normY = y2 - centerY;
				dist = Math.sqrt((normX * normX) + (normY * normY));
				x2 = centerX + ((normX / dist) * (dist + paddingX));
				y2 = centerY + ((normY / dist) * (dist + paddingY));
			}
			context.save();
			if (this.transform) {
				var mt = this.transform;
				context.transform(mt.a, mt.b, mt.c, mt.d, mt.tx, mt.ty);
			}
			context.beginPath();
			context.moveTo(x0, y0);
			context.lineTo(x1, y1);
			context.lineTo(x2, y2);
			context.closePath();
			context.clip();
			var delta = (u0 * v1) + (v0 * u2) + (u1 * v2) - (v1 * u2) - (v0 * u1) - (u0 * v2);
			var dDelta = 1 / delta;
			var deltaA = (x0 * v1) + (v0 * x2) + (x1 * v2) - (v1 * x2) - (v0 * x1) - (x0 * v2);
			var deltaB = (u0 * x1) + (x0 * u2) + (u1 * x2) - (x1 * u2) - (x0 * u1) - (u0 * x2);
			var deltaC = (u0 * v1 * x2) + (v0 * x1 * u2) + (x0 * u1 * v2) - (x0 * v1 * u2) - (v0 * u1 * x2) - (u0 * x1 * v2);
			var deltaD = (y0 * v1) + (v0 * y2) + (y1 * v2) - (v1 * y2) - (v0 * y1) - (y0 * v2);
			var deltaE = (u0 * y1) + (y0 * u2) + (u1 * y2) - (y1 * u2) - (y0 * u1) - (u0 * y2);
			var deltaF = (u0 * v1 * y2) + (v0 * y1 * u2) + (y0 * u1 * v2) - (y0 * v1 * u2) - (v0 * u1 * y2) - (u0 * y1 * v2);
			context.transform(deltaA * dDelta, deltaD * dDelta, deltaB * dDelta, deltaE * dDelta, deltaC * dDelta, deltaF * dDelta);
			context.drawImage(textureSource, texture.uv[0] * sourceWidth, texture.uv[1] * sourceHeight, textureWidth, textureHeight, texture.uv[0] * sourceWidth, texture.uv[1] * sourceHeight, textureWidth, textureHeight);
			context.restore();
		}

		return CanvasMeshRender;
	})()


	/**
	*@private
	*/
	//class laya.ani.bone.canvasmesh.MeshData
	var MeshData = (function () {
		function MeshData() {
			/**
			*纹理
			*/
			this.texture = null;
			/**
			*uv数据
			*/
			this.uvs = [0, 0, 1, 0, 1, 1, 0, 1];
			/**
			*顶点数据
			*/
			this.vertices = [0, 0, 100, 0, 100, 100, 0, 100];
			/**
			*顶点索引
			*/
			this.indexes = [0, 1, 3, 3, 1, 2];
			/**
			*uv变换矩阵
			*/
			this.uvTransform = null;
			/**
			*是否有uv变化矩阵
			*/
			this.useUvTransform = false;
			/**
			*扩展像素,用来去除黑边
			*/
			this.canvasPadding = 1;
		}

		__class(MeshData, 'laya.ani.bone.canvasmesh.MeshData');
		var __proto = MeshData.prototype;
		/**
		*计算mesh的Bounds
		*@return
		*
		*/
		__proto.getBounds = function () {
			return Rectangle._getWrapRec(this.vertices);
		}

		return MeshData;
	})()


	/**
	*@private
	*/
	//class laya.ani.bone.DeformAniData
	var DeformAniData = (function () {
		function DeformAniData() {
			this.skinName = null;
			this.deformSlotDataList = [];
		}

		__class(DeformAniData, 'laya.ani.bone.DeformAniData');
		return DeformAniData;
	})()


	/**
	*@private
	*/
	//class laya.ani.bone.DeformSlotData
	var DeformSlotData = (function () {
		function DeformSlotData() {
			this.deformSlotDisplayList = [];
		}

		__class(DeformSlotData, 'laya.ani.bone.DeformSlotData');
		return DeformSlotData;
	})()


	/**
	*@private
	*/
	//class laya.ani.bone.DeformSlotDisplayData
	var DeformSlotDisplayData = (function () {
		function DeformSlotDisplayData() {
			this.boneSlot = null;
			this.slotIndex = -1;
			this.attachment = null;
			this.deformData = null;
			this.frameIndex = 0;
			this.timeList = [];
			this.vectices = [];
			this.tweenKeyList = [];
		}

		__class(DeformSlotDisplayData, 'laya.ani.bone.DeformSlotDisplayData');
		var __proto = DeformSlotDisplayData.prototype;
		__proto.binarySearch1 = function (values, target) {
			var low = 0;
			var high = values.length - 2;
			if (high == 0)
				return 1;
			var current = high >>> 1;
			while (true) {
				if (values[Math.floor(current + 1)] <= target)
					low = current + 1;
				else
					high = current;
				if (low == high)
					return low + 1;
				current = (low + high) >>> 1;
			}
			return 0;
		}

		// Can't happen.
		__proto.apply = function (time, boneSlot, alpha) {
			(alpha === void 0) && (alpha = 1);
			time += 0.05;
			if (this.timeList.length <= 0) {
				return;
			};
			var i = 0;
			var n = 0;
			var tTime = this.timeList[0];
			if (time < tTime) {
				return;
			};
			var tVertexCount = this.vectices[0].length;
			var tVertices = [];
			var tFrameIndex = this.binarySearch1(this.timeList, time);
			this.frameIndex = tFrameIndex;
			if (time >= this.timeList[this.timeList.length - 1]) {
				var lastVertices = this.vectices[this.vectices.length - 1];
				if (alpha < 1) {
					for (i = 0; i < tVertexCount; i++) {
						tVertices[i] += (lastVertices[i] - tVertices[i]) * alpha;
					}
				} else {
					for (i = 0; i < tVertexCount; i++) {
						tVertices[i] = lastVertices[i];
					}
				}
				this.deformData = tVertices;
				return;
			};
			var tTweenKey = this.tweenKeyList[this.frameIndex];
			var tPrevVertices = this.vectices[this.frameIndex - 1];
			var tNextVertices = this.vectices[this.frameIndex];
			var tPreFrameTime = this.timeList[this.frameIndex - 1];
			var tFrameTime = this.timeList[this.frameIndex];
			if (this.tweenKeyList[tFrameIndex - 1]) {
				alpha = (time - tPreFrameTime) / (tFrameTime - tPreFrameTime);
			} else {
				alpha = 0;
			};
			var tPrev = NaN;
			for (i = 0; i < tVertexCount; i++) {
				tPrev = tPrevVertices[i];
				tVertices[i] = tPrev + (tNextVertices[i] - tPrev) * alpha;
			}
			this.deformData = tVertices;
		}

		return DeformSlotDisplayData;
	})()


	/**
	*@private
	*/
	//class laya.ani.bone.DrawOrderData
	var DrawOrderData = (function () {
		function DrawOrderData() {
			this.time = NaN;
			this.drawOrder = [];
		}

		__class(DrawOrderData, 'laya.ani.bone.DrawOrderData');
		return DrawOrderData;
	})()


	/**
	*@private
	*/
	//class laya.ani.bone.EventData
	var EventData = (function () {
		function EventData() {
			this.name = null;
			this.intValue = 0;
			this.floatValue = NaN;
			this.stringValue = null;
			this.time = NaN;
		}

		__class(EventData, 'laya.ani.bone.EventData');
		return EventData;
	})()


	/**
	*@private
	*/
	//class laya.ani.bone.IkConstraint
	var IkConstraint = (function () {
		function IkConstraint(data, bones) {
			this._targetBone = null;
			this._bones = null;
			this._data = null;
			this.name = null;
			this.mix = NaN;
			this.bendDirection = NaN;
			this.isSpine = true;
			//debug相关代码
			this._sp = null;
			this.isDebug = false;
			this._data = data;
			this._targetBone = bones[data.targetBoneIndex];
			this.isSpine = data.isSpine;
			if (this._bones == null) this._bones = [];
			this._bones.length = 0;
			for (var i = 0, n = data.boneIndexs.length; i < n; i++) {
				this._bones.push(bones[data.boneIndexs[i]]);
			}
			this.name = data.name;
			this.mix = data.mix;
			this.bendDirection = data.bendDirection;
		}

		__class(IkConstraint, 'laya.ani.bone.IkConstraint');
		var __proto = IkConstraint.prototype;
		__proto.apply = function () {
			switch (this._bones.length) {
				case 1:
					this._applyIk1(this._bones[0], this._targetBone.resultMatrix.tx, this._targetBone.resultMatrix.ty, this.mix);
					break;
				case 2:
					if (this.isSpine) {
						this._applyIk2(this._bones[0], this._bones[1], this._targetBone.resultMatrix.tx, this._targetBone.resultMatrix.ty, this.bendDirection, this.mix);
					} else {
						this._applyIk3(this._bones[0], this._bones[1], this._targetBone.resultMatrix.tx, this._targetBone.resultMatrix.ty, this.bendDirection, this.mix);
					}
					break;
			}
		}

		__proto._applyIk1 = function (bone, targetX, targetY, alpha) {
			var pp = bone.parentBone;
			var id = 1 / (pp.resultMatrix.a * pp.resultMatrix.d - pp.resultMatrix.b * pp.resultMatrix.c);
			var x = targetX - pp.resultMatrix.tx;
			var y = targetY - pp.resultMatrix.ty;
			var tx = (x * pp.resultMatrix.d - y * pp.resultMatrix.c) * id - bone.transform.x;
			var ty = (y * pp.resultMatrix.a - x * pp.resultMatrix.b) * id - bone.transform.y;
			var rotationIK = Math.atan2(ty, tx) * IkConstraint.radDeg - 0 - bone.transform.skX;
			if (bone.transform.scX < 0) rotationIK += 180;
			if (rotationIK > 180)
				rotationIK -= 360;
			else if (rotationIK < -180) rotationIK += 360;
			bone.transform.skX = bone.transform.skY = bone.transform.skX + rotationIK * alpha;
			bone.update();
		}

		__proto.updatePos = function (x, y) {
			if (this._sp) {
				this._sp.pos(x, y);
			}
		}

		__proto._applyIk2 = function (parent, child, targetX, targetY, bendDir, alpha) {
			if (alpha == 0) {
				return;
			};
			var px = parent.resultTransform.x, py = parent.resultTransform.y;
			var psx = parent.transform.scX, psy = parent.transform.scY;
			var csx = child.transform.scX;
			var os1 = 0, os2 = 0, s2 = 0;
			if (psx < 0) {
				psx = -psx;
				os1 = 180;
				s2 = -1;
			} else {
				os1 = 0;
				s2 = 1;
			}
			if (psy < 0) {
				psy = -psy;
				s2 = -s2;
			}
			if (csx < 0) {
				csx = -csx;
				os2 = 180;
			} else {
				os2 = 0
			};
			var cx = child.resultTransform.x, cy = NaN, cwx = NaN, cwy = NaN;
			var a = parent.resultMatrix.a, b = parent.resultMatrix.c;
			var c = parent.resultMatrix.b, d = parent.resultMatrix.d;
			var u = Math.abs(psx - psy) <= 0.0001;
			if (!u) {
				cy = 0;
				cwx = a * cx + parent.resultMatrix.tx;
				cwy = c * cx + parent.resultMatrix.ty;
			} else {
				cy = child.resultTransform.y;
				cwx = a * cx + b * cy + parent.resultMatrix.tx;
				cwy = c * cx + d * cy + parent.resultMatrix.ty;
			}
			if (this.isDebug) {
				if (!this._sp) {
					this._sp = new Sprite();
					Laya.stage.addChild(this._sp);
				}
				this._sp.graphics.clear();
				this._sp.graphics.drawCircle(targetX, targetY, 15, "#ffff00");
				this._sp.graphics.drawCircle(cwx, cwy, 15, "#ff00ff");
			}
			parent.setRotation(Math.atan2(cwy - parent.resultMatrix.ty, cwx - parent.resultMatrix.tx));
			var pp = parent.parentBone;
			a = pp.resultMatrix.a;
			b = pp.resultMatrix.c;
			c = pp.resultMatrix.b;
			d = pp.resultMatrix.d;
			var id = 1 / (a * d - b * c);
			var x = targetX - pp.resultMatrix.tx, y = targetY - pp.resultMatrix.ty;
			var tx = (x * d - y * b) * id - px;
			var ty = (y * a - x * c) * id - py;
			x = cwx - pp.resultMatrix.tx;
			y = cwy - pp.resultMatrix.ty;
			var dx = (x * d - y * b) * id - px;
			var dy = (y * a - x * c) * id - py;
			var l1 = Math.sqrt(dx * dx + dy * dy);
			var l2 = child.length * csx;
			var a1 = NaN, a2 = NaN;
			if (u) {
				l2 *= psx;
				var cos = (tx * tx + ty * ty - l1 * l1 - l2 * l2) / (2 * l1 * l2);
				if (cos < -1)
					cos = -1;
				else if (cos > 1) cos = 1;
				a2 = Math.acos(cos) * bendDir;
				a = l1 + l2 * cos;
				b = l2 * Math.sin(a2);
				a1 = Math.atan2(ty * a - tx * b, tx * a + ty * b);
			} else {
				a = psx * l2;
				b = psy * l2;
				var aa = a * a, bb = b * b, dd = tx * tx + ty * ty, ta = Math.atan2(ty, tx);
				c = bb * l1 * l1 + aa * dd - aa * bb;
				var c1 = -2 * bb * l1, c2 = bb - aa;
				d = c1 * c1 - 4 * c2 * c;
				if (d > 0) {
					var q = Math.sqrt(d);
					if (c1 < 0) q = -q;
					q = -(c1 + q) / 2;
					var r0 = q / c2, r1 = c / q;
					var r = Math.abs(r0) < Math.abs(r1) ? r0 : r1;
					if (r * r <= dd) {
						y = Math.sqrt(dd - r * r) * bendDir;
						a1 = ta - Math.atan2(y, r);
						a2 = Math.atan2(y / psy, (r - l1) / psx);
					}
				};
				var minAngle = 0, minDist = Number.MAX_VALUE, minX = 0, minY = 0;
				var maxAngle = 0, maxDist = 0, maxX = 0, maxY = 0;
				x = l1 + a;
				d = x * x;
				if (d > maxDist) {
					maxAngle = 0;
					maxDist = d;
					maxX = x;
				}
				x = l1 - a;
				d = x * x;
				if (d < minDist) {
					minAngle = Math.PI;
					minDist = d;
					minX = x;
				};
				var angle = Math.acos(-a * l1 / (aa - bb));
				x = a * Math.cos(angle) + l1;
				y = b * Math.sin(angle);
				d = x * x + y * y;
				if (d < minDist) {
					minAngle = angle;
					minDist = d;
					minX = x;
					minY = y;
				}
				if (d > maxDist) {
					maxAngle = angle;
					maxDist = d;
					maxX = x;
					maxY = y;
				}
				if (dd <= (minDist + maxDist) / 2) {
					a1 = ta - Math.atan2(minY * bendDir, minX);
					a2 = minAngle * bendDir;
				} else {
					a1 = ta - Math.atan2(maxY * bendDir, maxX);
					a2 = maxAngle * bendDir;
				}
			};
			var os = Math.atan2(cy, cx) * s2;
			var rotation = parent.resultTransform.skX;
			a1 = (a1 - os) * IkConstraint.radDeg + os1 - rotation;
			if (a1 > 180)
				a1 -= 360;
			else if (a1 < -180) a1 += 360;
			parent.resultTransform.x = px;
			parent.resultTransform.y = py;
			parent.resultTransform.skX = parent.resultTransform.skY = rotation + a1 * alpha;
			rotation = child.resultTransform.skX;
			rotation = rotation % 360;
			a2 = ((a2 + os) * IkConstraint.radDeg - 0) * s2 + os2 - rotation;
			if (a2 > 180)
				a2 -= 360;
			else if (a2 < -180) a2 += 360;
			child.resultTransform.x = cx;
			child.resultTransform.y = cy;
			child.resultTransform.skX = child.resultTransform.skY = child.resultTransform.skY + a2 * alpha;
			parent.update();
		}

		__proto._applyIk3 = function (parent, child, targetX, targetY, bendDir, alpha) {
			if (alpha == 0) {
				return;
			};
			var cwx = NaN, cwy = NaN;
			var x = child.resultMatrix.a * child.length;
			var y = child.resultMatrix.b * child.length;
			var lLL = x * x + y * y;
			var lL = Math.sqrt(lLL);
			var parentX = parent.resultMatrix.tx;
			var parentY = parent.resultMatrix.ty;
			var childX = child.resultMatrix.tx;
			var childY = child.resultMatrix.ty;
			var dX = childX - parentX;
			var dY = childY - parentY;
			var lPP = dX * dX + dY * dY;
			var lP = Math.sqrt(lPP);
			dX = targetX - parent.resultMatrix.tx;
			dY = targetY - parent.resultMatrix.ty;
			var lTT = dX * dX + dY * dY;
			var lT = Math.sqrt(lTT);
			var ikRadianA = 0;
			if (lL + lP <= lT || lT + lL <= lP || lT + lP <= lL) {
				var rate = NaN;
				if (lL + lP <= lT) {
					rate = 1;
				} else {
					rate = -1;
				}
				childX = parentX + rate * (targetX - parentX) * lP / lT;
				childY = parentY + rate * (targetY - parentY) * lP / lT;
			}
			else {
				var h = (lPP - lLL + lTT) / (2 * lTT);
				var r = Math.sqrt(lPP - h * h * lTT) / lT;
				var hX = parentX + (dX * h);
				var hY = parentY + (dY * h);
				var rX = -dY * r;
				var rY = dX * r;
				if (bendDir > 0) {
					childX = hX - rX;
					childY = hY - rY;
				}
				else {
					childX = hX + rX;
					childY = hY + rY;
				}
			}
			cwx = childX;
			cwy = childY;
			if (this.isDebug) {
				if (!this._sp) {
					this._sp = new Sprite();
					Laya.stage.addChild(this._sp);
				}
				this._sp.graphics.clear();
				this._sp.graphics.drawCircle(parentX, parentY, 15, "#ff00ff");
				this._sp.graphics.drawCircle(targetX, targetY, 15, "#ffff00");
				this._sp.graphics.drawCircle(cwx, cwy, 15, "#ff00ff");
			};
			var pRotation = NaN;
			pRotation = Math.atan2(cwy - parent.resultMatrix.ty, cwx - parent.resultMatrix.tx);
			parent.setRotation(pRotation);
			var pTarMatrix;
			pTarMatrix = IkConstraint._tempMatrix;
			pTarMatrix.identity();
			pTarMatrix.rotate(pRotation);
			pTarMatrix.scale(parent.resultMatrix.getScaleX(), parent.resultMatrix.getScaleY());
			pTarMatrix.translate(parent.resultMatrix.tx, parent.resultMatrix.ty);
			pTarMatrix.copyTo(parent.resultMatrix);
			parent.updateChild();
			var childRotation = NaN;
			childRotation = Math.atan2(targetY - cwy, targetX - cwx);
			child.setRotation(childRotation);
			var childTarMatrix;
			childTarMatrix = IkConstraint._tempMatrix;
			childTarMatrix.identity();
			childTarMatrix.rotate(childRotation);
			childTarMatrix.scale(child.resultMatrix.getScaleX(), child.resultMatrix.getScaleY());
			childTarMatrix.translate(cwx, cwy);
			pTarMatrix.copyTo(child.resultMatrix);
			child.updateChild();
		}

		__static(IkConstraint,
			['radDeg', function () { return this.radDeg = 180 / Math.PI; }, 'degRad', function () { return this.degRad = Math.PI / 180; }, '_tempMatrix', function () { return this._tempMatrix = new Matrix(); }
			]);
		return IkConstraint;
	})()


	/**
	*@private
	*/
	//class laya.ani.bone.IkConstraintData
	var IkConstraintData = (function () {
		function IkConstraintData() {
			this.name = null;
			this.targetBoneName = null;
			this.bendDirection = 1;
			this.mix = 1;
			this.isSpine = true;
			this.targetBoneIndex = -1;
			this.boneNames = [];
			this.boneIndexs = [];
		}

		__class(IkConstraintData, 'laya.ani.bone.IkConstraintData');
		return IkConstraintData;
	})()


	/**
	*@private
	*Mesh数据处理工具
	*@version 1.0
	*
	*@created 2017-4-28 下午2:46:23
	*/
	//class laya.ani.bone.MeshTools
	var MeshTools = (function () {
		function MeshTools() { }
		__class(MeshTools, 'laya.ani.bone.MeshTools');
		MeshTools.findEdge = function (verticles, offI, min) {
			(offI === void 0) && (offI = 0);
			(min === void 0) && (min = true);
			var i = 0, len = 0;
			var tIndex = 0;
			len = verticles.length;
			tIndex = -1;
			for (i = 0; i < len; i += 2) {
				if (tIndex < 0 || (min == (verticles[tIndex + offI] < verticles[i + offI]))) {
					tIndex = i;
				}
			}
			return tIndex;
		}

		MeshTools.findBestTriangle = function (verticles) {
			var topI = 0;
			topI = MeshTools.findEdge(verticles, 1, true);
			var bottomI = 0;
			bottomI = MeshTools.findEdge(verticles, 1, false);
			var leftI = 0;
			leftI = MeshTools.findEdge(verticles, 0, true);
			var rightI = 0;
			rightI = MeshTools.findEdge(verticles, 0, false);
			var rst;
			rst = MeshTools._bestTriangle;
			rst.length = 0;
			rst.push(leftI, rightI);
			if (rst.indexOf(topI) < 0) rst.push(topI);
			if (rst.indexOf(bottomI) < 0) rst.push(bottomI);
			return rst;
		}

		MeshTools.solveMesh = function (mesh, rst) {
			rst = rst || [];
			rst.length = 0;
			var mUv;
			mUv = mesh.uvs;
			var mVer;
			mVer = mesh.vertices;
			var uvAbs;
			var indexs;
			indexs = MeshTools.findBestTriangle(mUv);
			var index0 = 0;
			var index1 = 0;
			var index2 = 0;
			index0 = indexs[0];
			index1 = indexs[1];
			index2 = indexs[2];
			MeshTools._absArr.length = 0;
			uvAbs = MeshTools.solvePoints(mesh.texture.uv, mUv[index0], mUv[index0 + 1], mUv[index1] - mUv[index0], mUv[index1 + 1] - mUv[index0 + 1], mUv[index2] - mUv[index0], mUv[index2 + 1] - mUv[index0 + 1], MeshTools._absArr);
			var newVerticles;
			newVerticles = MeshTools.transPoints(uvAbs, mVer[index0], mVer[index0 + 1], mVer[index1] - mVer[index0], mVer[index1 + 1] - mVer[index0 + 1], mVer[index2] - mVer[index0], mVer[index2 + 1] - mVer[index0 + 1], rst);
			return newVerticles;
		}

		MeshTools.solvePoints = function (pointList, oX, oY, v1x, v1y, v2x, v2y, rst) {
			rst = rst || [];
			var i = 0, len = 0;
			len = pointList.length;
			var tRst;
			for (i = 0; i < len; i += 2) {
				tRst = MeshTools.solve2(pointList[i], pointList[i + 1], oX, oY, v1x, v1y, v2x, v2y);
				rst.push(tRst[0], tRst[1]);
			}
			return rst;
		}

		MeshTools.transPoints = function (abs, oX, oY, v1x, v1y, v2x, v2y, rst) {
			rst = rst || [];
			var i = 0, len = 0;
			len = abs.length;
			var tRst;
			for (i = 0; i < len; i += 2) {
				tRst = MeshTools.transPoint(abs[i], abs[i + 1], oX, oY, v1x, v1y, v2x, v2y, rst);
			}
			return rst;
		}

		MeshTools.transPoint = function (a, b, oX, oY, v1x, v1y, v2x, v2y, rst) {
			rst = rst || [];
			var nX = NaN;
			var nY = NaN;
			nX = oX + v1x * a + v2x * b;
			nY = oY + v1y * a + v2y * b;
			rst.push(nX, nY)
			return rst;
		}

		MeshTools.solve2 = function (rx, ry, oX, oY, v1x, v1y, v2x, v2y, rv, rst) {
			(rv === void 0) && (rv = false);
			rst = rst || [];
			var a = NaN, b = NaN;
			if (v1x == 0) {
				return MeshTools.solve2(rx, ry, oX, oY, v2x, v2y, v1x, v1y, true, rst);
			};
			var dX = NaN;
			var dY = NaN;
			dX = rx - oX;
			dY = ry - oY;
			b = (dY - dX * v1y / v1x) / (v2y - v2x * v1y / v1x);
			a = (dX - b * v2x) / v1x;
			if (rv) {
				rst.push(b, a);
			} else {
				rst.push(a, b);
			}
			return rst;
		}

		MeshTools.solve = function (pointC, point0, v1, v2) {
			return MeshTools.solve2(pointC.x, pointC.y, point0.x, point0.y, v1.x, v1.y, v2.x, v2.y);
		}

		MeshTools._bestTriangle = [];
		MeshTools._absArr = [];
		return MeshTools;
	})()


	/**
	*@private
	*路径作用器
	*1，生成根据骨骼计算控制点
	*2，根据控制点生成路径，并计算路径上的节点
	*3，根据节点，重新调整骨骼位置
	*/
	//class laya.ani.bone.PathConstraint
	var PathConstraint = (function () {
		function PathConstraint(data, bones) {
			this.target = null;
			this.data = null;
			this.bones = null;
			this.position = NaN;
			this.spacing = NaN;
			this.rotateMix = NaN;
			this.translateMix = NaN;
			this._debugKey = false;
			this._spaces = null;
			this._segments = [];
			this._curves = [];
			this.data = data;
			this.position = data.position;
			this.spacing = data.spacing;
			this.rotateMix = data.rotateMix;
			this.translateMix = data.translateMix;
			this.bones = [];
			var tBoneIds = this.data.bones;
			for (var i = 0, n = tBoneIds.length; i < n; i++) {
				this.bones.push(bones[tBoneIds[i]]);
			}
		}

		__class(PathConstraint, 'laya.ani.bone.PathConstraint');
		var __proto = PathConstraint.prototype;
		/**
		*计算骨骼在路径上的节点
		*@param boneSlot
		*@param boneMatrixArray
		*@param graphics
		*/
		__proto.apply = function (boneList, graphics) {
			if (!this.target)
				return;
			var tTranslateMix = this.translateMix;
			var tRotateMix = this.translateMix;
			var tTranslate = tTranslateMix > 0;
			var tRotate = tRotateMix > 0;
			var tSpacingMode = this.data.spacingMode;
			var tLengthSpacing = tSpacingMode == "length";
			var tRotateMode = this.data.rotateMode;
			var tTangents = tRotateMode == "tangent";
			var tScale = tRotateMode == "chainScale";
			var lengths = [];
			var boneCount = this.bones.length;
			var spacesCount = tTangents ? boneCount : boneCount + 1;
			var spaces = [];
			this._spaces = spaces;
			spaces[0] = this.position;
			var spacing = this.spacing;
			if (tScale || tLengthSpacing) {
				for (var i = 0, n = spacesCount - 1; i < n;) {
					var bone = this.bones[i];
					var length = bone.length;
					var x = length * bone.resultMatrix.a;
					var y = length * bone.resultMatrix.b;
					length = Math.sqrt(x * x + y * y);
					if (tScale)
						lengths[i] = length;
					spaces[++i] = tLengthSpacing ? Math.max(0, length + spacing) : spacing;
				}
			}
			else {
				for (i = 1; i < spacesCount; i++) {
					spaces[i] = spacing;
				}
			};
			var positions = this.computeWorldPositions(this.target, boneList, graphics, spacesCount, tTangents, this.data.positionMode == "percent", tSpacingMode == "percent");
			if (this._debugKey) {
				for (i = 0; i < positions.length; i++) {
					graphics.drawCircle(positions[i++], positions[i++], 5, "#00ff00");
				};
				var tLinePos = [];
				for (i = 0; i < positions.length; i++) {
					tLinePos.push(positions[i++], positions[i++]);
				}
				graphics.drawLines(0, 0, tLinePos, "#ff0000");
			};
			var skeletonX = NaN;
			var skeletonY = NaN;
			var boneX = positions[0];
			var boneY = positions[1];
			var offsetRotation = this.data.offsetRotation;
			var tip = tRotateMode == "chain" && offsetRotation == 0;
			var p = NaN;
			for (i = 0, p = 3; i < boneCount; i++ , p += 3) {
				bone = this.bones[i];
				bone.resultMatrix.tx += (boneX - bone.resultMatrix.tx) * tTranslateMix;
				bone.resultMatrix.ty += (boneY - bone.resultMatrix.ty) * tTranslateMix;
				x = positions[p];
				y = positions[p + 1];
				var dx = x - boneX, dy = y - boneY;
				if (tScale) {
					length = lengths[i];
					if (length != 0) {
						var s = (Math.sqrt(dx * dx + dy * dy) / length - 1) * tRotateMix + 1;
						bone.resultMatrix.a *= s;
						bone.resultMatrix.c *= s;
					}
				}
				boneX = x;
				boneY = y;
				if (tRotate) {
					var a = bone.resultMatrix.a;
					var b = bone.resultMatrix.c;
					var c = bone.resultMatrix.b;
					var d = bone.resultMatrix.d;
					var r = NaN;
					var cos = NaN;
					var sin = NaN;
					if (tTangents) {
						r = positions[p - 1];
					}
					else if (spaces[i + 1] == 0) {
						r = positions[p + 2];
					}
					else {
						r = Math.atan2(dy, dx);
					}
					r -= Math.atan2(c, a) - offsetRotation / 180 * Math.PI;
					if (tip) {
						cos = Math.cos(r);
						sin = Math.sin(r);
						length = bone.length;
						boneX += (length * (cos * a - sin * c) - dx) * tRotateMix;
						boneY += (length * (sin * a + cos * c) - dy) * tRotateMix;
					}
					if (r > Math.PI) {
						r -= (Math.PI * 2);
					}
					else if (r < -Math.PI) {
						r += (Math.PI * 2);
					}
					r *= tRotateMix;
					cos = Math.cos(r);
					sin = Math.sin(r);
					bone.resultMatrix.a = cos * a - sin * c;
					bone.resultMatrix.c = cos * b - sin * d;
					bone.resultMatrix.b = sin * a + cos * c;
					bone.resultMatrix.d = sin * b + cos * d;
				}
			}
		}

		/**
		*计算顶点的世界坐标
		*@param boneSlot
		*@param boneList
		*@param start
		*@param count
		*@param worldVertices
		*@param offset
		*/
		__proto.computeWorldVertices2 = function (boneSlot, boneList, start, count, worldVertices, offset) {
			var tBones = boneSlot.currDisplayData.bones;
			var tWeights = boneSlot.currDisplayData.weights;
			var tTriangles = boneSlot.currDisplayData.triangles;
			var tMatrix;
			var i = 0;
			var v = 0;
			var skip = 0;
			var n = 0;
			var w = 0;
			var b = 0;
			var wx = 0;
			var wy = 0;
			var vx = 0;
			var vy = 0;
			var bone;
			var len = 0;
			if (tBones == null) {
				if (!tTriangles) tTriangles = tWeights;
				if (boneSlot.deformData)
					tTriangles = boneSlot.deformData;
				var parentName;
				parentName = boneSlot.parent;
				if (boneList) {
					len = boneList.length;
					for (i = 0; i < len; i++) {
						if (boneList[i].name == parentName) {
							bone = boneList[i];
							break;
						}
					}
				};
				var tBoneMt;
				if (bone) {
					tBoneMt = bone.resultMatrix;
				}
				if (!tBoneMt) tBoneMt = PathConstraint._tempMt;
				var x = tBoneMt.tx;
				var y = tBoneMt.ty;
				var a = tBoneMt.a, bb = tBoneMt.b, c = tBoneMt.c, d = tBoneMt.d;
				if (bone) d *= bone.d;
				for (v = start, w = offset; w < count; v += 2, w += 2) {
					vx = tTriangles[v], vy = tTriangles[v + 1];
					worldVertices[w] = vx * a + vy * bb + x;
					worldVertices[w + 1] = -(vx * c + vy * d + y);
				}
				return;
			}
			for (i = 0; i < start; i += 2) {
				n = tBones[v];
				v += n + 1;
				skip += n;
			};
			var skeletonBones = boneList;
			for (w = offset, b = skip * 3; w < count; w += 2) {
				wx = 0, wy = 0;
				n = tBones[v++];
				n += v;
				for (; v < n; v++ , b += 3) {
					tMatrix = skeletonBones[tBones[v]].resultMatrix;
					vx = tWeights[b];
					vy = tWeights[b + 1];
					var weight = tWeights[b + 2];
					wx += (vx * tMatrix.a + vy * tMatrix.c + tMatrix.tx) * weight;
					wy += (vx * tMatrix.b + vy * tMatrix.d + tMatrix.ty) * weight;
				}
				worldVertices[w] = wx;
				worldVertices[w + 1] = wy;
			}
		}

		/**
		*计算路径上的节点
		*@param boneSlot
		*@param boneList
		*@param graphics
		*@param spacesCount
		*@param tangents
		*@param percentPosition
		*@param percentSpacing
		*@return
		*/
		__proto.computeWorldPositions = function (boneSlot, boneList, graphics, spacesCount, tangents, percentPosition, percentSpacing) {
			var tBones = boneSlot.currDisplayData.bones;
			var tWeights = boneSlot.currDisplayData.weights;
			var tTriangles = boneSlot.currDisplayData.triangles;
			var tRx = 0;
			var tRy = 0;
			var nn = 0;
			var tMatrix;
			var tX = NaN;
			var tY = NaN;
			var tB = 0;
			var tWeight = 0;
			var tVertices = [];
			var i = 0, j = 0, n = 0;
			var verticesLength = boneSlot.currDisplayData.verLen;
			var target = boneSlot;
			var position = this.position;
			var spaces = this._spaces;
			var world = [];
			var out = [];
			var closed = false;
			var curveCount = verticesLength / 6;
			var prevCurve = -1;
			var pathLength = NaN;
			var o = 0, curve = 0;
			var p = NaN;
			var space = NaN;
			var prev = NaN;
			var length = NaN;
			if (!true) {
				var lengths = boneSlot.currDisplayData.lengths;
				curveCount -= closed ? 1 : 2;
				pathLength = lengths[curveCount];
				if (percentPosition)
					position *= pathLength;
				if (percentSpacing) {
					for (i = 0; i < spacesCount; i++)
						spaces[i] *= pathLength;
				}
				world.length = 8;
				for (i = 0, o = 0, curve = 0; i < spacesCount; i++ , o += 3) {
					space = spaces[i];
					position += space;
					p = position;
					if (closed) {
						p %= pathLength;
						if (p < 0)
							p += pathLength;
						curve = 0;
					}
					else if (p < 0) {
						if (prevCurve != PathConstraint.BEFORE) {
							prevCurve = PathConstraint.BEFORE;
							this.computeWorldVertices2(target, boneList, 2, 4, world, 0);
						}
						this.addBeforePosition(p, world, 0, out, o);
						continue;
					}
					else if (p > pathLength) {
						if (prevCurve != PathConstraint.AFTER) {
							prevCurve = PathConstraint.AFTER;
							this.computeWorldVertices2(target, boneList, verticesLength - 6, 4, world, 0);
						}
						this.addAfterPosition(p - pathLength, world, 0, out, o);
						continue;
					}
					for (; ; curve++) {
						length = lengths[curve];
						if (p > length)
							continue;
						if (curve == 0)
							p /= length;
						else {
							prev = lengths[curve - 1];
							p = (p - prev) / (length - prev);
						}
						break;
					}
					if (curve != prevCurve) {
						prevCurve = curve;
						if (closed && curve == curveCount) {
							this.computeWorldVertices2(target, boneList, verticesLength - 4, 4, world, 0);
							this.computeWorldVertices2(target, boneList, 0, 4, world, 4);
						}
						else
							this.computeWorldVertices2(target, boneList, curve * 6 + 2, 8, world, 0);
					}
					this.addCurvePosition(p, world[0], world[1], world[2], world[3], world[4], world[5], world[6], world[7], out, o, tangents || (i > 0 && space == 0));
				}
				return out;
			}
			if (closed) {
				verticesLength += 2;
				world[verticesLength - 2] = world[0];
				world[verticesLength - 1] = world[1];
			}
			else {
				curveCount--;
				verticesLength -= 4;
				this.computeWorldVertices2(boneSlot, boneList, 2, verticesLength, tVertices, 0);
				if (this._debugKey) {
					for (i = 0; i < tVertices.length;) {
						graphics.drawCircle(tVertices[i++], tVertices[i++], 10, "#ff0000");
					}
				}
				world = tVertices;
			}
			this._curves.length = curveCount;
			var curves = this._curves;
			pathLength = 0;
			var x1 = world[0], y1 = world[1], cx1 = 0, cy1 = 0, cx2 = 0, cy2 = 0, x2 = 0, y2 = 0;
			var tmpx = NaN, tmpy = NaN, dddfx = NaN, dddfy = NaN, ddfx = NaN, ddfy = NaN, dfx = NaN, dfy = NaN;
			var w = 0;
			for (i = 0, w = 2; i < curveCount; i++ , w += 6) {
				cx1 = world[w];
				cy1 = world[w + 1];
				cx2 = world[w + 2];
				cy2 = world[w + 3];
				x2 = world[w + 4];
				y2 = world[w + 5];
				tmpx = (x1 - cx1 * 2 + cx2) * 0.1875;
				tmpy = (y1 - cy1 * 2 + cy2) * 0.1875;
				dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 0.09375;
				dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 0.09375;
				ddfx = tmpx * 2 + dddfx;
				ddfy = tmpy * 2 + dddfy;
				dfx = (cx1 - x1) * 0.75 + tmpx + dddfx * 0.16666667;
				dfy = (cy1 - y1) * 0.75 + tmpy + dddfy * 0.16666667;
				pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
				dfx += ddfx;
				dfy += ddfy;
				ddfx += dddfx;
				ddfy += dddfy;
				pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
				dfx += ddfx;
				dfy += ddfy;
				pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
				dfx += ddfx + dddfx;
				dfy += ddfy + dddfy;
				pathLength += Math.sqrt(dfx * dfx + dfy * dfy);
				curves[i] = pathLength;
				x1 = x2;
				y1 = y2;
			}
			if (percentPosition)
				position *= pathLength;
			if (percentSpacing) {
				for (i = 0; i < spacesCount; i++)
					spaces[i] *= pathLength;
			};
			var segments = this._segments;
			var curveLength = 0;
			var segment = 0;
			for (i = 0, o = 0, curve = 0, segment = 0; i < spacesCount; i++ , o += 3) {
				space = spaces[i];
				position += space;
				p = position;
				if (closed) {
					p %= pathLength;
					if (p < 0)
						p += pathLength;
					curve = 0;
				}
				else if (p < 0) {
					this.addBeforePosition(p, world, 0, out, o);
					continue;
				}
				else if (p > pathLength) {
					this.addAfterPosition(p - pathLength, world, verticesLength - 4, out, o);
					continue;
				}
				for (; ; curve++) {
					length = curves[curve];
					if (p > length)
						continue;
					if (curve == 0)
						p /= length;
					else {
						prev = curves[curve - 1];
						p = (p - prev) / (length - prev);
					}
					break;
				}
				if (curve != prevCurve) {
					prevCurve = curve;
					var ii = curve * 6;
					x1 = world[ii];
					y1 = world[ii + 1];
					cx1 = world[ii + 2];
					cy1 = world[ii + 3];
					cx2 = world[ii + 4];
					cy2 = world[ii + 5];
					x2 = world[ii + 6];
					y2 = world[ii + 7];
					tmpx = (x1 - cx1 * 2 + cx2) * 0.03;
					tmpy = (y1 - cy1 * 2 + cy2) * 0.03;
					dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 0.006;
					dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 0.006;
					ddfx = tmpx * 2 + dddfx;
					ddfy = tmpy * 2 + dddfy;
					dfx = (cx1 - x1) * 0.3 + tmpx + dddfx * 0.16666667;
					dfy = (cy1 - y1) * 0.3 + tmpy + dddfy * 0.16666667;
					curveLength = Math.sqrt(dfx * dfx + dfy * dfy);
					segments[0] = curveLength;
					for (ii = 1; ii < 8; ii++) {
						dfx += ddfx;
						dfy += ddfy;
						ddfx += dddfx;
						ddfy += dddfy;
						curveLength += Math.sqrt(dfx * dfx + dfy * dfy);
						segments[ii] = curveLength;
					}
					dfx += ddfx;
					dfy += ddfy;
					curveLength += Math.sqrt(dfx * dfx + dfy * dfy);
					segments[8] = curveLength;
					dfx += ddfx + dddfx;
					dfy += ddfy + dddfy;
					curveLength += Math.sqrt(dfx * dfx + dfy * dfy);
					segments[9] = curveLength;
					segment = 0;
				}
				p *= curveLength;
				for (; ; segment++) {
					length = segments[segment];
					if (p > length)
						continue;
					if (segment == 0)
						p /= length;
					else {
						prev = segments[segment - 1];
						p = segment + (p - prev) / (length - prev);
					}
					break;
				}
				this.addCurvePosition(p * 0.1, x1, y1, cx1, cy1, cx2, cy2, x2, y2, out, o, tangents || (i > 0 && space == 0));
			}
			return out;
		}

		__proto.addBeforePosition = function (p, temp, i, out, o) {
			var x1 = temp[i], y1 = temp[i + 1], dx = temp[i + 2] - x1, dy = temp[i + 3] - y1, r = Math.atan2(dy, dx);
			out[o] = x1 + p * Math.cos(r);
			out[o + 1] = y1 + p * Math.sin(r);
			out[o + 2] = r;
		}

		__proto.addAfterPosition = function (p, temp, i, out, o) {
			var x1 = temp[i + 2], y1 = temp[i + 3], dx = x1 - temp[i], dy = y1 - temp[i + 1], r = Math.atan2(dy, dx);
			out[o] = x1 + p * Math.cos(r);
			out[o + 1] = y1 + p * Math.sin(r);
			out[o + 2] = r;
		}

		__proto.addCurvePosition = function (p, x1, y1, cx1, cy1, cx2, cy2, x2, y2, out, o, tangents) {
			if (p == 0)
				p = 0.0001;
			var tt = p * p, ttt = tt * p, u = 1 - p, uu = u * u, uuu = uu * u;
			var ut = u * p, ut3 = ut * 3, uut3 = u * ut3, utt3 = ut3 * p;
			var x = x1 * uuu + cx1 * uut3 + cx2 * utt3 + x2 * ttt, y = y1 * uuu + cy1 * uut3 + cy2 * utt3 + y2 * ttt;
			out[o] = x;
			out[o + 1] = y;
			if (tangents) {
				out[o + 2] = Math.atan2(y - (y1 * uu + cy1 * ut * 2 + cy2 * tt), x - (x1 * uu + cx1 * ut * 2 + cx2 * tt));
			}
			else {
				out[o + 2] = 0;
			}
		}

		PathConstraint.NONE = -1;
		PathConstraint.BEFORE = -2;
		PathConstraint.AFTER = -3;
		__static(PathConstraint,
			['_tempMt', function () { return this._tempMt = new Matrix(); }
			]);
		return PathConstraint;
	})()


	/**
	*@private
	*/
	//class laya.ani.bone.PathConstraintData
	var PathConstraintData = (function () {
		function PathConstraintData() {
			this.name = null;
			this.target = null;
			this.positionMode = null;
			this.spacingMode = null;
			this.rotateMode = null;
			this.offsetRotation = NaN;
			this.position = NaN;
			this.spacing = NaN;
			this.rotateMix = NaN;
			this.translateMix = NaN;
			this.bones = [];
		}

		__class(PathConstraintData, 'laya.ani.bone.PathConstraintData');
		return PathConstraintData;
	})()


	/**
	*@private
	*/
	//class laya.ani.bone.SkinData
	var SkinData = (function () {
		function SkinData() {
			this.name = null;
			this.slotArr = [];
		}

		__class(SkinData, 'laya.ani.bone.SkinData');
		return SkinData;
	})()


	/**
	*@private
	*/
	//class laya.ani.bone.SkinSlotDisplayData
	var SkinSlotDisplayData = (function () {
		function SkinSlotDisplayData() {
			this.name = null;
			this.attachmentName = null;
			this.type = 0;
			this.transform = null;
			this.width = NaN;
			this.height = NaN;
			this.texture = null;
			this.bones = null;
			this.uvs = null;
			this.weights = null;
			this.triangles = null;
			this.vertices = null;
			this.lengths = null;
			this.verLen = 0;
		}

		__class(SkinSlotDisplayData, 'laya.ani.bone.SkinSlotDisplayData');
		var __proto = SkinSlotDisplayData.prototype;
		__proto.createTexture = function (currTexture) {
			if (this.texture) return this.texture;
			this.texture = new Texture(currTexture.bitmap, this.uvs);
			if (this.uvs[0] > this.uvs[4]
				&& this.uvs[1] > this.uvs[5]) {
				this.texture.width = currTexture.height;
				this.texture.height = currTexture.width;
				this.texture.offsetX = -currTexture.offsetX;
				this.texture.offsetY = -currTexture.offsetY;
				this.texture.sourceWidth = currTexture.sourceHeight;
				this.texture.sourceHeight = currTexture.sourceWidth;
			} else {
				this.texture.width = currTexture.width;
				this.texture.height = currTexture.height;
				this.texture.offsetX = -currTexture.offsetX;
				this.texture.offsetY = -currTexture.offsetY;
				this.texture.sourceWidth = currTexture.sourceWidth;
				this.texture.sourceHeight = currTexture.sourceHeight;
			}
			if (!Render.isWebGL) {
				if (this.uvs[1] > this.uvs[5]) {
					this.texture.offsetY = this.texture.sourceHeight - this.texture.height - this.texture.offsetY;
				}
			}
			return this.texture;
		}

		__proto.destory = function () {
			if (this.texture) this.texture.destroy();
		}

		return SkinSlotDisplayData;
	})()


	/**
	*@private
	*/
	//class laya.ani.bone.SlotData
	var SlotData = (function () {
		function SlotData() {
			this.name = null;
			this.displayArr = [];
		}

		__class(SlotData, 'laya.ani.bone.SlotData');
		var __proto = SlotData.prototype;
		__proto.getDisplayByName = function (name) {
			var tDisplay;
			for (var i = 0, n = this.displayArr.length; i < n; i++) {
				tDisplay = this.displayArr[i];
				if (tDisplay.attachmentName == name) {
					return i;
				}
			}
			return -1;
		}

		return SlotData;
	})()


	/**
	*@private
	*/
	//class laya.ani.bone.TfConstraint
	var TfConstraint = (function () {
		function TfConstraint(data, bones) {
			this._data = null;
			this._bones = null;
			this.target = null;
			this.rotateMix = NaN;
			this.translateMix = NaN;
			this.scaleMix = NaN;
			this.shearMix = NaN;
			this._temp = __newvec(2, 0);
			this._data = data;
			if (this._bones == null) {
				this._bones = [];
			}
			this.target = bones[data.targetIndex];
			var j = 0, n = 0;
			for (j = 0, n = data.boneIndexs.length; j < n; j++) {
				this._bones.push(bones[data.boneIndexs[j]]);
			}
			this.rotateMix = data.rotateMix;
			this.translateMix = data.translateMix;
			this.scaleMix = data.scaleMix;
			this.shearMix = data.shearMix;
		}

		__class(TfConstraint, 'laya.ani.bone.TfConstraint');
		var __proto = TfConstraint.prototype;
		__proto.apply = function () {
			var tTfBone;
			var ta = this.target.resultMatrix.a, tb = this.target.resultMatrix.b, tc = this.target.resultMatrix.c, td = this.target.resultMatrix.d;
			for (var j = 0, n = this._bones.length; j < n; j++) {
				tTfBone = this._bones[j];
				if (this.rotateMix > 0) {
					var a = tTfBone.resultMatrix.a, b = tTfBone.resultMatrix.b, c = tTfBone.resultMatrix.c, d = tTfBone.resultMatrix.d;
					var r = Math.atan2(tc, ta) - Math.atan2(c, a) + this._data.offsetRotation * Math.PI / 180;
					if (r > Math.PI)
						r -= Math.PI * 2;
					else if (r < -Math.PI) r += Math.PI * 2;
					r *= this.rotateMix;
					var cos = Math.cos(r), sin = Math.sin(r);
					tTfBone.resultMatrix.a = cos * a - sin * c;
					tTfBone.resultMatrix.b = cos * b - sin * d;
					tTfBone.resultMatrix.c = sin * a + cos * c;
					tTfBone.resultMatrix.d = sin * b + cos * d;
				}
				if (this.translateMix) {
					this._temp[0] = this._data.offsetX;
					this._temp[1] = this._data.offsetY;
					this.target.localToWorld(this._temp);
					tTfBone.resultMatrix.tx += (this._temp[0] - tTfBone.resultMatrix.tx) * this.translateMix;
					tTfBone.resultMatrix.ty += (this._temp[1] - tTfBone.resultMatrix.ty) * this.translateMix;
					tTfBone.updateChild();
				}
				if (this.scaleMix > 0) {
					var bs = Math.sqrt(tTfBone.resultMatrix.a * tTfBone.resultMatrix.a + tTfBone.resultMatrix.c * tTfBone.resultMatrix.c);
					var ts = Math.sqrt(ta * ta + tc * tc);
					var s = bs > 0.00001 ? (bs + (ts - bs + this._data.offsetScaleX) * this.scaleMix) / bs : 0;
					tTfBone.resultMatrix.a *= s;
					tTfBone.resultMatrix.c *= s;
					bs = Math.sqrt(tTfBone.resultMatrix.b * tTfBone.resultMatrix.b + tTfBone.resultMatrix.d * tTfBone.resultMatrix.d);
					ts = Math.sqrt(tb * tb + td * td);
					s = bs > 0.00001 ? (bs + (ts - bs + this._data.offsetScaleY) * this.scaleMix) / bs : 0;
					tTfBone.resultMatrix.b *= s;
					tTfBone.resultMatrix.d *= s;
				}
				if (this.shearMix > 0) {
					b = tTfBone.resultMatrix.b, d = tTfBone.resultMatrix.d;
					var by = Math.atan2(d, b);
					r = Math.atan2(td, tb) - Math.atan2(tc, ta) - (by - Math.atan2(tTfBone.resultMatrix.c, tTfBone.resultMatrix.a));
					if (r > Math.PI)
						r -= Math.PI * 2;
					else if (r < -Math.PI) r += Math.PI * 2;
					r = by + (r + this._data.offsetShearY * Math.PI / 180) * this.shearMix;
					s = Math.sqrt(b * b + d * d);
					tTfBone.resultMatrix.b = Math.cos(r) * s;
					tTfBone.resultMatrix.d = Math.sin(r) * s;
				}
			}
		}

		return TfConstraint;
	})()


	/**
	*@private
	*/
	//class laya.ani.bone.TfConstraintData
	var TfConstraintData = (function () {
		function TfConstraintData() {
			this.name = null;
			this.targetIndex = 0;
			this.rotateMix = NaN;
			this.translateMix = NaN;
			this.scaleMix = NaN;
			this.shearMix = NaN;
			this.offsetRotation = NaN;
			this.offsetX = NaN;
			this.offsetY = NaN;
			this.offsetScaleX = NaN;
			this.offsetScaleY = NaN;
			this.offsetShearY = NaN;
			this.boneIndexs = [];
		}

		__class(TfConstraintData, 'laya.ani.bone.TfConstraintData');
		return TfConstraintData;
	})()


	/**
	*@private
	*/
	//class laya.ani.bone.Transform
	var Transform = (function () {
		function Transform() {
			this.skX = 0;
			this.skY = 0;
			this.scX = 1;
			this.scY = 1;
			this.x = 0;
			this.y = 0;
			this.skewX = 0;
			this.skewY = 0;
			this.mMatrix = null;
		}

		__class(Transform, 'laya.ani.bone.Transform');
		var __proto = Transform.prototype;
		__proto.initData = function (data) {
			if (data.x != undefined) {
				this.x = data.x;
			}
			if (data.y != undefined) {
				this.y = data.y;
			}
			if (data.skX != undefined) {
				this.skX = data.skX;
			}
			if (data.skY != undefined) {
				this.skY = data.skY;
			}
			if (data.scX != undefined) {
				this.scX = data.scX;
			}
			if (data.scY != undefined) {
				this.scY = data.scY;
			}
		}

		__proto.getMatrix = function () {
			var tMatrix;
			if (this.mMatrix) {
				tMatrix = this.mMatrix;
			} else {
				tMatrix = this.mMatrix = new Matrix();
			}
			tMatrix.identity();
			tMatrix.scale(this.scX, this.scY);
			if (this.skewX || this.skewY) {
				this.skew(tMatrix, this.skewX * Math.PI / 180, this.skewY * Math.PI / 180);
			}
			tMatrix.rotate(this.skX * Math.PI / 180);
			tMatrix.translate(this.x, this.y);
			return tMatrix;
		}

		__proto.skew = function (m, x, y) {
			var sinX = Math.sin(y);
			var cosX = Math.cos(y);
			var sinY = Math.sin(x);
			var cosY = Math.cos(x);
			m.setTo(m.a * cosY - m.b * sinX,
				m.a * sinY + m.b * cosX,
				m.c * cosY - m.d * sinX,
				m.c * sinY + m.d * cosX,
				m.tx * cosY - m.ty * sinX,
				m.tx * sinY + m.ty * cosX);
			return m;
		}

		return Transform;
	})()


	/**
	*用于UV转换的工具类
	*@private
	*/
	//class laya.ani.bone.UVTools
	var UVTools = (function () {
		function UVTools() { }
		__class(UVTools, 'laya.ani.bone.UVTools');
		UVTools.getRelativeUV = function (bigUV, smallUV, rst) {
			var startX = bigUV[0];
			var width = bigUV[2] - bigUV[0];
			var startY = bigUV[1];
			var height = bigUV[5] - bigUV[1];
			if (!rst) rst = [];
			rst.length = smallUV.length;
			var i = 0, len = 0;
			len = rst.length;
			var dWidth = 1 / width;
			var dHeight = 1 / height;
			for (i = 0; i < len; i += 2) {
				rst[i] = (smallUV[i] - startX) * dWidth;
				rst[i + 1] = (smallUV[i + 1] - startY) * dHeight;
			}
			return rst;
		}

		UVTools.getAbsoluteUV = function (bigUV, smallUV, rst) {
			if (bigUV[0] == 0 && bigUV[1] == 0 && bigUV[4] == 1 && bigUV[5] == 1) {
				if (rst) {
					Utils.copyArray(rst, smallUV);
					return rst;
				} else {
					return smallUV;
				}
			};
			var startX = bigUV[0];
			var width = bigUV[2] - bigUV[0];
			var startY = bigUV[1];
			var height = bigUV[5] - bigUV[1];
			if (!rst) rst = [];
			rst.length = smallUV.length;
			var i = 0, len = 0;
			len = rst.length;
			for (i = 0; i < len; i += 2) {
				rst[i] = smallUV[i] * width + startX;
				rst[i + 1] = smallUV[i + 1] * height + startY;
			}
			return rst;
		}

		return UVTools;
	})()


	/**
	*@private
	*@author ...
	*/
	//class laya.ani.KeyFramesContent
	var KeyFramesContent = (function () {
		function KeyFramesContent() {
			this.startTime = NaN;
			this.duration = NaN;
			this.interpolationData = null;
			//私有插值方式 [type0(插值类型),Data0(插值数据,可为空)，type1(插值类型),Data1(插值数据,可为空)] 注意：254全线性插值，255全不插值
			this.data = null;
			//=new Float32Array();
			this.nextData = null;
		}

		__class(KeyFramesContent, 'laya.ani.KeyFramesContent');
		return KeyFramesContent;
	})()


	/**
	*@private
	*...
	*@author ww
	*/
	//class laya.ani.math.BezierLerp
	var BezierLerp = (function () {
		function BezierLerp() { }
		__class(BezierLerp, 'laya.ani.math.BezierLerp');
		BezierLerp.getBezierRate = function (t, px0, py0, px1, py1) {
			var key = BezierLerp._getBezierParamKey(px0, py0, px1, py1);
			var vKey = key * 100 + t;
			if (BezierLerp._bezierResultCache[vKey]) return BezierLerp._bezierResultCache[vKey];
			var points = BezierLerp._getBezierPoints(px0, py0, px1, py1, key);
			var i = 0, len = 0;
			len = points.length;
			for (i = 0; i < len; i += 2) {
				if (t <= points[i]) {
					BezierLerp._bezierResultCache[vKey] = points[i + 1];
					return points[i + 1];
				}
			}
			BezierLerp._bezierResultCache[vKey] = 1;
			return 1;
		}

		BezierLerp._getBezierParamKey = function (px0, py0, px1, py1) {
			return (((px0 * 100 + py0) * 100 + px1) * 100 + py1) * 100;
		}

		BezierLerp._getBezierPoints = function (px0, py0, px1, py1, key) {
			if (BezierLerp._bezierPointsCache[key]) return BezierLerp._bezierPointsCache[key];
			var controlPoints;
			controlPoints = [0, 0, px0, py0, px1, py1, 1, 1];
			var bz;
			bz = new Bezier();
			var points;
			points = bz.getBezierPoints(controlPoints, 100, 3);
			BezierLerp._bezierPointsCache[key] = points;
			return points;
		}

		BezierLerp._bezierResultCache = {};
		BezierLerp._bezierPointsCache = {};
		return BezierLerp;
	})()


	/**
	*<code>AnimationPlayer</code> 类用于动画播放器。
	*/
	//class laya.ani.AnimationPlayer extends laya.events.EventDispatcher
	var AnimationPlayer = (function (_super) {
		function AnimationPlayer() {
			/**@private */
			this._destroyed = false;
			/**数据模板*/
			this._templet = null;
			/**当前精确时间，不包括重播时间*/
			this._currentTime = NaN;
			/**当前帧时间，不包括重播时间*/
			this._currentFrameTime = NaN;
			/**动画播放的起始时间位置*/
			this._playStart = NaN;
			/**动画播放的结束时间位置*/
			this._playEnd = NaN;
			/**动画播放一次的总时间*/
			this._playDuration = NaN;
			/**动画播放总时间*/
			this._overallDuration = NaN;
			/**是否在一帧结束时停止*/
			this._stopWhenCircleFinish = false;
			/**已播放时间，包括重播时间*/
			this._elapsedPlaybackTime = NaN;
			/**播放时帧数*/
			this._startUpdateLoopCount = NaN;
			/**当前动画索引*/
			this._currentAnimationClipIndex = 0;
			/**当前帧数*/
			this._currentKeyframeIndex = 0;
			/**是否暂停*/
			this._paused = false;
			/**默认帧率,必须大于0*/
			this._cacheFrameRate = 0;
			/**帧率间隔时间*/
			this._cacheFrameRateInterval = NaN;
			/**缓存播放速率*/
			this._cachePlayRate = NaN;
			this._fullFrames = null;
			/**是否缓存*/
			this.isCache = true;
			/**播放速率*/
			this.playbackRate = 1.0;
			/**停止时是否归零*/
			this.returnToZeroStopped = false;
			AnimationPlayer.__super.call(this);
			this._destroyed = false;
			this._currentAnimationClipIndex = -1;
			this._currentKeyframeIndex = -1;
			this._currentTime = 0.0;
			this._overallDuration = Number.MAX_VALUE;
			this._stopWhenCircleFinish = false;
			this._elapsedPlaybackTime = 0;
			this._startUpdateLoopCount = -1;
			this._cachePlayRate = 1.0;
			this.cacheFrameRate = 60;
			this.returnToZeroStopped = false;
		}

		__class(AnimationPlayer, 'laya.ani.AnimationPlayer', _super);
		var __proto = AnimationPlayer.prototype;
		Laya.imps(__proto, { "laya.resource.IDestroy": true })
		/**
		*@private
		*/
		__proto._onTempletLoadedComputeFullKeyframeIndices = function (cachePlayRate, cacheFrameRate, templet) {
			if (this._templet === templet && this._cachePlayRate === cachePlayRate && this._cacheFrameRate === cacheFrameRate)
				this._computeFullKeyframeIndices();
		}

		/**
		*@private
		*/
		__proto._computeFullKeyframeIndices = function () {
			var anifullFrames = this._fullFrames = [];
			var templet = this._templet;
			var cacheFrameInterval = this._cacheFrameRateInterval * this._cachePlayRate;
			for (var i = 0, iNum = templet.getAnimationCount(); i < iNum; i++) {
				var aniFullFrame = [];
				for (var j = 0, jNum = templet.getAnimation(i).nodes.length; j < jNum; j++) {
					var node = templet.getAnimation(i).nodes[j];
					var frameCount = Math.floor(node.playTime / cacheFrameInterval + 0.01);
					var nodeFullFrames = new Uint16Array(frameCount + 1);
					var lastFrameIndex = -1;
					for (var n = 0, nNum = node.keyFrame.length; n < nNum; n++) {
						var keyFrame = node.keyFrame[n];
						var tm = keyFrame.startTime;
						var endTm = tm + keyFrame.duration + cacheFrameInterval;
						do {
							var frameIndex = Math.floor(tm / cacheFrameInterval + 0.5);
							for (var k = lastFrameIndex + 1; k < frameIndex; k++)
								nodeFullFrames[k] = n;
							lastFrameIndex = frameIndex;
							nodeFullFrames[frameIndex] = n;
							tm += cacheFrameInterval;
						} while (tm <= endTm);
					}
					aniFullFrame.push(nodeFullFrames);
				}
				anifullFrames.push(aniFullFrame);
			}
		}

		/**
		*@private
		*/
		__proto._onAnimationTempletLoaded = function () {
			(this.destroyed) || (this._calculatePlayDuration());
		}

		/**
		*@private
		*/
		__proto._calculatePlayDuration = function () {
			if (this.state !==/*laya.ani.AnimationState.stopped*/0) {
				var oriDuration = this._templet.getAniDuration(this._currentAnimationClipIndex);
				(this._playEnd === 0) && (this._playEnd = oriDuration);
				if (this._playEnd > oriDuration)
					this._playEnd = oriDuration;
				this._playDuration = this._playEnd - this._playStart;
			}
		}

		/**
		*@private
		*/
		__proto._setPlayParams = function (time, cacheFrameInterval) {
			this._currentTime = time;
			this._currentKeyframeIndex = Math.max(Math.floor((this.currentPlayTime) / cacheFrameInterval + 0.01), 0);
			this._currentFrameTime = this._currentKeyframeIndex * cacheFrameInterval;
		}

		/**
		*@private
		*/
		__proto._setPlayParamsWhenStop = function (currentAniClipPlayDuration, cacheFrameInterval) {
			this._currentTime = currentAniClipPlayDuration;
			this._currentKeyframeIndex = Math.max(Math.floor(currentAniClipPlayDuration / cacheFrameInterval + 0.01), 0);
			this._currentFrameTime = this._currentKeyframeIndex * cacheFrameInterval;
			this._currentAnimationClipIndex = -1;
		}

		/**
		*@private
		*/
		__proto._update = function (elapsedTime) {
			if (this._currentAnimationClipIndex === -1 || this._paused || !this._templet || !this._templet.loaded)
				return;
			var cacheFrameInterval = this._cacheFrameRateInterval * this._cachePlayRate;
			var time = 0;
			(this._startUpdateLoopCount !== Stat.loopCount) && (time = elapsedTime * this.playbackRate, this._elapsedPlaybackTime += time);
			var currentAniClipPlayDuration = this.playDuration;
			if ((this._overallDuration !== 0 && this._elapsedPlaybackTime >= this._overallDuration) || (this._overallDuration === 0 && this._elapsedPlaybackTime >= currentAniClipPlayDuration)) {
				this._setPlayParamsWhenStop(currentAniClipPlayDuration, cacheFrameInterval);
				this.event(/*laya.events.Event.STOPPED*/"stopped");
				return;
			}
			time += this._currentTime;
			if (currentAniClipPlayDuration > 0) {
				if (time >= currentAniClipPlayDuration) {
					do {
						time -= currentAniClipPlayDuration;
						if (this._stopWhenCircleFinish) {
							this._setPlayParamsWhenStop(currentAniClipPlayDuration, cacheFrameInterval);
							this._stopWhenCircleFinish = false;
							this.event(/*laya.events.Event.STOPPED*/"stopped");
							return;
						}
						if (time < currentAniClipPlayDuration) {
							this._setPlayParams(time, cacheFrameInterval);
							this.event(/*laya.events.Event.COMPLETE*/"complete");
						}
					} while (time >= currentAniClipPlayDuration)
				} else {
					this._setPlayParams(time, cacheFrameInterval);
				}
			} else {
				if (this._stopWhenCircleFinish) {
					this._setPlayParamsWhenStop(currentAniClipPlayDuration, cacheFrameInterval);
					this._stopWhenCircleFinish = false;
					this.event(/*laya.events.Event.STOPPED*/"stopped");
					return;
				}
				this._currentTime = this._currentFrameTime = this._currentKeyframeIndex = 0;
				this.event(/*laya.events.Event.COMPLETE*/"complete");
			}
		}

		/**
		*@private
		*/
		__proto._destroy = function () {
			this.offAll();
			this._templet = null;
			this._fullFrames = null;
			this._destroyed = true;
		}

		/**
		*播放动画。
		*@param index 动画索引。
		*@param playbackRate 播放速率。
		*@param duration 播放时长（0为1次,Number.MAX_VALUE为循环播放）。
		*@param playStart 播放的起始时间位置。
		*@param playEnd 播放的结束时间位置。（0为动画一次循环的最长结束时间位置）。
		*/
		__proto.play = function (index, playbackRate, overallDuration, playStart, playEnd) {
			(index === void 0) && (index = 0);
			(playbackRate === void 0) && (playbackRate = 1.0);
			(overallDuration === void 0) && (overallDuration = 2147483647);
			(playStart === void 0) && (playStart = 0);
			(playEnd === void 0) && (playEnd = 0);
			if (!this._templet)
				throw new Error("AnimationPlayer:templet must not be null,maybe you need to set url.");
			if (overallDuration < 0 || playStart < 0 || playEnd < 0)
				throw new Error("AnimationPlayer:overallDuration,playStart and playEnd must large than zero.");
			if ((playEnd !== 0) && (playStart > playEnd))
				throw new Error("AnimationPlayer:start must less than end.");
			this._currentTime = 0;
			this._currentFrameTime = 0;
			this._elapsedPlaybackTime = 0;
			this.playbackRate = playbackRate;
			this._overallDuration = overallDuration;
			this._playStart = playStart;
			this._playEnd = playEnd;
			this._paused = false;
			this._currentAnimationClipIndex = index;
			this._currentKeyframeIndex = 0;
			this._startUpdateLoopCount = Stat.loopCount;
			this.event(/*laya.events.Event.PLAYED*/"played");
			if (this._templet.loaded)
				this._calculatePlayDuration();
			else
				this._templet.once(/*laya.events.Event.LOADED*/"loaded", this, this._onAnimationTempletLoaded);
			this._update(0);
		}

		/**
		*播放动画。
		*@param index 动画索引。
		*@param playbackRate 播放速率。
		*@param duration 播放时长（0为1次,Number.MAX_VALUE为循环播放）。
		*@param playStartFrame 播放的原始起始帧率位置。
		*@param playEndFrame 播放的原始结束帧率位置。（0为动画一次循环的最长结束时间位置）。
		*/
		__proto.playByFrame = function (index, playbackRate, overallDuration, playStartFrame, playEndFrame, fpsIn3DBuilder) {
			(index === void 0) && (index = 0);
			(playbackRate === void 0) && (playbackRate = 1.0);
			(overallDuration === void 0) && (overallDuration = 2147483647);
			(playStartFrame === void 0) && (playStartFrame = 0);
			(playEndFrame === void 0) && (playEndFrame = 0);
			(fpsIn3DBuilder === void 0) && (fpsIn3DBuilder = 30);
			var interval = 1000.0 / fpsIn3DBuilder;
			this.play(index, playbackRate, overallDuration, playStartFrame * interval, playEndFrame * interval);
		}

		/**
		*停止播放当前动画
		*@param immediate 是否立即停止
		*/
		__proto.stop = function (immediate) {
			(immediate === void 0) && (immediate = true);
			if (immediate) {
				this._currentTime = this._currentFrameTime = this._currentKeyframeIndex = 0;
				this._currentAnimationClipIndex = -1;
				this.event(/*laya.events.Event.STOPPED*/"stopped");
			} else {
				this._stopWhenCircleFinish = true;
			}
		}

		/**
		*动画播放的结束时间位置。
		*@return 结束时间位置。
		*/
		__getset(0, __proto, 'playEnd', function () {
			return this._playEnd;
		});

		/**
		*设置动画数据模板,注意：修改此值会有计算开销。
		*@param value 动画数据模板
		*/
		/**
		*获取动画数据模板
		*@param value 动画数据模板
		*/
		__getset(0, __proto, 'templet', function () {
			return this._templet;
		}, function (value) {
			if (!this.state ===/*laya.ani.AnimationState.stopped*/0)
				this.stop(true);
			if (this._templet !== value) {
				this._templet = value;
				if (value.loaded)
					this._computeFullKeyframeIndices();
				else
					value.once(/*laya.events.Event.LOADED*/"loaded", this, this._onTempletLoadedComputeFullKeyframeIndices, [this._cachePlayRate, this._cacheFrameRate]);
			}
		});

		/**
		*动画播放的起始时间位置。
		*@return 起始时间位置。
		*/
		__getset(0, __proto, 'playStart', function () {
			return this._playStart;
		});

		/**
		*获取动画播放一次的总时间
		*@return 动画播放一次的总时间
		*/
		__getset(0, __proto, 'playDuration', function () {
			return this._playDuration;
		});

		/**
		*获取当前播放状态
		*@return 当前播放状态
		*/
		__getset(0, __proto, 'state', function () {
			if (this._currentAnimationClipIndex === -1)
				return /*laya.ani.AnimationState.stopped*/0;
			if (this._paused)
				return /*laya.ani.AnimationState.paused*/1;
			return /*laya.ani.AnimationState.playing*/2;
		});

		/**
		*获取当前帧数
		*@return 当前帧数
		*/
		__getset(0, __proto, 'currentKeyframeIndex', function () {
			return this._currentKeyframeIndex;
		});

		/**
		*获取动画播放的总总时间
		*@return 动画播放的总时间
		*/
		__getset(0, __proto, 'overallDuration', function () {
			return this._overallDuration;
		});

		/**
		*获取当前帧时间，不包括重播时间
		*@return value 当前时间
		*/
		__getset(0, __proto, 'currentFrameTime', function () {
			return this._currentFrameTime;
		});

		/**
		*获取当前动画索引
		*@return value 当前动画索引
		*/
		__getset(0, __proto, 'currentAnimationClipIndex', function () {
			return this._currentAnimationClipIndex;
		});

		/**
		*获取当前精确时间，不包括重播时间
		*@return value 当前时间
		*/
		__getset(0, __proto, 'currentPlayTime', function () {
			return this._currentTime + this._playStart;
		});

		/**
		*设置缓存播放速率,默认值为1.0,注意：修改此值会有计算开销。*
		*@return value 缓存播放速率。
		*/
		/**
		*获取缓存播放速率。*
		*@return 缓存播放速率。
		*/
		__getset(0, __proto, 'cachePlayRate', function () {
			return this._cachePlayRate;
		}, function (value) {
			if (this._cachePlayRate !== value) {
				this._cachePlayRate = value;
				if (this._templet)
					if (this._templet.loaded)
						this._computeFullKeyframeIndices();
					else
						this._templet.once(/*laya.events.Event.LOADED*/"loaded", this, this._onTempletLoadedComputeFullKeyframeIndices, [value, this._cacheFrameRate]);
			}
		});

		/**
		*设置默认帧率,每秒60帧,注意：修改此值会有计算开销。*
		*@return value 缓存帧率
		*/
		/**
		*获取默认帧率*
		*@return value 默认帧率
		*/
		__getset(0, __proto, 'cacheFrameRate', function () {
			return this._cacheFrameRate;
		}, function (value) {
			if (this._cacheFrameRate !== value) {
				this._cacheFrameRate = value;
				this._cacheFrameRateInterval = 1000.0 / this._cacheFrameRate;
				if (this._templet)
					if (this._templet.loaded)
						this._computeFullKeyframeIndices();
					else
						this._templet.once(/*laya.events.Event.LOADED*/"loaded", this, this._onTempletLoadedComputeFullKeyframeIndices, [this._cachePlayRate, value]);
			}
		});

		/**
		*设置当前播放位置
		*@param value 当前时间
		*/
		__getset(0, __proto, 'currentTime', null, function (value) {
			if (this._currentAnimationClipIndex === -1 || !this._templet || !this._templet.loaded)
				return;
			if (value < this._playStart || value > this._playEnd)
				throw new Error("AnimationPlayer:value must large than playStartTime,small than playEndTime.");
			this._startUpdateLoopCount = Stat.loopCount;
			var cacheFrameInterval = this._cacheFrameRateInterval * this._cachePlayRate;
			this._currentTime = value;
			this._currentKeyframeIndex = Math.max(Math.floor(this.currentPlayTime / cacheFrameInterval), 0);
			this._currentFrameTime = this._currentKeyframeIndex * cacheFrameInterval;
		});

		/**
		*设置是否暂停
		*@param value 是否暂停
		*/
		/**
		*获取当前是否暂停
		*@return 是否暂停
		*/
		__getset(0, __proto, 'paused', function () {
			return this._paused;
		}, function (value) {
			this._paused = value;
			value && this.event(/*laya.events.Event.PAUSED*/"paused");
		});

		/**
		*获取缓存帧率间隔时间
		*@return 缓存帧率间隔时间
		*/
		__getset(0, __proto, 'cacheFrameRateInterval', function () {
			return this._cacheFrameRateInterval;
		});

		/**
		*获取是否已销毁。
		*@return 是否已销毁。
		*/
		__getset(0, __proto, 'destroyed', function () {
			return this._destroyed;
		});
		__getset(0, __proto, 'disposed', function () {
			return this._destroyed;
		});
		return AnimationPlayer;
	})(EventDispatcher)


	/**
	*@private
	*/
	//class laya.ani.GraphicsAni extends laya.display.Graphics
	var GraphicsAni = (function (_super) {
		function GraphicsAni() {
			GraphicsAni.__super.call(this);
			if (Render.isConchNode) {
				this["drawSkin"] = function (skin) {
					skin.transform || (skin.transform = Matrix.EMPTY);
					this.setSkinMesh && this.setSkinMesh(skin._ps, skin.mVBData, skin.mEleNum, 0, skin.mTexture, skin.transform);
				};
			}
		}

		__class(GraphicsAni, 'laya.ani.GraphicsAni', _super);
		var __proto = GraphicsAni.prototype;
		/**
		*@private
		*画自定义蒙皮动画
		*@param skin
		*/
		__proto.drawSkin = function (skin) {
			var arr = [skin];
			this._saveToCmd(Render._context._drawSkin, arr);
		}

		return GraphicsAni;
	})(Graphics)


	/**
	*@private
	*Canvas版本的SkinMesh
	*/
	//class laya.ani.bone.canvasmesh.SkinMeshCanvas extends laya.ani.bone.canvasmesh.CanvasMeshRender
	var SkinMeshCanvas = (function (_super) {
		function SkinMeshCanvas() {
			SkinMeshCanvas.__super.call(this);
			this.mesh = new MeshData();
		}

		__class(SkinMeshCanvas, 'laya.ani.bone.canvasmesh.SkinMeshCanvas', _super);
		var __proto = SkinMeshCanvas.prototype;
		__proto.init2 = function (texture, vs, ps, verticles, uvs) {
			if (this.transform) {
				this.transform = null;
			};
			var _ps;
			if (ps) {
				_ps = ps;
			} else {
				_ps = [];
				_ps.push(0, 1, 3, 3, 1, 2);
			}
			this.mesh.texture = texture;
			this.mesh.indexes = _ps;
			this.mesh.vertices = verticles;
			this.mesh.uvs = uvs;
		}

		__proto.render = function (context, x, y) {
			if (!this.mesh.texture) return;
			if (!this.transform) {
				this.transform = SkinMeshCanvas._tempMatrix;
				this.transform.identity();
				this.transform.translate(x, y);
				this.renderToContext(context);
				this.transform.translate(-x, -y);
				this.transform = null;
			} else {
				this.transform.translate(x, y);
				this.renderToContext(context);
				this.transform.translate(-x, -y);
			}
		}

		__static(SkinMeshCanvas,
			['_tempMatrix', function () { return this._tempMatrix = new Matrix(); }
			]);
		return SkinMeshCanvas;
	})(CanvasMeshRender)


	/**
	*<code>AnimationTemplet</code> 类用于动画模板资源。
	*/
	//class laya.ani.AnimationTemplet extends laya.resource.Resource
	var AnimationTemplet = (function (_super) {
		function AnimationTemplet() {
			/**@private */
			//this._aniVersion=null;
			/**@private */
			this._aniMap = {};
			/**@private */
			//this._publicExtData=null;
			/**@private */
			//this._useParent=false;
			/**@private */
			//this.unfixedCurrentFrameIndexes=null;
			/**@private */
			//this.unfixedCurrentTimes=null;
			/**@private */
			//this.unfixedKeyframes=null;
			/**@private */
			this.unfixedLastAniIndex = -1;
			/**@private */
			//this._aniClassName=null;
			/**@private */
			//this._animationDatasCache=null;
			AnimationTemplet.__super.call(this);
			this._anis = new Array;
		}

		__class(AnimationTemplet, 'laya.ani.AnimationTemplet', _super);
		var __proto = AnimationTemplet.prototype;
		/**
		*@private
		*/
		__proto.parse = function (data) {
			var reader = new Byte(data);
			this._aniVersion = reader.readUTFString();
			AnimationParser01.parse(this, reader);
		}

		/**
		*@private
		*/
		__proto._calculateKeyFrame = function (node, keyframeCount, keyframeDataCount) {
			var keyFrames = node.keyFrame;
			keyFrames[keyframeCount] = keyFrames[0];
			for (var i = 0; i < keyframeCount; i++) {
				var keyFrame = keyFrames[i];
				keyFrame.nextData = (keyFrame.duration === 0) ? keyFrame.data : keyFrames[i + 1].data;
			}
			keyFrames.length--;
		}

		/**
		*@inheritDoc
		*/
		__proto.onAsynLoaded = function (url, data, params) {
			var reader = new Byte(data);
			this._aniVersion = reader.readUTFString();
			switch (this._aniVersion) {
				case "LAYAANIMATION:02":
					AnimationParser02.parse(this, reader);
					break;
				default:
					AnimationParser01.parse(this, reader);
			}
			this._endLoaded();
		}

		/**
		*@inheritDoc
		*/
		__proto.disposeResource = function () {
			this._aniVersion = null;
			this._anis = null;
			this._aniMap = null;
			this._publicExtData = null;
			this.unfixedCurrentFrameIndexes = null;
			this.unfixedCurrentTimes = null;
			this.unfixedKeyframes = null;
			this._aniClassName = null;
			this._animationDatasCache = null;
		}

		__proto.getAnimationCount = function () {
			return this._anis.length;
		}

		__proto.getAnimation = function (aniIndex) {
			return this._anis[aniIndex];
		}

		__proto.getAniDuration = function (aniIndex) {
			return this._anis[aniIndex].playTime;
		}

		__proto.getNodes = function (aniIndex) {
			return this._anis[aniIndex].nodes;
		}

		__proto.getNodeIndexWithName = function (aniIndex, name) {
			return this._anis[aniIndex].bone3DMap[name];
		}

		__proto.getNodeCount = function (aniIndex) {
			return this._anis[aniIndex].nodes.length;
		}

		__proto.getTotalkeyframesLength = function (aniIndex) {
			return this._anis[aniIndex].totalKeyframeDatasLength;
		}

		__proto.getPublicExtData = function () {
			return this._publicExtData;
		}

		__proto.getAnimationDataWithCache = function (key, cacheDatas, aniIndex, frameIndex) {
			var aniDatas = cacheDatas[aniIndex];
			if (!aniDatas) {
				return null;
			} else {
				var keyDatas = aniDatas[key];
				if (!keyDatas)
					return null;
				else {
					return keyDatas[frameIndex];
				}
			}
		}

		__proto.setAnimationDataWithCache = function (key, cacheDatas, aniIndex, frameIndex, data) {
			var aniDatas = (cacheDatas[aniIndex]) || (cacheDatas[aniIndex] = {});
			var aniDatasCache = (aniDatas[key]) || (aniDatas[key] = []);
			aniDatasCache[frameIndex] = data;
		}

		__proto.getOriginalData = function (aniIndex, originalData, nodesFrameIndices, frameIndex, playCurTime) {
			var oneAni = this._anis[aniIndex];
			var nodes = oneAni.nodes;
			var j = 0;
			for (var i = 0, n = nodes.length, outOfs = 0; i < n; i++) {
				var node = nodes[i];
				var key;
				key = node.keyFrame[nodesFrameIndices[i][frameIndex]];
				node.dataOffset = outOfs;
				var dt = playCurTime - key.startTime;
				var lerpType = node.lerpType;
				if (lerpType) {
					switch (lerpType) {
						case 0:
						case 1:
							for (j = 0; j < node.keyframeWidth;)
								j += node.interpolationMethod[j](node, j, originalData, outOfs + j, key.data, dt, null, key.duration, key.nextData);
							break;
						case 2: ;
							var interpolationData = key.interpolationData;
							var interDataLen = interpolationData.length;
							var dataIndex = 0;
							for (j = 0; j < interDataLen;) {
								var type = interpolationData[j];
								switch (type) {
									case 6:
										j += AnimationTemplet.interpolation[type](node, dataIndex, originalData, outOfs + dataIndex, key.data, dt, null, key.duration, key.nextData, interpolationData, j + 1);
										break;
									case 7:
										j += AnimationTemplet.interpolation[type](node, dataIndex, originalData, outOfs + dataIndex, key.data, dt, null, key.duration, key.nextData, interpolationData, j + 1);
										break;
									default:
										j += AnimationTemplet.interpolation[type](node, dataIndex, originalData, outOfs + dataIndex, key.data, dt, null, key.duration, key.nextData);
								}
								dataIndex++;
							}
							break;
					}
				} else {
					for (j = 0; j < node.keyframeWidth;)
						j += node.interpolationMethod[j](node, j, originalData, outOfs + j, key.data, dt, null, key.duration, key.nextData);
				}
				outOfs += node.keyframeWidth;
			}
		}

		__proto.getNodesCurrentFrameIndex = function (aniIndex, playCurTime) {
			var ani = this._anis[aniIndex];
			var nodes = ani.nodes;
			if (aniIndex !== this.unfixedLastAniIndex) {
				this.unfixedCurrentFrameIndexes = new Uint32Array(nodes.length);
				this.unfixedCurrentTimes = new Float32Array(nodes.length);
				this.unfixedLastAniIndex = aniIndex;
			}
			for (var i = 0, n = nodes.length, outOfs = 0; i < n; i++) {
				var node = nodes[i];
				if (playCurTime < this.unfixedCurrentTimes[i])
					this.unfixedCurrentFrameIndexes[i] = 0;
				this.unfixedCurrentTimes[i] = playCurTime;
				while ((this.unfixedCurrentFrameIndexes[i] < node.keyFrame.length)) {
					if (node.keyFrame[this.unfixedCurrentFrameIndexes[i]].startTime > this.unfixedCurrentTimes[i])
						break;
					this.unfixedCurrentFrameIndexes[i]++;
				}
				this.unfixedCurrentFrameIndexes[i]--;
			}
			return this.unfixedCurrentFrameIndexes;
		}

		__proto.getOriginalDataUnfixedRate = function (aniIndex, originalData, playCurTime) {
			var oneAni = this._anis[aniIndex];
			var nodes = oneAni.nodes;
			if (aniIndex !== this.unfixedLastAniIndex) {
				this.unfixedCurrentFrameIndexes = new Uint32Array(nodes.length);
				this.unfixedCurrentTimes = new Float32Array(nodes.length);
				this.unfixedKeyframes = __newvec(nodes.length);
				this.unfixedLastAniIndex = aniIndex;
			};
			var j = 0;
			for (var i = 0, n = nodes.length, outOfs = 0; i < n; i++) {
				var node = nodes[i];
				if (playCurTime < this.unfixedCurrentTimes[i])
					this.unfixedCurrentFrameIndexes[i] = 0;
				this.unfixedCurrentTimes[i] = playCurTime;
				while (this.unfixedCurrentFrameIndexes[i] < node.keyFrame.length) {
					if (node.keyFrame[this.unfixedCurrentFrameIndexes[i]].startTime > this.unfixedCurrentTimes[i])
						break;
					this.unfixedKeyframes[i] = node.keyFrame[this.unfixedCurrentFrameIndexes[i]];
					this.unfixedCurrentFrameIndexes[i]++;
				};
				var key = this.unfixedKeyframes[i];
				node.dataOffset = outOfs;
				var dt = playCurTime - key.startTime;
				var lerpType = node.lerpType;
				if (lerpType) {
					switch (node.lerpType) {
						case 0:
						case 1:
							for (j = 0; j < node.keyframeWidth;)
								j += node.interpolationMethod[j](node, j, originalData, outOfs + j, key.data, dt, null, key.duration, key.nextData);
							break;
						case 2: ;
							var interpolationData = key.interpolationData;
							var interDataLen = interpolationData.length;
							var dataIndex = 0;
							for (j = 0; j < interDataLen;) {
								var type = interpolationData[j];
								switch (type) {
									case 6:
										j += AnimationTemplet.interpolation[type](node, dataIndex, originalData, outOfs + dataIndex, key.data, dt, null, key.duration, key.nextData, interpolationData, j + 1);
										break;
									case 7:
										j += AnimationTemplet.interpolation[type](node, dataIndex, originalData, outOfs + dataIndex, key.data, dt, null, key.duration, key.nextData, interpolationData, j + 1);
										break;
									default:
										j += AnimationTemplet.interpolation[type](node, dataIndex, originalData, outOfs + dataIndex, key.data, dt, null, key.duration, key.nextData);
								}
								dataIndex++;
							}
							break;
					}
				} else {
					for (j = 0; j < node.keyframeWidth;)
						j += node.interpolationMethod[j](node, j, originalData, outOfs + j, key.data, dt, null, key.duration, key.nextData);
				}
				outOfs += node.keyframeWidth;
			}
		}

		AnimationTemplet._LinearInterpolation_0 = function (bone, index, out, outOfs, data, dt, dData, duration, nextData, interData) {
			var amount = duration === 0 ? 0 : dt / duration;
			out[outOfs] = (1.0 - amount) * data[index] + amount * nextData[index];
			return 1;
		}

		AnimationTemplet._QuaternionInterpolation_1 = function (bone, index, out, outOfs, data, dt, dData, duration, nextData, interData) {
			var amount = duration === 0 ? 0 : dt / duration;
			MathUtil.slerpQuaternionArray(data, index, nextData, index, amount, out, outOfs);
			return 4;
		}

		AnimationTemplet._AngleInterpolation_2 = function (bone, index, out, outOfs, data, dt, dData, duration, nextData, interData) {
			return 0;
		}

		AnimationTemplet._RadiansInterpolation_3 = function (bone, index, out, outOfs, data, dt, dData, duration, nextData, interData) {
			return 0;
		}

		AnimationTemplet._Matrix4x4Interpolation_4 = function (bone, index, out, outOfs, data, dt, dData, duration, nextData, interData) {
			for (var i = 0; i < 16; i++ , index++)
				out[outOfs + i] = data[index] + dt * dData[index];
			return 16;
		}

		AnimationTemplet._NoInterpolation_5 = function (bone, index, out, outOfs, data, dt, dData, duration, nextData, interData) {
			out[outOfs] = data[index];
			return 1;
		}

		AnimationTemplet._BezierInterpolation_6 = function (bone, index, out, outOfs, data, dt, dData, duration, nextData, interData, offset) {
			(offset === void 0) && (offset = 0);
			out[outOfs] = data[index] + (nextData[index] - data[index]) * BezierLerp.getBezierRate(dt / duration, interData[offset], interData[offset + 1], interData[offset + 2], interData[offset + 3]);
			return 5;
		}

		AnimationTemplet._BezierInterpolation_7 = function (bone, index, out, outOfs, data, dt, dData, duration, nextData, interData, offset) {
			(offset === void 0) && (offset = 0);
			out[outOfs] = interData[offset + 4] + interData[offset + 5] * BezierLerp.getBezierRate((dt * 0.001 + interData[offset + 6]) / interData[offset + 7], interData[offset], interData[offset + 1], interData[offset + 2], interData[offset + 3]);
			return 9;
		}

		AnimationTemplet.load = function (url) {
			return Laya.loader.create(url, null, null, AnimationTemplet);
		}

		AnimationTemplet.interpolation = [AnimationTemplet._LinearInterpolation_0, AnimationTemplet._QuaternionInterpolation_1, AnimationTemplet._AngleInterpolation_2, AnimationTemplet._RadiansInterpolation_3, AnimationTemplet._Matrix4x4Interpolation_4, AnimationTemplet._NoInterpolation_5, AnimationTemplet._BezierInterpolation_6, AnimationTemplet._BezierInterpolation_7];
		return AnimationTemplet;
	})(Resource)


	/**
	*@private
	*将mesh元素缓存到canvas中并进行绘制
	*/
	//class laya.ani.bone.canvasmesh.CacheAbleSkinMesh extends laya.ani.bone.canvasmesh.SkinMeshCanvas
	var CacheAbleSkinMesh = (function (_super) {
		function CacheAbleSkinMesh() {
			this.isCached = false;
			this.canvas = null;
			this.tex = null;
			this.rec = null;
			CacheAbleSkinMesh.__super.call(this);
		}

		__class(CacheAbleSkinMesh, 'laya.ani.bone.canvasmesh.CacheAbleSkinMesh', _super);
		var __proto = CacheAbleSkinMesh.prototype;
		__proto.getCanvasPic = function () {
			var canvas = new HTMLCanvas("2D");
			var ctx = canvas.getContext('2d');
			this.rec = this.mesh.getBounds();
			canvas.size(this.rec.width, this.rec.height);
			var preTransform;
			preTransform = this.transform;
			this.transform = CacheAbleSkinMesh.tempMt;
			this.transform.identity();
			this.transform.translate(-this.rec.x, -this.rec.y);
			this.renderToContext(ctx);
			this.transform.translate(+this.rec.x, +this.rec.y);
			this.transform = preTransform;
			return new Texture(canvas);
		}

		__proto.render = function (context, x, y) {
			if (!this.mesh.texture) return;
			if (!this.isCached) {
				this.isCached = true;
				this.tex = this.getCanvasPic();
			}
			if (!this.transform) {
				this.transform = SkinMeshCanvas._tempMatrix;
				this.transform.identity();
				this.transform.translate(x, y);
				this._renderTextureToContext(context);
				this.transform.translate(-x, -y);
				this.transform = null;
			} else {
				this.transform.translate(x, y);
				this._renderTextureToContext(context);
				this.transform.translate(-x, -y);
			}
		}

		__proto._renderTextureToContext = function (context) {
			this.context = context.ctx || context;
			context.save();
			var texture;
			texture = this.tex;
			if (this.transform) {
				var mt = this.transform;
				context.transform(mt.a, mt.b, mt.c, mt.d, mt.tx, mt.ty);
			}
			this.rec = this.mesh.getBounds();
			context.translate(this.rec.x, this.rec.y);
			context.drawTexture(texture, 0, 0, texture.width, texture.height, 0, 0);
			context.restore();
		}

		__static(CacheAbleSkinMesh,
			['tempMt', function () { return this.tempMt = new Matrix(); }
			]);
		return CacheAbleSkinMesh;
	})(SkinMeshCanvas)


	/**
	*@private
	*简化mesh绘制，多顶点mesh改为四顶点mesh，只绘制矩形不绘制三角形
	*/
	//class laya.ani.bone.canvasmesh.SimpleSkinMeshCanvas extends laya.ani.bone.canvasmesh.SkinMeshCanvas
	var SimpleSkinMeshCanvas = (function (_super) {
		function SimpleSkinMeshCanvas() {
			/**
			*当前mesh数据是否可用
			*/
			this.cacheOK = false;
			/**
			*当前渲染数据是否可用
			*/
			this.cacheCmdOK = false;
			/**
			*transform参数缓存
			*/
			this.transformCmds = [];
			/**
			*drawImage参数缓存
			*/
			this.drawCmds = []
			SimpleSkinMeshCanvas.__super.call(this);
			this.tempMesh = new MeshData();
		}

		__class(SimpleSkinMeshCanvas, 'laya.ani.bone.canvasmesh.SimpleSkinMeshCanvas', _super);
		var __proto = SimpleSkinMeshCanvas.prototype;
		__proto.init2 = function (texture, vs, ps, verticles, uvs) {
			_super.prototype.init2.call(this, texture, vs, ps, verticles, uvs);
			this.cacheOK = false;
			this.cacheCmdOK = false;
			this.transformCmds.length = 6;
			this.drawCmds.length = 9;
		}

		__proto.renderToContext = function (context) {
			this.context = context.ctx || context;
			if (this.mesh) {
				if (this.mesh.uvs.length <= 8) {
					if (this.mode == 0) {
						this._renderWithIndexes(this.mesh);
					}
					else {
						this._renderNoIndexes(this.mesh);
					}
					return;
				}
				if (!this.cacheOK) {
					this.tempMesh.texture = this.mesh.texture;
					this.tempMesh.uvs = this.mesh.texture.uv;
					this.tempMesh.vertices = MeshTools.solveMesh(this.mesh, this.tempMesh.vertices);
					this.cacheOK = true;
				}
				if (this.mode == 0) {
					this._renderWithIndexes(this.tempMesh);
				}
				else {
					this._renderNoIndexes(this.tempMesh);
				}
			}
		}

		__proto._renderWithIndexes = function (mesh) {
			if (this.cacheCmdOK) {
				this.renderByCache(mesh);
				return;
			};
			var indexes = mesh.indexes;
			var i = 0, len = indexes.length;
			if (len > 1)
				len = 1;
			for (i = 0; i < len; i += 3) {
				var index0 = indexes[i] * 2;
				var index1 = indexes[i + 1] * 2;
				var index2 = indexes[i + 2] * 2;
				this._renderDrawTriangle(mesh, index0, index1, index2);
			}
			this.cacheCmdOK = true;
		}

		__proto._renderDrawTriangle = function (mesh, index0, index1, index2) {
			var context = this.context;
			var uvs = mesh.uvs;
			var vertices = mesh.vertices;
			var texture = mesh.texture;
			var source = texture.bitmap;
			var textureSource = source.source;
			var textureWidth = texture.width;
			var textureHeight = texture.height;
			var sourceWidth = source.width;
			var sourceHeight = source.height;
			var u0 = NaN;
			var u1 = NaN;
			var u2 = NaN;
			var v0 = NaN;
			var v1 = NaN;
			var v2 = NaN;
			if (mesh.useUvTransform) {
				var ut = mesh.uvTransform;
				u0 = ((uvs[index0] * ut.a) + (uvs[index0 + 1] * ut.c) + ut.tx) * sourceWidth;
				u1 = ((uvs[index1] * ut.a) + (uvs[index1 + 1] * ut.c) + ut.tx) * sourceWidth;
				u2 = ((uvs[index2] * ut.a) + (uvs[index2 + 1] * ut.c) + ut.tx) * sourceWidth;
				v0 = ((uvs[index0] * ut.b) + (uvs[index0 + 1] * ut.d) + ut.ty) * sourceHeight;
				v1 = ((uvs[index1] * ut.b) + (uvs[index1 + 1] * ut.d) + ut.ty) * sourceHeight;
				v2 = ((uvs[index2] * ut.b) + (uvs[index2 + 1] * ut.d) + ut.ty) * sourceHeight;
			}
			else {
				u0 = uvs[index0] * sourceWidth;
				u1 = uvs[index1] * sourceWidth;
				u2 = uvs[index2] * sourceWidth;
				v0 = uvs[index0 + 1] * sourceHeight;
				v1 = uvs[index1 + 1] * sourceHeight;
				v2 = uvs[index2 + 1] * sourceHeight;
			};
			var x0 = vertices[index0];
			var x1 = vertices[index1];
			var x2 = vertices[index2];
			var y0 = vertices[index0 + 1];
			var y1 = vertices[index1 + 1];
			var y2 = vertices[index2 + 1];
			var delta = (u0 * v1) + (v0 * u2) + (u1 * v2) - (v1 * u2) - (v0 * u1) - (u0 * v2);
			var dDelta = 1 / delta;
			var deltaA = (x0 * v1) + (v0 * x2) + (x1 * v2) - (v1 * x2) - (v0 * x1) - (x0 * v2);
			var deltaB = (u0 * x1) + (x0 * u2) + (u1 * x2) - (x1 * u2) - (x0 * u1) - (u0 * x2);
			var deltaC = (u0 * v1 * x2) + (v0 * x1 * u2) + (x0 * u1 * v2) - (x0 * v1 * u2) - (v0 * u1 * x2) - (u0 * x1 * v2);
			var deltaD = (y0 * v1) + (v0 * y2) + (y1 * v2) - (v1 * y2) - (v0 * y1) - (y0 * v2);
			var deltaE = (u0 * y1) + (y0 * u2) + (u1 * y2) - (y1 * u2) - (y0 * u1) - (u0 * y2);
			var deltaF = (u0 * v1 * y2) + (v0 * y1 * u2) + (y0 * u1 * v2) - (y0 * v1 * u2) - (v0 * u1 * y2) - (u0 * y1 * v2);
			this.transformCmds[0] = deltaA * dDelta;
			this.transformCmds[1] = deltaD * dDelta;
			this.transformCmds[2] = deltaB * dDelta;
			this.transformCmds[3] = deltaE * dDelta;
			this.transformCmds[4] = deltaC * dDelta;
			this.transformCmds[5] = deltaF * dDelta;
			this.drawCmds[0] = textureSource;
			this.drawCmds[1] = texture.uv[0] * sourceWidth;
			this.drawCmds[2] = texture.uv[1] * sourceHeight;
			this.drawCmds[3] = textureWidth;
			this.drawCmds[4] = textureHeight;
			this.drawCmds[5] = texture.uv[0] * sourceWidth;
			this.drawCmds[6] = texture.uv[1] * sourceHeight;
			this.drawCmds[7] = textureWidth;
			this.drawCmds[8] = textureHeight;
			context.save();
			if (this.transform) {
				var mt = this.transform;
				context.transform(mt.a, mt.b, mt.c, mt.d, mt.tx, mt.ty);
			}
			context.transform.apply(context, this.transformCmds);
			context.drawImage.apply(context, this.drawCmds);
			context.restore();
		}

		/**
		*绘制缓存的命令
		*@param mesh
		*
		*/
		__proto.renderByCache = function (mesh) {
			var context = this.context;
			context.save();
			if (this.transform) {
				var mt = this.transform;
				context.transform(mt.a, mt.b, mt.c, mt.d, mt.tx, mt.ty);
			}
			context.transform.apply(context, this.transformCmds);
			context.drawImage.apply(context, this.drawCmds);
			context.restore();
		}

		return SimpleSkinMeshCanvas;
	})(SkinMeshCanvas)


	/**
	*骨骼动画由<code>Templet</code>，<code>AnimationPlayer</code>，<code>Skeleton</code>三部分组成。
	*/
	//class laya.ani.bone.Skeleton extends laya.display.Sprite
	var Skeleton = (function (_super) {
		function Skeleton(templet, aniMode) {
			this._templet = null;
			/**@private */
			this._player = null;
			/**@private */
			this._curOriginalData = null;
			//当前骨骼的偏移数据
			this._boneMatrixArray = [];
			//当前骨骼动画的最终结果数据
			this._lastTime = 0;
			//上次的帧时间
			this._currAniName = null;
			this._currAniIndex = -1;
			this._pause = true;
			/**@private */
			this._aniClipIndex = -1;
			/**@private */
			this._clipIndex = -1;
			this._skinIndex = 0;
			this._skinName = "default";
			this._aniMode = 0;
			//当前动画自己的缓冲区
			this._graphicsCache = null;
			this._boneSlotDic = null;
			this._bindBoneBoneSlotDic = null;
			this._boneSlotArray = null;
			this._index = -1;
			this._total = -1;
			this._indexControl = false;
			//加载路径
			this._aniPath = null;
			this._texturePath = null;
			this._complete = null;
			this._loadAniMode = 0;
			this._yReverseMatrix = null;
			this._ikArr = null;
			this._tfArr = null;
			this._pathDic = null;
			this._rootBone = null;
			/**@private */
			this._boneList = null;
			/**@private */
			this._aniSectionDic = null;
			this._eventIndex = 0;
			this._drawOrderIndex = 0;
			this._drawOrder = null;
			this._lastAniClipIndex = -1;
			this._lastUpdateAniClipIndex = -1;
			Skeleton.__super.call(this);
			(aniMode === void 0) && (aniMode = 0);
			if (templet) this.init(templet, aniMode);
		}

		__class(Skeleton, 'laya.ani.bone.Skeleton', _super);
		var __proto = Skeleton.prototype;
		/**
		*初始化动画
		*@param templet 模板
		*@param aniMode 动画模式
		*<table>
		*<tr><th>模式</th><th>描述</th></tr>
		*<tr>
		*<td>0</td> <td>使用模板缓冲的数据，模板缓冲的数据，不允许修改（内存开销小，计算开销小，不支持换装）</td>
		*</tr>
		*<tr>
		*<td>1</td> <td>使用动画自己的缓冲区，每个动画都会有自己的缓冲区，相当耗费内存 （内存开销大，计算开销小，支持换装）</td>
		*</tr>
		*<tr>
		*<td>2</td> <td>使用动态方式，去实时去画（内存开销小，计算开销大，支持换装,不建议使用）</td>
		*</tr>
		*</table>
		*/
		__proto.init = function (templet, aniMode) {
			(aniMode === void 0) && (aniMode = 0);
			var i = 0, n = 0;
			if (aniMode == 1) {
				this._graphicsCache = [];
				for (i = 0, n = templet.getAnimationCount(); i < n; i++) {
					this._graphicsCache.push([]);
				}
			}
			this._yReverseMatrix = templet.yReverseMatrix;
			this._aniMode = aniMode;
			this._templet = templet;
			this._player = new AnimationPlayer();
			this._player.cacheFrameRate = templet.rate;
			this._player.templet = templet;
			this._player.play();
			this._parseSrcBoneMatrix();
			this._boneList = templet.mBoneArr;
			this._rootBone = templet.mRootBone;
			this._aniSectionDic = templet.aniSectionDic;
			if (templet.ikArr.length > 0) {
				this._ikArr = [];
				for (i = 0, n = templet.ikArr.length; i < n; i++) {
					this._ikArr.push(new IkConstraint(templet.ikArr[i], this._boneList));
				}
			}
			if (templet.pathArr.length > 0) {
				var tPathData;
				var tPathConstraint;
				if (this._pathDic == null) this._pathDic = {};
				var tBoneSlot;
				for (i = 0, n = templet.pathArr.length; i < n; i++) {
					tPathData = templet.pathArr[i];
					tPathConstraint = new PathConstraint(tPathData, this._boneList);
					tBoneSlot = this._boneSlotDic[tPathData.name];
					if (tBoneSlot) {
						tPathConstraint = new PathConstraint(tPathData, this._boneList);
						tPathConstraint.target = tBoneSlot;
					}
					this._pathDic[tPathData.name] = tPathConstraint;
				}
			}
			if (templet.tfArr.length > 0) {
				this._tfArr = [];
				for (i = 0, n = templet.tfArr.length; i < n; i++) {
					this._tfArr.push(new TfConstraint(templet.tfArr[i], this._boneList));
				}
			}
			if (templet.skinDataArray.length > 0) {
				var tSkinData = this._templet.skinDataArray[this._skinIndex];
				this._skinName = tSkinData.name;
			}
			this._player.on(/*laya.events.Event.PLAYED*/"played", this, this._onPlay);
			this._player.on(/*laya.events.Event.STOPPED*/"stopped", this, this._onStop);
			this._player.on(/*laya.events.Event.PAUSED*/"paused", this, this._onPause);
		}

		/**
		*通过加载直接创建动画
		*@param path 要加载的动画文件路径
		*@param complete 加载完成的回调函数
		*@param aniMode 与<code>Skeleton.init</code>的<code>aniMode</code>作用一致
		*/
		__proto.load = function (path, complete, aniMode) {
			(aniMode === void 0) && (aniMode = 0);
			this._aniPath = path;
			this._complete = complete;
			this._loadAniMode = aniMode;
			Laya.loader.load([{ url: path, type:/*laya.net.Loader.BUFFER*/"arraybuffer" }], Handler.create(this, this._onLoaded));
		}

		/**
		*加载完成
		*/
		__proto._onLoaded = function () {
			var arraybuffer = Loader.getRes(this._aniPath);
			if (arraybuffer == null) return;
			if (Templet.TEMPLET_DICTIONARY == null) {
				Templet.TEMPLET_DICTIONARY = {};
			};
			var tFactory;
			tFactory = Templet.TEMPLET_DICTIONARY[this._aniPath];
			if (tFactory) {
				if (tFactory.isParseFail) {
					this._parseFail();
				} else {
					if (tFactory.isParserComplete) {
						this._parseComplete();
					} else {
						tFactory.on(/*laya.events.Event.COMPLETE*/"complete", this, this._parseComplete);
						tFactory.on(/*laya.events.Event.ERROR*/"error", this, this._parseFail);
					}
				}
			} else {
				tFactory = new Templet();
				tFactory._setUrl(this._aniPath);
				Templet.TEMPLET_DICTIONARY[this._aniPath] = tFactory;
				tFactory.on(/*laya.events.Event.COMPLETE*/"complete", this, this._parseComplete);
				tFactory.on(/*laya.events.Event.ERROR*/"error", this, this._parseFail);
				tFactory.isParserComplete = false;
				tFactory.parseData(null, arraybuffer);
			}
		}

		/**
		*解析完成
		*/
		__proto._parseComplete = function () {
			var tTemple = Templet.TEMPLET_DICTIONARY[this._aniPath];
			if (tTemple) {
				this.init(tTemple, this._loadAniMode);
				this.play(0, true);
			}
			this._complete && this._complete.runWith(this);
		}

		/**
		*解析失败
		*/
		__proto._parseFail = function () {
			console.log("[Error]:" + this._aniPath + "解析失败");
		}

		/**
		*传递PLAY事件
		*/
		__proto._onPlay = function () {
			this.event(/*laya.events.Event.PLAYED*/"played");
		}

		/**
		*传递STOP事件
		*/
		__proto._onStop = function () {
			var tEventData;
			var tEventAniArr = this._templet.eventAniArr;
			var tEventArr = tEventAniArr[this._aniClipIndex];
			if (tEventArr && this._eventIndex < tEventArr.length) {
				for (; this._eventIndex < tEventArr.length; this._eventIndex++) {
					tEventData = tEventArr[this._eventIndex];
					if (tEventData.time >= this._player.playStart && tEventData.time <= this._player.playEnd) {
						this.event(/*laya.events.Event.LABEL*/"label", tEventData);
					}
				}
			}
			this._eventIndex = 0;
			this._drawOrder = null;
			this.event(/*laya.events.Event.STOPPED*/"stopped");
		}

		/**
		*传递PAUSE事件
		*/
		__proto._onPause = function () {
			this.event(/*laya.events.Event.PAUSED*/"paused");
		}

		/**
		*创建骨骼的矩阵，保存每次计算的最终结果
		*/
		__proto._parseSrcBoneMatrix = function () {
			var i = 0, n = 0;
			n = this._templet.srcBoneMatrixArr.length;
			for (i = 0; i < n; i++) {
				this._boneMatrixArray.push(new Matrix());
			}
			if (this._aniMode == 0) {
				this._boneSlotDic = this._templet.boneSlotDic;
				this._bindBoneBoneSlotDic = this._templet.bindBoneBoneSlotDic;
				this._boneSlotArray = this._templet.boneSlotArray;
			} else {
				if (this._boneSlotDic == null) this._boneSlotDic = {};
				if (this._bindBoneBoneSlotDic == null) this._bindBoneBoneSlotDic = {};
				if (this._boneSlotArray == null) this._boneSlotArray = [];
				var tArr = this._templet.boneSlotArray;
				var tBS;
				var tBSArr;
				for (i = 0, n = tArr.length; i < n; i++) {
					tBS = tArr[i];
					tBSArr = this._bindBoneBoneSlotDic[tBS.parent];
					if (tBSArr == null) {
						this._bindBoneBoneSlotDic[tBS.parent] = tBSArr = [];
					}
					this._boneSlotDic[tBS.name] = tBS = tBS.copy();
					tBSArr.push(tBS);
					this._boneSlotArray.push(tBS);
				}
			}
		}

		__proto._emitMissedEvents = function (startTime, endTime, startIndex) {
			(startIndex === void 0) && (startIndex = 0);
			var tEventAniArr = this._templet.eventAniArr;
			var tEventArr = tEventAniArr[this._player.currentAnimationClipIndex];
			if (tEventArr) {
				var i = 0, len = 0;
				var tEventData;
				len = tEventArr.length;
				for (i = startIndex; i < len; i++) {
					tEventData = tEventArr[i];
					if (tEventData.time >= this._player.playStart && tEventData.time <= this._player.playEnd) {
						this.event(/*laya.events.Event.LABEL*/"label", tEventData);
					}
				}
			}
		}

		/**
		*更新动画
		*@param autoKey true为正常更新，false为index手动更新
		*/
		__proto._update = function (autoKey) {
			(autoKey === void 0) && (autoKey = true);
			if (this._pause) return;
			if (autoKey && this._indexControl) {
				return;
			};
			var tCurrTime = this.timer.currTimer;
			var preIndex = this._player.currentKeyframeIndex;
			var dTime = tCurrTime - this._lastTime;
			if (autoKey) {
				this._player._update(dTime);
			} else {
				preIndex = -1;
			}
			this._lastTime = tCurrTime;
			if (!this._player) return;
			this._index = this._clipIndex = this._player.currentKeyframeIndex;
			if (this._index < 0) return;
			if (dTime > 0 && this._clipIndex == preIndex && this._lastUpdateAniClipIndex == this._aniClipIndex) {
				return;
			}
			this._lastUpdateAniClipIndex = this._aniClipIndex;
			if (preIndex > this._clipIndex && this._eventIndex != 0) {
				this._emitMissedEvents(this._player.playStart, this._player.playEnd, this._eventIndex);
				this._eventIndex = 0;
			};
			var tEventData;
			var tEventAniArr = this._templet.eventAniArr;
			var tEventArr = tEventAniArr[this._aniClipIndex];
			if (tEventArr && this._eventIndex < tEventArr.length) {
				tEventData = tEventArr[this._eventIndex];
				if (tEventData.time >= this._player.playStart && tEventData.time <= this._player.playEnd) {
					if (this._player.currentPlayTime >= tEventData.time) {
						this.event(/*laya.events.Event.LABEL*/"label", tEventData);
						this._eventIndex++;
					}
				} else {
					this._eventIndex++;
				}
			};
			var tGraphics;
			if (this._aniMode == 0) {
				tGraphics = this._templet.getGrahicsDataWithCache(this._aniClipIndex, this._clipIndex);
				if (tGraphics) {
					if (this.graphics != tGraphics) {
						this.graphics = tGraphics;
					}
					return;
				} else {
					var i = 0, minIndex = 0;
					minIndex = this._clipIndex;
					while ((!this._templet.getGrahicsDataWithCache(this._aniClipIndex, minIndex - 1)) && (minIndex > 0)) {
						minIndex--;
					}
					if (minIndex < this._clipIndex) {
						for (i = minIndex; i < this._clipIndex; i++) {
							this._createGraphics(i);
						}
					}
				}
			} else if (this._aniMode == 1) {
				tGraphics = this._getGrahicsDataWithCache(this._aniClipIndex, this._clipIndex);
				if (tGraphics) {
					if (this.graphics != tGraphics) {
						this.graphics = tGraphics;
					}
					return;
				} else {
					minIndex = this._clipIndex;
					while ((!this._getGrahicsDataWithCache(this._aniClipIndex, minIndex - 1)) && (minIndex > 0)) {
						minIndex--;
					}
					if (minIndex < this._clipIndex) {
						for (i = minIndex; i < this._clipIndex; i++) {
							this._createGraphics(i);
						}
					}
				}
			}
			this._createGraphics();
		}

		/**
		*@private
		*创建grahics图像
		*/
		__proto._createGraphics = function (_clipIndex) {
			(_clipIndex === void 0) && (_clipIndex = -1);
			if (_clipIndex == -1) _clipIndex = this._clipIndex;
			var curTime = _clipIndex * this._player.cacheFrameRateInterval;
			var tDrawOrderData;
			var tDrawOrderAniArr = this._templet.drawOrderAniArr;
			var tDrawOrderArr = tDrawOrderAniArr[this._aniClipIndex];
			if (tDrawOrderArr && tDrawOrderArr.length > 0) {
				this._drawOrderIndex = 0;
				tDrawOrderData = tDrawOrderArr[this._drawOrderIndex];
				while (curTime >= tDrawOrderData.time) {
					this._drawOrder = tDrawOrderData.drawOrder;
					this._drawOrderIndex++;
					if (this._drawOrderIndex >= tDrawOrderArr.length) {
						break;
					}
					tDrawOrderData = tDrawOrderArr[this._drawOrderIndex];
				}
			};
			var tGraphics;
			if (this._aniMode == 0 || this._aniMode == 1) {
				this.graphics = new GraphicsAni();
			} else {
				if ((this.graphics instanceof laya.ani.GraphicsAni)) {
					this.graphics.clear();
				} else {
					this.graphics = new GraphicsAni();
				}
			}
			tGraphics = this.graphics;
			var bones = this._templet.getNodes(this._aniClipIndex);
			this._templet.getOriginalData(this._aniClipIndex, this._curOriginalData, this._player._fullFrames[this._aniClipIndex], _clipIndex, curTime);
			var tSectionArr = this._aniSectionDic[this._aniClipIndex];
			var tParentMatrix;
			var tStartIndex = 0;
			var i = 0, j = 0, k = 0, n = 0;
			var tDBBoneSlot;
			var tDBBoneSlotArr;
			var tParentTransform;
			var tSrcBone;
			var boneCount = this._templet.srcBoneMatrixArr.length;
			for (i = 0, n = tSectionArr[0]; i < boneCount; i++) {
				tSrcBone = this._boneList[i];
				tParentTransform = this._templet.srcBoneMatrixArr[i];
				tSrcBone.resultTransform.scX = tParentTransform.scX * this._curOriginalData[tStartIndex++];
				tSrcBone.resultTransform.skX = tParentTransform.skX + this._curOriginalData[tStartIndex++];
				tSrcBone.resultTransform.skY = tParentTransform.skY + this._curOriginalData[tStartIndex++];
				tSrcBone.resultTransform.scY = tParentTransform.scY * this._curOriginalData[tStartIndex++];
				tSrcBone.resultTransform.x = tParentTransform.x + this._curOriginalData[tStartIndex++];
				tSrcBone.resultTransform.y = tParentTransform.y + this._curOriginalData[tStartIndex++];
				if (this._templet.tMatrixDataLen === 8) {
					tSrcBone.resultTransform.skewX = tParentTransform.skewX + this._curOriginalData[tStartIndex++];
					tSrcBone.resultTransform.skewY = tParentTransform.skewY + this._curOriginalData[tStartIndex++];
				}
			};
			var tSlotDic = {};
			var tSlotAlphaDic = {};
			var tBoneData;
			for (n += tSectionArr[1]; i < n; i++) {
				tBoneData = bones[i];
				tSlotDic[tBoneData.name] = this._curOriginalData[tStartIndex++];
				tSlotAlphaDic[tBoneData.name] = this._curOriginalData[tStartIndex++];
				this._curOriginalData[tStartIndex++];
				this._curOriginalData[tStartIndex++];
				this._curOriginalData[tStartIndex++];
				this._curOriginalData[tStartIndex++];
			};
			var tBendDirectionDic = {};
			var tMixDic = {};
			for (n += tSectionArr[2]; i < n; i++) {
				tBoneData = bones[i];
				tBendDirectionDic[tBoneData.name] = this._curOriginalData[tStartIndex++];
				tMixDic[tBoneData.name] = this._curOriginalData[tStartIndex++];
				this._curOriginalData[tStartIndex++];
				this._curOriginalData[tStartIndex++];
				this._curOriginalData[tStartIndex++];
				this._curOriginalData[tStartIndex++];
			}
			if (this._pathDic) {
				var tPathConstraint;
				for (n += tSectionArr[3]; i < n; i++) {
					tBoneData = bones[i];
					tPathConstraint = this._pathDic[tBoneData.name];
					if (tPathConstraint) {
						var tByte = new Byte(tBoneData.extenData);
						switch (tByte.getByte()) {
							case 1:
								tPathConstraint.position = this._curOriginalData[tStartIndex++];
								break;
							case 2:
								tPathConstraint.spacing = this._curOriginalData[tStartIndex++];
								break;
							case 3:
								tPathConstraint.rotateMix = this._curOriginalData[tStartIndex++];
								tPathConstraint.translateMix = this._curOriginalData[tStartIndex++];
								break;
						}
					}
				}
			}
			if (this._yReverseMatrix) {
				this._rootBone.update(this._yReverseMatrix);
			} else {
				this._rootBone.update(Matrix.TEMP.identity());
			}
			if (this._ikArr) {
				var tIkConstraint;
				for (i = 0, n = this._ikArr.length; i < n; i++) {
					tIkConstraint = this._ikArr[i];
					if (tBendDirectionDic.hasOwnProperty(tIkConstraint.name)) {
						tIkConstraint.bendDirection = tBendDirectionDic[tIkConstraint.name];
					}
					if (tMixDic.hasOwnProperty(tIkConstraint.name)) {
						tIkConstraint.mix = tMixDic[tIkConstraint.name]
					}
					tIkConstraint.apply();
				}
			}
			if (this._pathDic) {
				for (var tPathStr in this._pathDic) {
					tPathConstraint = this._pathDic[tPathStr];
					tPathConstraint.apply(this._boneList, tGraphics);
				}
			}
			if (this._tfArr) {
				var tTfConstraint;
				for (i = 0, k = this._tfArr.length; i < k; i++) {
					tTfConstraint = this._tfArr[i];
					tTfConstraint.apply();
				}
			}
			for (i = 0, k = this._boneList.length; i < k; i++) {
				tSrcBone = this._boneList[i];
				tDBBoneSlotArr = this._bindBoneBoneSlotDic[tSrcBone.name];
				tSrcBone.resultMatrix.copyTo(this._boneMatrixArray[i]);
				if (tDBBoneSlotArr) {
					for (j = 0, n = tDBBoneSlotArr.length; j < n; j++) {
						tDBBoneSlot = tDBBoneSlotArr[j];
						if (tDBBoneSlot) {
							tDBBoneSlot.setParentMatrix(tSrcBone.resultMatrix);
						}
					}
				}
			};
			var tDeformDic = {};
			var tDeformAniArr = this._templet.deformAniArr;
			var tDeformAniData;
			var tDeformSlotData;
			var tDeformSlotDisplayData;
			if (tDeformAniArr && tDeformAniArr.length > 0) {
				if (this._lastAniClipIndex != this._aniClipIndex) {
					this._lastAniClipIndex = this._aniClipIndex;
					for (i = 0, n = this._boneSlotArray.length; i < n; i++) {
						tDBBoneSlot = this._boneSlotArray[i];
						tDBBoneSlot.deformData = null;
					}
				};
				var tSkinDeformAni = tDeformAniArr[this._aniClipIndex];
				tDeformAniData = (tSkinDeformAni["default"]);
				this._setDeform(tDeformAniData, tDeformDic, this._boneSlotArray, curTime);
				var tSkin;
				for (tSkin in tSkinDeformAni) {
					if (tSkin != "default" && tSkin != this._skinName) {
						tDeformAniData = tSkinDeformAni[tSkin];
						this._setDeform(tDeformAniData, tDeformDic, this._boneSlotArray, curTime);
					}
				}
				tDeformAniData = (tSkinDeformAni[this._skinName]);
				this._setDeform(tDeformAniData, tDeformDic, this._boneSlotArray, curTime);
			};
			var tSlotData2;
			var tSlotData3;
			var tObject;
			if (this._drawOrder) {
				for (i = 0, n = this._drawOrder.length; i < n; i++) {
					tDBBoneSlot = this._boneSlotArray[this._drawOrder[i]];
					tSlotData2 = tSlotDic[tDBBoneSlot.name];
					tSlotData3 = tSlotAlphaDic[tDBBoneSlot.name];
					if (!isNaN(tSlotData3)) {
						tGraphics.save();
						tGraphics.alpha(tSlotData3);
					}
					if (!isNaN(tSlotData2) && tSlotData2 != -2) {
						if (this._templet.attachmentNames) {
							tDBBoneSlot.showDisplayByName(this._templet.attachmentNames[tSlotData2]);
						} else {
							tDBBoneSlot.showDisplayByIndex(tSlotData2);
						}
					}
					if (tDeformDic[this._drawOrder[i]]) {
						tObject = tDeformDic[this._drawOrder[i]];
						if (tDBBoneSlot.currDisplayData && tObject[tDBBoneSlot.currDisplayData.attachmentName]) {
							tDBBoneSlot.deformData = tObject[tDBBoneSlot.currDisplayData.attachmentName];
						} else {
							tDBBoneSlot.deformData = null;
						}
					} else {
						tDBBoneSlot.deformData = null;
					}
					if (!isNaN(tSlotData3)) {
						tDBBoneSlot.draw(tGraphics, this._boneMatrixArray, this._aniMode == 2, tSlotData3);
					} else {
						tDBBoneSlot.draw(tGraphics, this._boneMatrixArray, this._aniMode == 2);
					}
					if (!isNaN(tSlotData3)) {
						tGraphics.restore();
					}
				}
			} else {
				for (i = 0, n = this._boneSlotArray.length; i < n; i++) {
					tDBBoneSlot = this._boneSlotArray[i];
					tSlotData2 = tSlotDic[tDBBoneSlot.name];
					tSlotData3 = tSlotAlphaDic[tDBBoneSlot.name];
					if (!isNaN(tSlotData3)) {
						tGraphics.save();
						tGraphics.alpha(tSlotData3);
					}
					if (!isNaN(tSlotData2) && tSlotData2 != -2) {
						if (this._templet.attachmentNames) {
							tDBBoneSlot.showDisplayByName(this._templet.attachmentNames[tSlotData2]);
						} else {
							tDBBoneSlot.showDisplayByIndex(tSlotData2);
						}
					}
					if (tDeformDic[i]) {
						tObject = tDeformDic[i];
						if (tDBBoneSlot.currDisplayData && tObject[tDBBoneSlot.currDisplayData.attachmentName]) {
							tDBBoneSlot.deformData = tObject[tDBBoneSlot.currDisplayData.attachmentName];
						} else {
							tDBBoneSlot.deformData = null;
						}
					} else {
						tDBBoneSlot.deformData = null;
					}
					if (!isNaN(tSlotData3)) {
						tDBBoneSlot.draw(tGraphics, this._boneMatrixArray, this._aniMode == 2, tSlotData3);
					} else {
						tDBBoneSlot.draw(tGraphics, this._boneMatrixArray, this._aniMode == 2);
					}
					if (!isNaN(tSlotData3)) {
						tGraphics.restore();
					}
				}
			}
			if (this._aniMode == 0) {
				this._templet.setGrahicsDataWithCache(this._aniClipIndex, _clipIndex, tGraphics);
			} else if (this._aniMode == 1) {
				this._setGrahicsDataWithCache(this._aniClipIndex, _clipIndex, tGraphics);
			}
		}

		/**
		*设置deform数据
		*@param tDeformAniData
		*@param tDeformDic
		*@param _boneSlotArray
		*@param curTime
		*/
		__proto._setDeform = function (tDeformAniData, tDeformDic, _boneSlotArray, curTime) {
			if (!tDeformAniData) return;
			var tDeformSlotData;
			var tDeformSlotDisplayData;
			var tDBBoneSlot;
			var i = 0, n = 0, j = 0;
			if (tDeformAniData) {
				for (i = 0, n = tDeformAniData.deformSlotDataList.length; i < n; i++) {
					tDeformSlotData = tDeformAniData.deformSlotDataList[i];
					for (j = 0; j < tDeformSlotData.deformSlotDisplayList.length; j++) {
						tDeformSlotDisplayData = tDeformSlotData.deformSlotDisplayList[j];
						tDBBoneSlot = _boneSlotArray[tDeformSlotDisplayData.slotIndex];
						tDeformSlotDisplayData.apply(curTime, tDBBoneSlot);
						if (!tDeformDic[tDeformSlotDisplayData.slotIndex]) {
							tDeformDic[tDeformSlotDisplayData.slotIndex] = {};
						}
						tDeformDic[tDeformSlotDisplayData.slotIndex][tDeformSlotDisplayData.attachment] = tDeformSlotDisplayData.deformData;
					}
				}
			}
		}

		/**
		*得到当前动画的数量
		*@return 当前动画的数量
		*/
		__proto.getAnimNum = function () {
			return this._templet.getAnimationCount();
		}

		/**
		*得到指定动画的名字
		*@param index 动画的索引
		*/
		__proto.getAniNameByIndex = function (index) {
			return this._templet.getAniNameByIndex(index);
		}

		/**
		*通过名字得到插槽的引用
		*@param name 动画的名字
		*@return 插槽的引用
		*/
		__proto.getSlotByName = function (name) {
			return this._boneSlotDic[name];
		}

		/**
		*通过名字显示一套皮肤
		*@param name 皮肤的名字
		*@param freshSlotIndex 是否将插槽纹理重置到初始化状态
		*/
		__proto.showSkinByName = function (name, freshSlotIndex) {
			(freshSlotIndex === void 0) && (freshSlotIndex = true);
			this.showSkinByIndex(this._templet.getSkinIndexByName(name), freshSlotIndex);
		}

		/**
		*通过索引显示一套皮肤
		*@param skinIndex 皮肤索引
		*@param freshSlotIndex 是否将插槽纹理重置到初始化状态
		*/
		__proto.showSkinByIndex = function (skinIndex, freshSlotIndex) {
			(freshSlotIndex === void 0) && (freshSlotIndex = true);
			for (var i = 0; i < this._boneSlotArray.length; i++) {
				(this._boneSlotArray[i]).showSlotData(null, freshSlotIndex);
			}
			if (this._templet.showSkinByIndex(this._boneSlotDic, skinIndex, freshSlotIndex)) {
				var tSkinData = this._templet.skinDataArray[skinIndex];
				this._skinIndex = skinIndex;
				this._skinName = tSkinData.name;
			}
			this._clearCache();
		}

		/**
		*设置某插槽的皮肤
		*@param slotName 插槽名称
		*@param index 插糟皮肤的索引
		*/
		__proto.showSlotSkinByIndex = function (slotName, index) {
			if (this._aniMode == 0) return;
			var tBoneSlot = this.getSlotByName(slotName);
			if (tBoneSlot) {
				tBoneSlot.showDisplayByIndex(index);
			}
			this._clearCache();
		}

		/**
		*设置某插槽的皮肤
		*@param slotName 插槽名称
		*@param name 皮肤名称
		*/
		__proto.showSlotSkinByName = function (slotName, name) {
			if (this._aniMode == 0) return;
			var tBoneSlot = this.getSlotByName(slotName);
			if (tBoneSlot) {
				tBoneSlot.showDisplayByName(name);
			}
			this._clearCache();
		}

		/**
		*替换插槽贴图名
		*@param slotName 插槽名称
		*@param oldName 要替换的贴图名
		*@param newName 替换后的贴图名
		*/
		__proto.replaceSlotSkinName = function (slotName, oldName, newName) {
			if (this._aniMode == 0) return;
			var tBoneSlot = this.getSlotByName(slotName);
			if (tBoneSlot) {
				tBoneSlot.replaceDisplayByName(oldName, newName);
			}
			this._clearCache();
		}

		/**
		*替换插槽的贴图索引
		*@param slotName 插槽名称
		*@param oldIndex 要替换的索引
		*@param newIndex 替换后的索引
		*/
		__proto.replaceSlotSkinByIndex = function (slotName, oldIndex, newIndex) {
			if (this._aniMode == 0) return;
			var tBoneSlot = this.getSlotByName(slotName);
			if (tBoneSlot) {
				tBoneSlot.replaceDisplayByIndex(oldIndex, newIndex);
			}
			this._clearCache();
		}

		/**
		*设置自定义皮肤
		*@param name 插糟的名字
		*@param texture 自定义的纹理
		*/
		__proto.setSlotSkin = function (slotName, texture) {
			if (this._aniMode == 0) return;
			var tBoneSlot = this.getSlotByName(slotName);
			if (tBoneSlot) {
				tBoneSlot.replaceSkin(texture);
			}
			this._clearCache();
		}

		/**
		*换装的时候，需要清一下缓冲区
		*/
		__proto._clearCache = function () {
			if (this._aniMode == 1) {
				for (var i = 0, n = this._graphicsCache.length; i < n; i++) {
					this._graphicsCache[i].length = 0;
				}
			}
		}

		/**
		*播放动画
		*
		*@param nameOrIndex 动画名字或者索引
		*@param loop 是否循环播放
		*@param force false,如果要播的动画跟上一个相同就不生效,true,强制生效
		*@param start 起始时间
		*@param end 结束时间
		*@param freshSkin 是否刷新皮肤数据
		*/
		__proto.play = function (nameOrIndex, loop, force, start, end, freshSkin) {
			(force === void 0) && (force = true);
			(start === void 0) && (start = 0);
			(end === void 0) && (end = 0);
			(freshSkin === void 0) && (freshSkin = true);
			this._indexControl = false;
			var index = -1;
			var duration = NaN;
			if (loop) {
				duration = 2147483647;
			} else {
				duration = 0;
			}
			if ((typeof nameOrIndex == 'string')) {
				for (var i = 0, n = this._templet.getAnimationCount(); i < n; i++) {
					var animation = this._templet.getAnimation(i);
					if (animation && nameOrIndex == animation.name) {
						index = i;
						break;
					}
				}
			} else {
				index = nameOrIndex;
			}
			if (index > -1 && index < this.getAnimNum()) {
				this._aniClipIndex = index;
				if (force || this._pause || this._currAniIndex != index) {
					this._currAniIndex = index;
					this._curOriginalData = new Float32Array(this._templet.getTotalkeyframesLength(index));
					this._drawOrder = null;
					this._eventIndex = 0;
					this._player.play(index, this._player.playbackRate, duration, start, end);
					if (freshSkin)
						this._templet.showSkinByIndex(this._boneSlotDic, this._skinIndex);
					if (this._pause) {
						this._pause = false;
						this._lastTime = Browser.now();
						this.timer.frameLoop(1, this, this._update, null, true);
					}
					this._update();
				}
			}
		}

		/**
		*停止动画
		*/
		__proto.stop = function () {
			if (!this._pause) {
				this._pause = true;
				if (this._player) {
					this._player.stop(true);
				}
				this.timer.clear(this, this._update);
			}
		}

		/**
		*设置动画播放速率
		*@param value 1为标准速率
		*/
		__proto.playbackRate = function (value) {
			if (this._player) {
				this._player.playbackRate = value;
			}
		}

		/**
		*暂停动画的播放
		*/
		__proto.paused = function () {
			if (!this._pause) {
				this._pause = true;
				if (this._player) {
					this._player.paused = true;
				}
				this.timer.clear(this, this._update);
			}
		}

		/**
		*恢复动画的播放
		*/
		__proto.resume = function () {
			this._indexControl = false;
			if (this._pause) {
				this._pause = false;
				if (this._player) {
					this._player.paused = false;
				}
				this._lastTime = Browser.now();
				this.timer.frameLoop(1, this, this._update, null, true);
			}
		}

		/**
		*@private
		*得到缓冲数据
		*@param aniIndex
		*@param frameIndex
		*@return
		*/
		__proto._getGrahicsDataWithCache = function (aniIndex, frameIndex) {
			return this._graphicsCache[aniIndex][frameIndex];
		}

		/**
		*@private
		*保存缓冲grahpics
		*@param aniIndex
		*@param frameIndex
		*@param graphics
		*/
		__proto._setGrahicsDataWithCache = function (aniIndex, frameIndex, graphics) {
			this._graphicsCache[aniIndex][frameIndex] = graphics;
		}

		/**
		*销毁当前动画
		*/
		__proto.destroy = function (destroyChild) {
			(destroyChild === void 0) && (destroyChild = true);
			_super.prototype.destroy.call(this, destroyChild);
			this._templet = null;
			if (this._player) this._player.offAll();
			this._player = null;
			this._curOriginalData = null;
			this._boneMatrixArray.length = 0;
			this._lastTime = 0;
			this.timer.clear(this, this._update);
		}

		/**
		*设置动画路径
		*/
		/**
		*得到资源的URL
		*/
		__getset(0, __proto, 'url', function () {
			return this._aniPath;
		}, function (path) {
			this.load(path);
		});

		/**
		*@private
		*设置帧索引
		*/
		/**
		*@private
		*得到帧索引
		*/
		__getset(0, __proto, 'index', function () {
			return this._index;
		}, function (value) {
			if (this.player) {
				this._index = value;
				this._player.currentTime = this._index * 1000 / this._player.cacheFrameRate;
				this._indexControl = true;
				this._update(false);
			}
		});

		/**
		*得到总帧数据
		*/
		__getset(0, __proto, 'total', function () {
			if (this._templet && this._player) {
				this._total = Math.floor(this._templet.getAniDuration(this._player.currentAnimationClipIndex) / 1000 * this._player.cacheFrameRate);
			} else {
				this._total = -1;
			}
			return this._total;
		});

		/**
		*得到动画模板的引用
		*/
		__getset(0, __proto, 'templet', function () {
			return this._templet;
		});

		/**
		*得到播放器的引用
		*/
		__getset(0, __proto, 'player', function () {
			return this._player;
		});

		Skeleton.useSimpleMeshInCanvas = false;
		return Skeleton;
	})(Sprite)


	/**
	*<p> <code>MovieClip</code> 用于播放经过工具处理后的 swf 动画。</p>
	*/
	//class laya.ani.swf.MovieClip extends laya.display.Sprite
	var MovieClip = (function (_super) {
		function MovieClip(parentMovieClip) {
			/**@private 数据起始位置。*/
			this._start = 0;
			/**@private 当前位置。*/
			this._Pos = 0;
			/**@private 数据。*/
			this._data = null;
			/**@private */
			this._curIndex = 0;
			/**@private */
			this._preIndex = 0;
			/**@private */
			this._playIndex = 0;
			/**@private */
			this._playing = false;
			/**@private */
			this._ended = true;
			/**@private 总帧数。*/
			this._count = 0;
			/**@private id_data起始位置表*/
			this._ids = null;
			/**@private */
			this._loadedImage = {};
			/**@private id_实例表*/
			this._idOfSprite = null;
			/**@private 父mc*/
			this._parentMovieClip = null;
			/**@private 需要更新的movieClip表*/
			this._movieClipList = null;
			/**@private */
			this._labels = null;
			/**资源根目录。*/
			this.basePath = null;
			/**@private */
			this._atlasPath = null;
			/**@private */
			this._url = null;
			/**@private */
			this._isRoot = false;
			/**@private */
			this._completeHandler = null;
			/**@private */
			this._endFrame = -1;
			/**播放间隔(单位：毫秒)。*/
			this.interval = 30;
			/**是否循环播放 */
			this.loop = false;
			MovieClip.__super.call(this);
			this._ids = {};
			this._idOfSprite = [];
			this._reset();
			this._playing = false;
			this._parentMovieClip = parentMovieClip;
			if (!parentMovieClip) {
				this._movieClipList = [this];
				this._isRoot = true;
				this._setUpNoticeType(/*laya.display.Node.NOTICE_DISPLAY*/0x1);
			} else {
				this._isRoot = false;
				this._movieClipList = parentMovieClip._movieClipList;
				this._movieClipList.push(this);
			}
		}

		__class(MovieClip, 'laya.ani.swf.MovieClip', _super);
		var __proto = MovieClip.prototype;
		/**
		*<p>销毁此对象。以及销毁引用的Texture</p>
		*@param destroyChild 是否同时销毁子节点，若值为true,则销毁子节点，否则不销毁子节点。
		*/
		__proto.destroy = function (destroyChild) {
			(destroyChild === void 0) && (destroyChild = true);
			this._clear();
			_super.prototype.destroy.call(this, destroyChild);
		}

		/**@private */
		__proto._setDisplay = function (value) {
			_super.prototype._setDisplay.call(this, value);
			if (this._isRoot) {
				this._$3__onDisplay(value);
			}
		}

		/**@private */
		__proto._$3__onDisplay = function (value) {
			if (value) this.timer.loop(this.interval, this, this.updates, null, true);
			else this.timer.clear(this, this.updates);
		}

		/**@private 更新时间轴*/
		__proto.updates = function () {
			if (this._parentMovieClip) return;
			var i = 0, len = 0;
			len = this._movieClipList.length;
			for (i = 0; i < len; i++) {
				this._movieClipList[i] && this._movieClipList[i]._update();
			}
		}

		/**
		*增加一个标签到index帧上，播放到此index后会派发label事件
		*@param label 标签名称
		*@param index 索引位置
		*/
		__proto.addLabel = function (label, index) {
			if (!this._labels) this._labels = {};
			this._labels[index] = label;
		}

		/**
		*删除某个标签
		*@param label 标签名字，如果label为空，则删除所有Label
		*/
		__proto.removeLabel = function (label) {
			if (!label) this._labels = null;
			else if (!this._labels) {
				for (var name in this._labels) {
					if (this._labels[name] === label) {
						delete this._labels[name];
						break;
					}
				}
			}
		}

		/**
		*@private
		*动画的帧更新处理函数。
		*/
		__proto._update = function () {
			if (!this._data) return;
			if (!this._playing) return;
			this._playIndex++;
			if (this._playIndex >= this._count) {
				if (!this.loop) {
					this._playIndex--;
					this.stop();
					return;
				}
				this._playIndex = 0;
			}
			this._parse(this._playIndex);
			if (this._labels && this._labels[this._playIndex]) this.event(/*laya.events.Event.LABEL*/"label", this._labels[this._playIndex]);
			if (this._endFrame != -1 && this._endFrame == this._playIndex) {
				this._endFrame = -1;
				if (this._completeHandler != null) {
					var handler = this._completeHandler;
					this._completeHandler = null;
					handler.run();
				}
				this.stop();
			}
		}

		/**
		*停止播放动画。
		*/
		__proto.stop = function () {
			this._playing = false;
		}

		/**
		*跳到某帧并停止播放动画。
		*@param frame 要跳到的帧
		*/
		__proto.gotoAndStop = function (index) {
			this.index = index;
			this.stop();
		}

		/**
		*@private
		*清理。
		*/
		__proto._clear = function () {
			this.stop();
			this._idOfSprite.length = 0;
			if (!this._parentMovieClip) {
				this.timer.clear(this, this.updates);
				var i = 0, len = 0;
				len = this._movieClipList.length;
				for (i = 0; i < len; i++) {
					if (this._movieClipList[i] != this)
						this._movieClipList[i]._clear();
				}
				this._movieClipList.length = 0;
			}
			if (this._atlasPath) {
				Loader.clearRes(this._atlasPath);
			};
			var key;
			for (key in this._loadedImage) {
				if (this._loadedImage[key]) {
					Loader.clearRes(key);
					this._loadedImage[key] = false;
				}
			}
			this.removeChildren();
			this.graphics = null;
			this._parentMovieClip = null;
		}

		/**
		*播放动画。
		*@param index 帧索引。
		*/
		__proto.play = function (index, loop) {
			(index === void 0) && (index = 0);
			(loop === void 0) && (loop = true);
			this.loop = loop;
			this._playing = true;
			if (this._data)
				this._displayFrame(index);
		}

		/**@private */
		__proto._displayFrame = function (frameIndex) {
			(frameIndex === void 0) && (frameIndex = -1);
			if (frameIndex != -1) {
				if (this._curIndex > frameIndex) this._reset();
				this._parse(frameIndex);
			}
		}

		/**@private */
		__proto._reset = function (rm) {
			(rm === void 0) && (rm = true);
			if (rm && this._curIndex != 1) this.removeChildren();
			this._preIndex = this._curIndex = -1;
			this._Pos = this._start;
		}

		/**@private */
		__proto._parse = function (frameIndex) {
			var curChild = this;
			var mc, sp, key = 0, type = 0, tPos = 0, ttype = 0, ifAdd = false;
			var _idOfSprite = this._idOfSprite, _data = this._data, eStr;
			if (this._ended) this._reset();
			_data.pos = this._Pos;
			this._ended = false;
			this._playIndex = frameIndex;
			if (this._curIndex > frameIndex && frameIndex < this._preIndex) {
				this._reset(true);
				_data.pos = this._Pos;
			}
			while ((this._curIndex <= frameIndex) && (!this._ended)) {
				type = _data.getUint16();
				switch (type) {
					case 12:
						key = _data.getUint16();
						tPos = this._ids[_data.getUint16()];
						this._Pos = _data.pos;
						_data.pos = tPos;
						if ((ttype = _data.getUint8()) == 0) {
							var pid = _data.getUint16();
							sp = _idOfSprite[key]
							if (!sp) {
								sp = _idOfSprite[key] = new Sprite();
								var spp = new Sprite();
								spp.loadImage(this.basePath + pid + ".png");
								this._loadedImage[this.basePath + pid + ".png"] = true;
								sp.addChild(spp);
								spp.size(_data.getFloat32(), _data.getFloat32());
								var mat = _data._getMatrix();
								spp.transform = mat;
							}
							sp.alpha = 1;
						} else if (ttype == 1) {
							mc = _idOfSprite[key]
							if (!mc) {
								_idOfSprite[key] = mc = new MovieClip(this);
								mc.interval = this.interval;
								mc._ids = this._ids;
								mc.basePath = this.basePath;
								mc._setData(_data, tPos);
								mc._initState();
								mc.play(0);
							}
							mc.alpha = 1;
						}
						_data.pos = this._Pos;
						break;
					case 3: ;
						var node = _idOfSprite[_data.getUint16()];
						if (node) {
							this.addChild(node);
							node.zOrder = _data.getUint16();
							ifAdd = true;
						}
						break;
					case 4:
						node = _idOfSprite[_data.getUint16()];
						node && node.removeSelf();
						break;
					case 5:
						_idOfSprite[_data.getUint16()][MovieClip._ValueList[_data.getUint16()]] = (_data.getFloat32());
						break;
					case 6:
						_idOfSprite[_data.getUint16()].visible = (_data.getUint8() > 0);
						break;
					case 7:
						sp = _idOfSprite[_data.getUint16()];
						var mt = sp.transform || Matrix.create();
						mt.setTo(_data.getFloat32(), _data.getFloat32(), _data.getFloat32(), _data.getFloat32(), _data.getFloat32(), _data.getFloat32());
						sp.transform = mt;
						break;
					case 8:
						_idOfSprite[_data.getUint16()].setPos(_data.getFloat32(), _data.getFloat32());
						break;
					case 9:
						_idOfSprite[_data.getUint16()].setSize(_data.getFloat32(), _data.getFloat32());
						break;
					case 10:
						_idOfSprite[_data.getUint16()].alpha = _data.getFloat32();
						break;
					case 11:
						_idOfSprite[_data.getUint16()].setScale(_data.getFloat32(), _data.getFloat32());
						break;
					case 98:
						eStr = _data.getString();
						this.event(eStr);
						if (eStr == "stop") this.stop();
						break;
					case 99:
						this._curIndex = _data.getUint16();
						ifAdd && this.updateZOrder();
						break;
					case 100:
						this._count = this._curIndex + 1;
						this._ended = true;
						if (this._playing) {
							this.event(/*laya.events.Event.FRAME*/"enterframe");
							this.event(/*laya.events.Event.END*/"end");
							this.event(/*laya.events.Event.COMPLETE*/"complete");
						}
						this._reset(false);
						break;
				}
			}
			if (this._playing && !this._ended) this.event(/*laya.events.Event.FRAME*/"enterframe");
			this._Pos = _data.pos;
		}

		/**@private */
		__proto._setData = function (data, start) {
			this._data = data;
			this._start = start + 3;
		}

		/**
		*加载资源。
		*@param url swf 资源地址。
		*@param atlas 是否使用图集资源
		*@param atlasPath 图集路径，默认使用与swf同名的图集
		*/
		__proto.load = function (url, atlas, atlasPath) {
			(atlas === void 0) && (atlas = false);
			this._url = url = URL.formatURL(url);
			if (atlas) this._atlasPath = atlasPath ? atlasPath : url.split(".swf")[0] + ".json";
			this.stop();
			this._clear();
			this._movieClipList = [this];
			var urls;
			urls = [{ url: url, type:/*laya.net.Loader.BUFFER*/"arraybuffer" }];
			if (this._atlasPath) {
				urls.push({ url: this._atlasPath, type:/*laya.net.Loader.ATLAS*/"atlas" });
			}
			Laya.loader.load(urls, Handler.create(this, this._onLoaded));
		}

		/**@private */
		__proto._onLoaded = function () {
			var data;
			data = Loader.getRes(this._url);
			if (!data) {
				this.event(/*laya.events.Event.ERROR*/"error", "file not find");
				return;
			}
			this.basePath = this._atlasPath ? Loader.getAtlas(this._atlasPath).dir : this._url.split(".swf")[0] + "/image/";
			this._initData(data);
		}

		/**@private */
		__proto._initState = function () {
			this._reset();
			this._ended = false;
			var preState = this._playing;
			this._playing = false;
			this._curIndex = 0;
			while (!this._ended) this._parse(++this._curIndex);
			this._playing = preState;
		}

		/**@private */
		__proto._initData = function (data) {
			this._data = new Byte(data);
			var i = 0, len = this._data.getUint16();
			for (i = 0; i < len; i++)this._ids[this._data.getInt16()] = this._data.getInt32();
			this.interval = 1000 / this._data.getUint16();
			this._setData(this._data, this._ids[32767]);
			this._initState();
			this.play(0);
			this.event(/*laya.events.Event.LOADED*/"loaded");
			if (!this._parentMovieClip) this.timer.loop(this.interval, this, this.updates, null, true);
		}

		/**
		*从开始索引播放到结束索引，结束之后出发complete回调
		*@param start 开始索引
		*@param end 结束索引
		*@param complete 结束回调
		*/
		__proto.playTo = function (start, end, complete) {
			this._completeHandler = complete;
			this._endFrame = end;
			this.play(start, false);
		}

		/**当前播放索引。*/
		__getset(0, __proto, 'index', function () {
			return this._playIndex;
		}, function (value) {
			this._playIndex = value;
			if (this._data)
				this._displayFrame(this._playIndex);
			if (this._labels && this._labels[value]) this.event(/*laya.events.Event.LABEL*/"label", this._labels[value]);
		});

		/**
		*帧总数。
		*/
		__getset(0, __proto, 'count', function () {
			return this._count;
		});

		/**
		*是否在播放中
		*/
		__getset(0, __proto, 'playing', function () {
			return this._playing;
		});

		/**
		*资源地址。
		*/
		__getset(0, __proto, 'url', null, function (path) {
			this.load(path);
		});

		MovieClip._ValueList = ["x", "y", "width", "height", "scaleX", "scaleY", "rotation", "alpha"];
		return MovieClip;
	})(Sprite)


	/**
	*动画模板类
	*/
	//class laya.ani.bone.Templet extends laya.ani.AnimationTemplet
	var Templet = (function (_super) {
		function Templet() {
			this._mainTexture = null;
			this._textureJson = null;
			this._graphicsCache = [];
			/**存放原始骨骼信息 */
			this.srcBoneMatrixArr = [];
			/**IK数据 */
			this.ikArr = [];
			/**transform数据 */
			this.tfArr = [];
			/**path数据 */
			this.pathArr = [];
			/**存放插槽数据的字典 */
			this.boneSlotDic = {};
			/**绑定插槽数据的字典 */
			this.bindBoneBoneSlotDic = {};
			/**存放插糟数据的数组 */
			this.boneSlotArray = [];
			/**皮肤数据 */
			this.skinDataArray = [];
			/**皮肤的字典数据 */
			this.skinDic = {};
			/**存放纹理数据 */
			this.subTextureDic = {};
			/**是否解析失败 */
			this.isParseFail = false;
			/**反转矩阵，有些骨骼动画要反转才能显示 */
			this.yReverseMatrix = null;
			/**渲染顺序动画数据 */
			this.drawOrderAniArr = [];
			/**事件动画数据 */
			this.eventAniArr = [];
			/**@private 索引对应的名称 */
			this.attachmentNames = null;
			/**顶点动画数据 */
			this.deformAniArr = [];
			this._isDestroyed = false;
			this._rate = 30;
			this.isParserComplete = false;
			this.aniSectionDic = {};
			this._skBufferUrl = null;
			this._textureDic = {};
			this._loadList = null;
			this._path = null;
			/**@private */
			this.tMatrixDataLen = 0;
			this.mRootBone = null;
			Templet.__super.call(this);
			this.skinSlotDisplayDataArr = [];
			this.mBoneArr = [];
		}

		__class(Templet, 'laya.ani.bone.Templet', _super);
		var __proto = Templet.prototype;
		__proto.loadAni = function (url) {
			this._skBufferUrl = url;
			Laya.loader.load(url, Handler.create(this, this.onComplete), null,/*laya.net.Loader.BUFFER*/"arraybuffer");
		}

		__proto.onComplete = function (content) {
			if (this._isDestroyed) {
				this.destroy();
				return;
			};
			var tSkBuffer = Loader.getRes(this._skBufferUrl);
			if (!tSkBuffer) {
				this.event(/*laya.events.Event.ERROR*/"error", "load failed:" + this._skBufferUrl);
				return;
			}
			this._path = this._skBufferUrl.slice(0, this._skBufferUrl.lastIndexOf("/")) + "/";
			this.parseData(null, tSkBuffer);
		}

		/**
		*解析骨骼动画数据
		*@param texture 骨骼动画用到的纹理
		*@param skeletonData 骨骼动画信息及纹理分块信息
		*@param playbackRate 缓冲的帧率数据（会根据帧率去分帧）
		*/
		__proto.parseData = function (texture, skeletonData, playbackRate) {
			(playbackRate === void 0) && (playbackRate = 30);
			if (!this._path && this.url) this._path = this.url.slice(0, this.url.lastIndexOf("/")) + "/";
			this._mainTexture = texture;
			if (this._mainTexture) {
				if (Render.isWebGL && texture.bitmap) {
					texture.bitmap.enableMerageInAtlas = false;
				}
			}
			this._rate = playbackRate;
			this.parse(skeletonData);
		}

		/**
		*创建动画
		*0,使用模板缓冲的数据，模板缓冲的数据，不允许修改 （内存开销小，计算开销小，不支持换装）
		*1,使用动画自己的缓冲区，每个动画都会有自己的缓冲区，相当耗费内存 （内存开销大，计算开销小，支持换装）
		*2,使用动态方式，去实时去画 （内存开销小，计算开销大，支持换装,不建议使用）
		*@param aniMode 0 动画模式，0:不支持换装,1,2支持换装
		*@return
		*/
		__proto.buildArmature = function (aniMode) {
			(aniMode === void 0) && (aniMode = 0);
			return new Skeleton(this, aniMode);
		}

		/**
		*@private
		*解析动画
		*@param data 解析的二进制数据
		*@param playbackRate 帧率
		*/
		__proto.parse = function (data) {
			_super.prototype.parse.call(this, data);
			this._endLoaded();
			if (this._aniVersion != Templet.LAYA_ANIMATION_VISION) {
				console.log("[Error] 版本不一致，请使用IDE版本配套的重新导出" + this._aniVersion + "->" + Templet.LAYA_ANIMATION_VISION);
				this._loaded = false;
			}
			if (this.loaded) {
				if (this._mainTexture) {
					this._parsePublicExtData();
				} else {
					this._parseTexturePath();
				}
			} else {
				this.event(/*laya.events.Event.ERROR*/"error", this);
				this.isParseFail = true;
			}
		}

		__proto._parseTexturePath = function () {
			if (this._isDestroyed) {
				this.destroy();
				return;
			};
			var i = 0;
			this._loadList = [];
			var tByte = new Byte(this.getPublicExtData());
			var tX = 0, tY = 0, tWidth = 0, tHeight = 0;
			var tFrameX = 0, tFrameY = 0, tFrameWidth = 0, tFrameHeight = 0;
			var tTempleData = 0;
			var tTextureLen = tByte.getInt32();
			var tTextureName = tByte.readUTFString();
			var tTextureNameArr = tTextureName.split("\n");
			var tTexture;
			var tSrcTexturePath;
			for (i = 0; i < tTextureLen; i++) {
				tSrcTexturePath = this._path + tTextureNameArr[i * 2];
				tTextureName = tTextureNameArr[i * 2 + 1];
				tX = tByte.getFloat32();
				tY = tByte.getFloat32();
				tWidth = tByte.getFloat32();
				tHeight = tByte.getFloat32();
				tTempleData = tByte.getFloat32();
				tFrameX = isNaN(tTempleData) ? 0 : tTempleData;
				tTempleData = tByte.getFloat32();
				tFrameY = isNaN(tTempleData) ? 0 : tTempleData;
				tTempleData = tByte.getFloat32();
				tFrameWidth = isNaN(tTempleData) ? tWidth : tTempleData;
				tTempleData = tByte.getFloat32();
				tFrameHeight = isNaN(tTempleData) ? tHeight : tTempleData;
				if (this._loadList.indexOf(tSrcTexturePath) == -1) {
					this._loadList.push(tSrcTexturePath);
				}
			}
			Laya.loader.load(this._loadList, Handler.create(this, this._textureComplete));
		}

		/**
		*纹理加载完成
		*/
		__proto._textureComplete = function () {
			var tTexture;
			var tTextureName;
			for (var i = 0, n = this._loadList.length; i < n; i++) {
				tTextureName = this._loadList[i];
				tTexture = this._textureDic[tTextureName] = Loader.getRes(tTextureName);
				if (Render.isWebGL && tTexture && tTexture.bitmap) {
					tTexture.bitmap.enableMerageInAtlas = false;
				}
			}
			this._parsePublicExtData();
		}

		/**
		*解析自定义数据
		*/
		__proto._parsePublicExtData = function () {
			var i = 0, j = 0, k = 0, l = 0, n = 0;
			for (i = 0, n = this.getAnimationCount(); i < n; i++) {
				this._graphicsCache.push([]);
			};
			var isSpine = false;
			isSpine = this._aniClassName != "Dragon";
			var tByte = new Byte(this.getPublicExtData());
			var tX = 0, tY = 0, tWidth = 0, tHeight = 0;
			var tFrameX = 0, tFrameY = 0, tFrameWidth = 0, tFrameHeight = 0;
			var tTempleData = 0;
			var tTextureLen = tByte.getInt32();
			var tTextureName = tByte.readUTFString();
			var tTextureNameArr = tTextureName.split("\n");
			var tTexture;
			var tSrcTexturePath;
			for (i = 0; i < tTextureLen; i++) {
				tTexture = this._mainTexture;
				tSrcTexturePath = this._path + tTextureNameArr[i * 2];
				tTextureName = tTextureNameArr[i * 2 + 1];
				if (this._mainTexture == null) {
					tTexture = this._textureDic[tSrcTexturePath];
				}
				if (!tTexture) {
					this.event(/*laya.events.Event.ERROR*/"error", this);
					this.isParseFail = true;
					return;
				}
				tX = tByte.getFloat32();
				tY = tByte.getFloat32();
				tWidth = tByte.getFloat32();
				tHeight = tByte.getFloat32();
				tTempleData = tByte.getFloat32();
				tFrameX = isNaN(tTempleData) ? 0 : tTempleData;
				tTempleData = tByte.getFloat32();
				tFrameY = isNaN(tTempleData) ? 0 : tTempleData;
				tTempleData = tByte.getFloat32();
				tFrameWidth = isNaN(tTempleData) ? tWidth : tTempleData;
				tTempleData = tByte.getFloat32();
				tFrameHeight = isNaN(tTempleData) ? tHeight : tTempleData;
				this.subTextureDic[tTextureName] = Texture.create(tTexture, tX, tY, tWidth, tHeight, -tFrameX, -tFrameY, tFrameWidth, tFrameHeight);
			}
			this._mainTexture = tTexture;
			var tAniCount = tByte.getUint16();
			var tSectionArr;
			for (i = 0; i < tAniCount; i++) {
				tSectionArr = [];
				tSectionArr.push(tByte.getUint16());
				tSectionArr.push(tByte.getUint16());
				tSectionArr.push(tByte.getUint16());
				tSectionArr.push(tByte.getUint16());
				this.aniSectionDic[i] = tSectionArr;
			};
			var tBone;
			var tParentBone;
			var tName;
			var tParentName;
			var tBoneLen = tByte.getInt16();
			var tBoneDic = {};
			var tRootBone;
			for (i = 0; i < tBoneLen; i++) {
				tBone = new Bone();
				if (i == 0) {
					tRootBone = tBone;
				} else {
					tBone.root = tRootBone;
				}
				tBone.d = isSpine ? -1 : 1;
				tName = tByte.readUTFString();
				tParentName = tByte.readUTFString();
				tBone.length = tByte.getFloat32();
				if (tByte.getByte() == 1) {
					tBone.inheritRotation = false;
				}
				if (tByte.getByte() == 1) {
					tBone.inheritScale = false;
				}
				tBone.name = tName;
				if (tParentName) {
					tParentBone = tBoneDic[tParentName];
					if (tParentBone) {
						tParentBone.addChild(tBone);
					} else {
						this.mRootBone = tBone;
					}
				}
				tBoneDic[tName] = tBone;
				this.mBoneArr.push(tBone);
			}
			this.tMatrixDataLen = tByte.getUint16();
			var tLen = tByte.getUint16();
			var parentIndex = 0;
			var boneLength = Math.floor(tLen / this.tMatrixDataLen);
			var tResultTransform;
			var tMatrixArray = this.srcBoneMatrixArr;
			for (i = 0; i < boneLength; i++) {
				tResultTransform = new Transform();
				tResultTransform.scX = tByte.getFloat32();
				tResultTransform.skX = tByte.getFloat32();
				tResultTransform.skY = tByte.getFloat32();
				tResultTransform.scY = tByte.getFloat32();
				tResultTransform.x = tByte.getFloat32();
				tResultTransform.y = tByte.getFloat32();
				if (this.tMatrixDataLen === 8) {
					tResultTransform.skewX = tByte.getFloat32();
					tResultTransform.skewY = tByte.getFloat32();
				}
				tMatrixArray.push(tResultTransform);
				tBone = this.mBoneArr[i];
				tBone.transform = tResultTransform;
			};
			var tIkConstraintData;
			var tIkLen = tByte.getUint16();
			var tIkBoneLen = 0;
			for (i = 0; i < tIkLen; i++) {
				tIkConstraintData = new IkConstraintData();
				tIkBoneLen = tByte.getUint16();
				for (j = 0; j < tIkBoneLen; j++) {
					tIkConstraintData.boneNames.push(tByte.readUTFString());
					tIkConstraintData.boneIndexs.push(tByte.getInt16());
				}
				tIkConstraintData.name = tByte.readUTFString();
				tIkConstraintData.targetBoneName = tByte.readUTFString();
				tIkConstraintData.targetBoneIndex = tByte.getInt16();
				tIkConstraintData.bendDirection = tByte.getFloat32();
				tIkConstraintData.mix = tByte.getFloat32();
				tIkConstraintData.isSpine = isSpine;
				this.ikArr.push(tIkConstraintData);
			};
			var tTfConstraintData;
			var tTfLen = tByte.getUint16();
			var tTfBoneLen = 0;
			for (i = 0; i < tTfLen; i++) {
				tTfConstraintData = new TfConstraintData();
				tTfBoneLen = tByte.getUint16();
				for (j = 0; j < tTfBoneLen; j++) {
					tTfConstraintData.boneIndexs.push(tByte.getInt16());
				}
				tTfConstraintData.name = tByte.getUTFString();
				tTfConstraintData.targetIndex = tByte.getInt16();
				tTfConstraintData.rotateMix = tByte.getFloat32();
				tTfConstraintData.translateMix = tByte.getFloat32();
				tTfConstraintData.scaleMix = tByte.getFloat32();
				tTfConstraintData.shearMix = tByte.getFloat32();
				tTfConstraintData.offsetRotation = tByte.getFloat32();
				tTfConstraintData.offsetX = tByte.getFloat32();
				tTfConstraintData.offsetY = tByte.getFloat32();
				tTfConstraintData.offsetScaleX = tByte.getFloat32();
				tTfConstraintData.offsetScaleY = tByte.getFloat32();
				tTfConstraintData.offsetShearY = tByte.getFloat32();
				this.tfArr.push(tTfConstraintData);
			};
			var tPathConstraintData;
			var tPathLen = tByte.getUint16();
			var tPathBoneLen = 0;
			for (i = 0; i < tPathLen; i++) {
				tPathConstraintData = new PathConstraintData();
				tPathConstraintData.name = tByte.readUTFString();
				tPathBoneLen = tByte.getUint16();
				for (j = 0; j < tPathBoneLen; j++) {
					tPathConstraintData.bones.push(tByte.getInt16());
				}
				tPathConstraintData.target = tByte.readUTFString();
				tPathConstraintData.positionMode = tByte.readUTFString();
				tPathConstraintData.spacingMode = tByte.readUTFString();
				tPathConstraintData.rotateMode = tByte.readUTFString();
				tPathConstraintData.offsetRotation = tByte.getFloat32();
				tPathConstraintData.position = tByte.getFloat32();
				tPathConstraintData.spacing = tByte.getFloat32();
				tPathConstraintData.rotateMix = tByte.getFloat32();
				tPathConstraintData.translateMix = tByte.getFloat32();
				this.pathArr.push(tPathConstraintData);
			};
			var tDeformSlotLen = 0;
			var tDeformSlotDisplayLen = 0;
			var tDSlotIndex = 0;
			var tDAttachment;
			var tDeformTimeLen = 0;
			var tDTime = NaN;
			var tDeformVecticesLen = 0;
			var tDeformAniData;
			var tDeformSlotData;
			var tDeformSlotDisplayData;
			var tDeformVectices;
			var tDeformAniLen = tByte.getInt16();
			for (i = 0; i < tDeformAniLen; i++) {
				var tDeformSkinLen = tByte.getUint8();
				var tSkinDic = {};
				this.deformAniArr.push(tSkinDic);
				for (var f = 0; f < tDeformSkinLen; f++) {
					tDeformAniData = new DeformAniData();
					tDeformAniData.skinName = tByte.getUTFString();
					tSkinDic[tDeformAniData.skinName] = tDeformAniData;
					tDeformSlotLen = tByte.getInt16();
					for (j = 0; j < tDeformSlotLen; j++) {
						tDeformSlotData = new DeformSlotData();
						tDeformAniData.deformSlotDataList.push(tDeformSlotData);
						tDeformSlotDisplayLen = tByte.getInt16();
						for (k = 0; k < tDeformSlotDisplayLen; k++) {
							tDeformSlotDisplayData = new DeformSlotDisplayData();
							tDeformSlotData.deformSlotDisplayList.push(tDeformSlotDisplayData);
							tDeformSlotDisplayData.slotIndex = tDSlotIndex = tByte.getInt16();
							tDeformSlotDisplayData.attachment = tDAttachment = tByte.getUTFString();
							tDeformTimeLen = tByte.getInt16();
							for (l = 0; l < tDeformTimeLen; l++) {
								if (tByte.getByte() == 1) {
									tDeformSlotDisplayData.tweenKeyList.push(true);
								} else {
									tDeformSlotDisplayData.tweenKeyList.push(false);
								}
								tDTime = tByte.getFloat32();
								tDeformSlotDisplayData.timeList.push(tDTime);
								tDeformVectices = [];
								tDeformSlotDisplayData.vectices.push(tDeformVectices);
								tDeformVecticesLen = tByte.getInt16();
								for (n = 0; n < tDeformVecticesLen; n++) {
									tDeformVectices.push(tByte.getFloat32());
								}
							}
						}
					}
				}
			};
			var tDrawOrderArr;
			var tDrawOrderAniLen = tByte.getInt16();
			var tDrawOrderLen = 0;
			var tDrawOrderData;
			var tDoLen = 0;
			for (i = 0; i < tDrawOrderAniLen; i++) {
				tDrawOrderLen = tByte.getInt16();
				tDrawOrderArr = [];
				for (j = 0; j < tDrawOrderLen; j++) {
					tDrawOrderData = new DrawOrderData();
					tDrawOrderData.time = tByte.getFloat32();
					tDoLen = tByte.getInt16();
					for (k = 0; k < tDoLen; k++) {
						tDrawOrderData.drawOrder.push(tByte.getInt16());
					}
					tDrawOrderArr.push(tDrawOrderData);
				}
				this.drawOrderAniArr.push(tDrawOrderArr);
			};
			var tEventArr;
			var tEventAniLen = tByte.getInt16();
			var tEventLen = 0;
			var tEventData;
			for (i = 0; i < tEventAniLen; i++) {
				tEventLen = tByte.getInt16();
				tEventArr = [];
				for (j = 0; j < tEventLen; j++) {
					tEventData = new EventData();
					tEventData.name = tByte.getUTFString();
					tEventData.intValue = tByte.getInt32();
					tEventData.floatValue = tByte.getFloat32();
					tEventData.stringValue = tByte.getUTFString();
					tEventData.time = tByte.getFloat32();
					tEventArr.push(tEventData);
				}
				this.eventAniArr.push(tEventArr);
			};
			var tAttachmentLen = tByte.getInt16();
			if (tAttachmentLen > 0) {
				this.attachmentNames = [];
				for (i = 0; i < tAttachmentLen; i++) {
					this.attachmentNames.push(tByte.getUTFString());
				}
			};
			var tBoneSlotLen = tByte.getInt16();
			var tDBBoneSlot;
			var tDBBoneSlotArr;
			for (i = 0; i < tBoneSlotLen; i++) {
				tDBBoneSlot = new BoneSlot();
				tDBBoneSlot.name = tByte.readUTFString();
				tDBBoneSlot.parent = tByte.readUTFString();
				tDBBoneSlot.attachmentName = tByte.readUTFString();
				tDBBoneSlot.srcDisplayIndex = tDBBoneSlot.displayIndex = tByte.getInt16();
				tDBBoneSlot.templet = this;
				this.boneSlotDic[tDBBoneSlot.name] = tDBBoneSlot;
				tDBBoneSlotArr = this.bindBoneBoneSlotDic[tDBBoneSlot.parent];
				if (tDBBoneSlotArr == null) {
					this.bindBoneBoneSlotDic[tDBBoneSlot.parent] = tDBBoneSlotArr = [];
				}
				tDBBoneSlotArr.push(tDBBoneSlot);
				this.boneSlotArray.push(tDBBoneSlot);
			};
			var tNameString = tByte.readUTFString();
			var tNameArray = tNameString.split("\n");
			var tNameStartIndex = 0;
			var tSkinDataLen = tByte.getUint8();
			var tSkinData, tSlotData, tDisplayData;
			var tSlotDataLen = 0, tDisplayDataLen = 0;
			var tUvLen = 0, tWeightLen = 0, tTriangleLen = 0, tVerticeLen = 0, tLengthLen = 0;
			for (i = 0; i < tSkinDataLen; i++) {
				tSkinData = new SkinData();
				tSkinData.name = tNameArray[tNameStartIndex++];
				tSlotDataLen = tByte.getUint8();
				for (j = 0; j < tSlotDataLen; j++) {
					tSlotData = new SlotData();
					tSlotData.name = tNameArray[tNameStartIndex++];
					tDBBoneSlot = this.boneSlotDic[tSlotData.name];
					tDisplayDataLen = tByte.getUint8();
					for (k = 0; k < tDisplayDataLen; k++) {
						tDisplayData = new SkinSlotDisplayData();
						this.skinSlotDisplayDataArr.push(tDisplayData);
						tDisplayData.name = tNameArray[tNameStartIndex++];
						tDisplayData.attachmentName = tNameArray[tNameStartIndex++];
						tDisplayData.transform = new Transform();
						tDisplayData.transform.scX = tByte.getFloat32();
						tDisplayData.transform.skX = tByte.getFloat32();
						tDisplayData.transform.skY = tByte.getFloat32();
						tDisplayData.transform.scY = tByte.getFloat32();
						tDisplayData.transform.x = tByte.getFloat32();
						tDisplayData.transform.y = tByte.getFloat32();
						tSlotData.displayArr.push(tDisplayData);
						tDisplayData.width = tByte.getFloat32();
						tDisplayData.height = tByte.getFloat32();
						tDisplayData.type = tByte.getUint8();
						tDisplayData.verLen = tByte.getUint16();
						tBoneLen = tByte.getUint16();
						if (tBoneLen > 0) {
							tDisplayData.bones = [];
							for (l = 0; l < tBoneLen; l++) {
								var tBoneId = tByte.getUint16();
								tDisplayData.bones.push(tBoneId);
							}
						}
						tUvLen = tByte.getUint16();
						if (tUvLen > 0) {
							tDisplayData.uvs = [];
							for (l = 0; l < tUvLen; l++) {
								tDisplayData.uvs.push(tByte.getFloat32());
							}
						}
						tWeightLen = tByte.getUint16();
						if (tWeightLen > 0) {
							tDisplayData.weights = [];
							for (l = 0; l < tWeightLen; l++) {
								tDisplayData.weights.push(tByte.getFloat32());
							}
						}
						tTriangleLen = tByte.getUint16();
						if (tTriangleLen > 0) {
							tDisplayData.triangles = [];
							for (l = 0; l < tTriangleLen; l++) {
								tDisplayData.triangles.push(tByte.getUint16());
							}
						}
						tVerticeLen = tByte.getUint16();
						if (tVerticeLen > 0) {
							tDisplayData.vertices = [];
							for (l = 0; l < tVerticeLen; l++) {
								tDisplayData.vertices.push(tByte.getFloat32());
							}
						}
						tLengthLen = tByte.getUint16();
						if (tLengthLen > 0) {
							tDisplayData.lengths = [];
							for (l = 0; l < tLengthLen; l++) {
								tDisplayData.lengths.push(tByte.getFloat32());
							}
						}
					}
					tSkinData.slotArr.push(tSlotData);
				}
				this.skinDic[tSkinData.name] = tSkinData;
				this.skinDataArray.push(tSkinData);
			};
			var tReverse = tByte.getUint8();
			if (tReverse == 1) {
				this.yReverseMatrix = new Matrix(1, 0, 0, -1, 0, 0);
				if (tRootBone) {
					tRootBone.setTempMatrix(this.yReverseMatrix);
				}
			} else {
				if (tRootBone) {
					tRootBone.setTempMatrix(new Matrix());
				}
			}
			this.showSkinByIndex(this.boneSlotDic, 0);
			this.isParserComplete = true;
			this.event(/*laya.events.Event.COMPLETE*/"complete", this);
		}

		/**
		*得到指定的纹理
		*@param name 纹理的名字
		*@return
		*/
		__proto.getTexture = function (name) {
			var tTexture = this.subTextureDic[name];
			if (tTexture == null) {
				return this._mainTexture;
			}
			return tTexture;
		}

		/**
		*@private
		*显示指定的皮肤
		*@param boneSlotDic 插糟字典的引用
		*@param skinIndex 皮肤的索引
		*@param freshDisplayIndex 是否重置插槽纹理
		*/
		__proto.showSkinByIndex = function (boneSlotDic, skinIndex, freshDisplayIndex) {
			(freshDisplayIndex === void 0) && (freshDisplayIndex = true);
			if (skinIndex < 0 && skinIndex >= this.skinDataArray.length) return false;
			var i = 0, n = 0;
			var tBoneSlot;
			var tSlotData;
			var tSkinData = this.skinDataArray[skinIndex];
			if (tSkinData) {
				for (i = 0, n = tSkinData.slotArr.length; i < n; i++) {
					tSlotData = tSkinData.slotArr[i];
					if (tSlotData) {
						tBoneSlot = boneSlotDic[tSlotData.name];
						if (tBoneSlot) {
							tBoneSlot.showSlotData(tSlotData, freshDisplayIndex);
							if (freshDisplayIndex && tBoneSlot.attachmentName != "undefined" && tBoneSlot.attachmentName != "null") {
								tBoneSlot.showDisplayByName(tBoneSlot.attachmentName);
							} else {
								tBoneSlot.showDisplayByIndex(tBoneSlot.displayIndex);
							}
						}
					}
				}
				return true;
			}
			return false;
		}

		/**
		*通过皮肤名字得到皮肤索引
		*@param skinName 皮肤名称
		*@return
		*/
		__proto.getSkinIndexByName = function (skinName) {
			var tSkinData;
			for (var i = 0, n = this.skinDataArray.length; i < n; i++) {
				tSkinData = this.skinDataArray[i];
				if (tSkinData.name == skinName) {
					return i;
				}
			}
			return -1;
		}

		/**
		*@private
		*得到缓冲数据
		*@param aniIndex 动画索引
		*@param frameIndex 帧索引
		*@return
		*/
		__proto.getGrahicsDataWithCache = function (aniIndex, frameIndex) {
			return this._graphicsCache[aniIndex][frameIndex];
		}

		/**
		*@private
		*保存缓冲grahpics
		*@param aniIndex 动画索引
		*@param frameIndex 帧索引
		*@param graphics 要保存的数据
		*/
		__proto.setGrahicsDataWithCache = function (aniIndex, frameIndex, graphics) {
			this._graphicsCache[aniIndex][frameIndex] = graphics;
		}

		/**
		*释放纹理
		*/
		__proto.destroy = function () {
			this._isDestroyed = true;
			var tTexture;
		/*for each*/for (var $each_tTexture in this.subTextureDic) {
				tTexture = this.subTextureDic[$each_tTexture];
				if (tTexture)
					tTexture.destroy();
			}
			var $each_tTexture;
		/*for each*/for ($each_tTexture in this._textureDic) {
				tTexture = this._textureDic[$each_tTexture];
				if (tTexture)
					tTexture.destroy();
			};
			var tSkinSlotDisplayData;
			for (var i = 0, n = this.skinSlotDisplayDataArr.length; i < n; i++) {
				tSkinSlotDisplayData = this.skinSlotDisplayDataArr[i];
				tSkinSlotDisplayData.destory();
			}
			this.skinSlotDisplayDataArr.length = 0;
			if (this.url) {
				delete Templet.TEMPLET_DICTIONARY[this.url];
			}
			laya.resource.Resource.prototype.destroy.call(this);
		}

		/**
		*通过索引得动画名称
		*@param index
		*@return
		*/
		__proto.getAniNameByIndex = function (index) {
			var tAni = this.getAnimation(index);
			if (tAni) return tAni.name;
			return null;
		}

		__getset(0, __proto, 'rate', function () {
			return this._rate;
		}, function (v) {
			this._rate = v;
		});

		Templet.LAYA_ANIMATION_VISION = "LAYAANIMATION:1.6.0";
		Templet.TEMPLET_DICTIONARY = null;
		return Templet;
	})(AnimationTemplet)



})(window, document, Laya);

if (typeof define === 'function' && define.amd) {
	define('laya.core', ['require', "exports"], function (require, exports) {
		'use strict';
		Object.defineProperty(exports, '__esModule', { value: true });
		for (var i in Laya) {
			var o = Laya[i];
			o && o.__isclass && (exports[i] = o);
		}
	});
}

(function (window, document, Laya) {
	var __un = Laya.un, __uns = Laya.uns, __static = Laya.static, __class = Laya.class, __getset = Laya.getset, __newvec = Laya.__newvec;

	var Browser = laya.utils.Browser, HTMLCanvas = laya.resource.HTMLCanvas, Handler = laya.utils.Handler, Loader = laya.net.Loader;
	var Point = laya.maths.Point, Rectangle = laya.maths.Rectangle, Render = laya.renders.Render, RenderContext = laya.renders.RenderContext;
	var Sprite = laya.display.Sprite, Texture = laya.resource.Texture;
	/**
	*tiledMap是整个地图的核心
	*地图以层级来划分地图（例如：地表层，植被层，建筑层）
	*每层又以分块（GridSprite)来处理显示对象，只显示在视口区域的区
	*每块又包括N*N个格子（tile)
	*格子类型又分为动画格子跟图片格子两种
	*@author ...
	*/
	//class laya.map.TiledMap
	var TiledMap = (function () {
		var GRect, TileMapAniData, TileSet;
		function TiledMap() {
			//json数据
			this._jsonData = null;
			//存放地图中用到的所有子纹理数据
			this._tileTexSetArr = [];
			//主纹理数据，主要在释放纹理资源时使用
			this._texArray = [];
			//地图信息中的一些基本数据
			this._x = 0;
			//地图的坐标
			this._y = 0;
			//_height=_mapTileH *_mapH
			this._width = 0;
			//地图的宽度
			this._height = 0;
			//地图的高度
			this._mapW = 0;
			//地图的横向格子数
			this._mapH = 0;
			//地图的竖向格子数
			this._mapTileW = 0;
			//tile的宽度
			this._mapTileH = 0;
			//地图的显示对象
			this._mapSprite = null;
			//地图的显示对象
			this._layerArray = [];
			//这里保存所有的MapLayer对象
			this._renderLayerArray = [];
			//这里保存需要渲染的MapLayer对象
			this._gridArray = [];
			//地图块相关的
			this._showGridKey = false;
			//是否显示块边界线（用来调试用）
			this._totalGridNum = 0;
			//一层中的GridSprite的总数
			this._gridW = 0;
			//地图的横向块数
			this._gridH = 0;
			//地图的坚向块数
			this._gridWidth = 450;
			//块的默认宽度
			this._gridHeight = 450;
			//块的默认高度
			this._jsonLoader = null;
			//用来加载JSON文件用的LOADER
			this._loader = null;
			//用来加载纹理数据用的LOADER
			this._tileSetArray = [];
			//用来存放还需要哪些儿纹理等待加载
			this._currTileSet = null;
			//正在加载的纹理需要的数据源
			this._completeHandler = null;
			//上次视口显示的块范围
			this._index = 0;
			this._animationDic = {};
			//需要创建的动画数据
			this._properties = null;
			//当前地图的自定义属性
			this._tileProperties = {};
			//图块属性
			this._tileProperties2 = {};
			//默认的地图类型（具体要看JSON文件）
			this._orientation = "orthogonal";
			//默认的tile渲染顺序（具体要看JSON文件）
			this._renderOrder = "right-down";
			//调试用的颜色组合
			this._colorArray = ["FF", "00", "33", "66"];
			//缩放相关的操作
			this._scale = 1;
			this._pivotScaleX = 0.5;
			this._pivotScaleY = 0.5;
			this._centerX = 0;
			this._centerY = 0;
			/**@private */
			this._viewPortX = 0;
			/**@private */
			this._viewPortY = 0;
			this._viewPortWidth = 0;
			this._viewPortHeight = 0;
			//是否开启线性取样
			this._enableLinear = true;
			//资源的相对路径
			this._resPath = null;
			this._pathArray = null;
			//把地图限制在显示区域
			this._limitRange = false;
			/**
			*快速更新模式是否不可用
			*/
			this._fastDirty = true;
			/**
			*是否自动缓存没有动画的地块
			*/
			this.autoCache = true;
			/**
			*自动缓存类型,地图较大时建议使用normal
			*/
			this.autoCacheType = "normal";
			/**
			*是否合并图层,开启合并图层时，图层属性内可添加layer属性，运行时将会将相邻的layer属性相同的图层进行合并以提高性能
			*/
			this.enableMergeLayer = false;
			/**
			*是否移除被覆盖的格子,地块可添加type属性，type不为0时表示不透明，被不透明地块遮挡的地块将会被剔除以提高性能
			*/
			this.removeCoveredTile = false;
			/**
			*是否显示大格子里显示的贴图数量
			*/
			this.showGridTextureCount = false;
			/**
			*是否调整地块边缘消除缩放导致的缝隙
			*/
			this.antiCrack = true;
			/**
			*是否在加载完成之后cache所有大格子
			*/
			this.cacheAllAfterInit = false;
			this._texutreStartDic = {};
			this._rect = new Rectangle();
			this._paddingRect = new Rectangle();
			this._mapRect = new GRect();
			this._mapLogicRect = new GRect();
			this._mapLastRect = new GRect();
			this._mapSprite = new Sprite();
		}

		__class(TiledMap, 'laya.map.TiledMap');
		var __proto = TiledMap.prototype;
		/**
		*创建地图
		*@param mapName JSON文件名字
		*@param viewRect 视口区域
		*@param completeHandler 地图创建完成的回调函数
		*@param viewRectPadding 视口扩充区域，把视口区域上、下、左、右扩充一下，防止视口移动时的穿帮
		*@param gridSize grid大小
		*@param enableLinear 是否开启线性取样（为false时，可以解决地图黑线的问题，但画质会锐化）
		*@param limitRange 把地图限制在显示区域
		*/
		__proto.createMap = function (mapName, viewRect, completeHandler, viewRectPadding, gridSize, enableLinear, limitRange) {
			(enableLinear === void 0) && (enableLinear = true);
			(limitRange === void 0) && (limitRange = false);
			this._enableLinear = enableLinear;
			this._limitRange = limitRange;
			this._rect.x = viewRect.x;
			this._rect.y = viewRect.y;
			this._rect.width = viewRect.width;
			this._rect.height = viewRect.height;
			this._viewPortWidth = viewRect.width / this._scale;
			this._viewPortHeight = viewRect.height / this._scale;
			this._completeHandler = completeHandler;
			if (viewRectPadding) {
				this._paddingRect.copyFrom(viewRectPadding);
			}
			else {
				this._paddingRect.setTo(0, 0, 0, 0);
			}
			if (gridSize) {
				this._gridWidth = gridSize.x;
				this._gridHeight = gridSize.y;
			};
			var tIndex = mapName.lastIndexOf("/");
			if (tIndex > -1) {
				this._resPath = mapName.substr(0, tIndex);
				this._pathArray = this._resPath.split("/");
			}
			else {
				this._resPath = "";
				this._pathArray = [];
			}
			this._jsonLoader = new Loader();
			this._jsonLoader.once("complete", this, this.onJsonComplete);
			this._jsonLoader.load(mapName,/*laya.net.Loader.JSON*/"json", false);
		}

		/**
		*json文件读取成功后，解析里面的纹理数据，进行加载
		*@param e JSON数据
		*/
		__proto.onJsonComplete = function (e) {
			var tJsonData = this._jsonData = e;
			this._properties = tJsonData.properties;
			this._orientation = tJsonData.orientation;
			this._renderOrder = tJsonData.renderorder;
			this._mapW = tJsonData.width;
			this._mapH = tJsonData.height;
			this._mapTileW = tJsonData.tilewidth;
			this._mapTileH = tJsonData.tileheight;
			this._width = this._mapTileW * this._mapW;
			this._height = this._mapTileH * this._mapH;
			if (this._orientation == "staggered") {
				this._height = (0.5 + this._mapH * 0.5) * this._mapTileH;
			}
			this._mapLastRect.top = this._mapLastRect.bottom = this._mapLastRect.left = this._mapLastRect.right = -1;
			var tArray = tJsonData.tilesets;
			var tileset;
			var tTileSet;
			var i = 0;
			for (i = 0; i < tArray.length; i++) {
				tileset = tArray[i];
				tTileSet = new TileSet();
				tTileSet.init(tileset);
				if (tTileSet.properties && tTileSet.properties.ignore) continue;
				this._tileProperties[i] = tTileSet.tileproperties;
				this.addTileProperties(tTileSet.tileproperties);
				this._tileSetArray.push(tTileSet);
				var tTiles = tileset.tiles;
				if (tTiles) {
					for (var p in tTiles) {
						var tAnimation = tTiles[p].animation;
						if (tAnimation) {
							var tAniData = new TileMapAniData();
							this._animationDic[p] = tAniData;
							tAniData.image = tileset.image;
							for (var j = 0; j < tAnimation.length; j++) {
								var tAnimationItem = tAnimation[j];
								tAniData.mAniIdArray.push(tAnimationItem.tileid);
								tAniData.mDurationTimeArray.push(tAnimationItem.duration);
							}
						}
					}
				}
			}
			this._tileTexSetArr.push(null);
			if (this._tileSetArray.length > 0) {
				tTileSet = this._currTileSet = this._tileSetArray.shift();
				this._loader = new Loader();
				this._loader.once("complete", this, this.onTextureComplete);
				var tPath = this.mergePath(this._resPath, tTileSet.image);
				this._loader.load(tPath,/*laya.net.Loader.IMAGE*/"image", false);
			}
		}

		/**
		*合并路径
		*@param resPath
		*@param relativePath
		*@return
		*/
		__proto.mergePath = function (resPath, relativePath) {
			var tResultPath = "";
			var tImageArray = relativePath.split("/");
			var tParentPathNum = 0;
			var i = 0;
			for (i = tImageArray.length - 1; i >= 0; i--) {
				if (tImageArray[i] == "..") {
					tParentPathNum++;
				}
			}
			if (tParentPathNum == 0) {
				if (this._pathArray.length > 0) {
					tResultPath = resPath + "/" + relativePath;
				}
				else {
					tResultPath = relativePath;
				}
				return tResultPath;
			};
			var tSrcNum = this._pathArray.length - tParentPathNum;
			if (tSrcNum < 0) {
				console.log("[error]path does not exist", this._pathArray, tImageArray, resPath, relativePath);
			}
			for (i = 0; i < tSrcNum; i++) {
				if (i == 0) {
					tResultPath += this._pathArray[i];
				}
				else {
					tResultPath = tResultPath + "/" + this._pathArray[i];
				}
			}
			for (i = tParentPathNum; i < tImageArray.length; i++) {
				tResultPath = tResultPath + "/" + tImageArray[i];
			}
			return tResultPath;
		}

		/**
		*纹理加载完成，如果所有的纹理加载，开始初始化地图
		*@param e 纹理数据
		*/
		__proto.onTextureComplete = function (e) {
			var json = this._jsonData;
			var tTexture = e;
			if (Render.isWebGL && (!this._enableLinear)) {
				tTexture.bitmap.minFifter = 0x2600;
				tTexture.bitmap.magFifter = 0x2600;
				tTexture.bitmap.enableMerageInAtlas = false;
			}
			this._texArray.push(tTexture);
			var tSubTexture = null;
			var tTileSet = this._currTileSet;
			var tTileTextureW = tTileSet.tilewidth;
			var tTileTextureH = tTileSet.tileheight;
			var tImageWidth = tTileSet.imagewidth;
			var tImageHeight = tTileSet.imageheight;
			var tFirstgid = tTileSet.firstgid;
			var tTileWNum = Math.floor((tImageWidth - tTileSet.margin - tTileTextureW) / (tTileTextureW + tTileSet.spacing)) + 1;
			var tTileHNum = Math.floor((tImageHeight - tTileSet.margin - tTileTextureH) / (tTileTextureH + tTileSet.spacing)) + 1;
			var tTileTexSet = null;
			this._texutreStartDic[tTileSet.image] = this._tileTexSetArr.length;
			for (var i = 0; i < tTileHNum; i++) {
				for (var j = 0; j < tTileWNum; j++) {
					tTileTexSet = new TileTexSet();
					tTileTexSet.offX = tTileSet.titleoffsetX;
					tTileTexSet.offY = tTileSet.titleoffsetY - (tTileTextureH - this._mapTileH);
					tTileTexSet.texture = Texture.createFromTexture(tTexture, tTileSet.margin + (tTileTextureW + tTileSet.spacing) * j, tTileSet.margin + (tTileTextureH + tTileSet.spacing) * i, tTileTextureW, tTileTextureH);
					if (this.antiCrack)
						this.adptTexture(tTileTexSet.texture);
					this._tileTexSetArr.push(tTileTexSet);
					tTileTexSet.gid = this._tileTexSetArr.length;
				}
			}
			if (this._tileSetArray.length > 0) {
				tTileSet = this._currTileSet = this._tileSetArray.shift();
				this._loader.once("complete", this, this.onTextureComplete);
				var tPath = this.mergePath(this._resPath, tTileSet.image);
				this._loader.load(tPath,/*laya.net.Loader.IMAGE*/"image", false);
			}
			else {
				this._currTileSet = null;
				this.initMap();
			}
		}

		__proto.adptTexture = function (tex) {
			if (!tex) return;
			var pX = tex.uv[0];
			var pX1 = tex.uv[2];
			var pY = tex.uv[1];
			var pY1 = tex.uv[7];
			var dW = 1 / tex.bitmap.width;
			var dH = 1 / tex.bitmap.height;
			tex.uv[0] = tex.uv[6] = pX + dW;
			tex.uv[2] = tex.uv[4] = pX1 - dW;
			tex.uv[1] = tex.uv[3] = pY + dH;
			tex.uv[5] = tex.uv[7] = pY1 - dH;
		}

		/**
		*初始化地图
		*/
		__proto.initMap = function () {
			var i = 0, n = 0;
			for (var p in this._animationDic) {
				var tAniData = this._animationDic[p];
				var gStart = 0;
				gStart = this._texutreStartDic[tAniData.image];
				var tTileTexSet = this.getTexture(parseInt(p) + gStart);
				if (tAniData.mAniIdArray.length > 0) {
					tTileTexSet.textureArray = [];
					tTileTexSet.durationTimeArray = tAniData.mDurationTimeArray;
					tTileTexSet.isAnimation = true;
					tTileTexSet.animationTotalTime = 0;
					for (i = 0, n = tTileTexSet.durationTimeArray.length; i < n; i++) {
						tTileTexSet.animationTotalTime += tTileTexSet.durationTimeArray[i];
					}
					for (i = 0, n = tAniData.mAniIdArray.length; i < n; i++) {
						var tTexture = this.getTexture(tAniData.mAniIdArray[i] + gStart);
						tTileTexSet.textureArray.push(tTexture);
					}
				}
			}
			this._gridWidth = Math.floor(this._gridWidth / this._mapTileW) * this._mapTileW;
			this._gridHeight = Math.floor(this._gridHeight / this._mapTileH) * this._mapTileH;
			if (this._gridWidth < this._mapTileW) {
				this._gridWidth = this._mapTileW;
			}
			if (this._gridHeight < this._mapTileH) {
				this._gridHeight = this._mapTileH;
			}
			this._gridW = Math.ceil(this._width / this._gridWidth);
			this._gridH = Math.ceil(this._height / this._gridHeight);
			this._totalGridNum = this._gridW * this._gridH;
			for (i = 0; i < this._gridH; i++) {
				var tGridArray = [];
				this._gridArray.push(tGridArray);
				for (var j = 0; j < this._gridW; j++) {
					tGridArray.push(null);
				}
			};
			var tLayerArray = this._jsonData.layers;
			var isFirst = true;
			var tTarLayerID = 1;
			var tLayerTarLayerName;
			var preLayerTarName;
			var preLayer;
			for (var tLayerLoop = 0; tLayerLoop < tLayerArray.length; tLayerLoop++) {
				var tLayerData = tLayerArray[tLayerLoop];
				if (tLayerData.visible == true) {
					var tMapLayer = new MapLayer();
					tMapLayer.init(tLayerData, this);
					if (!this.enableMergeLayer) {
						this._mapSprite.addChild(tMapLayer);
						this._renderLayerArray.push(tMapLayer);
					} else {
						tLayerTarLayerName = tMapLayer.getLayerProperties("layer");
						isFirst = isFirst || (!preLayer) || (tLayerTarLayerName != preLayerTarName);
						if (isFirst) {
							isFirst = false;
							tMapLayer.tarLayer = tMapLayer;
							preLayer = tMapLayer;
							this._mapSprite.addChild(tMapLayer);
							this._renderLayerArray.push(tMapLayer);
						} else {
							tMapLayer.tarLayer = preLayer;
						}
						preLayerTarName = tLayerTarLayerName;
					}
					this._layerArray.push(tMapLayer);
				}
			}
			if (this.removeCoveredTile) {
				this.adptTiledMapData();
			}
			if (this.cacheAllAfterInit) {
				this.cacheAllGrid();
			}
			this.moveViewPort(this._rect.x, this._rect.y);
			Laya.stage.addChild(this.mapSprite());
			if (this._completeHandler != null) {
				this._completeHandler.run();
			}
		}

		//这里应该发送消息，通知上层，地图创建完成
		__proto.addTileProperties = function (tileDataDic) {
			var key;
			for (key in tileDataDic) {
				this._tileProperties2[key] = tileDataDic[key];
			}
		}

		__proto.getTileUserData = function (id, sign, defaultV) {
			if (!this._tileProperties2 || !this._tileProperties2[id] || !(sign in this._tileProperties2[id])) return defaultV;
			return this._tileProperties2[id][sign];
		}

		__proto.adptTiledMapData = function () {
			var i = 0, len = 0;
			len = this._layerArray.length;
			var tLayer;
			var noNeeds = {};
			var tDatas;
			for (i = len - 1; i >= 0; i--) {
				tLayer = this._layerArray[i];
				tDatas = tLayer._mapData;
				if (!tDatas) continue;
				this.removeCoverd(tDatas, noNeeds);
				this.collectCovers(tDatas, noNeeds, i);
			}
		}

		__proto.removeCoverd = function (datas, noNeeds) {
			var i = 0, len = 0;
			len = datas.length;
			for (i = 0; i < len; i++) {
				if (noNeeds[i]) {
					datas[i] = 0;
				}
			}
		}

		__proto.collectCovers = function (datas, noNeeds, layer) {
			var i = 0, len = 0;
			len = datas.length;
			var tTileData = 0;
			var isCover = 0;
			for (i = 0; i < len; i++) {
				tTileData = datas[i];
				if (tTileData > 0) {
					isCover = this.getTileUserData(tTileData - 1, "type", 0);
					if (isCover > 0) {
						noNeeds[i] = tTileData;
					}
				}
			}
		}

		/**
		*得到一块指定的地图纹理
		*@param index 纹理的索引值，默认从1开始
		*@return
		*/
		__proto.getTexture = function (index) {
			if (index < this._tileTexSetArr.length) {
				return this._tileTexSetArr[index];
			}
			return null;
		}

		/**
		*得到地图的自定义属性
		*@param name 属性名称
		*@return
		*/
		__proto.getMapProperties = function (name) {
			if (this._properties) {
				return this._properties[name];
			}
			return null;
		}

		/**
		*得到tile自定义属性
		*@param index 地图块索引
		*@param id 具体的TileSetID
		*@param name 属性名称
		*@return
		*/
		__proto.getTileProperties = function (index, id, name) {
			if (this._tileProperties[index] && this._tileProperties[index][id]) {
				return this._tileProperties[index][id][name];
			}
			return null;
		}

		/**
		*通过纹理索引，生成一个可控制物件
		*@param index 纹理的索引值，默认从1开始
		*@return
		*/
		__proto.getSprite = function (index, width, height) {
			if (0 < this._tileTexSetArr.length) {
				var tGridSprite = new GridSprite();
				tGridSprite.initData(this, true);
				tGridSprite.size(width, height);
				var tTileTexSet = this._tileTexSetArr[index];
				if (tTileTexSet != null && tTileTexSet.texture != null) {
					if (tTileTexSet.isAnimation) {
						var tAnimationSprite = new TileAniSprite();
						this._index++;
						tAnimationSprite.setTileTextureSet(this._index.toString(), tTileTexSet);
						tGridSprite.addAniSprite(tAnimationSprite);
						tGridSprite.addChild(tAnimationSprite);
					}
					else {
						tGridSprite.graphics.drawTexture(tTileTexSet.texture, 0, 0, width, height);
					}
					tGridSprite.drawImageNum++;
				}
				return tGridSprite;
			}
			return null;
		}

		/**
		*设置视口的缩放中心点（例如：scaleX=scaleY=0.5,就是以视口中心缩放）
		*@param scaleX
		*@param scaleY
		*/
		__proto.setViewPortPivotByScale = function (scaleX, scaleY) {
			this._pivotScaleX = scaleX;
			this._pivotScaleY = scaleY;
			this._fastDirty = true;
		}

		/**
		*移动视口
		*@param moveX 视口的坐标x
		*@param moveY 视口的坐标y
		*/
		__proto.moveViewPort = function (moveX, moveY) {
			this._x = -moveX;
			this._y = -moveY;
			if (this._fastDirty) {
				this._rect.x = moveX;
				this._rect.y = moveY;
				this.updateViewPort();
			} else {
				var dx = NaN, dy = NaN;
				dx = moveX - this._rect.x;
				dy = moveY - this._rect.y;
				this._rect.x = moveX;
				this._rect.y = moveY;
				this.updateViewPortFast(dx, dy);
			}
		}

		/**
		*改变视口大小
		*@param moveX 视口的坐标x
		*@param moveY 视口的坐标y
		*@param width 视口的宽
		*@param height 视口的高
		*/
		__proto.changeViewPort = function (moveX, moveY, width, height) {
			if (moveX == this._rect.x && moveY == this._rect.y && width == this._rect.width && height == this._rect.height) return;
			if (width == this._rect.width && height == this._rect.height) {
				this.moveViewPort(moveX, moveY);
				return;
			}
			this._fastDirty = true;
			this._x = -moveX;
			this._y = -moveY;
			this._rect.x = moveX;
			this._rect.y = moveY;
			this._rect.width = width;
			this._rect.height = height;
			this._viewPortWidth = width / this._scale;
			this._viewPortHeight = height / this._scale;
			this.updateViewPort();
		}

		/**
		*在锚点的基础上计算，通过宽和高，重新计算视口
		*@param width 新视口宽
		*@param height 新视口高
		*@param rect 返回的结果
		*@return
		*/
		__proto.changeViewPortBySize = function (width, height, rect) {
			if (rect == null) {
				rect = new Rectangle();
			}
			this._centerX = this._rect.x + this._rect.width * this._pivotScaleX;
			this._centerY = this._rect.y + this._rect.height * this._pivotScaleY;
			rect.x = this._centerX - width * this._pivotScaleX;
			rect.y = this._centerY - height * this._pivotScaleY;
			rect.width = width;
			rect.height = height;
			this.changeViewPort(rect.x, rect.y, rect.width, rect.height);
			return rect;
		}

		/**
		*快速更新视口 ,只有在视口大小和各种缩放信息没有改变时才可以使用这个函数更新
		*@param dx 视口偏移x
		*@param dy 视口偏移y
		*/
		__proto.updateViewPortFast = function (dx, dy) {
			this._centerX += dx;
			this._centerY += dy;
			this._viewPortX += dx;
			this._viewPortY += dy;
			var posChanged = false;
			var dyG = dy / this._gridHeight;
			var dxG = dx / this._gridWidth;
			this._mapLogicRect.top += dyG;
			this._mapLogicRect.bottom += dyG;
			this._mapLogicRect.left += dxG;
			this._mapLogicRect.right += dxG;
			this._mapRect.top = 0 | this._mapLogicRect.top;
			this._mapRect.bottom = 0 | this._mapLogicRect.bottom;
			this._mapRect.left = 0 | this._mapLogicRect.left;
			this._mapRect.right = 0 | this._mapLogicRect.right;
			if (this._mapRect.top != this._mapLastRect.top || this._mapRect.bottom != this._mapLastRect.bottom || this._mapRect.left != this._mapLastRect.left || this._mapRect.right != this._mapLastRect.right) {
				this.clipViewPort();
				this._mapLastRect.top = this._mapRect.top;
				this._mapLastRect.bottom = this._mapRect.bottom;
				this._mapLastRect.left = this._mapRect.left;
				this._mapLastRect.right = this._mapRect.right;
				posChanged = true;
			}; posChanged = posChanged || (dx != 0 || dy != 0);
			if (!posChanged) return;
			this.updateMapLayersPos();
		}

		/**
		*刷新地图层坐标
		*/
		__proto.updateMapLayersPos = function () {
			var tMapLayer;
			var len = this._renderLayerArray.length;
			for (var i = 0; i < len; i++) {
				tMapLayer = this._renderLayerArray[i];
				if (tMapLayer._gridSpriteArray.length > 0) {
					tMapLayer.updateAloneObject();
					tMapLayer.pos(-this._viewPortX, -this._viewPortY);
				}
			}
		}

		/**
		*刷新视口
		*/
		__proto.updateViewPort = function () {
			this._fastDirty = false;
			var dw = this._rect.width * this._pivotScaleX;
			var dh = this._rect.height * this._pivotScaleY;
			this._centerX = this._rect.x + dw;
			this._centerY = this._rect.y + dh;
			var posChanged = false;
			var preValue = this._viewPortX;
			this._viewPortX = this._centerX - dw / this._scale;
			if (preValue != this._viewPortX) {
				posChanged = true;
			} else {
				preValue = this._viewPortY;
			}
			this._viewPortY = this._centerY - dh / this._scale;
			if (!posChanged && preValue != this._viewPortY) {
				posChanged = true;
			}
			if (this._limitRange) {
				var tRight = this._viewPortX + this._viewPortWidth;
				if (tRight > this._width) {
					this._viewPortX = this._width - this._viewPortWidth;
				};
				var tBottom = this._viewPortY + this._viewPortHeight;
				if (tBottom > this._height) {
					this._viewPortY = this._height - this._viewPortHeight;
				}
				if (this._viewPortX < 0) {
					this._viewPortX = 0;
				}
				if (this._viewPortY < 0) {
					this._viewPortY = 0;
				}
			};
			var tPaddingRect = this._paddingRect;
			this._mapLogicRect.top = (this._viewPortY - tPaddingRect.y) / this._gridHeight;
			this._mapLogicRect.bottom = (this._viewPortY + this._viewPortHeight + tPaddingRect.height + tPaddingRect.y) / this._gridHeight;
			this._mapLogicRect.left = (this._viewPortX - tPaddingRect.x) / this._gridWidth;
			this._mapLogicRect.right = (this._viewPortX + this._viewPortWidth + tPaddingRect.width + tPaddingRect.x) / this._gridWidth;
			this._mapRect.top = 0 | this._mapLogicRect.top;
			this._mapRect.bottom = 0 | this._mapLogicRect.bottom;
			this._mapRect.left = 0 | this._mapLogicRect.left;
			this._mapRect.right = 0 | this._mapLogicRect.right;
			if (this._mapRect.top != this._mapLastRect.top || this._mapRect.bottom != this._mapLastRect.bottom || this._mapRect.left != this._mapLastRect.left || this._mapRect.right != this._mapLastRect.right) {
				this.clipViewPort();
				this._mapLastRect.top = this._mapRect.top;
				this._mapLastRect.bottom = this._mapRect.bottom;
				this._mapLastRect.left = this._mapRect.left;
				this._mapLastRect.right = this._mapRect.right;
				posChanged = true;
			}
			if (!posChanged) return;
			this.updateMapLayersPos();
		}

		/**
		*GRID裁剪
		*/
		__proto.clipViewPort = function () {
			var tSpriteNum = 0;
			var tSprite;
			var tIndex = 0;
			var tSub = 0;
			var tAdd = 0;
			var i = 0, j = 0;
			if (this._mapRect.left > this._mapLastRect.left) {
				tSub = this._mapRect.left - this._mapLastRect.left;
				if (tSub > 0) {
					for (j = this._mapLastRect.left; j < this._mapLastRect.left + tSub; j++) {
						for (i = this._mapLastRect.top; i <= this._mapLastRect.bottom; i++) {
							this.hideGrid(j, i);
						}
					}
				}
			}
			else {
				tAdd = Math.min(this._mapLastRect.left, this._mapRect.right + 1) - this._mapRect.left;
				if (tAdd > 0) {
					for (j = this._mapRect.left; j < this._mapRect.left + tAdd; j++) {
						for (i = this._mapRect.top; i <= this._mapRect.bottom; i++) {
							this.showGrid(j, i);
						}
					}
				}
			}
			if (this._mapRect.right > this._mapLastRect.right) {
				tAdd = this._mapRect.right - this._mapLastRect.right;
				if (tAdd > 0) {
					for (j = Math.max(this._mapLastRect.right + 1, this._mapRect.left); j <= this._mapLastRect.right + tAdd; j++) {
						for (i = this._mapRect.top; i <= this._mapRect.bottom; i++) {
							this.showGrid(j, i);
						}
					}
				}
			}
			else {
				tSub = this._mapLastRect.right - this._mapRect.right
				if (tSub > 0) {
					for (j = this._mapRect.right + 1; j <= this._mapRect.right + tSub; j++) {
						for (i = this._mapLastRect.top; i <= this._mapLastRect.bottom; i++) {
							this.hideGrid(j, i);
						}
					}
				}
			}
			if (this._mapRect.top > this._mapLastRect.top) {
				tSub = this._mapRect.top - this._mapLastRect.top;
				if (tSub > 0) {
					for (i = this._mapLastRect.top; i < this._mapLastRect.top + tSub; i++) {
						for (j = this._mapLastRect.left; j <= this._mapLastRect.right; j++) {
							this.hideGrid(j, i);
						}
					}
				}
			}
			else {
				tAdd = Math.min(this._mapLastRect.top, this._mapRect.bottom + 1) - this._mapRect.top;
				if (tAdd > 0) {
					for (i = this._mapRect.top; i < this._mapRect.top + tAdd; i++) {
						for (j = this._mapRect.left; j <= this._mapRect.right; j++) {
							this.showGrid(j, i);
						}
					}
				}
			}
			if (this._mapRect.bottom > this._mapLastRect.bottom) {
				tAdd = this._mapRect.bottom - this._mapLastRect.bottom;
				if (tAdd > 0) {
					for (i = Math.max(this._mapLastRect.bottom + 1, this._mapRect.top); i <= this._mapLastRect.bottom + tAdd; i++) {
						for (j = this._mapRect.left; j <= this._mapRect.right; j++) {
							this.showGrid(j, i);
						}
					}
				}
			}
			else {
				tSub = this._mapLastRect.bottom - this._mapRect.bottom
				if (tSub > 0) {
					for (i = this._mapRect.bottom + 1; i <= this._mapRect.bottom + tSub; i++) {
						for (j = this._mapLastRect.left; j <= this._mapLastRect.right; j++) {
							this.hideGrid(j, i);
						}
					}
				}
			}
		}

		/**
		*显示指定的GRID
		*@param gridX
		*@param gridY
		*/
		__proto.showGrid = function (gridX, gridY) {
			if (gridX < 0 || gridX >= this._gridW || gridY < 0 || gridY >= this._gridH) {
				return;
			};
			var i = 0, j = 0;
			var tGridSprite;
			var tTempArray = this._gridArray[gridY][gridX];
			if (tTempArray == null) {
				tTempArray = this.getGridArray(gridX, gridY);
			}
			else {
				for (i = 0; i < tTempArray.length && i < this._layerArray.length; i++) {
					var tLayerSprite = this._layerArray[i];
					if (tLayerSprite && tTempArray[i]) {
						tGridSprite = tTempArray[i];
						if (tGridSprite.visible == false && tGridSprite.drawImageNum > 0) {
							tGridSprite.show();
						}
					}
				}
			}
		}

		__proto.cacheAllGrid = function () {
			var i = 0, j = 0;
			var tempArr;
			for (i = 0; i < this._gridW; i++) {
				for (j = 0; j < this._gridH; j++) {
					tempArr = this.getGridArray(i, j);
					this.cacheGridsArray(tempArr);
				}
			}
		}

		__proto.cacheGridsArray = function (arr) {
			var canvas;
			if (!TiledMap._tempContext) {
				TiledMap._tempContext = new RenderContext(1, 1, HTMLCanvas.create(/*laya.resource.HTMLCanvas.TYPEAUTO*/"AUTO"));
			}
			canvas = TiledMap._tempContext.canvas;
			canvas.context.asBitmap = false;
			var i = 0, len = 0;
			len = arr.length;
			var tGrid;
			for (i = 0; i < len; i++) {
				tGrid = arr[i];
				canvas.clear();
				canvas.size(1, 1);
				tGrid.render(TiledMap._tempContext, 0, 0);
				tGrid.hide();
			}
			canvas.clear();
			canvas.size(1, 1);
		}

		__proto.getGridArray = function (gridX, gridY) {
			var i = 0, j = 0;
			var tGridSprite;
			var tTempArray = this._gridArray[gridY][gridX];
			if (tTempArray == null) {
				tTempArray = this._gridArray[gridY][gridX] = [];
				var tLeft = 0;
				var tRight = 0;
				var tTop = 0;
				var tBottom = 0;
				var tGridWidth = this._gridWidth;
				var tGridHeight = this._gridHeight;
				switch (this.orientation) {
					case /*CLASS CONST:laya.map.TiledMap.ORIENTATION_ISOMETRIC*/"isometric":
						tLeft = Math.floor(gridX * tGridWidth);
						tRight = Math.floor(gridX * tGridWidth + tGridWidth);
						tTop = Math.floor(gridY * tGridHeight);
						tBottom = Math.floor(gridY * tGridHeight + tGridHeight);
						var tLeft1 = 0, tRight1 = 0, tTop1 = 0, tBottom1 = 0;
						break;
					case /*CLASS CONST:laya.map.TiledMap.ORIENTATION_STAGGERED*/"staggered":
						tLeft = Math.floor(gridX * tGridWidth / this._mapTileW);
						tRight = Math.floor((gridX * tGridWidth + tGridWidth) / this._mapTileW);
						tTop = Math.floor(gridY * tGridHeight / (this._mapTileH / 2));
						tBottom = Math.floor((gridY * tGridHeight + tGridHeight) / (this._mapTileH / 2));
						break;
					case /*CLASS CONST:laya.map.TiledMap.ORIENTATION_ORTHOGONAL*/"orthogonal":
						tLeft = Math.floor(gridX * tGridWidth / this._mapTileW);
						tRight = Math.floor((gridX * tGridWidth + tGridWidth) / this._mapTileW);
						tTop = Math.floor(gridY * tGridHeight / this._mapTileH);
						tBottom = Math.floor((gridY * tGridHeight + tGridHeight) / this._mapTileH);
						break;
					case /*CLASS CONST:laya.map.TiledMap.ORIENTATION_HEXAGONAL*/"hexagonal": ;
						var tHeight = this._mapTileH * 2 / 3;
						tLeft = Math.floor(gridX * tGridWidth / this._mapTileW);
						tRight = Math.ceil((gridX * tGridWidth + tGridWidth) / this._mapTileW);
						tTop = Math.floor(gridY * tGridHeight / tHeight);
						tBottom = Math.ceil((gridY * tGridHeight + tGridHeight) / tHeight);
						break;
				};
				var tLayer = null;
				var tTGridSprite;
				var tDrawMapLayer;
				for (var z = 0; z < this._layerArray.length; z++) {
					tLayer = this._layerArray[z];
					if (this.enableMergeLayer) {
						if (tLayer.tarLayer != tDrawMapLayer) {
							tTGridSprite = null;
							tDrawMapLayer = tLayer.tarLayer;
						}
						if (!tTGridSprite) {
							tTGridSprite = tDrawMapLayer.getDrawSprite(gridX, gridY);
							tTempArray.push(tTGridSprite);
						}
						tGridSprite = tTGridSprite;
					}
					else {
						tGridSprite = tLayer.getDrawSprite(gridX, gridY);
						tTempArray.push(tGridSprite);
					};
					var tColorStr;
					if (this._showGridKey) {
						tColorStr = "#";
						tColorStr += this._colorArray[Math.floor(Math.random() * this._colorArray.length)];
						tColorStr += this._colorArray[Math.floor(Math.random() * this._colorArray.length)];
						tColorStr += this._colorArray[Math.floor(Math.random() * this._colorArray.length)];
					}
					switch (this.orientation) {
						case /*CLASS CONST:laya.map.TiledMap.ORIENTATION_ISOMETRIC*/"isometric": ;
							var tHalfTileHeight = this.tileHeight / 2;
							var tHalfTileWidth = this.tileWidth / 2;
							var tHalfMapWidth = this._width / 2;
							tTop1 = Math.floor(tTop / tHalfTileHeight);
							tBottom1 = Math.floor(tBottom / tHalfTileHeight);
							tLeft1 = this._mapW + Math.floor((tLeft - tHalfMapWidth) / tHalfTileWidth);
							tRight1 = this._mapW + Math.floor((tRight - tHalfMapWidth) / tHalfTileWidth);
							var tMapW = this._mapW * 2;
							var tMapH = this._mapH * 2;
							if (tTop1 < 0) {
								tTop1 = 0;
							}
							if (tTop1 >= tMapH) {
								tTop1 = tMapH - 1;
							}
							if (tBottom1 < 0) {
								tBottom = 0;
							}
							if (tBottom1 >= tMapH) {
								tBottom1 = tMapH - 1;
							}
							tGridSprite.zOrder = this._totalGridNum * z + gridY * this._gridW + gridX;
							for (i = tTop1; i < tBottom1; i++) {
								for (j = 0; j <= i; j++) {
									var tIndexX = i - j;
									var tIndexY = j;
									var tIndexValue = (tIndexX - tIndexY) + this._mapW;
									if (tIndexValue > tLeft1 && tIndexValue <= tRight1) {
										if (tLayer.drawTileTexture(tGridSprite, tIndexX, tIndexY)) {
											tGridSprite.drawImageNum++;
										}
									}
								}
							}
							break;
						case /*CLASS CONST:laya.map.TiledMap.ORIENTATION_STAGGERED*/"staggered":
							tGridSprite.zOrder = z * this._totalGridNum + gridY * this._gridW + gridX;
							for (i = tTop; i < tBottom; i++) {
								for (j = tLeft; j < tRight; j++) {
									if (tLayer.drawTileTexture(tGridSprite, j, i)) {
										tGridSprite.drawImageNum++;
									}
								}
							}
							break;
						case /*CLASS CONST:laya.map.TiledMap.ORIENTATION_ORTHOGONAL*/"orthogonal":
						case /*CLASS CONST:laya.map.TiledMap.ORIENTATION_HEXAGONAL*/"hexagonal":
							switch (this._renderOrder) {
								case "right-down":
									tGridSprite.zOrder = z * this._totalGridNum + gridY * this._gridW + gridX;
									for (i = tTop; i < tBottom; i++) {
										for (j = tLeft; j < tRight; j++) {
											if (tLayer.drawTileTexture(tGridSprite, j, i)) {
												tGridSprite.drawImageNum++;
											}
										}
									}
									break;
								case "right-up":
									tGridSprite.zOrder = z * this._totalGridNum + (this._gridH - 1 - gridY) * this._gridW + gridX;
									for (i = tBottom - 1; i >= tTop; i--) {
										for (j = tLeft; j < tRight; j++) {
											if (tLayer.drawTileTexture(tGridSprite, j, i)) {
												tGridSprite.drawImageNum++;
											}
										}
									}
									break;
								case "left-down":
									tGridSprite.zOrder = z * this._totalGridNum + gridY * this._gridW + (this._gridW - 1 - gridX);
									for (i = tTop; i < tBottom; i++) {
										for (j = tRight - 1; j >= tLeft; j--) {
											if (tLayer.drawTileTexture(tGridSprite, j, i)) {
												tGridSprite.drawImageNum++;
											}
										}
									}
									break;
								case "left-up":
									tGridSprite.zOrder = z * this._totalGridNum + (this._gridH - 1 - gridY) * this._gridW + (this._gridW - 1 - gridX);
									for (i = tBottom - 1; i >= tTop; i--) {
										for (j = tRight - 1; j >= tLeft; j--) {
											if (tLayer.drawTileTexture(tGridSprite, j, i)) {
												tGridSprite.drawImageNum++;
											}
										}
									}
									break;
							}
							break;
					}
					if (!tGridSprite.isHaveAnimation) {
						tGridSprite.autoSize = true;
						if (this.autoCache)
							tGridSprite.cacheAs = this.autoCacheType;
						tGridSprite.autoSize = false;
					}
					if (!this.enableMergeLayer) {
						if (tGridSprite.drawImageNum > 0) {
							tLayer.addChild(tGridSprite);
							tGridSprite.visible = false;
							tGridSprite.show();
						}
						if (this._showGridKey) {
							tGridSprite.graphics.drawRect(0, 0, tGridWidth, tGridHeight, null, tColorStr);
						}
					} else {
						if (tTGridSprite && tTGridSprite.drawImageNum > 0 && tDrawMapLayer) {
							tDrawMapLayer.addChild(tTGridSprite);
							tTGridSprite.visible = false;
							tTGridSprite.show();
						}
					}
				}
				if (this.enableMergeLayer && this.showGridTextureCount) {
					if (tTGridSprite) {
						tTGridSprite.graphics.fillText(tTGridSprite.drawImageNum + "", 20, 20, null, "#ff0000", "left");
					}
				}
			}
			return tTempArray;
		}

		/**
		*隐藏指定的GRID
		*@param gridX
		*@param gridY
		*/
		__proto.hideGrid = function (gridX, gridY) {
			if (gridX < 0 || gridX >= this._gridW || gridY < 0 || gridY >= this._gridH) {
				return;
			};
			var tTempArray = this._gridArray[gridY][gridX];
			if (tTempArray) {
				var tGridSprite;
				for (var i = 0; i < tTempArray.length; i++) {
					tGridSprite = tTempArray[i];
					if (tGridSprite.drawImageNum > 0) {
						if (tGridSprite != null) {
							tGridSprite.hide();
						}
					}
				}
			}
		}

		/**
		*得到对象层上的某一个物品
		*@param layerName 层的名称
		*@param objectName 所找物品的名称
		*@return
		*/
		__proto.getLayerObject = function (layerName, objectName) {
			var tLayer = null;
			for (var i = 0; i < this._layerArray.length; i++) {
				tLayer = this._layerArray[i];
				if (tLayer.layerName == layerName) {
					break;
				}
			}
			if (tLayer) {
				return tLayer.getObjectByName(objectName);
			}
			return null;
		}

		/**
		*销毁地图
		*/
		__proto.destroy = function () {
			this._orientation = "orthogonal";
			this._jsonData = null;
			var i = 0;
			var j = 0;
			var z = 0;
			this._gridArray = [];
			var tTileTexSet;
			for (i = 0; i < this._tileTexSetArr.length; i++) {
				tTileTexSet = this._tileTexSetArr[i];
				if (tTileTexSet) {
					tTileTexSet.clearAll();
				}
			}
			this._tileTexSetArr = [];
			var tTexture;
			for (i = 0; i < this._texArray.length; i++) {
				tTexture = this._texArray[i];
				tTexture.destroy();
			}
			this._texArray = [];
			this._width = 0;
			this._height = 0;
			this._mapW = 0;
			this._mapH = 0;
			this._mapTileW = 0;
			this._mapTileH = 0;
			this._rect.setTo(0, 0, 0, 0);
			var tLayer;
			for (i = 0; i < this._layerArray.length; i++) {
				tLayer = this._layerArray[i];
				tLayer.clearAll();
			}
			this._layerArray = [];
			this._renderLayerArray = [];
			if (this._mapSprite) {
				this._mapSprite.destroy();
				this._mapSprite = null;
			}
			this._jsonLoader = null;
			this._loader = null;
			var tDic = this._animationDic;
			for (var p in tDic) {
				delete tDic[p];
			}
			this._properties = null;
			tDic = this._tileProperties;
			for (p in tDic) {
				delete tDic[p];
			}
			this._currTileSet = null;
			this._completeHandler = null;
			this._mapRect.clearAll();
			this._mapLastRect.clearAll();
			this._tileSetArray = [];
			this._gridWidth = 450;
			this._gridHeight = 450;
			this._gridW = 0;
			this._gridH = 0;
			this._x = 0;
			this._y = 0;
			this._index = 0;
			this._enableLinear = true;
			this._resPath = null;
			this._pathArray = null;
		}

		/**
		*整个地图的显示容器
		*@return 地图的显示容器
		*/
		__proto.mapSprite = function () {
			return this._mapSprite;
		}

		/**
		*得到指定的MapLayer
		*@param layerName 要找的层名称
		*@return
		*/
		__proto.getLayerByName = function (layerName) {
			var tMapLayer;
			for (var i = 0; i < this._layerArray.length; i++) {
				tMapLayer = this._layerArray[i];
				if (layerName == tMapLayer.layerName) {
					return tMapLayer;
				}
			}
			return null;
		}

		/**
		*通过索引得MapLayer
		*@param index 要找的层索引
		*@return
		*/
		__proto.getLayerByIndex = function (index) {
			if (index < this._layerArray.length) {
				return this._layerArray[index];
			}
			return null;
		}

		/**
		*当前地图类型
		*/
		__getset(0, __proto, 'orientation', function () {
			return this._orientation;
		});

		/**
		*@private
		*视口x坐标
		*/
		__getset(0, __proto, 'viewPortX', function () {
			return -this._viewPortX;
		});

		/**
		*设置地图缩放
		*@param scale
		*/
		/**
		*得到当前地图的缩放
		*/
		__getset(0, __proto, 'scale', function () {
			return this._scale;
		}, function (scale) {
			if (scale <= 0)
				return;
			this._scale = scale;
			this._viewPortWidth = this._rect.width / scale;
			this._viewPortHeight = this._rect.height / scale;
			this._mapSprite.scale(this._scale, this._scale);
			this.updateViewPort();
		});

		/**
		*格子的宽度
		*/
		__getset(0, __proto, 'tileWidth', function () {
			return this._mapTileW;
		});

		/**
		*@private
		*视口的y坐标
		*/
		__getset(0, __proto, 'viewPortY', function () {
			return -this._viewPortY;
		});

		/**
		*格子的高度
		*/
		__getset(0, __proto, 'tileHeight', function () {
			return this._mapTileH;
		});

		/**
		*地图的宽度
		*/
		__getset(0, __proto, 'width', function () {
			return this._width;
		});

		/**
		*地图竖向的格子数
		*/
		__getset(0, __proto, 'numRowsTile', function () {
			return this._mapH;
		});

		/**
		*地图横向的格子数
		*/
		__getset(0, __proto, 'numColumnsTile', function () {
			return this._mapW;
		});

		/**
		*地图的高度
		*/
		__getset(0, __proto, 'height', function () {
			return this._height;
		});

		/**
		*@private
		*视口的宽度
		*/
		__getset(0, __proto, 'viewPortWidth', function () {
			return this._viewPortWidth;
		});

		/**
		*@private
		*视口的高度
		*/
		__getset(0, __proto, 'viewPortHeight', function () {
			return this._viewPortHeight;
		});

		/**
		*地图的x坐标
		*/
		__getset(0, __proto, 'x', function () {
			return this._x;
		});

		/**
		*地图的y坐标
		*/
		__getset(0, __proto, 'y', function () {
			return this._y;
		});

		/**
		*块的宽度
		*/
		__getset(0, __proto, 'gridWidth', function () {
			return this._gridWidth;
		});

		/**
		*块的高度
		*/
		__getset(0, __proto, 'gridHeight', function () {
			return this._gridHeight;
		});

		/**
		*地图的横向块数
		*/
		__getset(0, __proto, 'numColumnsGrid', function () {
			return this._gridW;
		});

		/**
		*地图的坚向块数
		*/
		__getset(0, __proto, 'numRowsGrid', function () {
			return this._gridH;
		});

		/**
		*tile渲染顺序
		*/
		__getset(0, __proto, 'renderOrder', function () {
			return this._renderOrder;
		});

		TiledMap.ORIENTATION_ORTHOGONAL = "orthogonal";
		TiledMap.ORIENTATION_ISOMETRIC = "isometric";
		TiledMap.ORIENTATION_STAGGERED = "staggered";
		TiledMap.ORIENTATION_HEXAGONAL = "hexagonal";
		TiledMap.RENDERORDER_RIGHTDOWN = "right-down";
		TiledMap.RENDERORDER_RIGHTUP = "right-up";
		TiledMap.RENDERORDER_LEFTDOWN = "left-down";
		TiledMap.RENDERORDER_LEFTUP = "left-up";
		TiledMap._tempContext = null;
		TiledMap.__init$ = function () {
			//class GRect
			GRect = (function () {
				function GRect() {
					this.left = 0;
					this.top = 0;
					this.right = 0;
					this.bottom = 0;
				}
				__class(GRect, '');
				var __proto = GRect.prototype;
				__proto.clearAll = function () {
					this.left = this.top = this.right = this.bottom = 0;
				}
				return GRect;
			})()
			//class TileMapAniData
			TileMapAniData = (function () {
				function TileMapAniData() {
					this.mAniIdArray = [];
					this.mDurationTimeArray = [];
					this.mTileTexSetArr = [];
					this.image = null;
				}
				__class(TileMapAniData, '');
				return TileMapAniData;
			})()
			//class TileSet
			TileSet = (function () {
				function TileSet() {
					this.firstgid = 0;
					this.image = "";
					this.imageheight = 0;
					this.imagewidth = 0;
					this.margin = 0;
					this.name = 0;
					this.properties = null;
					this.spacing = 0;
					this.tileheight = 0;
					this.tilewidth = 0;
					this.titleoffsetX = 0;
					this.titleoffsetY = 0;
					this.tileproperties = null;
				}
				__class(TileSet, '');
				var __proto = TileSet.prototype;
				__proto.init = function (data) {
					this.firstgid = data.firstgid;
					this.image = data.image;
					this.imageheight = data.imageheight;
					this.imagewidth = data.imagewidth;
					this.margin = data.margin;
					this.name = data.name;
					this.properties = data.properties;
					this.spacing = data.spacing;
					this.tileheight = data.tileheight;
					this.tilewidth = data.tilewidth;
					this.tileproperties = data.tileproperties;
					var tTileoffset = data.tileoffset;
					if (tTileoffset) {
						this.titleoffsetX = tTileoffset.x;
						this.titleoffsetY = tTileoffset.y;
					}
				}
				return TileSet;
			})()
		}

		return TiledMap;
	})()


	/**
	*此类是子纹理类，也包括同类动画的管理
	*TiledMap会把纹理分割成无数子纹理，也可以把其中的某块子纹理替换成一个动画序列
	*本类的实现就是如果发现子纹理被替换成一个动画序列，animationKey会被设为true
	*即animationKey为true,就使用TileAniSprite来做显示，把动画序列根据时间画到TileAniSprite上
	*@author ...
	*/
	//class laya.map.TileTexSet
	var TileTexSet = (function () {
		function TileTexSet() {
			/**唯一标识*/
			this.gid = -1;
			/**子纹理的引用*/
			this.texture = null;
			/**纹理显示时的坐标偏移X*/
			this.offX = 0;
			/**纹理显示时的坐标偏移Y*/
			this.offY = 0;
			/**当前要播放动画的纹理序列*/
			this.textureArray = null;
			/**当前动画每帧的时间间隔*/
			this.durationTimeArray = null;
			/**动画播放的总时间 */
			this.animationTotalTime = 0;
			/**true表示当前纹理，是一组动画，false表示当前只有一个纹理*/
			this.isAnimation = false;
			this._spriteNum = 0;
			//当前动画有多少个显示对象
			this._aniDic = null;
			//通过显示对象的唯一名字，去保存显示显示对象
			this._frameIndex = 0;
			//当前动画播放到第几帧
			this._time = 0;
			//距离上次动画刷新，过了多少长时间
			this._interval = 0;
			//每帧刷新的时间间隔
			this._preFrameTime = 0;
		}

		__class(TileTexSet, 'laya.map.TileTexSet');
		var __proto = TileTexSet.prototype;
		/**
		*加入一个动画显示对象到此动画中
		*@param aniName //显示对象的名字
		*@param sprite //显示对象
		*/
		__proto.addAniSprite = function (aniName, sprite) {
			if (this.animationTotalTime == 0) {
				return;
			}
			if (this._aniDic == null) {
				this._aniDic = {};
			}
			if (this._spriteNum == 0) {
				Laya.timer.frameLoop(3, this, this.animate);
				this._preFrameTime = Browser.now();
				this._frameIndex = 0;
				this._time = 0;
				this._interval = 0;
			}
			this._spriteNum++;
			this._aniDic[aniName] = sprite;
			if (this.textureArray && this._frameIndex < this.textureArray.length) {
				var tTileTextureSet = this.textureArray[this._frameIndex];
				this.drawTexture(sprite, tTileTextureSet);
			}
		}

		/**
		*把动画画到所有注册的SPRITE上
		*/
		__proto.animate = function () {
			if (this.textureArray && this.textureArray.length > 0 && this.durationTimeArray && this.durationTimeArray.length > 0) {
				var tNow = Browser.now();
				this._interval = tNow - this._preFrameTime;
				this._preFrameTime = tNow;
				if (this._interval > this.animationTotalTime) {
					this._interval = this._interval % this.animationTotalTime;
				}
				this._time += this._interval;
				var tTime = this.durationTimeArray[this._frameIndex];
				while (this._time > tTime) {
					this._time -= tTime;
					this._frameIndex++;
					if (this._frameIndex >= this.durationTimeArray.length || this._frameIndex >= this.textureArray.length) {
						this._frameIndex = 0;
					};
					var tTileTextureSet = this.textureArray[this._frameIndex];
					var tSprite;
					for (var p in this._aniDic) {
						tSprite = this._aniDic[p];
						this.drawTexture(tSprite, tTileTextureSet);
					}
					tTime = this.durationTimeArray[this._frameIndex];
				}
			}
		}

		__proto.drawTexture = function (sprite, tileTextSet) {
			sprite.graphics.clear();
			sprite.graphics.drawTexture(tileTextSet.texture, tileTextSet.offX, tileTextSet.offY);
		}

		/**
		*移除不需要更新的SPRITE
		*@param _name
		*/
		__proto.removeAniSprite = function (_name) {
			if (this._aniDic && this._aniDic[_name]) {
				delete this._aniDic[_name];
				this._spriteNum--
				if (this._spriteNum == 0) {
					Laya.timer.clear(this, this.animate);
				}
			}
		}

		/**
		*显示当前动画的使用情况
		*/
		__proto.showDebugInfo = function () {
			var tInfo = null;
			if (this._spriteNum > 0) {
				tInfo = "TileTextureSet::gid:" + this.gid.toString() + " 动画数:" + this._spriteNum.toString();
			}
			return tInfo;
		}

		/**
		*清理
		*/
		__proto.clearAll = function () {
			this.gid = -1;
			if (this.texture) {
				this.texture.destroy();
				this.texture = null;
			}
			this.offX = 0;
			this.offY = 0;
			this.textureArray = null;
			this.durationTimeArray = null;
			this.isAnimation = false;
			this._spriteNum = 0;
			this._aniDic = null;
			this._frameIndex = 0;
			this._preFrameTime = 0;
			this._time = 0;
			this._interval = 0;
		}

		return TileTexSet;
	})()


	/**
	*地图的每层都会分块渲染处理
	*本类就是地图的块数据
	*@author ...
	*/
	//class laya.map.GridSprite extends laya.display.Sprite
	var GridSprite = (function (_super) {
		function GridSprite() {
			/**相对于地图X轴的坐标*/
			this.relativeX = 0;
			/**相对于地图Y轴的坐标*/
			this.relativeY = 0;
			/**是否用于对象层的独立物件*/
			this.isAloneObject = false;
			/**当前GRID中是否有动画*/
			this.isHaveAnimation = false;
			/**当前GRID包含的动画*/
			this.aniSpriteArray = null;
			/**当前GRID包含多少个TILE(包含动画)*/
			this.drawImageNum = 0;
			this._map = null;
			GridSprite.__super.call(this);
		}

		__class(GridSprite, 'laya.map.GridSprite', _super);
		var __proto = GridSprite.prototype;
		/**
		*传入必要的参数，用于裁剪，跟确认此对象类型
		*@param map 把地图的引用传进来，参与一些裁剪计算
		*@param objectKey true:表示当前GridSprite是个活动对象，可以控制，false:地图层的组成块
		*/
		__proto.initData = function (map, objectKey) {
			(objectKey === void 0) && (objectKey = false);
			this._map = map;
			this.isAloneObject = objectKey;
		}

		/**@private */
		__proto._setDisplay = function (value) {
			if (!value) {
				var cc = this._$P.cacheCanvas;
				if (cc && cc.ctx) {
					cc.ctx.canvas.destroy();
					cc.ctx = null;
				};
				var fc = this._$P._filterCache;
				if (fc) {
					fc.destroy();
					fc.recycle();
					this._set$P('_filterCache', null);
				}
				this._$P._isHaveGlowFilter && this._set$P('_isHaveGlowFilter', false);
			}
			_super.prototype._setDisplay.call(this, value);
		}

		/**
		*把一个动画对象绑定到当前GridSprite
		*@param sprite 动画的显示对象
		*/
		__proto.addAniSprite = function (sprite) {
			if (this.aniSpriteArray == null) {
				this.aniSpriteArray = [];
			}
			this.aniSpriteArray.push(sprite);
		}

		/**
		*显示当前GridSprite，并把上面的动画全部显示
		*/
		__proto.show = function () {
			if (!this.visible) {
				this.visible = true;
				if (!this.isAloneObject) {
					var tParent;
					tParent = this.parent;
					if (tParent) {
						tParent.showGridSprite(this);
					}
				}
				if (!Render.isWebGL && this._map.autoCache) {
					this.cacheAs = this._map.autoCacheType;
				}
				if (this.aniSpriteArray == null) {
					return;
				};
				var tAniSprite;
				for (var i = 0; i < this.aniSpriteArray.length; i++) {
					tAniSprite = this.aniSpriteArray[i];
					tAniSprite.show();
				}
			}
		}

		/**
		*隐藏当前GridSprite，并把上面绑定的动画全部移除
		*/
		__proto.hide = function () {
			if (this.visible) {
				this.visible = false;
				if (!this.isAloneObject) {
					var tParent;
					tParent = this.parent;
					if (tParent) {
						tParent.hideGridSprite(this);
					}
				}
				if (!Render.isWebGL && this._map.autoCache) {
					this.cacheAs = "none";
				}
				if (this.aniSpriteArray == null) {
					return;
				};
				var tAniSprite;
				for (var i = 0; i < this.aniSpriteArray.length; i++) {
					tAniSprite = this.aniSpriteArray[i];
					tAniSprite.hide();
				}
			}
		}

		/**
		*刷新坐标，当我们自己控制一个GridSprite移动时，需要调用此函数，手动刷新
		*/
		__proto.updatePos = function () {
			if (this.isAloneObject) {
				if (this._map) {
					this.x = this.relativeX;
					this.y = this.relativeY;
				}
				if (this.x < 0 || this.x > this._map.viewPortWidth || this.y < 0 || this.y > this._map.viewPortHeight) {
					this.hide();
				} else {
					this.show();
				}
			} else {
				if (this._map) {
					this.x = this.relativeX;
					this.y = this.relativeY;
				}
			}
		}

		/**
		*重置当前对象的所有属性
		*/
		__proto.clearAll = function () {
			if (this._map) {
				this._map = null;
			}
			this.visible = false;
			if (this.aniSpriteArray == null) {
				return;
			};
			var tAniSprite;
			for (var i = 0; i < this.aniSpriteArray.length; i++) {
				tAniSprite = this.aniSpriteArray[i];
				tAniSprite.clearAll();
			}
			this.destroy();
			this.relativeX = 0;
			this.relativeY = 0;
			this.isHaveAnimation = false;
			this.aniSpriteArray = null;
			this.drawImageNum = 0;
		}

		return GridSprite;
	})(Sprite)


	/**
	*地图支持多层渲染（例如，地表层，植被层，建筑层等）
	*本类就是层级类
	*@author ...
	*/
	//class laya.map.MapLayer extends laya.display.Sprite
	var MapLayer = (function (_super) {
		function MapLayer() {
			this._map = null;
			this._mapData = null;
			this._tileWidthHalf = 0;
			this._tileHeightHalf = 0;
			this._mapWidthHalf = 0;
			this._mapHeightHalf = 0;
			/**
			*@private
			*/
			this._gridSpriteArray = [];
			this._objDic = null;
			//用来做字典，方便查询
			this._dataDic = null;
			//临时变量
			this._properties = null;
			/**被合到的层*/
			this.tarLayer = null;
			/**当前Layer的名称*/
			this.layerName = null;
			/**
			*当前需要更新的gridSprite列表
			*/
			this._showGridList = [];
			/**
			*活动对象列表,活动对象不管是否显示都需要更新
			*/
			this._aloneObjs = [];
			MapLayer.__super.call(this);
			this._tempMapPos = new Point();
		}

		__class(MapLayer, 'laya.map.MapLayer', _super);
		var __proto = MapLayer.prototype;
		/**
		*解析LAYER数据，以及初始化一些数据
		*@param layerData 地图数据中，layer数据的引用
		*@param map 地图的引用
		*/
		__proto.init = function (layerData, map) {
			this._map = map;
			this._mapData = layerData.data;
			var tHeight = layerData.height;
			var tWidth = layerData.width;
			var tTileW = map.tileWidth;
			var tTileH = map.tileHeight;
			this.layerName = layerData.name;
			this._properties = layerData.properties;
			this.alpha = layerData.opacity;
			this._tileWidthHalf = tTileW / 2;
			this._tileHeightHalf = tTileH / 2;
			this._mapWidthHalf = this._map.width / 2 - this._tileWidthHalf;
			this._mapHeightHalf = this._map.height / 2;
			switch (layerData.type) {
				case "tilelayer":
					break;
				case "objectgroup": ;
					var tObjectGid = 0;
					var tArray = layerData.objects;
					if (tArray.length > 0) {
						this._objDic = {};
						this._dataDic = {};
					};
					var tObjectData;
					var tObjWidth = NaN;
					var tObjHeight = NaN;
					for (var i = 0; i < tArray.length; i++) {
						tObjectData = tArray[i];
						this._dataDic[tObjectData.name] = tObjectData;
						if (tObjectData.visible == true) {
							tObjWidth = tObjectData.width;
							tObjHeight = tObjectData.height;
							var tSprite = map.getSprite(tObjectData.gid, tObjWidth, tObjHeight);
							if (tSprite != null) {
								switch (this._map.orientation) {
									case /*laya.map.TiledMap.ORIENTATION_ISOMETRIC*/"isometric":
										this.getScreenPositionByTilePos(tObjectData.x / tTileH, tObjectData.y / tTileH, Point.TEMP);
										tSprite.pivot(tObjWidth / 2, tObjHeight / 2);
										tSprite.rotation = tObjectData.rotation;
										tSprite.x = tSprite.relativeX = Point.TEMP.x + this._map.viewPortX;
										tSprite.y = tSprite.relativeY = Point.TEMP.y + this._map.viewPortY - tObjHeight / 2;
										break;
									case /*laya.map.TiledMap.ORIENTATION_STAGGERED*/"staggered":
										tSprite.pivot(tObjWidth / 2, tObjHeight / 2);
										tSprite.rotation = tObjectData.rotation;
										tSprite.x = tSprite.relativeX = tObjectData.x + tObjWidth / 2;
										tSprite.y = tSprite.relativeY = tObjectData.y - tObjHeight / 2;
										break;
									case /*laya.map.TiledMap.ORIENTATION_ORTHOGONAL*/"orthogonal":
										tSprite.pivot(tObjWidth / 2, tObjHeight / 2);
										tSprite.rotation = tObjectData.rotation;
										tSprite.x = tSprite.relativeX = tObjectData.x + tObjWidth / 2;
										tSprite.y = tSprite.relativeY = tObjectData.y - tObjHeight / 2;
										break;
									case /*laya.map.TiledMap.ORIENTATION_HEXAGONAL*/"hexagonal":
										tSprite.x = tSprite.relativeX = tObjectData.x;
										tSprite.y = tSprite.relativeY = tObjectData.y;
										break;
								}
								this.addChild(tSprite);
								this._gridSpriteArray.push(tSprite);
								if (tSprite.isAloneObject) {
									this._showGridList.push(tSprite);
									this._aloneObjs.push(tSprite);
								}
								this._objDic[tObjectData.name] = tSprite;
							}
						}
					}
					break;
			}
		}

		/**
		*通过名字获取控制对象，如果找不到返回为null
		*@param objName 所要获取对象的名字
		*@return
		*/
		__proto.getObjectByName = function (objName) {
			if (this._objDic) {
				return this._objDic[objName];
			}
			return null;
		}

		/**
		*通过名字获取数据，如果找不到返回为null
		*@param objName 所要获取对象的名字
		*@return
		*/
		__proto.getObjectDataByName = function (objName) {
			if (this._dataDic) {
				return this._dataDic[objName];
			}
			return null;
		}

		/**
		*得到地图层的自定义属性
		*@param name
		*@return
		*/
		__proto.getLayerProperties = function (name) {
			if (this._properties) {
				return this._properties[name];
			}
			return null;
		}

		/**
		*得到指定格子的数据
		*@param tileX 格子坐标X
		*@param tileY 格子坐标Y
		*@return
		*/
		__proto.getTileData = function (tileX, tileY) {
			if (tileY >= 0 && tileY < this._map.numRowsTile && tileX >= 0 && tileX < this._map.numColumnsTile) {
				var tIndex = tileY * this._map.numColumnsTile + tileX;
				var tMapData = this._mapData;
				if (tMapData != null && tIndex < tMapData.length) {
					return tMapData[tIndex];
				}
			}
			return 0;
		}

		/**
		*通过地图坐标得到屏幕坐标
		*@param tileX 格子坐标X
		*@param tileY 格子坐标Y
		*@param screenPos 把计算好的屏幕坐标数据，放到此对象中
		*/
		__proto.getScreenPositionByTilePos = function (tileX, tileY, screenPos) {
			if (screenPos) {
				switch (this._map.orientation) {
					case /*laya.map.TiledMap.ORIENTATION_ISOMETRIC*/"isometric":
						screenPos.x = this._map.width / 2 - (tileY - tileX) * this._tileWidthHalf;
						screenPos.y = (tileY + tileX) * this._tileHeightHalf;
						break;
					case /*laya.map.TiledMap.ORIENTATION_STAGGERED*/"staggered":
						tileX = Math.floor(tileX);
						tileY = Math.floor(tileY);
						screenPos.x = tileX * this._map.tileWidth + (tileY & 1) * this._tileWidthHalf;
						screenPos.y = tileY * this._tileHeightHalf;
						break;
					case /*laya.map.TiledMap.ORIENTATION_ORTHOGONAL*/"orthogonal":
						screenPos.x = tileX * this._map.tileWidth;
						screenPos.y = tileY * this._map.tileHeight;
						break;
					case /*laya.map.TiledMap.ORIENTATION_HEXAGONAL*/"hexagonal":
						tileX = Math.floor(tileX);
						tileY = Math.floor(tileY);
						var tTileHeight = this._map.tileHeight * 2 / 3;
						screenPos.x = (tileX * this._map.tileWidth + tileY % 2 * this._tileWidthHalf) % this._map.gridWidth;
						screenPos.y = (tileY * tTileHeight) % this._map.gridHeight;
						break;
				}
				screenPos.x = (screenPos.x + this._map.viewPortX) * this._map.scale;
				screenPos.y = (screenPos.y + this._map.viewPortY) * this._map.scale;
			}
		}

		/**
		*通过屏幕坐标来获取选中格子的数据
		*@param screenX 屏幕坐标x
		*@param screenY 屏幕坐标y
		*@return
		*/
		__proto.getTileDataByScreenPos = function (screenX, screenY) {
			var tData = 0;
			if (this.getTilePositionByScreenPos(screenX, screenY, this._tempMapPos)) {
				tData = this.getTileData(Math.floor(this._tempMapPos.x), Math.floor(this._tempMapPos.y));
			}
			return tData;
		}

		/**
		*通过屏幕坐标来获取选中格子的索引
		*@param screenX 屏幕坐标x
		*@param screenY 屏幕坐标y
		*@param result 把计算好的格子坐标，放到此对象中
		*@return
		*/
		__proto.getTilePositionByScreenPos = function (screenX, screenY, result) {
			screenX = screenX / this._map.scale - this._map.viewPortX;
			screenY = screenY / this._map.scale - this._map.viewPortY;
			var tTileW = this._map.tileWidth;
			var tTileH = this._map.tileHeight;
			var tV = 0;
			var tU = 0;
			switch (this._map.orientation) {
				case /*laya.map.TiledMap.ORIENTATION_ISOMETRIC*/"isometric": ;
					var tDirX = screenX - this._map.width / 2;
					var tDirY = screenY;
					tV = -(tDirX / tTileW - tDirY / tTileH);
					tU = tDirX / tTileW + tDirY / tTileH;
					if (result) {
						result.x = tU;
						result.y = tV;
					}
					return true;
					break;
				case /*laya.map.TiledMap.ORIENTATION_STAGGERED*/"staggered":
					if (result) {
						var cx = 0, cy = 0, rx = 0, ry = 0;
						cx = Math.floor(screenX / tTileW) * tTileW + tTileW / 2;
						cy = Math.floor(screenY / tTileH) * tTileH + tTileH / 2;
						rx = (screenX - cx) * tTileH / 2;
						ry = (screenY - cy) * tTileW / 2;
						if (Math.abs(rx) + Math.abs(ry) <= tTileW * tTileH / 4) {
							tU = Math.floor(screenX / tTileW);
							tV = Math.floor(screenY / tTileH) * 2;
						} else {
							screenX = screenX - tTileW / 2;
							tU = Math.floor(screenX / tTileW) + 1;
							screenY = screenY - tTileH / 2;
							tV = Math.floor(screenY / tTileH) * 2 + 1;
						}
						result.x = tU - (tV & 1);
						result.y = tV;
					}
					return true;
					break;
				case /*laya.map.TiledMap.ORIENTATION_ORTHOGONAL*/"orthogonal":
					tU = screenX / tTileW;
					tV = screenY / tTileH;
					if (result) {
						result.x = tU;
						result.y = tV;
					}
					return true;
					break;
				case /*laya.map.TiledMap.ORIENTATION_HEXAGONAL*/"hexagonal": ;
					var tTileHeight = tTileH * 2 / 3;
					tV = screenY / tTileHeight;
					tU = (screenX - tV % 2 * this._tileWidthHalf) / tTileW;
					if (result) {
						result.x = tU;
						result.y = tV;
					}
					break;
			}
			return false;
		}

		/**
		*得到一个GridSprite
		*@param gridX 当前Grid的X轴索引
		*@param gridY 当前Grid的Y轴索引
		*@return 一个GridSprite对象
		*/
		__proto.getDrawSprite = function (gridX, gridY) {
			var tSprite = new GridSprite();
			tSprite.relativeX = gridX * this._map.gridWidth;
			tSprite.relativeY = gridY * this._map.gridHeight;
			tSprite.initData(this._map);
			tSprite.updatePos();
			this._gridSpriteArray.push(tSprite);
			return tSprite;
		}

		/**
		*将gridSprite设为显示状态
		*@param gridSprite
		*/
		__proto.showGridSprite = function (gridSprite) {
			var gridList = this._showGridList;
			var i = 0, len = 0;
			len = gridList.length;
			var ok_i = -1;
			var tGridSprite;
			for (i = 0; i < len; i++) {
				tGridSprite = gridList[i];
				if (tGridSprite == gridSprite) return;
				if (!tGridSprite.isAloneObject && !tGridSprite.visible) {
					ok_i = i;
				}
			}
			if (ok_i >= 0) {
				gridList[ok_i] = gridSprite;
			} else {
				gridList.push(gridSprite);
			}
		}

		/**
		*将gridSprite设为隐藏状态
		*@param gridSprite
		*
		*/
		__proto.hideGridSprite = function (gridSprite) {
			gridSprite.visible = false;
		}

		/**
		*更新此层中块的坐标
		*手动刷新的目的是，保持层级的宽和高保持最小，加快渲染
		*/
		__proto.updateGridPos = function () {
			var tSprite;
			var tList;
			tList = this._showGridList;
			var len = 0;
			len = tList.length;
			for (var i = 0; i < len; i++) {
				tSprite = tList[i];
				if ((tSprite._style.visible || tSprite.isAloneObject) && tSprite.drawImageNum > 0) {
					tSprite.updatePos();
				}
			}
		}

		/**
		*更新此层中的活动对象
		*/
		__proto.updateAloneObject = function () {
			var tSprite;
			var tList;
			tList = this._aloneObjs;
			var len = 0;
			len = tList.length;
			for (var i = 0; i < len; i++) {
				tSprite = tList[i];
				if (tSprite.drawImageNum > 0) {
					tSprite.updatePos();
				}
			}
		}

		/**
		*渲染时使用需要更新的列表进行渲染，减少遍历
		*@param context
		*@param x
		*@param y
		*
		*/
		__proto.render = function (context, x, y) {
			var childs = this._childs;
			this._childs = this._showGridList;
			_super.prototype.render.call(this, context, x, y);
			this._childs = childs;
		}

		/**
		*@private
		*把tile画到指定的显示对象上
		*@param gridSprite 被指定显示的目标
		*@param tileX 格子的X轴坐标
		*@param tileY 格子的Y轴坐标
		*@return
		*/
		__proto.drawTileTexture = function (gridSprite, tileX, tileY) {
			if (tileY >= 0 && tileY < this._map.numRowsTile && tileX >= 0 && tileX < this._map.numColumnsTile) {
				var tIndex = tileY * this._map.numColumnsTile + tileX;
				var tMapData = this._mapData;
				if (tMapData != null && tIndex < tMapData.length) {
					if (tMapData[tIndex] != 0) {
						var tTileTexSet = this._map.getTexture(tMapData[tIndex]);
						if (tTileTexSet) {
							var tX = 0;
							var tY = 0;
							var tTexture = tTileTexSet.texture;
							switch (this._map.orientation) {
								case /*laya.map.TiledMap.ORIENTATION_STAGGERED*/"staggered":
									tX = tileX * this._map.tileWidth % this._map.gridWidth + (tileY & 1) * this._tileWidthHalf;
									tY = tileY * this._tileHeightHalf % this._map.gridHeight;
									break;
								case /*laya.map.TiledMap.ORIENTATION_ORTHOGONAL*/"orthogonal":
									tX = tileX * this._map.tileWidth % this._map.gridWidth;
									tY = tileY * this._map.tileHeight % this._map.gridHeight;
									break;
								case /*laya.map.TiledMap.ORIENTATION_ISOMETRIC*/"isometric":
									tX = (this._mapWidthHalf + (tileX - tileY) * this._tileWidthHalf) % this._map.gridWidth;
									tY = ((tileX + tileY) * this._tileHeightHalf) % this._map.gridHeight;
									break;
								case /*laya.map.TiledMap.ORIENTATION_HEXAGONAL*/"hexagonal": ;
									var tTileHeight = this._map.tileHeight * 2 / 3;
									tX = (tileX * this._map.tileWidth + tileY % 2 * this._tileWidthHalf) % this._map.gridWidth;
									tY = (tileY * tTileHeight) % this._map.gridHeight;
									break;
							}
							if (tTileTexSet.isAnimation) {
								var tAnimationSprite = new TileAniSprite();
								tAnimationSprite.x = tX;
								tAnimationSprite.y = tY;
								tAnimationSprite.setTileTextureSet(tIndex.toString(), tTileTexSet);
								gridSprite.addAniSprite(tAnimationSprite);
								gridSprite.addChild(tAnimationSprite);
								gridSprite.isHaveAnimation = true;
							} else {
								gridSprite.graphics.drawTexture(tTileTexSet.texture, tX + tTileTexSet.offX, tY + tTileTexSet.offY);
							}
							return true;
						}
					}
				}
			}
			return false;
		}

		/**
		*@private
		*清理当前对象
		*/
		__proto.clearAll = function () {
			this._map = null;
			this._mapData = null;
			this._tileWidthHalf = 0;
			this._tileHeightHalf = 0;
			this._mapWidthHalf = 0;
			this._mapHeightHalf = 0;
			this.layerName = null;
			var i = 0;
			if (this._objDic) {
				for (var p in this._objDic) {
					delete this._objDic[p];
				}
				this._objDic = null;
			}
			if (this._dataDic) {
				for (p in this._dataDic) {
					delete this._dataDic[p];
				}
				this._dataDic = null;
			};
			var tGridSprite;
			for (i = 0; i < this._gridSpriteArray.length; i++) {
				tGridSprite = this._gridSpriteArray[i];
				tGridSprite.clearAll();
			}
			this._properties = null;
			this._tempMapPos = null;
			this.tarLayer = null;
		}

		return MapLayer;
	})(Sprite)


	/**
	*TildMap的动画显示对象（一个动画（TileTexSet），可以绑定多个动画显示对象（TileAniSprite））
	*@author ...
	*/
	//class laya.map.TileAniSprite extends laya.display.Sprite
	var TileAniSprite = (function (_super) {
		function TileAniSprite() {
			this._tileTextureSet = null;
			//动画的引用
			this._aniName = null;
			TileAniSprite.__super.call(this);
		}

		__class(TileAniSprite, 'laya.map.TileAniSprite', _super);
		var __proto = TileAniSprite.prototype;
		/**
		*确定当前显示对象的名称以及属于哪个动画
		*@param aniName 当前动画显示对象的名字，名字唯一
		*@param tileTextureSet 当前显示对象属于哪个动画（一个动画，可以绑定多个同类显示对象）
		*/
		__proto.setTileTextureSet = function (aniName, tileTextureSet) {
			this._aniName = aniName;
			this._tileTextureSet = tileTextureSet;
			tileTextureSet.addAniSprite(this._aniName, this);
		}

		/**
		*把当前动画加入到对应的动画刷新列表中
		*/
		__proto.show = function () {
			this._tileTextureSet.addAniSprite(this._aniName, this);
		}

		/**
		*把当前动画从对应的动画刷新列表中移除
		*/
		__proto.hide = function () {
			this._tileTextureSet.removeAniSprite(this._aniName);
		}

		/**
		*清理
		*/
		__proto.clearAll = function () {
			this._tileTextureSet.removeAniSprite(this._aniName);
			this.destroy();
			this._tileTextureSet = null;
			this._aniName = null;
		}

		return TileAniSprite;
	})(Sprite)


	Laya.__init([TiledMap]);
})(window, document, Laya);

if (typeof define === 'function' && define.amd) {
	define('laya.core', ['require', "exports"], function (require, exports) {
		'use strict';
		Object.defineProperty(exports, '__esModule', { value: true });
		for (var i in Laya) {
			var o = Laya[i];
			o && o.__isclass && (exports[i] = o);
		}
	});
}


(function (window, document, Laya) {
	var __un = Laya.un, __uns = Laya.uns, __static = Laya.static, __class = Laya.class, __getset = Laya.getset, __newvec = Laya.__newvec;

	var Bitmap = laya.resource.Bitmap, Browser = laya.utils.Browser, Event = laya.events.Event, EventDispatcher = laya.events.EventDispatcher;
	var Handler = laya.utils.Handler, Rectangle = laya.maths.Rectangle, Render = laya.renders.Render, Sprite = laya.display.Sprite;
	var Stage = laya.display.Stage, Texture = laya.resource.Texture, Utils = laya.utils.Utils, WebGL = laya.webgl.WebGL;
	var WebGLContext = laya.webgl.WebGLContext;
	/**
	*使用前可用<code>supported</code>查看浏览器支持。
	*/
	//class laya.device.geolocation.Geolocation
	var Geolocation = (function () {
		function Geolocation() { }
		__class(Geolocation, 'laya.device.geolocation.Geolocation');
		Geolocation.getCurrentPosition = function (onSuccess, onError) {
			Geolocation.navigator.geolocation.getCurrentPosition(function (pos) {
				Geolocation.position.setPosition(pos);
				onSuccess.runWith(Geolocation.position);
			},
				function (error) {
					onError.runWith(error);
				}, {
					enableHighAccuracy: laya.device.geolocation.Geolocation.enableHighAccuracy,
					timeout: laya.device.geolocation.Geolocation.timeout,
					maximumAge: laya.device.geolocation.Geolocation.maximumAge
				});
		}

		Geolocation.watchPosition = function (onSuccess, onError) {
			return Geolocation.navigator.geolocation.watchPosition(function (pos) {
				Geolocation.position.setPosition(pos);
				onSuccess.runWith(Geolocation.position);
			},
				function (error) {
					onError.runWith(error);
				}, {
					enableHighAccuracy: Geolocation.enableHighAccuracy,
					timeout: Geolocation.timeout,
					maximumAge: Geolocation.maximumAge
				});
		}

		Geolocation.clearWatch = function (id) {
			Geolocation.navigator.geolocation.clearWatch(id);
		}

		Geolocation.PERMISSION_DENIED = 1;
		Geolocation.POSITION_UNAVAILABLE = 2;
		Geolocation.TIMEOUT = 3;
		Geolocation.enableHighAccuracy = false;
		Geolocation.maximumAge = 0;
		__static(Geolocation,
			['navigator', function () { return this.navigator = Browser.window.navigator; }, 'position', function () { return this.position = new GeolocationInfo(); }, 'supported', function () { return this.supported = !!Geolocation.navigator.geolocation; }, 'timeout', function () { return this.timeout = 1E10; }
			]);
		return Geolocation;
	})()


	//class laya.device.geolocation.GeolocationInfo
	var GeolocationInfo = (function () {
		function GeolocationInfo() {
			this.pos = null;
			this.coords = null;
		}

		__class(GeolocationInfo, 'laya.device.geolocation.GeolocationInfo');
		var __proto = GeolocationInfo.prototype;
		__proto.setPosition = function (pos) {
			this.pos = pos;
			this.coords = pos.coords;
		}

		__getset(0, __proto, 'heading', function () {
			return this.coords.heading;
		});

		__getset(0, __proto, 'latitude', function () {
			return this.coords.latitude;
		});

		__getset(0, __proto, 'altitudeAccuracy', function () {
			return this.coords.altitudeAccuracy;
		});

		__getset(0, __proto, 'longitude', function () {
			return this.coords.longitude;
		});

		__getset(0, __proto, 'altitude', function () {
			return this.coords.altitude;
		});

		__getset(0, __proto, 'accuracy', function () {
			return this.coords.accuracy;
		});

		__getset(0, __proto, 'speed', function () {
			return this.coords.speed;
		});

		__getset(0, __proto, 'timestamp', function () {
			return this.pos.timestamp;
		});

		return GeolocationInfo;
	})()


	/**
	*Media用于捕捉摄像头和麦克风。可以捕捉任意之一，或者同时捕捉两者。<code>getCamera</code>前可以使用<code>supported()</code>检查当前浏览器是否支持。
	*<b>NOTE:</b>
	*<p>目前Media在移动平台只支持Android，不支持IOS。只可在FireFox完整地使用，Chrome测试时无法捕捉视频。</p>
	*/
	//class laya.device.media.Media
	var Media = (function () {
		function Media() { }
		__class(Media, 'laya.device.media.Media');
		Media.supported = function () {
			return !!Browser.window.navigator.getUserMedia;
		}

		Media.getMedia = function (options, onSuccess, onError) {
			if (Browser.window.navigator.getUserMedia) {
				Browser.window.navigator.getUserMedia(options, function (stream) {
					onSuccess.runWith(Browser.window.URL.createObjectURL(stream));
				}, function (err) {
					onError.runWith(err);
				});
			}
		}

		Media.__init$ = function () {
		/*__JS__ */navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia;;
		}

		return Media;
	})()


	/**
	*加速度x/y/z的单位均为m/s²。
	*在硬件（陀螺仪）不支持的情况下，alpha、beta和gamma值为null。
	*
	*@author Survivor
	*/
	//class laya.device.motion.AccelerationInfo
	var AccelerationInfo = (function () {
		function AccelerationInfo() {
			/**
			*x轴上的加速度值。
			*/
			this.x = NaN;
			/**
			*y轴上的加速度值。
			*/
			this.y = NaN;
			/**
			*z轴上的加速度值。
			*/
			this.z = NaN;
		}

		__class(AccelerationInfo, 'laya.device.motion.AccelerationInfo');
		return AccelerationInfo;
	})()


	/**
	*保存旋转信息的类。请勿修改本类的属性。
	*@author Survivor
	*/
	//class laya.device.motion.RotationInfo
	var RotationInfo = (function () {
		function RotationInfo() {
			/**
			*<p>
			*指示设备是否可以提供绝对方位数据（指向地球坐标系），或者设备决定的任意坐标系。
			*关于坐标系参见<i>https://developer.mozilla.org/en-US/docs/Web/Guide/Events/Orientation_and_motion_data_explained</i>。
			*</p>
			*需要注意的是，IOS环境下，该值始终为false。即使如此，你依旧可以从<code>alpha</code>中取得正确的值。
			*/
			this.absolute = false;
			/**
			*Z轴旋转角度，其值范围从0至360。
			*若<code>absolute</code>为true或者在IOS中，alpha值是从北方到当前设备方向的角度值。
			*/
			this.alpha = NaN;
			/**
			*X轴旋转角度,其值范围从-180至180。代表设备从前至后的运动。
			*/
			this.beta = NaN;
			/**
			*Y轴旋转角度，其值范围从-90至90。代表设备从左至右的运动。
			*/
			this.gamma = NaN;
			/**
			*罗盘数据的精确度（角度）。仅IOS可用。
			*/
			this.compassAccuracy = NaN;
		}

		__class(RotationInfo, 'laya.device.motion.RotationInfo');
		return RotationInfo;
	})()


	/**
	*Accelerator.instance获取唯一的Accelerator引用，请勿调用构造函数。
	*
	*<p>
	*listen()的回调处理器接受四个参数：
	*<ol>
	*<li><b>acceleration</b>:表示用户给予设备的加速度。</li>
	*<li><b>accelerationIncludingGravity</b>:设备受到的总加速度（包含重力）。</li>
	*<li><b>rotationRate</b>:设备的自转速率。</li>
	*<li><b>interval</b>:加速度获取的时间间隔（毫秒）。</li>
	*</ol>
	*</p>
	*<p>
	*<b>NOTE</b><br/>
	*如，rotationRate的alpha在apple和moz文档中都是z轴旋转角度，但是实测是x轴旋转角度。为了使各属性表示的值与文档所述相同，实际值与其他属性进行了对调。
	*其中：
	*<ul>
	*<li>alpha使用gamma值。</li>
	*<li>beta使用alpha值。</li>
	*<li>gamma使用beta。</li>
	*</ul>
	*目前孰是孰非尚未可知，以此为注。
	*</p>
	*/
	//class laya.device.motion.Accelerator extends laya.events.EventDispatcher
	var Accelerator = (function (_super) {
		function Accelerator(singleton) {
			Accelerator.__super.call(this);
		/*__JS__ */this.onDeviceOrientationChange = this.onDeviceOrientationChange.bind(this);
		}

		__class(Accelerator, 'laya.device.motion.Accelerator', _super);
		var __proto = Accelerator.prototype;
		/**
		*侦听加速器运动。
		*@param observer 回调函数接受4个参数，见类说明。
		*/
		__proto.on = function (type, caller, listener, args) {
			_super.prototype.on.call(this, type, caller, listener, args);
			Browser.window.addEventListener('devicemotion', this.onDeviceOrientationChange);
			return this;
		}

		/**
		*取消侦听加速器。
		*@param handle 侦听加速器所用处理器。
		*/
		__proto.off = function (type, caller, listener, onceOnly) {
			(onceOnly === void 0) && (onceOnly = false);
			if (!this.hasListener(type))
				Browser.window.removeEventListener('devicemotion', this.onDeviceOrientationChange)
			return _super.prototype.off.call(this, type, caller, listener, onceOnly);
		}

		__proto.onDeviceOrientationChange = function (e) {
			var interval = e.interval;
			Accelerator.acceleration.x = e.acceleration.x;
			Accelerator.acceleration.y = e.acceleration.y;
			Accelerator.acceleration.z = e.acceleration.z;
			Accelerator.accelerationIncludingGravity.x = e.accelerationIncludingGravity.x;
			Accelerator.accelerationIncludingGravity.y = e.accelerationIncludingGravity.y;
			Accelerator.accelerationIncludingGravity.z = e.accelerationIncludingGravity.z;
			Accelerator.rotationRate.alpha = e.rotationRate.gamma * -1;
			Accelerator.rotationRate.beta = e.rotationRate.alpha * -1;
			Accelerator.rotationRate.gamma = e.rotationRate.beta;
			if (Browser.onAndriod) {
				if (Accelerator.onChrome) {
					Accelerator.rotationRate.alpha *= 180 / Math.PI;
					Accelerator.rotationRate.beta *= 180 / Math.PI;
					Accelerator.rotationRate.gamma *= 180 / Math.PI;
				}
				Accelerator.acceleration.x *= -1;
				Accelerator.accelerationIncludingGravity.x *= -1;
			}
			else if (Browser.onIOS) {
				Accelerator.acceleration.y *= -1;
				Accelerator.acceleration.z *= -1;
				Accelerator.accelerationIncludingGravity.y *= -1;
				Accelerator.accelerationIncludingGravity.z *= -1;
				interval *= 1000;
			}
			this.event(/*laya.events.Event.CHANGE*/"change", [Accelerator.acceleration, Accelerator.accelerationIncludingGravity, Accelerator.rotationRate, interval]);
		}

		__getset(1, Accelerator, 'instance', function () {
			Accelerator._instance = Accelerator._instance || new Accelerator(0)
			return Accelerator._instance;
		}, laya.events.EventDispatcher._$SET_instance);

		Accelerator.getTransformedAcceleration = function (acceleration) {
			Accelerator.transformedAcceleration = Accelerator.transformedAcceleration || new AccelerationInfo();
			Accelerator.transformedAcceleration.z = acceleration.z;
			if (Browser.window.orientation == 90) {
				Accelerator.transformedAcceleration.x = acceleration.y;
				Accelerator.transformedAcceleration.y = -acceleration.x;
			}
			else if (Browser.window.orientation == -90) {
				Accelerator.transformedAcceleration.x = -acceleration.y;
				Accelerator.transformedAcceleration.y = acceleration.x;
			}
			else if (!Browser.window.orientation) {
				Accelerator.transformedAcceleration.x = acceleration.x;
				Accelerator.transformedAcceleration.y = acceleration.y;
			}
			else if (Browser.window.orientation == 180) {
				Accelerator.transformedAcceleration.x = -acceleration.x;
				Accelerator.transformedAcceleration.y = -acceleration.y;
			};
			var tx = NaN;
			if (Laya.stage.canvasDegree == -90) {
				tx = Accelerator.transformedAcceleration.x;
				Accelerator.transformedAcceleration.x = -Accelerator.transformedAcceleration.y;
				Accelerator.transformedAcceleration.y = tx;
			}
			else if (Laya.stage.canvasDegree == 90) {
				tx = Accelerator.transformedAcceleration.x;
				Accelerator.transformedAcceleration.x = Accelerator.transformedAcceleration.y;
				Accelerator.transformedAcceleration.y = -tx;
			}
			return Accelerator.transformedAcceleration;
		}

		Accelerator._instance = null;
		Accelerator.transformedAcceleration = null;
		__static(Accelerator,
			['acceleration', function () { return this.acceleration = new AccelerationInfo(); }, 'accelerationIncludingGravity', function () { return this.accelerationIncludingGravity = new AccelerationInfo(); }, 'rotationRate', function () { return this.rotationRate = new RotationInfo(); }, 'onChrome', function () { return this.onChrome = (Browser.userAgent.indexOf("Chrome") > -1); }
			]);
		return Accelerator;
	})(EventDispatcher)


	/**
	*使用Gyroscope.instance获取唯一的Gyroscope引用，请勿调用构造函数。
	*
	*<p>
	*listen()的回调处理器接受两个参数：
	*<code>function onOrientationChange(absolute:Boolean,info:RotationInfo):void</code>
	*<ol>
	*<li><b>absolute</b>:指示设备是否可以提供绝对方位数据（指向地球坐标系），或者设备决定的任意坐标系。关于坐标系参见<i>https://developer.mozilla.org/en-US/docs/Web/Guide/Events/Orientation_and_motion_data_explained</i>。</li>
	*<li><b>info</b>:<code>RotationInfo</code>类型参数，保存设备的旋转值。</li>
	*</ol>
	*</p>
	*
	*<p>
	*浏览器兼容性参见：<i>http://caniuse.com/#search=deviceorientation</i>
	*</p>
	*/
	//class laya.device.motion.Gyroscope extends laya.events.EventDispatcher
	var Gyroscope = (function (_super) {
		function Gyroscope(singleton) {
			Gyroscope.__super.call(this);
		/*__JS__ */this.onDeviceOrientationChange = this.onDeviceOrientationChange.bind(this);
		}

		__class(Gyroscope, 'laya.device.motion.Gyroscope', _super);
		var __proto = Gyroscope.prototype;
		/**
		*监视陀螺仪运动。
		*@param observer 回调函数接受一个Boolean类型的<code>absolute</code>和<code>GyroscopeInfo</code>类型参数。
		*/
		__proto.on = function (type, caller, listener, args) {
			_super.prototype.on.call(this, type, caller, listener, args);
			Browser.window.addEventListener('deviceorientation', this.onDeviceOrientationChange);
			return this;
		}

		/**
		*取消指定处理器对陀螺仪的监视。
		*@param observer
		*/
		__proto.off = function (type, caller, listener, onceOnly) {
			(onceOnly === void 0) && (onceOnly = false);
			if (!this.hasListener(type))
				Browser.window.removeEventListener('deviceorientation', this.onDeviceOrientationChange);
			return _super.prototype.off.call(this, type, caller, listener, onceOnly);
		}

		__proto.onDeviceOrientationChange = function (e) {
			Gyroscope.info.alpha = e.alpha;
			Gyroscope.info.beta = e.beta;
			Gyroscope.info.gamma = e.gamma;
			if (e.webkitCompassHeading) {
				Gyroscope.info.alpha = e.webkitCompassHeading * -1;
				Gyroscope.info.compassAccuracy = e.webkitCompassAccuracy;
			}
			this.event(/*laya.events.Event.CHANGE*/"change", [e.absolute, Gyroscope.info]);
		}

		__getset(1, Gyroscope, 'instance', function () {
			Gyroscope._instance = Gyroscope._instance || new Gyroscope(0);
			return Gyroscope._instance;
		}, laya.events.EventDispatcher._$SET_instance);

		Gyroscope._instance = null;
		__static(Gyroscope,
			['info', function () { return this.info = new RotationInfo(); }
			]);
		return Gyroscope;
	})(EventDispatcher)


	/**
	*Shake只能在支持此操作的设备上有效。
	*
	*@author Survivor
	*/
	//class laya.device.Shake extends laya.events.EventDispatcher
	var Shake = (function (_super) {
		function Shake() {
			this.throushold = 0;
			this.shakeInterval = 0;
			this.callback = null;
			this.lastX = NaN;
			this.lastY = NaN;
			this.lastZ = NaN;
			this.lastMillSecond = NaN;
			Shake.__super.call(this);
		}

		__class(Shake, 'laya.device.Shake', _super);
		var __proto = Shake.prototype;
		/**
		*开始响应设备摇晃。
		*@param throushold 响应的瞬时速度阈值，轻度摇晃的值约在5~10间。
		*@param timeout 设备摇晃的响应间隔时间。
		*@param callback 在设备摇晃触发时调用的处理器。
		*/
		__proto.start = function (throushold, interval) {
			this.throushold = throushold;
			this.shakeInterval = interval;
			this.lastX = this.lastY = this.lastZ = NaN;
			Accelerator.instance.on(/*laya.events.Event.CHANGE*/"change", this, this.onShake);
		}

		/**
		*停止响应设备摇晃。
		*/
		__proto.stop = function () {
			Accelerator.instance.off(/*laya.events.Event.CHANGE*/"change", this, this.onShake);
		}

		__proto.onShake = function (acceleration, accelerationIncludingGravity, rotationRate, interval) {
			if (isNaN(this.lastX)) {
				this.lastX = accelerationIncludingGravity.x;
				this.lastY = accelerationIncludingGravity.y;
				this.lastZ = accelerationIncludingGravity.z;
				this.lastMillSecond = Browser.now();
				return;
			};
			var deltaX = Math.abs(this.lastX - accelerationIncludingGravity.x);
			var deltaY = Math.abs(this.lastY - accelerationIncludingGravity.y);
			var deltaZ = Math.abs(this.lastZ - accelerationIncludingGravity.z);
			if (this.isShaked(deltaX, deltaY, deltaZ)) {
				var deltaMillSecond = Browser.now() - this.lastMillSecond;
				if (deltaMillSecond > this.shakeInterval) {
					this.event(/*laya.events.Event.CHANGE*/"change");
					this.lastMillSecond = Browser.now();
				}
			}
			this.lastX = accelerationIncludingGravity.x;
			this.lastY = accelerationIncludingGravity.y;
			this.lastZ = accelerationIncludingGravity.z;
		}

		// 通过任意两个分量判断是否满足摇晃设定。
		__proto.isShaked = function (deltaX, deltaY, deltaZ) {
			return (deltaX > this.throushold && deltaY > this.throushold) ||
				(deltaX > this.throushold && deltaZ > this.throushold) ||
				(deltaY > this.throushold && deltaZ > this.throushold)
		}

		__getset(1, Shake, 'instance', function () {
			Shake._instance = Shake._instance || new Shake();
			return Shake._instance;
		}, laya.events.EventDispatcher._$SET_instance);

		Shake._instance = null;
		return Shake;
	})(EventDispatcher)


	/**
	*<code>Video</code>将视频显示到Canvas上。<code>Video</code>可能不会在所有浏览器有效。
	*<p>关于Video支持的所有事件参见：<i>http://www.w3school.com.cn/tags/html_ref_audio_video_dom.asp</i>。</p>
	*<p>
	*<b>注意：</b><br/>
	*在PC端可以在任何时机调用<code>play()</code>因此，可以在程序开始运行时就使Video开始播放。但是在移动端，只有在用户第一次触碰屏幕后才可以调用play()，所以移动端不可能在程序开始运行时就自动开始播放Video。
	*</p>
	*
	*<p>MDN Video链接： <i>https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video</i></p>
	*/
	//class laya.device.media.Video extends laya.display.Sprite
	var Video = (function (_super) {
		function Video(width, height) {
			this.htmlVideo = null;
			this.videoElement = null;
			this.internalTexture = null;
			(width === void 0) && (width = 320);
			(height === void 0) && (height = 240);
			Video.__super.call(this);
			if (Render.isWebGL)
				this.htmlVideo = new WebGLVideo();
			else
				this.htmlVideo = new HtmlVideo();
			this.videoElement = this.htmlVideo.getVideo();
			this.videoElement.the3Target = this;
			this.internalTexture = new Texture(this.htmlVideo);
			this.videoElement.addEventListener("abort", Video.onAbort);
			this.videoElement.addEventListener("canplay", Video.onCanplay);
			this.videoElement.addEventListener("canplaythrough", Video.onCanplaythrough);
			this.videoElement.addEventListener("durationchange", Video.onDurationchange);
			this.videoElement.addEventListener("emptied", Video.onEmptied);
			this.videoElement.addEventListener("error", Video.onError);
			this.videoElement.addEventListener("loadeddata", Video.onLoadeddata);
			this.videoElement.addEventListener("loadedmetadata", Video.onLoadedmetadata);
			this.videoElement.addEventListener("loadstart", Video.onLoadstart);
			this.videoElement.addEventListener("pause", Video.onPause);
			this.videoElement.addEventListener("play", Video.onPlay);
			this.videoElement.addEventListener("playing", Video.onPlaying);
			this.videoElement.addEventListener("progress", Video.onProgress);
			this.videoElement.addEventListener("ratechange", Video.onRatechange);
			this.videoElement.addEventListener("seeked", Video.onSeeked);
			this.videoElement.addEventListener("seeking", Video.onSeeking);
			this.videoElement.addEventListener("stalled", Video.onStalled);
			this.videoElement.addEventListener("suspend", Video.onSuspend);
			this.videoElement.addEventListener("timeupdate", Video.onTimeupdate);
			this.videoElement.addEventListener("volumechange", Video.onVolumechange);
			this.videoElement.addEventListener("waiting", Video.onWaiting);
			this.videoElement.addEventListener("ended", this.onPlayComplete['bind'](this));
			this.size(width, height);
			if (Browser.onMobile) {
			/*__JS__ */this.onDocumentClick = this.onDocumentClick.bind(this);
				Browser.document.addEventListener("touchend", this.onDocumentClick);
			}
		}

		__class(Video, 'laya.device.media.Video', _super);
		var __proto = Video.prototype;
		__proto.onPlayComplete = function (e) {
			Laya.timer.clear(this, this.renderCanvas);
			this.event("ended");
		}

		/**
		*设置播放源。
		*@param url 播放源路径。
		*/
		__proto.load = function (url) {
			if (url.indexOf("blob:") == 0)
				this.videoElement.src = url;
			else
				this.htmlVideo.setSource(url, laya.device.media.Video.MP4);
		}

		/**
		*开始播放视频。
		*/
		__proto.play = function () {
			this.videoElement.play();
			Laya.timer.frameLoop(1, this, this.renderCanvas);
		}

		/**
		*暂停视频播放。
		*/
		__proto.pause = function () {
			this.videoElement.pause();
			Laya.timer.clear(this, this.renderCanvas);
		}

		/**
		*重新加载视频。
		*/
		__proto.reload = function () {
			this.videoElement.load();
		}

		/**
		*检测是否支持播放指定格式视频。
		*@param type 参数为Video.MP4 / Video.OGG / Video.WEBM之一。
		*@return 表示支持的级别。可能的值：
		*<ul>
		*<li>"probably"，Video.SUPPORT_PROBABLY-浏览器最可能支持该音频/视频类型</li>
		*<li>"maybe"，Video.SUPPORT_MAYBY-浏览器也许支持该音频/视频类型</li>
		*<li>""，Video.SUPPORT_NO-（空字符串）浏览器不支持该音频/视频类型</li>
		*</ul>
		*/
		__proto.canPlayType = function (type) {
			var typeString;
			switch (type) {
				case laya.device.media.Video.MP4:
					typeString = "video/mp4";
					break;
				case laya.device.media.Video.OGG:
					typeString = "video/ogg";
					break;
				case laya.device.media.Video.WEBM:
					typeString = "video/webm";
					break;
			}
			return this.videoElement.canPlayType(typeString);
		}

		__proto.renderCanvas = function () {
			if (this.readyState === 0)
				return;
			if (Render.isWebGL)
				this.htmlVideo['updateTexture']();
			this.graphics.clear();
			this.graphics.drawTexture(this.internalTexture, 0, 0, this.width, this.height);
		}

		__proto.onDocumentClick = function () {
			this.videoElement.play();
			this.videoElement.pause();
			Browser.document.removeEventListener("touchend", this.onDocumentClick);
		}

		__proto.size = function (width, height) {
			_super.prototype.size.call(this, width, height)
			this.videoElement.width = width / Browser.pixelRatio;
			if (this.paused) this.renderCanvas();
			return this;
		}

		/**
		*销毁内部事件绑定。
		*/
		__proto.destroy = function (detroyChildren) {
			(detroyChildren === void 0) && (detroyChildren = true);
			_super.prototype.destroy.call(this, detroyChildren);
			this.videoElement.removeEventListener("abort", Video.onAbort);
			this.videoElement.removeEventListener("canplay", Video.onCanplay);
			this.videoElement.removeEventListener("canplaythrough", Video.onCanplaythrough);
			this.videoElement.removeEventListener("durationchange", Video.onDurationchange);
			this.videoElement.removeEventListener("emptied", Video.onEmptied);
			this.videoElement.removeEventListener("error", Video.onError);
			this.videoElement.removeEventListener("loadeddata", Video.onLoadeddata);
			this.videoElement.removeEventListener("loadedmetadata", Video.onLoadedmetadata);
			this.videoElement.removeEventListener("loadstart", Video.onLoadstart);
			this.videoElement.removeEventListener("pause", Video.onPause);
			this.videoElement.removeEventListener("play", Video.onPlay);
			this.videoElement.removeEventListener("playing", Video.onPlaying);
			this.videoElement.removeEventListener("progress", Video.onProgress);
			this.videoElement.removeEventListener("ratechange", Video.onRatechange);
			this.videoElement.removeEventListener("seeked", Video.onSeeked);
			this.videoElement.removeEventListener("seeking", Video.onSeeking);
			this.videoElement.removeEventListener("stalled", Video.onStalled);
			this.videoElement.removeEventListener("suspend", Video.onSuspend);
			this.videoElement.removeEventListener("timeupdate", Video.onTimeupdate);
			this.videoElement.removeEventListener("volumechange", Video.onVolumechange);
			this.videoElement.removeEventListener("waiting", Video.onWaiting);
			this.videoElement.removeEventListener("ended", this.onPlayComplete);
			this.pause();
			this.videoElement = null;
		}

		__proto.syncVideoPosition = function () {
			var stage = Laya.stage;
			var rec;
			rec = Utils.getGlobalPosAndScale(this);
			var a = stage._canvasTransform.a, d = stage._canvasTransform.d;
			var x = rec.x * stage.clientScaleX * a + stage.offset.x;
			var y = rec.y * stage.clientScaleY * d + stage.offset.y;
			this.videoElement.style.left = x + 'px';;
			this.videoElement.style.top = y + 'px';
			this.videoElement.width = this.width / Browser.pixelRatio;
			this.videoElement.height = this.height / Browser.pixelRatio;
		}

		/**
		*buffered 属性返回 TimeRanges(JS)对象。TimeRanges 对象表示用户的音视频缓冲范围。缓冲范围指的是已缓冲音视频的时间范围。如果用户在音视频中跳跃播放，会得到多个缓冲范围。
		*<p>buffered.length返回缓冲范围个数。如获取第一个缓冲范围则是buffered.start(0)和buffered.end(0)。以秒计。</p>
		*@return TimeRanges(JS)对象
		*/
		__getset(0, __proto, 'buffered', function () {
			return this.videoElement.buffered;
		});

		/**
		*获取视频源尺寸。ready事件触发后可用。
		*/
		__getset(0, __proto, 'videoWidth', function () {
			return this.videoElement.videoWidth;
		});

		/**
		*获取当前播放源路径。
		*/
		__getset(0, __proto, 'currentSrc', function () {
			return this.videoElement.currentSrc;
		});

		/**
		*设置和获取当前播放头位置。
		*/
		__getset(0, __proto, 'currentTime', function () {
			return this.videoElement.currentTime;
		}, function (value) {
			this.videoElement.currentTime = value;
			this.renderCanvas();
		});

		/**
		*返回音频/视频的播放是否已结束
		*/
		__getset(0, __proto, 'ended', function () {
			return this.videoElement.ended;
		});

		/**
		*设置和获取当前音量。
		*/
		__getset(0, __proto, 'volume', function () {
			return this.videoElement.volume;
		}, function (value) {
			this.videoElement.volume = value;
		});

		__getset(0, __proto, 'videoHeight', function () {
			return this.videoElement.videoHeight;
		});

		/**
		*表示视频元素的就绪状态：
		*<ul>
		*<li>0=HAVE_NOTHING-没有关于音频/视频是否就绪的信息</li>
		*<li>1=HAVE_METADATA-关于音频/视频就绪的元数据</li>
		*<li>2=HAVE_CURRENT_DATA-关于当前播放位置的数据是可用的，但没有足够的数据来播放下一帧/毫秒</li>
		*<li>3=HAVE_FUTURE_DATA-当前及至少下一帧的数据是可用的</li>
		*<li>4=HAVE_ENOUGH_DATA-可用数据足以开始播放</li>
		*</ul>
		*/
		__getset(0, __proto, 'readyState', function () {
			return this.videoElement.readyState;
		});

		/**
		*获取视频长度（秒）。ready事件触发后可用。
		*/
		__getset(0, __proto, 'duration', function () {
			return this.videoElement.duration;
		});

		/**
		*返回表示音频/视频错误状态的 MediaError（JS）对象。
		*/
		__getset(0, __proto, 'error', function () {
			return this.videoElement.error;
		});

		/**
		*设置或返回音频/视频是否应在结束时重新播放。
		*/
		__getset(0, __proto, 'loop', function () {
			return this.videoElement.loop;
		}, function (value) {
			this.videoElement.loop = value;
		});

		/**
		*playbackRate 属性设置或返回音频/视频的当前播放速度。如：
		*<ul>
		*<li>1.0 正常速度</li>
		*<li>0.5 半速（更慢）</li>
		*<li>2.0 倍速（更快）</li>
		*<li>-1.0 向后，正常速度</li>
		*<li>-0.5 向后，半速</li>
		*</ul>
		*<p>只有 Google Chrome 和 Safari 支持 playbackRate 属性。</p>
		*/
		__getset(0, __proto, 'playbackRate', function () {
			return this.videoElement.playbackRate;
		}, function (value) {
			this.videoElement.playbackRate = value;
		});

		/**
		*获取和设置静音状态。
		*/
		__getset(0, __proto, 'muted', function () {
			return this.videoElement.muted;
		}, function (value) {
			this.videoElement.muted = value;
		});

		/**
		*返回视频是否暂停
		*/
		__getset(0, __proto, 'paused', function () {
			return this.videoElement.paused;
		});

		/**
		*preload 属性设置或返回是否在页面加载后立即加载视频。可赋值如下：
		*<ul>
		*<li>auto 指示一旦页面加载，则开始加载视频。</li>
		*<li>metadata 指示当页面加载后仅加载音频/视频的元数据。</li>
		*<li>none 指示页面加载后不应加载音频/视频。</li>
		*</ul>
		*/
		__getset(0, __proto, 'preload', function () {
			return this.videoElement.preload;
		}, function (value) {
			this.videoElement.preload = value;
		});

		/**
		*参见 <i>http://www.w3school.com.cn/tags/av_prop_seekable.asp</i>。
		*/
		__getset(0, __proto, 'seekable', function () {
			return this.videoElement.seekable;
		});

		/**
		*seeking 属性返回用户目前是否在音频/视频中寻址。
		*寻址中（Seeking）指的是用户在音频/视频中移动/跳跃到新的位置。
		*/
		__getset(0, __proto, 'seeking', function () {
			return this.videoElement.seeking;
		});

		__getset(0, __proto, 'height', _super.prototype._$get_height, function (value) {
			Laya.superSet(Sprite, this, 'height', value);
			if (this.paused) this.renderCanvas();
		});

		__getset(0, __proto, 'width', _super.prototype._$get_width, function (value) {
			this.videoElement.width = this.width / Browser.pixelRatio;
			Laya.superSet(Sprite, this, 'width', value);
			if (this.paused) this.renderCanvas();
		});

		Video.onAbort = function (e) { e.target.the3Target.event("abort") }
		Video.onCanplay = function (e) { e.target.the3Target.event("canplay") }
		Video.onCanplaythrough = function (e) { e.target.the3Target.event("canplaythrough") }
		Video.onDurationchange = function (e) { e.target.the3Target.event("durationchange") }
		Video.onEmptied = function (e) { e.target.the3Target.event("emptied") }
		Video.onError = function (e) { e.target.the3Target.event("error") }
		Video.onLoadeddata = function (e) { e.target.the3Target.event("loadeddata") }
		Video.onLoadedmetadata = function (e) { e.target.the3Target.event("loadedmetadata") }
		Video.onLoadstart = function (e) { e.target.the3Target.event("loadstart") }
		Video.onPause = function (e) { e.target.the3Target.event("pause") }
		Video.onPlay = function (e) { e.target.the3Target.event("play") }
		Video.onPlaying = function (e) { e.target.the3Target.event("playing") }
		Video.onProgress = function (e) { e.target.the3Target.event("progress") }
		Video.onRatechange = function (e) { e.target.the3Target.event("ratechange") }
		Video.onSeeked = function (e) { e.target.the3Target.event("seeked") }
		Video.onSeeking = function (e) { e.target.the3Target.event("seeking") }
		Video.onStalled = function (e) { e.target.the3Target.event("stalled") }
		Video.onSuspend = function (e) { e.target.the3Target.event("suspend") }
		Video.onTimeupdate = function (e) { e.target.the3Target.event("timeupdate") }
		Video.onVolumechange = function (e) { e.target.the3Target.event("volumechange") }
		Video.onWaiting = function (e) { e.target.the3Target.event("waiting") }
		Video.MP4 = 1;
		Video.OGG = 2;
		Video.CAMERA = 4;
		Video.WEBM = 8;
		Video.SUPPORT_PROBABLY = "probably";
		Video.SUPPORT_MAYBY = "maybe";
		Video.SUPPORT_NO = "";
		return Video;
	})(Sprite)


	/**
	*@private
	*/
	//class laya.device.media.HtmlVideo extends laya.resource.Bitmap
	var HtmlVideo = (function (_super) {
		function HtmlVideo() {
			this.video = null;
			HtmlVideo.__super.call(this);
			this._w = 1;
			this._h = 1;
			this.createDomElement();
		}

		__class(HtmlVideo, 'laya.device.media.HtmlVideo', _super);
		var __proto = HtmlVideo.prototype;
		__proto.createDomElement = function () {
			var _$this = this;
			this._source = this.video = Browser.createElement("video");
			var style = this.video.style;
			style.position = 'absolute';
			style.top = '0px';
			style.left = '0px';
			this.video.addEventListener("loadedmetadata", (function () {
				this._w = _$this.video.videoWidth;
				this._h = _$this.video.videoHeight;
			})['bind'](this));
		}

		__proto.setSource = function (url, extension) {
			while (this.video.childElementCount)
				this.video.firstChild.remove();
			if (extension & Video.MP4)
				this.appendSource(url, "video/mp4");
			if (extension & Video.OGG)
				this.appendSource(url + ".ogg", "video/ogg");
		}

		__proto.appendSource = function (source, type) {
			var sourceElement = Browser.createElement("source");
			sourceElement.src = source;
			sourceElement.type = type;
			this.video.appendChild(sourceElement);
		}

		__proto.getVideo = function () {
			return this.video;
		}

		HtmlVideo.create = function () {
			return new HtmlVideo();
		}

		return HtmlVideo;
	})(Bitmap)


	/**
	*@private
	*/
	//class laya.device.media.WebGLVideo extends laya.device.media.HtmlVideo
	var WebGLVideo = (function (_super) {
		function WebGLVideo() {
			this.gl = null;
			this.preTarget = null;
			this.preTexture = null;
			WebGLVideo.__super.call(this);
			if (Browser.onIPhone)
				return;
			this.gl = WebGL.mainContext;
			this._source = this.gl.createTexture();
			this.preTarget = WebGLContext.curBindTexTarget;
			this.preTexture = WebGLContext.curBindTexValue;
			WebGLContext.bindTexture(this.gl,/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1, this._source);
			this.gl.texParameteri(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,/*laya.webgl.WebGLContext.TEXTURE_WRAP_S*/0x2802,/*laya.webgl.WebGLContext.CLAMP_TO_EDGE*/0x812F);
			this.gl.texParameteri(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,/*laya.webgl.WebGLContext.TEXTURE_WRAP_T*/0x2803,/*laya.webgl.WebGLContext.CLAMP_TO_EDGE*/0x812F);
			this.gl.texParameteri(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,/*laya.webgl.WebGLContext.TEXTURE_MAG_FILTER*/0x2800,/*laya.webgl.WebGLContext.LINEAR*/0x2601);
			this.gl.texParameteri(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1,/*laya.webgl.WebGLContext.TEXTURE_MIN_FILTER*/0x2801,/*laya.webgl.WebGLContext.LINEAR*/0x2601);
			(this.preTarget && this.preTexture) && (WebGLContext.bindTexture(this.gl, this.preTarget, this.preTexture));
		}

		__class(WebGLVideo, 'laya.device.media.WebGLVideo', _super);
		var __proto = WebGLVideo.prototype;
		__proto.updateTexture = function () {
			if (Browser.onIPhone)
				return;
			WebGLContext.bindTexture(this.gl,/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1, this._source);
			this.gl.texImage2D(/*laya.webgl.WebGLContext.TEXTURE_2D*/0x0DE1, 0,/*laya.webgl.WebGLContext.RGB*/0x1907,/*laya.webgl.WebGLContext.RGB*/0x1907,/*laya.webgl.WebGLContext.UNSIGNED_BYTE*/0x1401, this.video);
		}

		return WebGLVideo;
	})(HtmlVideo)


	Laya.__init([Media]);
})(window, document, Laya);

if (typeof define === 'function' && define.amd) {
	define('laya.core', ['require', "exports"], function (require, exports) {
		'use strict';
		Object.defineProperty(exports, '__esModule', { value: true });
		for (var i in Laya) {
			var o = Laya[i];
			o && o.__isclass && (exports[i] = o);
		}
	});
}


(function (window, document, Laya) {
	var __un = Laya.un, __uns = Laya.uns, __static = Laya.static, __class = Laya.class, __getset = Laya.getset, __newvec = Laya.__newvec;

	var BlendMode = laya.webgl.canvas.BlendMode, Event = laya.events.Event, HTMLCanvas = laya.resource.HTMLCanvas;
	var Handler = laya.utils.Handler, IndexBuffer2D = laya.webgl.utils.IndexBuffer2D, Loader = laya.net.Loader, MathUtil = laya.maths.MathUtil;
	var Matrix = laya.maths.Matrix, Render = laya.renders.Render, RenderContext = laya.renders.RenderContext, RenderSprite = laya.renders.RenderSprite;
	var Shader = laya.webgl.shader.Shader, Sprite = laya.display.Sprite, Stat = laya.utils.Stat, Texture = laya.resource.Texture;
	var Utils = laya.utils.Utils, Value2D = laya.webgl.shader.d2.value.Value2D, VertexBuffer2D = laya.webgl.utils.VertexBuffer2D;
	var WebGL = laya.webgl.WebGL, WebGLContext = laya.webgl.WebGLContext;
	/**
	*<code>EmitterBase</code> 类是粒子发射器类
	*/
	//class laya.particle.emitter.EmitterBase
	var EmitterBase = (function () {
		function EmitterBase() {
			/**
			*积累的帧时间
			*/
			this._frameTime = 0;
			/**
			*粒子发射速率
			*/
			this._emissionRate = 60;
			/**
			*当前剩余发射时间
			*/
			this._emissionTime = 0;
			/**
			*发射粒子最小时间间隔
			*/
			this.minEmissionTime = 1 / 60;
			/**@private */
			this._particleTemplate = null;
		}

		__class(EmitterBase, 'laya.particle.emitter.EmitterBase');
		var __proto = EmitterBase.prototype;
		/**
		*开始发射粒子
		*@param duration 发射持续的时间(秒)
		*/
		__proto.start = function (duration) {
			(duration === void 0) && (duration = 2147483647);
			if (this._emissionRate != 0)
				this._emissionTime = duration;
		}

		/**
		*停止发射粒子
		*@param clearParticles 是否清理当前的粒子
		*/
		__proto.stop = function () {
			this._emissionTime = 0;
		}

		/**
		*清理当前的活跃粒子
		*@param clearTexture 是否清理贴图数据,若清除贴图数据将无法再播放
		*/
		__proto.clear = function () {
			this._emissionTime = 0;
		}

		/**
		*发射一个粒子
		*
		*/
		__proto.emit = function () { }
		/**
		*时钟前进
		*@param passedTime 前进时间
		*
		*/
		__proto.advanceTime = function (passedTime) {
			(passedTime === void 0) && (passedTime = 1);
			this._emissionTime -= passedTime;
			if (this._emissionTime < 0) return;
			this._frameTime += passedTime;
			if (this._frameTime < this.minEmissionTime) return;
			while (this._frameTime > this.minEmissionTime) {
				this._frameTime -= this.minEmissionTime;
				this.emit();
			}
		}

		/**
		*设置粒子粒子模板
		*@param particleTemplate 粒子模板
		*
		*/
		__getset(0, __proto, 'particleTemplate', null, function (particleTemplate) {
			this._particleTemplate = particleTemplate;
		});

		/**
		*设置粒子发射速率
		*@param emissionRate 粒子发射速率 (个/秒)
		*/
		/**
		*获取粒子发射速率
		*@return 发射速率 粒子发射速率 (个/秒)
		*/
		__getset(0, __proto, 'emissionRate', function () {
			return this._emissionRate;
		}, function (_emissionRate) {
			if (_emissionRate <= 0) return;
			this._emissionRate = _emissionRate;
			(_emissionRate > 0) && (this.minEmissionTime = 1 / _emissionRate);
		});

		return EmitterBase;
	})()


	/**
	*@private
	*/
	//class laya.particle.ParticleData
	var ParticleData = (function () {
		function ParticleData() {
			this.position = null;
			this.velocity = null;
			this.startColor = null;
			this.endColor = null;
			this.sizeRotation = null;
			this.radius = null;
			this.radian = null;
			this.durationAddScale = NaN;
			this.time = NaN;
		}

		__class(ParticleData, 'laya.particle.ParticleData');
		ParticleData.Create = function (settings, position, velocity, time) {
			var particleData = new ParticleData();
			particleData.position = position;
			MathUtil.scaleVector3(velocity, settings.emitterVelocitySensitivity, ParticleData._tempVelocity);
			var horizontalVelocity = MathUtil.lerp(settings.minHorizontalVelocity, settings.maxHorizontalVelocity, Math.random());
			var horizontalAngle = Math.random() * Math.PI * 2;
			ParticleData._tempVelocity[0] += horizontalVelocity * Math.cos(horizontalAngle);
			ParticleData._tempVelocity[2] += horizontalVelocity * Math.sin(horizontalAngle);
			ParticleData._tempVelocity[1] += MathUtil.lerp(settings.minVerticalVelocity, settings.maxVerticalVelocity, Math.random());
			particleData.velocity = ParticleData._tempVelocity;
			particleData.startColor = ParticleData._tempStartColor;
			particleData.endColor = ParticleData._tempEndColor;
			var i = 0;
			if (settings.disableColor) {
				for (i = 0; i < 4; i++) {
					particleData.startColor[i] = 1;
					particleData.endColor[i] = 1;
				}
			}
			else {
				if (settings.colorComponentInter) {
					for (i = 0; i < 4; i++) {
						particleData.startColor[i] = MathUtil.lerp(settings.minStartColor[i], settings.maxStartColor[i], Math.random());
						particleData.endColor[i] = MathUtil.lerp(settings.minEndColor[i], settings.maxEndColor[i], Math.random());
					}
				} else {
					MathUtil.lerpVector4(settings.minStartColor, settings.maxStartColor, Math.random(), particleData.startColor);
					MathUtil.lerpVector4(settings.minEndColor, settings.maxEndColor, Math.random(), particleData.endColor);
				}
			}
			particleData.sizeRotation = ParticleData._tempSizeRotation;
			var sizeRandom = Math.random();
			particleData.sizeRotation[0] = MathUtil.lerp(settings.minStartSize, settings.maxStartSize, sizeRandom);
			particleData.sizeRotation[1] = MathUtil.lerp(settings.minEndSize, settings.maxEndSize, sizeRandom);
			particleData.sizeRotation[2] = MathUtil.lerp(settings.minRotateSpeed, settings.maxRotateSpeed, Math.random());
			particleData.radius = ParticleData._tempRadius;
			var radiusRandom = Math.random();
			particleData.radius[0] = MathUtil.lerp(settings.minStartRadius, settings.maxStartRadius, radiusRandom);
			particleData.radius[1] = MathUtil.lerp(settings.minEndRadius, settings.maxEndRadius, radiusRandom);
			particleData.radian = ParticleData._tempRadian;
			particleData.radian[0] = MathUtil.lerp(settings.minHorizontalStartRadian, settings.maxHorizontalStartRadian, Math.random());
			particleData.radian[1] = MathUtil.lerp(settings.minVerticalStartRadian, settings.maxVerticalStartRadian, Math.random());
			var useEndRadian = settings.useEndRadian;
			particleData.radian[2] = useEndRadian ? MathUtil.lerp(settings.minHorizontalEndRadian, settings.maxHorizontalEndRadian, Math.random()) : particleData.radian[0];
			particleData.radian[3] = useEndRadian ? MathUtil.lerp(settings.minVerticalEndRadian, settings.maxVerticalEndRadian, Math.random()) : particleData.radian[1];
			particleData.durationAddScale = settings.ageAddScale * Math.random();
			particleData.time = time;
			return particleData;
		}

		__static(ParticleData,
			['_tempVelocity', function () { return this._tempVelocity = new Float32Array(3); }, '_tempStartColor', function () { return this._tempStartColor = new Float32Array(4); }, '_tempEndColor', function () { return this._tempEndColor = new Float32Array(4); }, '_tempSizeRotation', function () { return this._tempSizeRotation = new Float32Array(3); }, '_tempRadius', function () { return this._tempRadius = new Float32Array(2); }, '_tempRadian', function () { return this._tempRadian = new Float32Array(4); }
			]);
		return ParticleData;
	})()


	/**
	*@private
	*/
	//class laya.particle.ParticleEmitter
	var ParticleEmitter = (function () {
		function ParticleEmitter(templet, particlesPerSecond, initialPosition) {
			this._templet = null;
			this._timeBetweenParticles = NaN;
			this._previousPosition = null;
			this._timeLeftOver = 0;
			this._tempVelocity = new Float32Array([0, 0, 0]);
			this._tempPosition = new Float32Array([0, 0, 0]);
			this._templet = templet;
			this._timeBetweenParticles = 1.0 / particlesPerSecond;
			this._previousPosition = initialPosition;
		}

		__class(ParticleEmitter, 'laya.particle.ParticleEmitter');
		var __proto = ParticleEmitter.prototype;
		__proto.update = function (elapsedTime, newPosition) {
			elapsedTime = elapsedTime / 1000;
			if (elapsedTime > 0) {
				MathUtil.subtractVector3(newPosition, this._previousPosition, this._tempVelocity);
				MathUtil.scaleVector3(this._tempVelocity, 1 / elapsedTime, this._tempVelocity);
				var timeToSpend = this._timeLeftOver + elapsedTime;
				var currentTime = -this._timeLeftOver;
				while (timeToSpend > this._timeBetweenParticles) {
					currentTime += this._timeBetweenParticles;
					timeToSpend -= this._timeBetweenParticles;
					MathUtil.lerpVector3(this._previousPosition, newPosition, currentTime / elapsedTime, this._tempPosition);
					this._templet.addParticleArray(this._tempPosition, this._tempVelocity);
				}
				this._timeLeftOver = timeToSpend;
			}
			this._previousPosition[0] = newPosition[0];
			this._previousPosition[1] = newPosition[1];
			this._previousPosition[2] = newPosition[2];
		}

		return ParticleEmitter;
	})()


	/**
	*<code>ParticleSettings</code> 类是粒子配置数据类
	*/
	//class laya.particle.ParticleSetting
	var ParticleSetting = (function () {
		function ParticleSetting() {
			/**贴图*/
			this.textureName = null;
			/**贴图个数,默认为1可不设置*/
			this.textureCount = 1;
			/**最大同屏粒子个数，最大饱和粒子数为maxPartices-1。注意:WebGL模式下释放粒子时间为最大声明周期，可能会出现释放延迟,实际看到的同屏粒子数小于该数值，如连续喷发出现中断，请调大该数值。*/
			this.maxPartices = 100;
			/**粒子持续时间(单位:秒）*/
			this.duration = 1;
			/**如果大于0，某些粒子的持续时间会小于其他粒子,并具有随机性(单位:无）*/
			this.ageAddScale = 0;
			/**粒子受发射器速度的敏感度（需在自定义发射器中编码设置）*/
			this.emitterVelocitySensitivity = 1;
			/**最小开始尺寸（单位：2D像素、3D坐标）*/
			this.minStartSize = 100;
			/**最大开始尺寸（单位：2D像素、3D坐标）*/
			this.maxStartSize = 100;
			/**最小结束尺寸（单位：2D像素、3D坐标）*/
			this.minEndSize = 100;
			/**最大结束尺寸（单位：2D像素、3D坐标）*/
			this.maxEndSize = 100;
			/**最小水平速度（单位：2D像素、3D坐标）*/
			this.minHorizontalVelocity = 0;
			/**最大水平速度（单位：2D像素、3D坐标）*/
			this.maxHorizontalVelocity = 0;
			/**最小垂直速度（单位：2D像素、3D坐标）*/
			this.minVerticalVelocity = 0;
			/**最大垂直速度（单位：2D像素、3D坐标）*/
			this.maxVerticalVelocity = 0;
			/**等于1时粒子从出生到消亡保持一致的速度，等于0时粒子消亡时速度为0，大于1时粒子会保持加速（单位：无）*/
			this.endVelocity = 1;
			/**最小旋转速度（单位：2D弧度/秒、3D弧度/秒）*/
			this.minRotateSpeed = 0;
			/**最大旋转速度（单位：2D弧度/秒、3D弧度/秒）*/
			this.maxRotateSpeed = 0;
			/**最小开始半径（单位：2D像素、3D坐标）*/
			this.minStartRadius = 0;
			/**最大开始半径（单位：2D像素、3D坐标）*/
			this.maxStartRadius = 0;
			/**最小结束半径（单位：2D像素、3D坐标）*/
			this.minEndRadius = 0;
			/**最大结束半径（单位：2D像素、3D坐标）*/
			this.maxEndRadius = 0;
			/**最小水平开始弧度（单位：2D弧度、3D弧度）*/
			this.minHorizontalStartRadian = 0;
			/**最大水平开始弧度（单位：2D弧度、3D弧度）*/
			this.maxHorizontalStartRadian = 0;
			/**最小垂直开始弧度（单位：2D弧度、3D弧度）*/
			this.minVerticalStartRadian = 0;
			/**最大垂直开始弧度（单位：2D弧度、3D弧度）*/
			this.maxVerticalStartRadian = 0;
			/**是否使用结束弧度,false为结束时与起始弧度保持一致,true为根据minHorizontalEndRadian、maxHorizontalEndRadian、minVerticalEndRadian、maxVerticalEndRadian计算结束弧度。*/
			this.useEndRadian = true;
			/**最小水平结束弧度（单位：2D弧度、3D弧度）*/
			this.minHorizontalEndRadian = 0;
			/**最大水平结束弧度（单位：2D弧度、3D弧度）*/
			this.maxHorizontalEndRadian = 0;
			/**最小垂直结束弧度（单位：2D弧度、3D弧度）*/
			this.minVerticalEndRadian = 0;
			/**最大垂直结束弧度（单位：2D弧度、3D弧度）*/
			this.maxVerticalEndRadian = 0;
			/**false代表RGBA整体插值，true代表RGBA逐分量插值*/
			this.colorComponentInter = false;
			/**false代表使用参数颜色数据，true代表使用原图颜色数据*/
			this.disableColor = false;
			/**混合模式，待调整，引擎中暂无BlendState抽象*/
			this.blendState = 0;
			/**发射器类型,"point","box","sphere","ring"*/
			this.emitterType = "null";
			/**发射器发射速率*/
			this.emissionRate = 0;
			/**球发射器半径*/
			this.sphereEmitterRadius = 1;
			/**球发射器速度*/
			this.sphereEmitterVelocity = 0;
			/**球发射器速度随机值*/
			this.sphereEmitterVelocityAddVariance = 0;
			/**环发射器半径*/
			this.ringEmitterRadius = 30;
			/**环发射器速度*/
			this.ringEmitterVelocity = 0;
			/**环发射器速度随机值*/
			this.ringEmitterVelocityAddVariance = 0;
			/**环发射器up向量，0代表X轴,1代表Y轴,2代表Z轴*/
			this.ringEmitterUp = 2;
			this.gravity = new Float32Array([0, 0, 0]);
			this.minStartColor = new Float32Array([1, 1, 1, 1]);
			this.maxStartColor = new Float32Array([1, 1, 1, 1]);
			this.minEndColor = new Float32Array([1, 1, 1, 1]);
			this.maxEndColor = new Float32Array([1, 1, 1, 1]);
			this.pointEmitterPosition = new Float32Array([0, 0, 0]);
			this.pointEmitterPositionVariance = new Float32Array([0, 0, 0]);
			this.pointEmitterVelocity = new Float32Array([0, 0, 0]);
			this.pointEmitterVelocityAddVariance = new Float32Array([0, 0, 0]);
			this.boxEmitterCenterPosition = new Float32Array([0, 0, 0]);
			this.boxEmitterSize = new Float32Array([0, 0, 0]);
			this.boxEmitterVelocity = new Float32Array([0, 0, 0]);
			this.boxEmitterVelocityAddVariance = new Float32Array([0, 0, 0]);
			this.sphereEmitterCenterPosition = new Float32Array([0, 0, 0]);
			this.ringEmitterCenterPosition = new Float32Array([0, 0, 0]);
			this.positionVariance = new Float32Array([0, 0, 0]);
		}

		__class(ParticleSetting, 'laya.particle.ParticleSetting');
		ParticleSetting.checkSetting = function (setting) {
			var key;
			for (key in ParticleSetting._defaultSetting) {
				if (!setting.hasOwnProperty(key)) {
					setting[key] = ParticleSetting._defaultSetting[key];
				}
			}
		}

		__static(ParticleSetting,
			['_defaultSetting', function () { return this._defaultSetting = new ParticleSetting(); }
			]);
		return ParticleSetting;
	})()


	/**
	*
	*<code>ParticleTemplateBase</code> 类是粒子模板基类
	*
	*/
	//class laya.particle.ParticleTemplateBase
	var ParticleTemplateBase = (function () {
		function ParticleTemplateBase() {
			/**
			*粒子配置数据
			*/
			this.settings = null;
			/**
			*粒子贴图
			*/
			this.texture = null;
		}

		__class(ParticleTemplateBase, 'laya.particle.ParticleTemplateBase');
		var __proto = ParticleTemplateBase.prototype;
		/**
		*添加一个粒子
		*@param position 粒子位置
		*@param velocity 粒子速度
		*
		*/
		__proto.addParticleArray = function (position, velocity) { }
		return ParticleTemplateBase;
	})()


	/**
	*@private
	*/
	//class laya.particle.particleUtils.CanvasShader
	var CanvasShader = (function () {
		function CanvasShader() {
			this.u_Duration = NaN;
			this.u_EndVelocity = NaN;
			this.u_Gravity = null;
			this.a_Position = null;
			this.a_Velocity = null;
			this.a_StartColor = null;
			this.a_EndColor = null;
			this.a_SizeRotation = null;
			this.a_Radius = null;
			this.a_Radian = null;
			this.a_AgeAddScale = NaN;
			this.gl_Position = null;
			this.v_Color = null;
			this.oSize = NaN;
			this._color = new Float32Array(4);
			this._position = new Float32Array(3);
		}

		__class(CanvasShader, 'laya.particle.particleUtils.CanvasShader');
		var __proto = CanvasShader.prototype;
		__proto.getLen = function (position) {
			return Math.sqrt(position[0] * position[0] + position[1] * position[1] + position[2] * position[2]);
		}

		__proto.ComputeParticlePosition = function (position, velocity, age, normalizedAge) {
			this._position[0] = position[0];
			this._position[1] = position[1];
			this._position[2] = position[2];
			var startVelocity = this.getLen(velocity);
			var endVelocity = startVelocity * this.u_EndVelocity;
			var velocityIntegral = startVelocity * normalizedAge + (endVelocity - startVelocity) * normalizedAge * normalizedAge / 2.0;
			var lenVelocity = NaN;
			lenVelocity = this.getLen(velocity);
			var i = 0, len = 0;
			len = 3;
			for (i = 0; i < len; i++) {
				this._position[i] = this._position[i] + (velocity[i] / lenVelocity) * velocityIntegral * this.u_Duration;
				this._position[i] += this.u_Gravity[i] * age * normalizedAge;
			};
			var radius = MathUtil.lerp(this.a_Radius[0], this.a_Radius[1], normalizedAge);
			var radianHorizontal = MathUtil.lerp(this.a_Radian[0], this.a_Radian[2], normalizedAge);
			var radianVertical = MathUtil.lerp(this.a_Radian[1], this.a_Radian[3], normalizedAge);
			var r = Math.cos(radianVertical) * radius;
			this._position[1] += Math.sin(radianVertical) * radius;
			this._position[0] += Math.cos(radianHorizontal) * r;
			this._position[2] += Math.sin(radianHorizontal) * r;
			return new Float32Array([this._position[0], this._position[1], 0.0, 1.0]);
		}

		__proto.ComputeParticleSize = function (startSize, endSize, normalizedAge) {
			var size = MathUtil.lerp(startSize, endSize, normalizedAge);
			return size;
		}

		__proto.ComputeParticleRotation = function (rot, age) {
			return rot * age;
		}

		__proto.ComputeParticleColor = function (startColor, endColor, normalizedAge) {
			var rst = this._color;
			MathUtil.lerpVector4(startColor, endColor, normalizedAge, rst);
			rst[3] = rst[3] * normalizedAge * (1.0 - normalizedAge) * (1.0 - normalizedAge) * 6.7;
			return rst;
		}

		__proto.clamp = function (value, min, max) {
			if (value < min) return min;
			if (value > max) return max;
			return value;
		}

		__proto.getData = function (age) {
			age *= 1.0 + this.a_AgeAddScale;
			var normalizedAge = this.clamp(age / this.u_Duration, 0.0, 1.0);
			this.gl_Position = this.ComputeParticlePosition(this.a_Position, this.a_Velocity, age, normalizedAge);
			var pSize = this.ComputeParticleSize(this.a_SizeRotation[0], this.a_SizeRotation[1], normalizedAge);
			var rotation = this.ComputeParticleRotation(this.a_SizeRotation[2], age);
			this.v_Color = this.ComputeParticleColor(this.a_StartColor, this.a_EndColor, normalizedAge);
			var matric = new Matrix();
			var scale = NaN;
			scale = pSize / this.oSize * 2;
			matric.scale(scale, scale);
			matric.rotate(rotation);
			matric.setTranslate(this.gl_Position[0], -this.gl_Position[1]);
			var alpha = NaN;
			alpha = this.v_Color[3];
			return [this.v_Color, alpha, matric, this.v_Color[0] * alpha, this.v_Color[1] * alpha, this.v_Color[2] * alpha];
		}

		return CanvasShader;
	})()


	/**
	*
	*@private
	*
	*@created 2015-8-25 下午3:41:07
	*/
	//class laya.particle.particleUtils.CMDParticle
	var CMDParticle = (function () {
		function CMDParticle() {
			/**
			*最大帧
			*/
			this.maxIndex = 0;
			/**
			*帧命令数组
			*/
			this.cmds = null;
			/**
			*粒子id
			*/
			this.id = 0;
		}

		__class(CMDParticle, 'laya.particle.particleUtils.CMDParticle');
		var __proto = CMDParticle.prototype;
		__proto.setCmds = function (cmds) {
			this.cmds = cmds;
			this.maxIndex = cmds.length - 1;
		}

		return CMDParticle;
	})()


	//class laya.particle.particleUtils.PicTool
	var PicTool = (function () {
		function PicTool() { }
		__class(PicTool, 'laya.particle.particleUtils.PicTool');
		PicTool.getCanvasPic = function (img, color) {
			img = img.bitmap;
			var canvas = new HTMLCanvas("2D");
			var ctx = canvas.getContext('2d');
			canvas.size(img.width, img.height);
			var red = (color >> 16 & 0xFF);
			var green = (color >> 8 & 0xFF);
			var blue = (color & 0xFF);
			if (Render.isConchApp) {
				ctx.setFilter(red / 255, green / 255, blue / 255, 0);
			}
			ctx.drawImage(img.source, 0, 0);
			if (!Render.isConchApp) {
				var imgdata = ctx.getImageData(0, 0, canvas.width, canvas.height);
				var data = imgdata.data;
				for (var i = 0, n = data.length; i < n; i += 4) {
					if (data[i + 3] == 0) continue;
					data[i] *= red / 255;
					data[i + 1] *= green / 255;
					data[i + 2] *= blue / 255;
				}
				ctx.putImageData(imgdata, 0, 0);
			}
			return canvas;
		}

		PicTool.getRGBPic = function (img) {
			var rst;
			rst = [new Texture(PicTool.getCanvasPic(img, 0xFF0000)), new Texture(PicTool.getCanvasPic(img, 0x00FF00)), new Texture(PicTool.getCanvasPic(img, 0x0000FF))];
			return rst;
		}

		return PicTool;
	})()


	/**
	*
	*@private
	*/
	//class laya.particle.emitter.Emitter2D extends laya.particle.emitter.EmitterBase
	var Emitter2D = (function (_super) {
		function Emitter2D(_template) {
			this.setting = null;
			this._posRange = null;
			this._canvasTemplate = null;
			this._emitFun = null;
			Emitter2D.__super.call(this);
			this.template = _template;
		}

		__class(Emitter2D, 'laya.particle.emitter.Emitter2D', _super);
		var __proto = Emitter2D.prototype;
		__proto.emit = function () {
			_super.prototype.emit.call(this);
			if (this._emitFun != null)
				this._emitFun();
		}

		__proto.getRandom = function (value) {
			return (Math.random() * 2 - 1) * value;
		}

		__proto.webGLEmit = function () {
			var pos = new Float32Array(3);
			pos[0] = this.getRandom(this._posRange[0]);
			pos[1] = this.getRandom(this._posRange[1]);
			pos[2] = this.getRandom(this._posRange[2]);
			var v = new Float32Array(3);
			v[0] = 0;
			v[1] = 0;
			v[2] = 0;
			this._particleTemplate.addParticleArray(pos, v);
		}

		__proto.canvasEmit = function () {
			var pos = new Float32Array(3);
			pos[0] = this.getRandom(this._posRange[0]);
			pos[1] = this.getRandom(this._posRange[1]);
			pos[2] = this.getRandom(this._posRange[2]);
			var v = new Float32Array(3);
			v[0] = 0;
			v[1] = 0;
			v[2] = 0;
			this._particleTemplate.addParticleArray(pos, v);
		}

		__getset(0, __proto, 'template', function () {
			return this._particleTemplate;
		}, function (template) {
			this._particleTemplate = template;
			if (!template) {
				this._emitFun = null;
				this.setting = null;
				this._posRange = null;
			};
			this.setting = template.settings;
			this._posRange = this.setting.positionVariance;
			if ((this._particleTemplate instanceof laya.particle.ParticleTemplate2D)) {
				this._emitFun = this.webGLEmit;
			} else
				if ((this._particleTemplate instanceof laya.particle.ParticleTemplateCanvas)) {
					this._canvasTemplate = template;
					this._emitFun = this.canvasEmit;
				}
		});

		return Emitter2D;
	})(EmitterBase)


	/**
	*@private
	*/
	//class laya.particle.ParticleTemplateWebGL extends laya.particle.ParticleTemplateBase
	var ParticleTemplateWebGL = (function (_super) {
		function ParticleTemplateWebGL(parSetting) {
			this._vertices = null;
			this._vertexBuffer = null;
			this._indexBuffer = null;
			this._floatCountPerVertex = 29;
			//0~3为CornerTextureCoordinate,4~6为Position,7~9Velocity,10到13为StartColor,14到17为EndColor,18到20位SizeRotation，21到22位Radius,23到26位Radian，27为DurationAddScaleShaderValue,28为Time
			this._firstActiveElement = 0;
			this._firstNewElement = 0;
			this._firstFreeElement = 0;
			this._firstRetiredElement = 0;
			this._currentTime = 0;
			this._drawCounter = 0;
			ParticleTemplateWebGL.__super.call(this);
			this.settings = parSetting;
		}

		__class(ParticleTemplateWebGL, 'laya.particle.ParticleTemplateWebGL', _super);
		var __proto = ParticleTemplateWebGL.prototype;
		__proto.initialize = function () {
			this._vertices = new Float32Array(this.settings.maxPartices * this._floatCountPerVertex * 4);
			var particleOffset = 0;
			for (var i = 0; i < this.settings.maxPartices; i++) {
				var random = Math.random();
				var cornerYSegement = this.settings.textureCount ? 1.0 / this.settings.textureCount : 1.0;
				var cornerY = NaN;
				for (cornerY = 0; cornerY < this.settings.textureCount; cornerY += cornerYSegement) {
					if (random < cornerY + cornerYSegement)
						break;
				}
				particleOffset = i * this._floatCountPerVertex * 4;
				this._vertices[particleOffset + this._floatCountPerVertex * 0 + 0] = -1;
				this._vertices[particleOffset + this._floatCountPerVertex * 0 + 1] = -1;
				this._vertices[particleOffset + this._floatCountPerVertex * 0 + 2] = 0;
				this._vertices[particleOffset + this._floatCountPerVertex * 0 + 3] = cornerY;
				this._vertices[particleOffset + this._floatCountPerVertex * 1 + 0] = 1;
				this._vertices[particleOffset + this._floatCountPerVertex * 1 + 1] = -1;
				this._vertices[particleOffset + this._floatCountPerVertex * 1 + 2] = 1;
				this._vertices[particleOffset + this._floatCountPerVertex * 1 + 3] = cornerY;
				this._vertices[particleOffset + this._floatCountPerVertex * 2 + 0] = 1;
				this._vertices[particleOffset + this._floatCountPerVertex * 2 + 1] = 1;
				this._vertices[particleOffset + this._floatCountPerVertex * 2 + 2] = 1;
				this._vertices[particleOffset + this._floatCountPerVertex * 2 + 3] = cornerY + cornerYSegement;
				this._vertices[particleOffset + this._floatCountPerVertex * 3 + 0] = -1;
				this._vertices[particleOffset + this._floatCountPerVertex * 3 + 1] = 1;
				this._vertices[particleOffset + this._floatCountPerVertex * 3 + 2] = 0;
				this._vertices[particleOffset + this._floatCountPerVertex * 3 + 3] = cornerY + cornerYSegement;
			}
		}

		__proto.loadContent = function () { }
		__proto.update = function (elapsedTime) {
			this._currentTime += elapsedTime / 1000;
			this.retireActiveParticles();
			this.freeRetiredParticles();
			if (this._firstActiveElement == this._firstFreeElement)
				this._currentTime = 0;
			if (this._firstRetiredElement == this._firstActiveElement)
				this._drawCounter = 0;
		}

		__proto.retireActiveParticles = function () {
			var epsilon = 0.0001;
			var particleDuration = this.settings.duration;
			while (this._firstActiveElement != this._firstNewElement) {
				var offset = this._firstActiveElement * this._floatCountPerVertex * 4;
				var index = offset + 28;
				var particleAge = this._currentTime - this._vertices[index];
				particleAge *= (1.0 + this._vertices[offset + 27]);
				if (particleAge + epsilon < particleDuration)
					break;
				this._vertices[index] = this._drawCounter;
				this._firstActiveElement++;
				if (this._firstActiveElement >= this.settings.maxPartices)
					this._firstActiveElement = 0;
			}
		}

		__proto.freeRetiredParticles = function () {
			while (this._firstRetiredElement != this._firstActiveElement) {
				var age = this._drawCounter - this._vertices[this._firstRetiredElement * this._floatCountPerVertex * 4 + 28];
				if (age < 3)
					break;
				this._firstRetiredElement++;
				if (this._firstRetiredElement >= this.settings.maxPartices)
					this._firstRetiredElement = 0;
			}
		}

		__proto.addNewParticlesToVertexBuffer = function () { }
		__proto.addParticleArray = function (position, velocity) {
			var nextFreeParticle = this._firstFreeElement + 1;
			if (nextFreeParticle >= this.settings.maxPartices)
				nextFreeParticle = 0;
			if (nextFreeParticle === this._firstRetiredElement)
				return;
			var particleData = ParticleData.Create(this.settings, position, velocity, this._currentTime);
			var startIndex = this._firstFreeElement * this._floatCountPerVertex * 4;
			for (var i = 0; i < 4; i++) {
				var j = 0, offset = 0;
				for (j = 0, offset = 4; j < 3; j++)
					this._vertices[startIndex + i * this._floatCountPerVertex + offset + j] = particleData.position[j];
				for (j = 0, offset = 7; j < 3; j++)
					this._vertices[startIndex + i * this._floatCountPerVertex + offset + j] = particleData.velocity[j];
				for (j = 0, offset = 10; j < 4; j++)
					this._vertices[startIndex + i * this._floatCountPerVertex + offset + j] = particleData.startColor[j];
				for (j = 0, offset = 14; j < 4; j++)
					this._vertices[startIndex + i * this._floatCountPerVertex + offset + j] = particleData.endColor[j];
				for (j = 0, offset = 18; j < 3; j++)
					this._vertices[startIndex + i * this._floatCountPerVertex + offset + j] = particleData.sizeRotation[j];
				for (j = 0, offset = 21; j < 2; j++)
					this._vertices[startIndex + i * this._floatCountPerVertex + offset + j] = particleData.radius[j];
				for (j = 0, offset = 23; j < 4; j++)
					this._vertices[startIndex + i * this._floatCountPerVertex + offset + j] = particleData.radian[j];
				this._vertices[startIndex + i * this._floatCountPerVertex + 27] = particleData.durationAddScale;
				this._vertices[startIndex + i * this._floatCountPerVertex + 28] = particleData.time;
			}
			this._firstFreeElement = nextFreeParticle;
		}

		return ParticleTemplateWebGL;
	})(ParticleTemplateBase)


	/**
	*@private
	*/
	//class laya.particle.ParticleTemplateCanvas extends laya.particle.ParticleTemplateBase
	var ParticleTemplateCanvas = (function (_super) {
		function ParticleTemplateCanvas(particleSetting) {
			/**
			*是否处于可播放状态
			*/
			this._ready = false;
			/**
			*贴图列表
			*/
			this.textureList = [];
			/**
			*粒子列表
			*/
			this.particleList = [];
			/**
			*贴图中心偏移x
			*/
			this.pX = 0;
			/**
			*贴图中心偏移y
			*/
			this.pY = 0;
			/**
			*当前活跃的粒子
			*/
			this.activeParticles = [];
			/**
			*粒子pool
			*/
			this.deadParticles = [];
			/**
			*粒子播放进度列表
			*/
			this.iList = [];
			/**
			*粒子系统使用的最大粒子数
			*/
			this._maxNumParticles = 0;
			/**
			*纹理的宽度
			*/
			this.textureWidth = NaN;
			/**
			*宽度倒数
			*/
			this.dTextureWidth = NaN;
			/**
			*是否支持颜色变化
			*/
			this.colorChange = true;
			/**
			*采样步长
			*/
			this.step = 1 / 60;
			this.canvasShader = new CanvasShader();
			ParticleTemplateCanvas.__super.call(this);
			this.settings = particleSetting;
			this._maxNumParticles = particleSetting.maxPartices;
			this.texture = new Texture();
			this.texture.on(/*laya.events.Event.LOADED*/"loaded", this, this._textureLoaded);
			this.texture.load(particleSetting.textureName);
		}

		__class(ParticleTemplateCanvas, 'laya.particle.ParticleTemplateCanvas', _super);
		var __proto = ParticleTemplateCanvas.prototype;
		__proto._textureLoaded = function (e) {
			this.setTexture(this.texture);
			this._ready = true;
		}

		__proto.clear = function (clearTexture) {
			(clearTexture === void 0) && (clearTexture = true);
			this.deadParticles.length = 0;
			this.activeParticles.length = 0;
			this.textureList.length = 0;
		}

		/**
		*设置纹理
		*@param texture
		*
		*/
		__proto.setTexture = function (texture) {
			this.texture = texture;
			this.textureWidth = texture.width;
			this.dTextureWidth = 1 / this.textureWidth;
			this.pX = -texture.width * 0.5;
			this.pY = -texture.height * 0.5;
			this.textureList = ParticleTemplateCanvas.changeTexture(texture, this.textureList);
			this.particleList.length = 0;
			this.deadParticles.length = 0;
			this.activeParticles.length = 0;
		}

		/**
		*创建一个粒子数据
		*@return
		*
		*/
		__proto._createAParticleData = function (position, velocity) {
			this.canvasShader.u_EndVelocity = this.settings.endVelocity;
			this.canvasShader.u_Gravity = this.settings.gravity;
			this.canvasShader.u_Duration = this.settings.duration;
			var particle;
			particle = ParticleData.Create(this.settings, position, velocity, 0);
			this.canvasShader.a_Position = particle.position;
			this.canvasShader.a_Velocity = particle.velocity;
			this.canvasShader.a_StartColor = particle.startColor;
			this.canvasShader.a_EndColor = particle.endColor;
			this.canvasShader.a_SizeRotation = particle.sizeRotation;
			this.canvasShader.a_Radius = particle.radius;
			this.canvasShader.a_Radian = particle.radian;
			this.canvasShader.a_AgeAddScale = particle.durationAddScale;
			this.canvasShader.oSize = this.textureWidth;
			var rst = new CMDParticle();
			var i = 0, len = this.settings.duration / (1 + particle.durationAddScale);
			var params = [];
			var mStep = NaN;
			for (i = 0; i < len; i += this.step) {
				params.push(this.canvasShader.getData(i));
			}
			rst.id = this.particleList.length;
			this.particleList.push(rst);
			rst.setCmds(params);
			return rst;
		}

		__proto.addParticleArray = function (position, velocity) {
			if (!this._ready) return;
			var tParticle;
			if (this.particleList.length < this._maxNumParticles) {
				tParticle = this._createAParticleData(position, velocity);
				this.iList[tParticle.id] = 0;
				this.activeParticles.push(tParticle);
			} else {
				if (this.deadParticles.length > 0) {
					tParticle = this.deadParticles.pop();
					this.iList[tParticle.id] = 0;
					this.activeParticles.push(tParticle);
				}
			}
		}

		__proto.advanceTime = function (passedTime) {
			(passedTime === void 0) && (passedTime = 1);
			if (!this._ready) return;
			var particleList = this.activeParticles;
			var pool = this.deadParticles;
			var i = 0, len = particleList.length;
			var tcmd;
			var tI = 0;
			var iList = this.iList;
			for (i = len - 1; i > -1; i--) {
				tcmd = particleList[i];
				tI = iList[tcmd.id];
				if (tI >= tcmd.maxIndex) {
					tI = 0;
					particleList.splice(i, 1);
					pool.push(tcmd);
				} else {
					tI += 1;
				}
				iList[tcmd.id] = tI;
			}
		}

		__proto.render = function (context, x, y) {
			if (!this._ready) return;
			if (this.activeParticles.length < 1) return;
			if (this.textureList.length < 2) return;
			if (this.settings.disableColor) {
				this.noColorRender(context, x, y);
			} else {
				this.canvasRender(context, x, y);
			}
		}

		__proto.noColorRender = function (context, x, y) {
			var particleList = this.activeParticles;
			var i = 0, len = particleList.length;
			var tcmd;
			var tParam;
			var tAlpha = NaN;
			var px = this.pX, py = this.pY;
			var pw = -px * 2, ph = -py * 2;
			var tI = 0;
			var textureList = this.textureList;
			var iList = this.iList;
			var preAlpha = NaN;
			context.translate(x, y);
			preAlpha = context.ctx.globalAlpha;
			for (i = 0; i < len; i++) {
				tcmd = particleList[i];
				tI = iList[tcmd.id];
				tParam = tcmd.cmds[tI];
				if (!tParam) continue;
				if ((tAlpha = tParam[1]) <= 0.01) continue;
				context.setAlpha(preAlpha * tAlpha);
				context.drawTextureWithTransform(this.texture, px, py, pw, ph, tParam[2], 1);
			}
			context.setAlpha(preAlpha);
			context.translate(-x, -y);
		}

		__proto.canvasRender = function (context, x, y) {
			var particleList = this.activeParticles;
			var i = 0, len = particleList.length;
			var tcmd;
			var tParam;
			var tAlpha = NaN;
			var px = this.pX, py = this.pY;
			var pw = -px * 2, ph = -py * 2;
			var tI = 0;
			var textureList = this.textureList;
			var iList = this.iList;
			var preAlpha = NaN;
			var preB;
			context.translate(x, y);
			preAlpha = context.ctx.globalAlpha;
			preB = context.ctx.globalCompositeOperation;
			context.blendMode("lighter");
			for (i = 0; i < len; i++) {
				tcmd = particleList[i];
				tI = iList[tcmd.id];
				tParam = tcmd.cmds[tI];
				if (!tParam) continue;
				if ((tAlpha = tParam[1]) <= 0.01) continue;
				context.save();
				context.transformByMatrix(tParam[2]);
				if (tParam[3] > 0.01) {
					context.setAlpha(preAlpha * tParam[3]);
					context.drawTexture(textureList[0], px, py, pw, ph);
				}
				if (tParam[4] > 0.01) {
					context.setAlpha(preAlpha * tParam[4]);
					context.drawTexture(textureList[1], px, py, pw, ph);
				}
				if (tParam[5] > 0.01) {
					context.setAlpha(preAlpha * tParam[5]);
					context.drawTexture(textureList[2], px, py, pw, ph);
				}
				context.restore();
			}
			context.setAlpha(preAlpha);
			context.translate(-x, -y);
			context.blendMode(preB);
		}

		ParticleTemplateCanvas.changeTexture = function (texture, rst, settings) {
			if (!rst) rst = [];
			rst.length = 0;
			if (settings && settings.disableColor) {
				rst.push(texture, texture, texture);
			} else {
				Utils.copyArray(rst, PicTool.getRGBPic(texture));
			}
			return rst;
		}

		return ParticleTemplateCanvas;
	})(ParticleTemplateBase)


	/**
	*@private
	*/
	//class laya.particle.ParticleTemplate2D extends laya.particle.ParticleTemplateWebGL
	var ParticleTemplate2D = (function (_super) {
		function ParticleTemplate2D(parSetting) {
			this._vertexBuffer2D = null;
			this._indexBuffer2D = null;
			this.x = 0;
			this.y = 0;
			this._blendFn = null;
			this._startTime = 0;
			this.sv = new ParticleShaderValue();
			ParticleTemplate2D.__super.call(this, parSetting);
			var _this = this;
			Laya.loader.load(this.settings.textureName, Handler.create(null, function (texture) {
				(texture.bitmap).enableMerageInAtlas = false;
				_this.texture = texture;
			}));
			this.sv.u_Duration = this.settings.duration;
			this.sv.u_Gravity = this.settings.gravity;
			this.sv.u_EndVelocity = this.settings.endVelocity;
			this._blendFn = BlendMode.fns[parSetting.blendState];
			this.initialize();
			this._vertexBuffer = this._vertexBuffer2D = VertexBuffer2D.create(-1,/*laya.webgl.WebGLContext.DYNAMIC_DRAW*/0x88E8);
			this._indexBuffer = this._indexBuffer2D = IndexBuffer2D.create(/*laya.webgl.WebGLContext.STATIC_DRAW*/0x88E4);
			this.loadContent();
		}

		__class(ParticleTemplate2D, 'laya.particle.ParticleTemplate2D', _super);
		var __proto = ParticleTemplate2D.prototype;
		Laya.imps(__proto, { "laya.webgl.submit.ISubmit": true })
		__proto.getRenderType = function () { return -111 }
		__proto.releaseRender = function () { }
		__proto.addParticleArray = function (position, velocity) {
			position[0] += this.x;
			position[1] += this.y;
			_super.prototype.addParticleArray.call(this, position, velocity);
		}

		__proto.loadContent = function () {
			var indexes = new Uint16Array(this.settings.maxPartices * 6);
			for (var i = 0; i < this.settings.maxPartices; i++) {
				indexes[i * 6 + 0] = (i * 4 + 0);
				indexes[i * 6 + 1] = (i * 4 + 1);
				indexes[i * 6 + 2] = (i * 4 + 2);
				indexes[i * 6 + 3] = (i * 4 + 0);
				indexes[i * 6 + 4] = (i * 4 + 2);
				indexes[i * 6 + 5] = (i * 4 + 3);
			}
			this._indexBuffer2D.clear();
			this._indexBuffer2D.append(indexes);
			this._indexBuffer2D.upload();
		}

		__proto.addNewParticlesToVertexBuffer = function () {
			this._vertexBuffer2D.clear();
			this._vertexBuffer2D.append(this._vertices);
			var start = 0;
			if (this._firstNewElement < this._firstFreeElement) {
				start = this._firstNewElement * 4 * this._floatCountPerVertex * 4;
				this._vertexBuffer2D.subUpload(start, start, start + (this._firstFreeElement - this._firstNewElement) * 4 * this._floatCountPerVertex * 4);
			} else {
				start = this._firstNewElement * 4 * this._floatCountPerVertex * 4;
				this._vertexBuffer2D.subUpload(start, start, start + (this.settings.maxPartices - this._firstNewElement) * 4 * this._floatCountPerVertex * 4);
				if (this._firstFreeElement > 0) {
					this._vertexBuffer2D.setNeedUpload();
					this._vertexBuffer2D.subUpload(0, 0, this._firstFreeElement * 4 * this._floatCountPerVertex * 4);
				}
			}
			this._firstNewElement = this._firstFreeElement;
		}

		__proto.renderSubmit = function () {
			if (this.texture && this.texture.loaded) {
				this.update(Laya.timer.delta);
				this.sv.u_CurrentTime = this._currentTime;
				if (this._firstNewElement != this._firstFreeElement) {
					this.addNewParticlesToVertexBuffer();
				}
				this.blend();
				if (this._firstActiveElement != this._firstFreeElement) {
					var gl = WebGL.mainContext;
					this._vertexBuffer2D.bind(this._indexBuffer2D);
					this.sv.u_texture = this.texture.source;
					this.sv.upload();
					if (this._firstActiveElement < this._firstFreeElement) {
						WebGL.mainContext.drawElements(/*laya.webgl.WebGLContext.TRIANGLES*/0x0004, (this._firstFreeElement - this._firstActiveElement) * 6,/*laya.webgl.WebGLContext.UNSIGNED_SHORT*/0x1403, this._firstActiveElement * 6 * 2);
					}
					else {
						WebGL.mainContext.drawElements(/*laya.webgl.WebGLContext.TRIANGLES*/0x0004, (this.settings.maxPartices - this._firstActiveElement) * 6,/*laya.webgl.WebGLContext.UNSIGNED_SHORT*/0x1403, this._firstActiveElement * 6 * 2);
						if (this._firstFreeElement > 0)
							WebGL.mainContext.drawElements(/*laya.webgl.WebGLContext.TRIANGLES*/0x0004, this._firstFreeElement * 6,/*laya.webgl.WebGLContext.UNSIGNED_SHORT*/0x1403, 0);
					}
					Stat.drawCall++;
				}
				this._drawCounter++;
			}
			return 1;
		}

		__proto.blend = function () {
			if (BlendMode.activeBlendFunction !== this._blendFn) {
				var gl = WebGL.mainContext;
				gl.enable(/*laya.webgl.WebGLContext.BLEND*/0x0BE2);
				this._blendFn(gl);
				BlendMode.activeBlendFunction = this._blendFn;
			}
		}

		__proto.dispose = function () {
			this._vertexBuffer2D.dispose();
			this._indexBuffer2D.dispose();
		}

		ParticleTemplate2D.activeBlendType = -1;
		return ParticleTemplate2D;
	})(ParticleTemplateWebGL)


	/**
	*@private
	*/
	//class laya.particle.shader.value.ParticleShaderValue extends laya.webgl.shader.d2.value.Value2D
	var ParticleShaderValue = (function (_super) {
		function ParticleShaderValue() {
			this.a_CornerTextureCoordinate = [4,/*laya.webgl.WebGLContext.FLOAT*/0x1406, false, 116, 0];
			this.a_Position = [3,/*laya.webgl.WebGLContext.FLOAT*/0x1406, false, 116, 16];
			this.a_Velocity = [3,/*laya.webgl.WebGLContext.FLOAT*/0x1406, false, 116, 28];
			this.a_StartColor = [4,/*laya.webgl.WebGLContext.FLOAT*/0x1406, false, 116, 40];
			this.a_EndColor = [4,/*laya.webgl.WebGLContext.FLOAT*/0x1406, false, 116, 56];
			this.a_SizeRotation = [3,/*laya.webgl.WebGLContext.FLOAT*/0x1406, false, 116, 72];
			this.a_Radius = [2,/*laya.webgl.WebGLContext.FLOAT*/0x1406, false, 116, 84];
			this.a_Radian = [4,/*laya.webgl.WebGLContext.FLOAT*/0x1406, false, 116, 92];
			this.a_AgeAddScale = [1,/*laya.webgl.WebGLContext.FLOAT*/0x1406, false, 116, 108];
			this.a_Time = [1,/*laya.webgl.WebGLContext.FLOAT*/0x1406, false, 116, 112];
			this.u_CurrentTime = NaN;
			this.u_Duration = NaN;
			this.u_Gravity = null;
			//v3
			this.u_EndVelocity = NaN;
			this.u_texture = null;
			ParticleShaderValue.__super.call(this, 0, 0);
		}

		__class(ParticleShaderValue, 'laya.particle.shader.value.ParticleShaderValue', _super);
		var __proto = ParticleShaderValue.prototype;
		__proto.upload = function () {
			this.refresh();
			ParticleShaderValue.pShader.upload(this);
		}

		__static(ParticleShaderValue,
			['pShader', function () { return this.pShader = new ParticleShader(); }
			]);
		return ParticleShaderValue;
	})(Value2D)


	/**
	*<code>Particle2D</code> 类是2D粒子播放类
	*
	*/
	//class laya.particle.Particle2D extends laya.display.Sprite
	var Particle2D = (function (_super) {
		function Particle2D(setting) {
			/**@private */
			this._matrix4 = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
			/**@private */
			this._particleTemplate = null;
			/**@private */
			this._canvasTemplate = null;
			/**@private */
			this._emitter = null;
			/**是否自动播放*/
			this.autoPlay = true;
			Particle2D.__super.call(this);
			if (setting) this.setParticleSetting(setting);
		}

		__class(Particle2D, 'laya.particle.Particle2D', _super);
		var __proto = Particle2D.prototype;
		/**
		*加载粒子文件
		*@param url 粒子文件地址
		*/
		__proto.load = function (url) {
			Laya.loader.load(url, Handler.create(this, this.setParticleSetting), null,/*laya.net.Loader.JSON*/"json");
		}

		/**
		*设置粒子配置数据
		*@param settings 粒子配置数据
		*/
		__proto.setParticleSetting = function (setting) {
			var _$this = this;
			if (!setting) return this.stop();
			ParticleSetting.checkSetting(setting);
			if (/*__JS__ */!window.ConchParticleTemplate2D || Render.isWebGL) this.customRenderEnable = true;
			if (Render.isWebGL) {
				this._particleTemplate = new ParticleTemplate2D(setting);
				this.graphics._saveToCmd(Render.context._drawParticle, [this._particleTemplate]);
			}
			else if (Render.isConchApp &&/*__JS__ */window.ConchParticleTemplate2D) {
				this._particleTemplate =/*__JS__ */new ConchParticleTemplate2D();
				var _this = this;
				Laya.loader.load(setting.textureName, Handler.create(null, function (texture) {
				/*__JS__ */_this._particleTemplate.texture = texture;
					_this._particleTemplate.settings = setting;
					if (Render.isConchNode) {
					/*__JS__ */_this.graphics.drawParticle(_this._particleTemplate);
					}
					else {
						_this.graphics._saveToCmd(Render.context._drawParticle, [_$this._particleTemplate]);
					}
				}));
				this._emitter = { start: function () { } };
			/*__JS__ */this.play = this._particleTemplate.play.bind(this._particleTemplate);
			/*__JS__ */this.stop = this._particleTemplate.stop.bind(this._particleTemplate);
				if (this.autoPlay) this.play();
				return;
			}
			else {
				this._particleTemplate = this._canvasTemplate = new ParticleTemplateCanvas(setting);
			}
			if (!this._emitter) {
				this._emitter = new Emitter2D(this._particleTemplate);
			} else {
				(this._emitter).template = this._particleTemplate;
			}
			if (this.autoPlay) {
				this.emitter.start();
				this.play();
			}
		}

		/**
		*播放
		*/
		__proto.play = function () {
			this.timer.frameLoop(1, this, this._loop);
		}

		/**
		*停止
		*/
		__proto.stop = function () {
			this.timer.clear(this, this._loop);
		}

		/**@private */
		__proto._loop = function () {
			this.advanceTime(1 / 60);
		}

		/**
		*时钟前进
		*@param passedTime 时钟前进时间
		*/
		__proto.advanceTime = function (passedTime) {
			(passedTime === void 0) && (passedTime = 1);
			if (this._canvasTemplate) {
				this._canvasTemplate.advanceTime(passedTime);
			}
			if (this._emitter) {
				this._emitter.advanceTime(passedTime);
			}
		}

		__proto.customRender = function (context, x, y) {
			if (Render.isWebGL) {
				this._matrix4[0] = context.ctx._curMat.a;
				this._matrix4[1] = context.ctx._curMat.b;
				this._matrix4[4] = context.ctx._curMat.c;
				this._matrix4[5] = context.ctx._curMat.d;
				this._matrix4[12] = context.ctx._curMat.tx;
				this._matrix4[13] = context.ctx._curMat.ty;
				var sv = (this._particleTemplate).sv;
				// 此处追加了自定义常量参数进shader计算
				sv.u_xxxx = {0:0,1:0,2:0};
				sv.u_mmat = this._matrix4;
			}
			if (this._canvasTemplate) {
				this._canvasTemplate.render(context, x, y);
			}
		}

		__proto.destroy = function (destroyChild) {
			(destroyChild === void 0) && (destroyChild = true);
			if ((this._particleTemplate instanceof laya.particle.ParticleTemplate2D))
				(this._particleTemplate).dispose();
			_super.prototype.destroy.call(this, destroyChild);
		}

		/**
		*设置 粒子文件地址
		*@param path 粒子文件地址
		*/
		__getset(0, __proto, 'url', null, function (url) {
			this.load(url);
		});

		/**
		*获取粒子发射器
		*/
		__getset(0, __proto, 'emitter', function () {
			return this._emitter;
		});

		return Particle2D;
	})(Sprite)


	/**
	*@private
	*/
	//class laya.particle.shader.ParticleShader extends laya.webgl.shader.Shader
	var ParticleShader = (function (_super) {
		function ParticleShader() {
			ParticleShader.__super.call(this, ParticleShader.vs, ParticleShader.ps, "ParticleShader");
		}

		__class(ParticleShader, 'laya.particle.shader.ParticleShader', _super);
		__static(ParticleShader,
			['vs', function () { return this.vs = "attribute vec4 a_CornerTextureCoordinate;\nattribute vec3 a_Position;\nattribute vec3 a_Velocity;\nattribute vec4 a_StartColor;\nattribute vec4 a_EndColor;\nattribute vec3 a_SizeRotation;\nattribute vec2 a_Radius;\nattribute vec4 a_Radian;\nattribute float a_AgeAddScale;\nattribute float a_Time;\n\nvarying vec4 v_Color;\nvarying vec2 v_TextureCoordinate;\n\nuniform float u_CurrentTime;\nuniform float u_Duration;\nuniform float u_EndVelocity;\nuniform vec3 u_Gravity;\n\n#ifdef PARTICLE3D\n uniform mat4 u_WorldMat;\n uniform mat4 u_View;\n uniform mat4 u_Projection;\n uniform vec2 u_ViewportScale;\n#else\n uniform vec2 size;\n uniform mat4 mmat;\n uniform mat4 u_mmat;\n#endif\n\nvec4 ComputeParticlePosition(in vec3 position, in vec3 velocity,in float age,in float normalizedAge)\n{\n\n   float startVelocity = length(velocity);//起始标量速度\n   float endVelocity = startVelocity * u_EndVelocity;//结束标量速度\n\n   float velocityIntegral = startVelocity * normalizedAge +(endVelocity - startVelocity) * normalizedAge *normalizedAge/2.0;//计算当前速度的标量（单位空间），vt=v0*t+(1/2)*a*(t^2)\n   \n   vec3 addPosition = normalize(velocity) * velocityIntegral * u_Duration;//计算受自身速度影响的位置，转换标量到矢量    \n   addPosition += u_Gravity * age * normalizedAge;//计算受重力影响的位置\n   \n   float radius=mix(a_Radius.x, a_Radius.y, normalizedAge); //计算粒子受半径和角度影响（无需计算角度和半径时，可用宏定义优化屏蔽此计算）\n   float radianHorizontal =mix(a_Radian.x,a_Radian.z,normalizedAge);\n   float radianVertical =mix(a_Radian.y,a_Radian.w,normalizedAge);\n   \n   float r =cos(radianVertical)* radius;\n   addPosition.y += sin(radianVertical) * radius;\n	\n   addPosition.x += cos(radianHorizontal) *r;\n   addPosition.z += sin(radianHorizontal) *r;\n  \n   #ifdef PARTICLE3D\n   position+=addPosition;\n    return  u_Projection*u_View*u_WorldMat*(vec4(position, 1.0));\n   #else\n   addPosition.y=-addPosition.y;//2D粒子位置更新需要取负，2D粒子坐标系Y轴正向朝上\n   position+=addPosition;\n    return  vec4(position,1.0);\n   #endif\n}\n\nfloat ComputeParticleSize(in float startSize,in float endSize, in float normalizedAge)\n{    \n    float size = mix(startSize, endSize, normalizedAge);\n    \n	#ifdef PARTICLE3D\n    //Project the size into screen coordinates.\n     return size * u_Projection[1][1];\n	#else\n	 return size;\n	#endif\n}\n\nmat2 ComputeParticleRotation(in float rot,in float age)\n{    \n    float rotation =rot * age;\n    //计算2x2旋转矩阵.\n    float c = cos(rotation);\n    float s = sin(rotation);\n    return mat2(c, -s, s, c);\n}\n\nvec4 ComputeParticleColor(in vec4 startColor,in vec4 endColor,in float normalizedAge)\n{\n	vec4 color=mix(startColor,endColor,normalizedAge);\n    //硬编码设置，使粒子淡入很快，淡出很慢,6.7的缩放因子把置归一在0到1之间，可以谷歌x*(1-x)*(1-x)*6.7的制图表\n    color.a *= normalizedAge * (1.0-normalizedAge) * (1.0-normalizedAge) * 6.7;\n   \n    return color;\n}\n\nvoid main()\n{\n   float age = u_CurrentTime - a_Time;\n   age *= 1.0 + a_AgeAddScale;\n   float normalizedAge = clamp(age / u_Duration,0.0,1.0);\n   gl_Position = ComputeParticlePosition(a_Position, a_Velocity, age, normalizedAge);//计算粒子位置\n   float pSize = ComputeParticleSize(a_SizeRotation.x,a_SizeRotation.y, normalizedAge);\n   mat2 rotation = ComputeParticleRotation(a_SizeRotation.z, age);\n	\n   #ifdef PARTICLE3D\n	gl_Position.xy += (rotation*a_CornerTextureCoordinate.xy) * pSize * u_ViewportScale;\n   #else\n    mat4 mat=u_mmat*mmat;\n    gl_Position=vec4((mat*gl_Position).xy,0.0,1.0);\n	gl_Position.xy += (rotation*a_CornerTextureCoordinate.xy) * pSize*vec2(mat[0][0],mat[1][1]);\n    gl_Position=vec4((gl_Position.x/size.x-0.5)*2.0,(0.5-gl_Position.y/size.y)*2.0,0.0,1.0);\n   #endif\n   \n   v_Color = ComputeParticleColor(a_StartColor,a_EndColor, normalizedAge);\n   v_TextureCoordinate =a_CornerTextureCoordinate.zw;\n}\n\n"; }, 'ps', function () { return this.ps = "#ifdef FSHIGHPRECISION\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\nvarying vec4 v_Color;\nvarying vec2 v_TextureCoordinate;\nuniform sampler2D u_texture;\n\nvoid main()\n{	\n	gl_FragColor=texture2D(u_texture,v_TextureCoordinate)*v_Color;\n	gl_FragColor.xyz *= v_Color.w;\n}"; }
			]);
		return ParticleShader;
	})(Shader)



})(window, document, Laya);

if (typeof define === 'function' && define.amd) {
	define('laya.core', ['require', "exports"], function (require, exports) {
		'use strict';
		Object.defineProperty(exports, '__esModule', { value: true });
		for (var i in Laya) {
			var o = Laya[i];
			o && o.__isclass && (exports[i] = o);
		}
	});
}
// ++
/**
 * 该文件在运行时附加，IDE-Stand不附加 
 * Created by kds on 2017/1/16.
 */
"use strict";
//------------------------------------------------------------------------------------------------------
// 插件用的继承关系（TS编译后的继承）
//------------------------------------------------------------------------------------------------------
var __extends = (this && this.__extends) || function (d, b) {
	for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	function __() { this.constructor = d; }
	d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
//------------------------------------------------------------------------------------------------------
// 初始化
//------------------------------------------------------------------------------------------------------
var os = {};
/**
 * 系统初始化
 * @param w 宽度
 * @param h 高度
 * @param isWebGL 是否使用WEBGL
 * @param is3D 是否启用3D模块
 */
os.init = function (w, h, isWebGL, is3D) {
	// 不输入或0的话表示全屏
	if (w == null || w == 0) w = window.innerWidth || document.body.clientWidth;
	if (h == null || h == 0) h = window.innerHeight || document.body.clientHeight;
	isWebGL = isWebGL == null ? true : isWebGL;
	is3D = is3D == null ? false : is3D;
	Browser.container = document.getElementById("layer1");
	if (is3D) {
		The33D.init(w, h, true);
	}
	else {
		isWebGL ? Laya.init(w, h, WebGL) : Laya.init(w, h);
	}
	window.stage = Laya.stage;
	window.loader = os.loader = Laya.loader;
	window.timer = Laya.timer;
	if (!isWebGL) Config.isAlpha = true;
	os.canvas = document.getElementById("the3Canvas");

	os.context = Laya.RunDriver.getWebGLContext(os.canvas);
	if (os.context) os.MAX_TEXTURE_SIZE = os.context.getParameter(os.context.MAX_TEXTURE_SIZE);

	// if (!is3D) {
	//     WorkerLoader.workerPath = "/kdsrpg/kdsrpg_core/libs/worker.js";
	//     WorkerLoader.enable = true;
	// }
	// alert(WorkerLoader)
	// 适配KS
	//for (var i in kdsrpg_staticVarInitFuncs) { kdsrpg_staticVarInitFuncs[i](); };
	//kdsrpg_staticVarInitFuncs = [];
};
// 音频默认关闭的
if (!!!window.navigator.userAgent.match(/\(i[^;]+;(U;)? CPU.+Mac OS X/)) {
	(function () {
		// window["mozAudioContext"] = top.window["mozAudioContext"];
		// window["AudioContext"] = top.window["AudioContext"];
		// window["webkitAudioContext"] = top.window["webkitAudioContext"];
		// window["_mozAudioContext"] = window["mozAudioContext"];
		// window["_AudioContext"] = window["AudioContext"];
		// window["_webkitAudioContext"] = window["webkitAudioContext"];
	})();
}

/**
 *
 * @returns Mac/Unix/Linux/Win2000/WinXP/Win2003/WinVista/Win7/other
 */
os.detectOS = function () {
	var sUserAgent = navigator.userAgent;
	var isWin = (navigator.platform == "Win32") || (navigator.platform == "Windows");
	var isMac = (navigator.platform == "Mac68K") || (navigator.platform == "MacPPC") || (navigator.platform == "Macintosh") || (navigator.platform == "MacIntel");
	if (isMac) return "Mac";
	var isUnix = (navigator.platform == "X11") && !isWin && !isMac;
	if (isUnix) return "Unix";
	var isLinux = (String(navigator.platform).indexOf("Linux") > -1);
	if (isLinux) return "Linux";
	if (isWin) {
		var isWin2K = sUserAgent.indexOf("Windows NT 5.0") > -1 || sUserAgent.indexOf("Windows 2000") > -1;
		if (isWin2K) return "Win2000";
		var isWinXP = sUserAgent.indexOf("Windows NT 5.1") > -1 || sUserAgent.indexOf("Windows XP") > -1;
		if (isWinXP) return "WinXP";
		var isWin2003 = sUserAgent.indexOf("Windows NT 5.2") > -1 || sUserAgent.indexOf("Windows 2003") > -1;
		if (isWin2003) return "Win2003";
		var isWinVista = sUserAgent.indexOf("Windows NT 6.0") > -1 || sUserAgent.indexOf("Windows Vista") > -1;
		if (isWinVista) return "WinVista";
		var isWin7 = sUserAgent.indexOf("Windows NT 6.1") > -1 || sUserAgent.indexOf("Windows 7") > -1;
		if (isWin7) return "Win7";
	}
	return "other";
};
//------------------------------------------------------------------------------------------------------
// 鼠标样式设定
//------------------------------------------------------------------------------------------------------
os._recordCursor = "default";
os.setCursor = function (style) { if (document.body.style.cursor == style) { return }; os._recordCursor = document.body.style.cursor; document.body.style.cursor = style; };
os.restoreCursor = function () { document.body.style.cursor = os._recordCursor; };
// enterframe 对同一个对象注册多次，在移除的时候会按照注册的顺序移除，同样要移除多次才能移除
window.requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;
os._enterframeMap = new Map();
os._removeframeMap = new Map();
os.add_ENTERFRAME = function (onHappen, thisPtr, args) {
	var _loop;
	window.requestAnimationFrame(_loop = function () {
		var _removeArr = os._removeframeMap.get(onHappen);
		if (_removeArr) {
			var idx = _removeArr.indexOf(thisPtr);
			if (idx != -1) {
				_removeArr.splice(idx, 1);
				return;
			}
		}
		onHappen.apply(thisPtr, args);
		window.requestAnimationFrame(_loop); // next frame 执行本函数
	});
	var enterArr = os._enterframeMap.get(onHappen);
	if (!enterArr) {
		enterArr = [];
		os._enterframeMap.set(onHappen, enterArr);
	}
	enterArr.push(thisPtr);
};
os.remove_ENTERFRAME = function (onHappen, thisPtr) {
	var enterArr = os._enterframeMap.get(onHappen);
	if (!enterArr) return;
	var idx = enterArr.indexOf(thisPtr);
	if (idx == -1) return;
	enterArr.splice(idx, 1);
	var removeArr = os._removeframeMap.get(onHappen);
	if (!removeArr) {
		removeArr = [];
		os._removeframeMap.set(onHappen, removeArr);
	}
	removeArr.push(thisPtr);
};

Object.defineProperty(os, 'defaultFamily', {
	get: function () {
		return Font.defaultFamily;
	},
	set: function (v) {
		Font.defaultFamily = v;
	}
});
//------------------------------------------------------------------------------------------------------
// top namespace
//------------------------------------------------------------------------------------------------------
for (var p in Laya) {
	if (typeof window[p] == "undefined") {
		var t = Laya[p];
		window[p] = t;
		if (t && t.prototype && t.prototype.destroy != null && t.prototype.dispose==null) t.prototype.dispose = t.prototype.destroy;
	}
}
window.TextField = Laya.Text;
window.URLInfo = Laya.URL;
window.EngineConfig = Laya.Config;
window.EventObject = Laya.Event;
window.TreeNode = Laya.Node;
window.UIImage = Laya.Image;
window.LayaAnimation = Laya.Animation;
window.UIEventObject = Laya.UIEvent;
window.DevGeolocation = Laya.Geolocation;
window.DivElement = Laya.HTMLDivElement;

//------------------------------------------------------------------------------------------------------
// class Extends
//------------------------------------------------------------------------------------------------------
// event extends
function eventExtends(evArr, clsObj) {
	if (clsObj == null) return;
	function toUpFuncName(funcName) {
		var regx = new RegExp("[A-Z]", "g");
		var m = funcName.match(regx);
		for (var i in m)
			funcName = funcName.replace(m[i], "_" + m[i])
		return funcName.toUpperCase();;
	}
	function evPush(extStr, evUpStr, evAPI, evType) {
		clsObj.prototype[extStr + evUpStr] = function (a, b, c) {
			this[evAPI](evType, b, a, c);
		}
	}
	function evHas(evType, evUpStr) {
		clsObj.prototype["has_" + evUpStr] = function () {
			return this.hasListener(evType);
		};
	}
	function evHappen(evType, evUpStr) {
		clsObj.prototype["happen_" + evUpStr] = function (data) {
			this.event(evType, data);
		};
	}
	for (var s in evArr) {
		var evType = evArr[s];
		var evUpStr = toUpFuncName(evType);
		evPush("add_", evUpStr, "on", evType);
		evPush("remove_", evUpStr, "off", evType);
		evPush("addOnce_", evUpStr, "once", evType);
		evHas(evType, evUpStr);
		evHappen(evType, evUpStr);
	}
	clsObj.prototype.removeAllListen = function () {
		this.offAll();
	}
}
var node_events = ["added", "display", "removed", "undisplay"];
eventExtends(node_events, TreeNode);
var sprite_events = ["click", "dragend", "dragmove", "dragstart", "mousedown", "mousedown", "mousemove", "mouseout", "mouseover", "mouseup", "mousewheel", "doubleclick", "rightclick", "rightmousedown", "rightmouseup", "enterframe"];
eventExtends(sprite_events, Sprite);
var stage_events = ["blur", "focus", "focuschange", "fullscreenchange", "resize", "visibilitychange", "keydown", "keypress", "keyup"];
eventExtends(stage_events, Stage);
var httpRequest_event = ["complete", "error", "progress"];
eventExtends(httpRequest_event, HttpRequest);
var Socket_event = ["close", "error", "message", "open"];
eventExtends(Socket_event, Socket);
var Animation_event = ["complete", "label"];
eventExtends(Animation_event, Animation);
var FrameAnimation_event = ["complete"];
eventExtends(FrameAnimation_event, FrameAnimation);
// 由于the3Box的双击存在BUG，暂时还未修复，先使用这个拿去用下
Sprite.prototype.add_DOUBLECLICK = function (onHappen, thisPtr, args) {
	var clickTimes = 0;
	var lastMouseX = null, lastMouseY = null;
	this.__dbclickObj = null;
	var timeF = [];
	var _onClick = function (e) {
		var dPx = Browser.onMobile ? 100 : 5;
		if (lastMouseX != null && (Math.abs(e.stageX - lastMouseX) > dPx || Math.abs(e.stageY - lastMouseY) > dPx)) {
			clickTimes = 0;
			for (var i in timeF) {
				clearTimeout(timeF[i]);
			}
			timeF.length = 0;
		}
		lastMouseX = e.stageX;
		lastMouseY = e.stageY;
		clickTimes++;
		var f = setTimeout(function () {
			clickTimes--;
			timeF.shift();
		}, 250);
		timeF.push(f);
		if (clickTimes == 2) {
			clickTimes = 0;
			for (var i in timeF) {
				clearTimeout(timeF[i]);
			}
			timeF.length = 0;
			e.type = "doubleClick";
			var params = args ? args.concat(e) : [e];
			onHappen.apply(thisPtr, params);
		}
	};
	if (this.__doubleClickFuncs == null) this.__doubleClickFuncs = {};
	this.__doubleClickFuncs[onHappen] = _onClick;
	this.add_CLICK(_onClick);
};
Sprite.prototype.remove_DOUBLECLICK = function (onHappen, thisPtr, args) {
	if (this.__doubleClickFuncs) {
		var _onClick = this.__doubleClickFuncs[onHappen];
		if (!_onClick) return;
		delete this.__doubleClickFuncs[onHappen];
		this.remove_CLICK(_onClick);
	}
};


var component_events = ["resize"];
eventExtends(component_events, Component);
var label_events = ["change"];
eventExtends(label_events, Label);
var textInput_events = ["enter", "input", "blur", "focus"];
eventExtends(textInput_events, TextInput);
var UIGroup_events = ["change"];
eventExtends(UIGroup_events, UIGroup);
var clip_events = ["change", "loaded"];
var scroll_events = ["change", "end", "start"]
eventExtends(clip_events, Clip);
eventExtends(label_events, Button);
eventExtends(UIGroup_events, ComboBox);
eventExtends(scroll_events, ScrollBar);
eventExtends(UIGroup_events, List);
// 获取选中的列表以及设置为选中
getset(0, List.prototype, 'selectedItemList', function () {
	var arr = [];
	for (var i in this.array) {
		var item = this.array[i];
		if (item.selected) arr.push(item);
	}
	return arr;
}, function (arr) {
	for (var i in arr) {
		var item = arr[i];
		if (this.array.indexOf(item) != -1) item.selected = true;
	}
});
// 获取未选中的的列表以及设置为未选中
getset(0, List.prototype, 'unSelectedItemList', function () {
	var arr = [];
	for (var i in this.array) {
		var item = this.array[i];
		if (!item.selected) arr.push(item);
	}
	return arr;
}, function (arr) {
	for (var i in arr) {
		var item = arr[i];
		if (this.array.indexOf(item) != -1) item.selected = false;
	}
});
// Handler
Handler.prototype.delayRun = function (delay) {
	return setTimeout(function (handler) {
		handler.run();
	}, delay, this);
};
Handler.prototype.delayRunConver = function (delay) {
	if (this.delayRunSign) {
		clearTimeout(this.delayRunSign);
	}
	this.delayRunSign = this.delayRun(delay);
};
// utils Browser
getset(0, Browser, 'onMac', function () {
	return os.detectOS() == "Mac";
});
// Point
Point.interpolate = function (to, from, per) {
	var p = new Point();
	p.x = (to.x - from.x) * per + from.x;
	p.y = (to.y - from.y) * per + from.y;
	return p;
}
Point.distance = function (from, to) {
	return from.distance(to.x, to.y);
}
//------------------------------------------------------------------------------------------------------
// 插件
//------------------------------------------------------------------------------------------------------
/**
 * 用于容器分割
 * -- 横向分割/纵向分割
 * -- 可贴墙（贴墙可传入两个显示对象用于图标）
 * Created by kds on 2017/1/18 0018.
 */

//------------------------------------------------------------------------------------------------------
// 追加的事件类型
//------------------------------------------------------------------------------------------------------
UIEventObject.DATA_CHANGE = "DATA_CHANGE";




var ListItemData = (function (_super) {
    __extends(ListItemData, _super);
    function ListItemData() {
        _super.call(this);
        this._selected = false;
        this._group = null;
        this._label = "";
    }
    Object.defineProperty(ListItemData.prototype, "selected", {
        get: function () { return this._selected; },
        set: function (v) {
            if (v != this._selected) {
                this._selected = v;
                this.happen_SELECTE_CHANGED();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ListItemData.prototype, "label", {
        get: function () { return this._label; },
        set: function (v) { this._label = v; },
        enumerable: true,
        configurable: true
    });
    ListItemData.prototype.add_SELECTE_CHANGED = function (onHappen, thisPtr, args) {
        if (args === void 0) { args = null; }
        this.on("SELECTE_CHANGED", thisPtr, onHappen, args);
    };
    ListItemData.prototype.remove_SELECTE_CHANGED = function (onHappen, thisPtr) {
        this.off("SELECTE_CHANGED", thisPtr, onHappen);
    };
    ListItemData.prototype.happen_SELECTE_CHANGED = function (data) {
        if (data === void 0) { data = null; }
        this.event("SELECTE_CHANGED", data);
    };
    ListItemData.prototype.has_SELECTE_CHANGED = function () {
        return this.hasListener("SELECTE_CHANGED");
    };
    return ListItemData;
}(EventDispatcher));
var ComputeTS = (function () {
    function ComputeTS() {
    }
    ComputeTS.init = function (onFin) {
        if (onFin === void 0) { onFin = null; }
        var tsUR = new HttpRequest();
        tsUR.send("http://www.kdsrpg.com/include/getTsTok.php?pid=" + ComputeTS.projectID, "", "post");
        tsUR.add_COMPLETE(function (str) {
            if (str != "error") {
                ComputeTS.kdsrpgTSToken = JSON.parse(str).access_token;
                onFin && onFin(true);
            }
            else {
                onFin && onFin(false);
            }
        }, this);
        tsUR.add_ERROR(function () {
            onFin && onFin(false);
        }, this);
    };
    ComputeTS.play = function (content, per, speed, pit, vol) {
        if (per === void 0) { per = 0; }
        if (speed === void 0) { speed = 7; }
        if (pit === void 0) { pit = 5; }
        if (vol === void 0) { vol = 8; }
        if (!ComputeTS.kdsrpgTSToken)
            return;
        var lan = "zh";
        var ctp = "1";
        var body = "tex=" + content + "&lan=" + lan + "&tok=" + ComputeTS.kdsrpgTSToken + "&ctp=" + ctp + "&cuid=" + ComputeTS.projectID + "&spd=" + speed + "&pit=" + pit + "&vol=" + vol + "&per=" + per;
        var soundURL = "http://tsn.baidu.com/text2audio?" + body;
        SoundManager.playSound(soundURL);
    };
    ComputeTS.projectID = 1;
    return ComputeTS;
}());





var PartitionBox = (function (_super) {
    __extends(PartitionBox, _super);
    function PartitionBox() {
        _super.call(this);
        this._wallThick = 1;
        this._wallThickHalf = this._wallThick * 0.5;
        this._wallTouchThick = 2;
        this._wallTouchThickHalf = this._wallTouchThick * 0.5;
        this._horizontalPartition = true;
        this._partitionPercent = 50;
        this._partitionValue = 50;
        this._isUseParcent = true;
        this._wallSprite = new UIImage("comp/progress.png");
        this._isDragingWall = false;
        this._cantDragWall = false;
        this.firstMin = null;
        this.firstMax = null;
        this.secondMin = null;
        this.secondMax = null;
        this._wallSprite.alpha = 0;
        new Handler(this, this.init).delayRun(0);
        this.on(EventObject.RESIZE, this, this.update);
    }
    PartitionBox.prototype.init = function () {
        this._wallSprite.pivotX = this._wallSprite.pivotY = this._wallThickHalf;
        this._wallSprite.name = "PartitionBoxWall";
        this.addChild(this._wallSprite);
        this._wallSprite.add_MOUSEDOWN(this.onWallMouseDown, this);
        this._wallSprite.add_MOUSEMOVE(function () { if (this._cantDragWall)
            return; this._horizontalPartition ? os.setCursor("e-resize") : os.setCursor("n-resize"); }, this);
        this._wallSprite.add_MOUSEOUT(function () { if (this._cantDragWall)
            return; if (!this._isDragingWall)
            os.restoreCursor(); }, this);
        this.update();
    };
    Object.defineProperty(PartitionBox.prototype, "horizontalPartition", {
        set: function (v) {
            this._horizontalPartition = v;
            this.update();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PartitionBox.prototype, "cantDragWall", {
        set: function (v) {
            this._cantDragWall = v;
            this._wallSprite.visible = !v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PartitionBox.prototype, "partitionPercent", {
        set: function (v) {
            this._isUseParcent = true;
            this._partitionPercent = v;
            this.update();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PartitionBox.prototype, "partitionValue", {
        set: function (v) {
            this._isUseParcent = false;
            this._partitionValue = v;
            this.update();
        },
        enumerable: true,
        configurable: true
    });
    PartitionBox.prototype.wallEnabled = function (v) {
        this._wallSprite.mouseEnabled = v;
    };
    PartitionBox.prototype.onWallMouseDown = function () {
        if (this._cantDragWall)
            return;
        this._isDragingWall = true;
        var dragRect;
        if (this._horizontalPartition) {
            dragRect = new Rectangle(1, 0, this.width - 2, 0);
        }
        else {
            dragRect = new Rectangle(0, 1, 0, this.height - 2);
        }
        this.lastWallPos = [this._wallSprite.x, this._wallSprite.y];
        var wallSprite = this._wallSprite;
        var _this = this;
        var _onWindowMouseMove, _onWindowMouseUp;
        window.addEventListener("mousemove", _onWindowMouseMove = function (e) {
            var clientX, clientY;
            clientX = e.offsetX;
            clientY = e.offsetY;
            var globalP = new Point(clientX, clientY);
            var p = _this.globalToLocal(globalP);
            p.x = Math.max(dragRect.x, p.x);
            p.x = Math.min(dragRect.right, p.x);
            p.y = Math.max(dragRect.y, p.y);
            p.y = Math.min(dragRect.bottom, p.y);
            wallSprite.x = p.x;
            wallSprite.y = p.y;
            _this.onWallMouseMove();
        });
        window.addEventListener("mouseup", _onWindowMouseUp = function (e) {
            _this._isDragingWall = false;
            os.restoreCursor();
            window.removeEventListener("mousemove", _onWindowMouseMove);
            window.removeEventListener("mouseup", _onWindowMouseUp);
        });
    };
    PartitionBox.prototype.onWallMouseMove = function () {
        var lastWallPos = [this._wallSprite.x, this._wallSprite.y];
        if (lastWallPos[0] == this.lastWallPos[0] && lastWallPos[1] == this.lastWallPos[1])
            return;
        this.lastWallPos = [this._wallSprite.x, this._wallSprite.y];
        if (this._horizontalPartition) {
            if (this._isUseParcent) {
                this._partitionPercent = this._wallSprite.x * 100 / this.width;
            }
            else {
                this._partitionValue = this._wallSprite.x;
            }
        }
        else {
            if (this._isUseParcent) {
                this._partitionPercent = this._wallSprite.y * 100 / this.height;
            }
            else {
                this._partitionValue = this._wallSprite.y;
            }
        }
        if (this.firstMin && this._partitionValue < this.firstMin) {
            this._partitionValue = this.firstMin;
        }
        if (this.firstMax && this._partitionValue > this.firstMax) {
            this._partitionValue = this.firstMax;
        }
        if (this.secondMax && this.width - this._partitionValue > this.secondMax) {
            this._partitionValue = this.width - this.secondMax;
        }
        if (this.secondMin && this.width - this._partitionValue < this.secondMin) {
            this._partitionValue = this.width - this.secondMin;
        }
        this._partitionValue = this._partitionValue;
        this.update(false);
    };
    PartitionBox.prototype.update = function (setWallPos) {
        if (setWallPos === void 0) { setWallPos = null; }
        setWallPos = setWallPos || true;
        var len = this.numChildren;
        if (len > 3)
            throw ("too many children in partitionBox!");
        if (len == 0)
            return;
        var dynamicPos, fixPos, dynamicWH, fixWH, wallX, wallY, wallWidth, wallHeight;
        if (this._horizontalPartition) {
            dynamicPos = "x";
            fixPos = "y";
            dynamicWH = "width";
            fixWH = "height";
            wallWidth = this._wallThick;
            wallHeight = this.height;
        }
        else {
            dynamicPos = "y";
            fixPos = "x";
            dynamicWH = "height";
            fixWH = "width";
            wallHeight = this._wallThick;
            wallWidth = this.width;
        }
        var _partitionPercent = len == 1 ? 100 : this._partitionPercent;
        var childA = this.getChildAt(0);
        childA[dynamicPos] = 0;
        childA[fixPos] = 0;
        if (this._isUseParcent) {
            childA[dynamicWH] = (this[dynamicWH] * _partitionPercent) / 100 - this._wallThickHalf;
        }
        else {
            childA[dynamicWH] = this._partitionValue;
        }
        childA[fixWH] = this[fixWH];
        if (len >= 2) {
            var childB = this.getChildAt(1);
            childB[dynamicPos] = childA[dynamicWH] + this._wallThick;
            childB[fixPos] = 0;
            childB[dynamicWH] = this[dynamicWH] - childA[dynamicWH] - this._wallThick;
            childB[fixWH] = this[fixWH];
        }
        if (setWallPos) {
            this._wallSprite[fixPos] = 0;
            this._wallSprite[dynamicPos] = childA[dynamicWH] + this._wallThickHalf;
            this._wallSprite.width = wallWidth;
            this._wallSprite.height = wallHeight;
            this._wallSprite.hitArea = new Rectangle(-this._wallTouchThickHalf, -this._wallTouchThickHalf, this._wallSprite.width + this._wallTouchThick, this._wallSprite.height + this._wallTouchThick);
        }
    };
    return PartitionBox;
}(Box));
var PartitionBoxV = (function (_super) {
    __extends(PartitionBoxV, _super);
    function PartitionBoxV() {
        _super.call(this);
        this._horizontalPartition = false;
    }
    return PartitionBoxV;
}(PartitionBox));
Sprite.prototype["getGlobalBounds"] = function () {
    var min = this.localToGlobal(new Point(0, 0));
    var max = this.localToGlobal(new Point(this.width, this.height));
    var resultRect = new Rectangle();
    resultRect.x = min.x;
    resultRect.y = min.y;
    resultRect.width = max.x - min.x;
    resultRect.height = max.y - min.y;
    return resultRect;
};
Sprite.prototype["getGlobalSelfBounds"] = function () {
    var rect = this.getSelfBounds();
    var min = this.localToGlobal(new Point(rect.x, rect.y));
    var max = this.localToGlobal(new Point(rect.right, rect.bottom));
    var resultRect = new Rectangle();
    resultRect.x = min.x;
    resultRect.y = min.y;
    resultRect.width = max.x - min.x;
    resultRect.height = max.y - min.y;
    return resultRect;
};
Point["distance2"] = function (ax, ay, bx, by) {
    return Math.sqrt((bx - ax) * (bx - ax) + (by - ay) * (by - ay));
};
Point["interpolate2"] = function (toX, toY, fromX, fromY, per) {
    var x = (toX - fromX) * per + fromX;
    var y = (toY - fromY) * per + fromY;
    return [x, y];
};





var ListRender = (function (_super) {
    __extends(ListRender, _super);
    function ListRender() {
        _super.call(this);
        new Handler(this, this._init).delayRun(0);
    }
    ListRender.prototype._init = function () {
        this.initEvent();
    };
    Object.defineProperty(ListRender.prototype, "mainComp", {
        get: function () {
            if (this._mainComp)
                return this._mainComp;
            if (this.parent == null) {
                return null;
            }
            this._mainComp = this.parent.parent;
            return this._mainComp;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ListRender.prototype, "dataList", {
        get: function () {
            return this.mainComp.array;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ListRender.prototype, "lastSelected", {
        get: function () {
            return this.mainComp ? this.mainComp.selectedItem : null;
        },
        set: function (v) {
            if (this.mainComp)
                this.mainComp.selectedItem = v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ListRender.prototype, "dataSource", {
        get: function () {
            return this.data;
        },
        set: function (v) {
            if (this.data != v) {
                if (this.data) {
                    this.data.remove_SELECTE_CHANGED(this._onDataSelectChange, this);
                }
                this.data = v;
                if (this.data) {
                    this.data.add_SELECTE_CHANGED(this._onDataSelectChange, this);
                    this._onDataSelectChange();
                }
                this.happen_DATACHANGE();
            }
            this.updateAppearance();
        },
        enumerable: true,
        configurable: true
    });
    ListRender.prototype.addChild = function (node) {
        this[node.name] = node;
        if (node.name == "overImg" || node.name == "selectImg") {
            node.visible = false;
        }
        return _super.prototype.addChild.call(this, node);
    };
    ListRender.prototype.initEvent = function () {
        this.add_MOUSEOVER(this._onMouseOver, this);
        this.add_MOUSEOUT(this._onMouseOut, this);
        this.add_CLICK(this._onMouseDown, this);
        this.add_RIGHTMOUSEDOWN(this._onMouseDown, this);
        this.add_DOUBLECLICK(this._onDBClick, this);
    };
    ListRender.prototype._onMouseOver = function () {
        if (this.mainComp["__overImg"])
            this.mainComp["__overImg"].visible = false;
        this.overImg.visible = true;
        this.mainComp["__overImg"] = this.overImg;
    };
    ListRender.prototype._onMouseOut = function () {
        this.overImg.visible = false;
    };
    ListRender.prototype._onMouseDown = function (e) {
        if (!this.data)
            return;
        var mainComp = this.mainComp;
        if (mainComp.disabled)
            return;
        var dataList = this.dataList;
        if (e.type == "rightmousedown" && this.data.selected) {
            return;
        }
        if (mainComp.supportMultiSelect) {
            this.isMultiSelect = e.ctrlKey || e.shiftKey;
            if (e.shiftKey) {
                if (this.lastSelected) {
                    var lastSelected = this.lastSelected;
                    var listLen = dataList.length;
                    var lastItemIdx = dataList.indexOf(lastSelected);
                    var thisItemIdx = dataList.indexOf(this.data);
                    if (lastItemIdx != -1 && thisItemIdx != -1) {
                        var formIdx, toIdx;
                        if (lastItemIdx > thisItemIdx) {
                            formIdx = thisItemIdx;
                            toIdx = lastItemIdx;
                        }
                        else {
                            formIdx = lastItemIdx;
                            toIdx = thisItemIdx;
                        }
                        for (var i = formIdx; i <= toIdx; i++) {
                            dataList[i].selected = true;
                        }
                        for (var i = 0; i < formIdx; i++) {
                            dataList[i].selected = false;
                        }
                        for (var i = toIdx + 1; i < listLen; i++) {
                            dataList[i].selected = false;
                        }
                        this.lastSelected = lastSelected;
                        return;
                    }
                }
            }
        }
        var toSelected = !this.data.selected;
        if (mainComp.mustSelectOne && !toSelected) {
            var selectCount = 0;
            var dataListLen = dataList.length;
            for (var i = 0; i < dataListLen; i++) {
                if (dataList[i].selected)
                    selectCount++;
                if (selectCount > 1)
                    break;
            }
            if (selectCount == 1) {
                return;
            }
        }
        if (!this.isMultiSelect) {
            var isCancelElse = false;
            for (var i = 0; i < this.dataList.length; i++) {
                var elseData = this.dataList[i];
                if (elseData != this.data && elseData.selected) {
                    elseData.selected = false;
                    isCancelElse = true;
                }
            }
            this.data.selected = !isCancelElse ? toSelected : true;
        }
        else {
            this.data.selected = toSelected;
        }
        if (this.data.selected)
            this.lastSelected = this.data;
    };
    ListRender.prototype._onDBClick = function (e) {
        this.mainComp.event("itemDoubleClick", this.data);
    };
    ListRender.prototype._onDataSelectChange = function (e) {
        if (e === void 0) { e = null; }
        this.updateAppearance_selected();
        if (this.data.selected) {
            this.lastSelected = this.data;
        }
    };
    ListRender.prototype.updateAppearance_selected = function () {
        if (this.data == null) {
            return;
        }
        this.selectImg.visible = this.data.selected;
        if (this["labelStyle"]) {
        }
        if (this["labelStyle"] && this["labelStyle"].labelColors) {
            var cArr = this["labelStyle"].labelColors.split(",");
            this.label.color = this.data.selected ? cArr[0] : cArr[1];
        }
        else {
            this.label.color = this.data.selected ? "#ffffff" : "#868686";
        }
    };
    ListRender.prototype.updateAppearance = function () {
        if (this.data == null)
            return;
        this.label.text = this.data.label;
        this.updateAppearance_selected();
        if (this.data.renderFunc) {
            this.data.renderFunc.apply(this);
        }
    };
    ListRender.prototype.add_DATACHANGE = function (onHappen, thisPtr, args) {
        if (args === void 0) { args = null; }
        this.on(UIEventObject.DATA_CHANGE, thisPtr, onHappen, args);
    };
    ;
    ListRender.prototype.remove_DATACHANGE = function (onHappen, thisPtr) {
        this.off(UIEventObject.DATA_CHANGE, thisPtr, onHappen);
    };
    ;
    ListRender.prototype.happen_DATACHANGE = function (data) {
        if (data === void 0) { data = null; }
        this.event(UIEventObject.DATA_CHANGE, data);
    };
    ;
    ListRender.prototype.destroy = function () {
        _super.prototype.destroy.call(this);
        if (this.data && this.data.has_SELECTE_CHANGED()) {
            this.data.remove_SELECTE_CHANGED(this._onDataSelectChange, this);
        }
    };
    return ListRender;
}(Box));





var HueFilter = (function (_super) {
    __extends(HueFilter, _super);
    function HueFilter(hue) {
        if (hue === void 0) { hue = 0; }
        if (hue < -180)
            hue = -180;
        if (hue > 180)
            hue = 180;
        var colorArr, toColor;
        if (hue == 0) {
            colorArr = HueFilter.normal;
        }
        else {
            colorArr = [];
            var fromColor;
            var per;
            if (hue < 0 && hue >= -60) {
                fromColor = HueFilter.normal;
                toColor = HueFilter.redblue;
                per = hue / -60;
            }
            else if (hue < -60 && hue >= -120) {
                fromColor = HueFilter.redblue;
                toColor = HueFilter.blue;
                per = (hue + 60) / -60;
            }
            else if (hue < -120) {
                fromColor = HueFilter.blue;
                toColor = HueFilter.bluegreen;
                per = (hue + 120) / -60;
            }
            else if (hue > 0 && hue <= 60) {
                fromColor = HueFilter.normal;
                toColor = HueFilter.redgreen;
                per = hue / 60;
            }
            else if (hue > 60 && hue <= 120) {
                fromColor = HueFilter.redgreen;
                toColor = HueFilter.green;
                per = (hue - 60) / 60;
            }
            else {
                fromColor = HueFilter.green;
                toColor = HueFilter.bluegreen;
                per = (hue - 120) / 60;
            }
            for (var s = 0; s < fromColor.length; s++) {
                colorArr[s] = (toColor[s] - fromColor[s]) * per + fromColor[s];
            }
        }
        _super.call(this, colorArr);
        this.colorMat = colorArr;
    }
    HueFilter.normal = [
        1, 0, 0, 0, 0,
        0, 1, 0, 0, 0,
        0, 0, 1, 0, 0,
        0, 0, 0, 1, 0,
    ];
    HueFilter.redblue = [
        1, 0, 0, 0, 0,
        0, 1, 0, 0, 0,
        1, 0, 0, 0, 0,
        0, 0, 0, 1, 0,
    ];
    HueFilter.blue = [
        0, 1, 0, 0, 0,
        0, 1, 0, 0, 0,
        1, 0, 0, 0, 0,
        0, 0, 0, 1, 0,
    ];
    HueFilter.bluegreen = [
        0, 1, 0, 0, 0,
        1, 0, 0, 0, 0,
        1, 0, 0, 0, 0,
        0, 0, 0, 1, 0,
    ];
    HueFilter.redgreen = [
        1, 0, 0, 0, 0,
        1, 0, 0, 0, 0,
        0, 1, 0, 0, 0,
        0, 0, 0, 1, 0,
    ];
    HueFilter.green = [
        0, 1, 0, 0, 0,
        1, 0, 0, 0, 0,
        0, 1, 0, 0, 0,
        0, 0, 0, 1, 0,
    ];
    return HueFilter;
}(ColorFilter));





var TreeItemData = (function (_super) {
    __extends(TreeItemData, _super);
    function TreeItemData() {
        _super.call(this);
        this._visible = false;
        this._isOpen = true;
        this.isDirectory = false;
        this._children = [];
        this._parent = null;
        this._visible = true;
    }
    Object.defineProperty(TreeItemData.prototype, "isOpen", {
        get: function () { return this._isOpen; },
        set: function (v) { this._isOpen = v; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TreeItemData.prototype, "visible", {
        get: function () { return this._visible; },
        set: function (v) { this._visible = v; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TreeItemData.prototype, "parent", {
        get: function () { return this._parent; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TreeItemData.prototype, "nodeParent", {
        get: function () { return this._parent; },
        enumerable: true,
        configurable: true
    });
    TreeItemData.prototype.addChild = function (item) { this._children.push(item); item._parent = this; };
    TreeItemData.prototype.addChildAt = function (item, index) { this._children.splice(index, 0, item); item._parent = this; };
    TreeItemData.prototype.removeChild = function (item) { this._children.splice(this._children.indexOf(item), 1); item._parent = null; };
    TreeItemData.prototype.removeChildAt = function (index) { var item = this._children.splice(index, 1)[0]; item._parent = null; };
    TreeItemData.prototype.removeAll = function () { for (var i in this._children) {
        this._children[i]._parent = null;
    } ; this._children.length = 0; };
    TreeItemData.prototype.getChildAt = function (index) { return this._children[index]; };
    TreeItemData.prototype.getChildIndex = function (item) { return this._children.indexOf(item); };
    TreeItemData.prototype.getChildByName = function (name) { for (var i in this._children) {
        if (this._children[i].label == name)
            return this._children[i];
    } ; return null; };
    Object.defineProperty(TreeItemData.prototype, "numChildren", {
        get: function () { return this._children.length; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TreeItemData.prototype, "children", {
        get: function () { return this._children; },
        enumerable: true,
        configurable: true
    });
    TreeItemData.prototype.isInherit = function (data) {
        var p = this.parent;
        while (p) {
            if (p == data)
                return true;
            p = p._parent;
        }
        return false;
    };
    TreeItemData.prototype.getList = function (arr) {
        arr.push(this);
        var len = this.numChildren;
        for (var i = 0; i < len; i++) {
            this.getChildAt(i).getList(arr);
        }
    };
    Object.defineProperty(TreeItemData.prototype, "root", {
        get: function () {
            var p = this;
            while (true) {
                if (p._parent) {
                    p = p._parent;
                }
                else {
                    break;
                }
            }
            return p;
        },
        enumerable: true,
        configurable: true
    });
    TreeItemData.removeExistChild = function (list) {
        for (var i = list.length - 1; i >= 0; i--) {
            for (var s in list) {
                if (list[i].isInherit(list[s])) {
                    list.splice(i, 1);
                    break;
                }
            }
        }
    };
    return TreeItemData;
}(ListItemData));
var FrameSelectUtils = (function () {
    function FrameSelectUtils() {
    }
    FrameSelectUtils.init = function () {
        if (FrameSelectUtils.isInit)
            return;
        FrameSelectUtils.isInit = true;
        FrameSelectUtils.frameSelectSp = new Sprite();
        FrameSelectUtils.frameSelectSp.mouseEnabled = true;
        FrameSelectUtils.frameSelectSp.alpha = 0.5;
    };
    FrameSelectUtils.reg = function (container, hitAreas, onFrameSelected) {
        FrameSelectUtils.init();
        this.setHitAreas(container, hitAreas);
        container["__onFrameSelected"] = onFrameSelected;
        container.on(EventObject.MOUSE_DOWN, container, FrameSelectUtils.onMouseDown);
    };
    FrameSelectUtils.setHitAreas = function (container, hitAreas) {
        container["__hitArea"] = hitAreas;
    };
    FrameSelectUtils.cancelReg = function (container) {
        container["__hitArea"] = null;
        container["__onFrameSelected"] = null;
        container.off(EventObject.MOUSE_DOWN, container, FrameSelectUtils.onMouseDown);
    };
    FrameSelectUtils.onMouseDown = function (e) {
        if (!FrameSelectUtils.enabled)
            return;
        var frameSelectSp = FrameSelectUtils.frameSelectSp;
        var container = e.currentTarget;
        var hitAreas = container["__hitArea"];
        if (hitAreas && hitAreas.indexOf(e.target) == -1)
            return;
        FrameSelectUtils.currentContainer = container;
        container.addChild(frameSelectSp);
        FrameSelectUtils.frameSelectSp.size(container.width, container.height);
        FrameSelectUtils.startP = new Point(container.mouseX, container.mouseY);
        this.frameRect = null;
        stage.on(EventObject.MOUSE_MOVE, container, FrameSelectUtils.onMouseMove);
        stage.on(EventObject.MOUSE_UP, container, FrameSelectUtils.onMouseUp);
    };
    FrameSelectUtils.onMouseMove = function (e) {
        var container = FrameSelectUtils.currentContainer;
        var startP = FrameSelectUtils.startP;
        var nowP = new Point(container.mouseX, container.mouseY);
        var leftP = new Point(Math.min(nowP.x, startP.x), Math.min(nowP.y, startP.y));
        var bottomP = new Point(Math.max(nowP.x, startP.x), Math.max(nowP.y, startP.y));
        var rect = new Rectangle(leftP.x, leftP.y, bottomP.x - leftP.x, bottomP.y - leftP.y);
        var frameSelectSp = FrameSelectUtils.frameSelectSp;
        frameSelectSp.graphics.clear();
        frameSelectSp.graphics.drawRect(rect.x, rect.y, rect.width, rect.height, "#8484bd");
        this.frameRect = rect;
        container["__onFrameSelected"].runWith([rect, e]);
    };
    FrameSelectUtils.onMouseUp = function (e) {
        var container = FrameSelectUtils.currentContainer;
        var frameSelectSp = FrameSelectUtils.frameSelectSp;
        container.removeChild(frameSelectSp);
        frameSelectSp.graphics.clear();
        stage.off(EventObject.MOUSE_MOVE, container, FrameSelectUtils.onMouseMove);
        stage.off(EventObject.MOUSE_UP, container, FrameSelectUtils.onMouseUp);
        container["__onFrameSelected"].runWith([this.frameRect, e]);
    };
    FrameSelectUtils.getFrameSpr = function () {
        return FrameSelectUtils.frameSelectSp;
    };
    FrameSelectUtils.enabled = true;
    return FrameSelectUtils;
}());
var oldsendEvents = TouchManager.prototype["sendEvents"];
TouchManager.prototype["sendEvents"] = function (eles, type, touchID) {
    if (type == "rightmousedown") {
        if (this._event.nativeEvent.button == 1) {
            type = "middlemousedown";
        }
    }
    if (type == "rightmouseup") {
        if (this._event.nativeEvent.button == 1) {
            type = "middlemouseup";
        }
    }
    oldsendEvents.call(this, eles, type, touchID);
};
Shader2D.__init__ = function () {
    Shader.addInclude("parts/ColorFilter_ps_uniform.glsl", "uniform vec4 colorAlpha;\nuniform mat4 colorMat;");
    Shader.addInclude("parts/ColorFilter_ps_logic.glsl", "mat4 alphaMat =colorMat;\n\tfloat lastDr = alphaMat[0][3];\n\tfloat lastDg = alphaMat[1][3];\n\tfloat lastDb = alphaMat[2][3];\n\talphaMat[0][3] =0.0;\n\talphaMat[1][3] =0.0;\n\talphaMat[2][3] =0.0;\n\tgl_FragColor = gl_FragColor * alphaMat;\n\tgl_FragColor.r += lastDr*(lastDr<0.0?gl_FragColor.r:1.0);\n\tgl_FragColor.g += lastDg*(lastDr<0.0?gl_FragColor.g:1.0);\n\tgl_FragColor.b += lastDb*(lastDr<0.0?gl_FragColor.b:1.0);\n\t");
    Shader.addInclude("parts/GlowFilter_ps_uniform.glsl", "uniform vec4 u_color;\nuniform float u_strength;\nuniform float u_blurX;\nuniform float u_blurY;\nuniform float u_offsetX;\nuniform float u_offsetY;\nuniform float u_textW;\nuniform float u_textH;");
    Shader.addInclude("parts/GlowFilter_ps_logic.glsl", "const float c_IterationTime = 10.0;\nfloat floatIterationTotalTime = c_IterationTime * c_IterationTime;\nvec4 vec4Color = vec4(0.0,0.0,0.0,0.0);\nvec2 vec2FilterDir = vec2(-(u_offsetX)/u_textW,-(u_offsetY)/u_textH);\nvec2 vec2FilterOff = vec2(u_blurX/u_textW/c_IterationTime * 2.0,u_blurY/u_textH/c_IterationTime * 2.0);\nfloat maxNum = u_blurX * u_blurY;\nvec2 vec2Off = vec2(0.0,0.0);\nfloat floatOff = c_IterationTime/2.0;\nfor(float i = 0.0;i<=c_IterationTime; ++i){\n	for(float j = 0.0;j<=c_IterationTime; ++j){\n		vec2Off = vec2(vec2FilterOff.x * (i - floatOff),vec2FilterOff.y * (j - floatOff));\n		vec4Color += texture2D(texture, v_texcoord + vec2FilterDir + vec2Off)/floatIterationTotalTime;\n	}\n}\ngl_FragColor = vec4(u_color.rgb,vec4Color.a * u_strength);\ngl_FragColor.rgb *= gl_FragColor.a;");
    Shader.addInclude("parts/BlurFilter_ps_logic.glsl", "gl_FragColor =   blur();\ngl_FragColor.w*=alpha;");
    Shader.addInclude("parts/BlurFilter_ps_uniform.glsl", "\n\tuniform vec4 strength_sig2_2sig2_gauss1;\n\tuniform vec2 blurInfo;\n\t\n\tvec4 blur(){\n\t\t\n\t\tconst int sampleRadius = 5;\n\t\tconst int samples = sampleRadius * 2 + 1;\n\t\t// \n\t\tfloat GAUSSIAN_VALUES[11];\n\t\tGAUSSIAN_VALUES[0] = 0.0093;\n\t\tGAUSSIAN_VALUES[1] = 0.028002;\n\t\tGAUSSIAN_VALUES[2] = 0.065984;\n\t\tGAUSSIAN_VALUES[3] = 0.121703;\n\t\tGAUSSIAN_VALUES[4] = 0.175713;\n\t\tGAUSSIAN_VALUES[5] = 0.198596;\n\t\tGAUSSIAN_VALUES[6] = 0.175713;\n\t\tGAUSSIAN_VALUES[7] = 0.121703;\n\t\tGAUSSIAN_VALUES[8] = 0.065984;\n\t\tGAUSSIAN_VALUES[9] = 0.028002;\n\t\tGAUSSIAN_VALUES[10] = 0.0093;\n\t\t//\n\t\tvec2 blurUv = strength_sig2_2sig2_gauss1.xx / blurInfo;\n\t\tvec4 color = vec4(0, 0, 0, 0);\n\t\tvec2 uv = vec2(0.0, 0.0);\n\t\tblurUv /= float(sampleRadius);\n\t\n\t\tfor (int i = -sampleRadius; i <= sampleRadius; i++) {\n\t\t\tuv.x = v_texcoord.x + float(i) * blurUv.x;\n\t\t\tuv.y = v_texcoord.y + float(i) * blurUv.y;\n\t\t\tcolor += texture2D(texture, uv) * GAUSSIAN_VALUES[i + sampleRadius];\n\t\t}\n\t\treturn color;\n\t}\n\t");
    Shader.addInclude("parts/ColorAdd_ps_uniform.glsl", "uniform vec4 colorAdd;\n");
    Shader.addInclude("parts/ColorAdd_ps_logic.glsl", "gl_FragColor = vec4(colorAdd.rgb,colorAdd.a*gl_FragColor.a);\ngl_FragColor.xyz *= colorAdd.a;");
    var vs, ps;
    vs = "attribute vec4 position;\nattribute vec2 texcoord;\nuniform vec2 size;\n\n#ifdef WORLDMAT\nuniform mat4 mmat;\n#endif\nvarying vec2 v_texcoord;\nvoid main() {\n  #ifdef WORLDMAT\n  vec4 pos=mmat*position;\n  gl_Position =vec4((pos.x/size.x-0.5)*2.0,(0.5-pos.y/size.y)*2.0,pos.z,1.0);\n  #else\n  gl_Position =vec4((position.x/size.x-0.5)*2.0,(0.5-position.y/size.y)*2.0,position.z,1.0);\n  #endif\n  \n  v_texcoord = texcoord;\n}";
    ps = "precision mediump float;\n//precision highp float;\nvarying vec2 v_texcoord;\nuniform sampler2D texture;\nuniform float alpha;\n#include?BLUR_FILTER  \"parts/BlurFilter_ps_uniform.glsl\";\n#include?COLOR_FILTER \"parts/ColorFilter_ps_uniform.glsl\";\n#include?GLOW_FILTER \"parts/GlowFilter_ps_uniform.glsl\";\n#include?COLOR_ADD \"parts/ColorAdd_ps_uniform.glsl\";\n\nvoid main() {\n   vec4 color= texture2D(texture, v_texcoord);\nif(color.a<1.0)color.rgb*=1.0/color.a;\n   color.a*=alpha;\n   \n   gl_FragColor=color;\n   #include?COLOR_ADD \"parts/ColorAdd_ps_logic.glsl\";   \n   #include?BLUR_FILTER  \"parts/BlurFilter_ps_logic.glsl\";\n   #include?COLOR_FILTER \"parts/ColorFilter_ps_logic.glsl\";\n   #include?GLOW_FILTER \"parts/GlowFilter_ps_logic.glsl\";\n}";
    Shader.preCompile2D(0, 0x01, vs, ps, null);
    vs = "attribute vec4 position;\nuniform vec2 size;\nuniform mat4 mmat;\nvoid main() {\n  vec4 pos=mmat*position;\n  gl_Position =vec4((pos.x/size.x-0.5)*2.0,(0.5-pos.y/size.y)*2.0,pos.z,1.0);\n}";
    ps = "precision mediump float;\nuniform vec4 color;\nuniform float alpha;\n#include?COLOR_FILTER \"parts/ColorFilter_ps_uniform.glsl\";\nvoid main() {\n	vec4 a = vec4(color.r, color.g, color.b, color.a);\n	a.w = alpha;\n	a.xyz *= alpha;\n	gl_FragColor = a;\n	#include?COLOR_FILTER \"parts/ColorFilter_ps_logic.glsl\";\n}";
    Shader.preCompile2D(0, 0x02, vs, ps, null);
    vs = "attribute vec4 position;\nattribute vec3 a_color;\nuniform mat4 mmat;\nuniform mat4 u_mmat2;\nuniform vec2 u_pos;\nuniform vec2 size;\nvarying vec3 color;\nvoid main(){\n  vec4 tPos = vec4(position.x + u_pos.x,position.y + u_pos.y,position.z,position.w);\n  vec4 pos=mmat*u_mmat2*tPos;\n  gl_Position =vec4((pos.x/size.x-0.5)*2.0,(0.5-pos.y/size.y)*2.0,pos.z,1.0);\n  color=a_color;\n}";
    ps = "precision mediump float;\n//precision mediump float;\nvarying vec3 color;\nuniform float alpha;\nvoid main(){\n	//vec4 a=vec4(color.r, color.g, color.b, 1);\n	//a.a*=alpha;\n    gl_FragColor=vec4(color.r, color.g, color.b, alpha);\n	gl_FragColor.rgb*=alpha;\n}";
    Shader.preCompile2D(0, 0x04, vs, ps, null);
    vs = "attribute vec4 position;\nattribute vec2 texcoord;\nuniform vec2 size;\n\n#ifdef WORLDMAT\nuniform mat4 mmat;\n#endif\nvarying vec2 v_texcoord;\nvoid main() {\n  #ifdef WORLDMAT\n  vec4 pos=mmat*position;\n  gl_Position =vec4((pos.x/size.x-0.5)*2.0,(0.5-pos.y/size.y)*2.0,pos.z,1.0);\n  #else\n  gl_Position =vec4((position.x/size.x-0.5)*2.0,(0.5-position.y/size.y)*2.0,position.z,1.0);\n  #endif\n  \n  v_texcoord = texcoord;\n}";
    ps = "#ifdef FSHIGHPRECISION\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n//precision highp float;\nvarying vec2 v_texcoord;\nuniform sampler2D texture;\nuniform float alpha;\nuniform vec4 u_TexRange;\nuniform vec2 u_offset;\n#include?BLUR_FILTER  \"parts/BlurFilter_ps_uniform.glsl\";\n#include?COLOR_FILTER \"parts/ColorFilter_ps_uniform.glsl\";\n#include?GLOW_FILTER \"parts/GlowFilter_ps_uniform.glsl\";\n#include?COLOR_ADD \"parts/ColorAdd_ps_uniform.glsl\";\n\nvoid main() {\n   vec2 newTexCoord;\n   newTexCoord.x = mod(u_offset.x + v_texcoord.x,u_TexRange.y) + u_TexRange.x;\n   newTexCoord.y = mod(u_offset.y + v_texcoord.y,u_TexRange.w) + u_TexRange.z;\n   vec4 color= texture2D(texture, newTexCoord);\n if(color.a<1.0)color.rgb*=1.0/color.a;  color.a*=alpha;\n   gl_FragColor=color;\n   #include?COLOR_ADD \"parts/ColorAdd_ps_logic.glsl\";   \n   #include?BLUR_FILTER  \"parts/BlurFilter_ps_logic.glsl\";\n   #include?COLOR_FILTER \"parts/ColorFilter_ps_logic.glsl\";\n   #include?GLOW_FILTER \"parts/GlowFilter_ps_logic.glsl\";\n}";
    Shader.preCompile2D(0, 0x100, vs, ps, null);
    vs = "attribute vec2 position;\nattribute vec2 texcoord;\nattribute vec4 color;\nuniform vec2 size;\nuniform float offsetX;\nuniform float offsetY;\nuniform mat4 mmat;\nuniform mat4 u_mmat2;\nvarying vec2 v_texcoord;\nvarying vec4 v_color;\nvoid main() {\n  vec4 pos=mmat*u_mmat2*vec4(offsetX+position.x,offsetY+position.y,0,1 );\n  gl_Position = vec4((pos.x/size.x-0.5)*2.0,(0.5-pos.y/size.y)*2.0,pos.z,1.0);\n  v_color = color;\n  v_color.rgb *= v_color.a;\n  v_texcoord = texcoord;  \n}";
    ps = "precision mediump float;\nvarying vec2 v_texcoord;\nvarying vec4 v_color;\nuniform sampler2D texture;\nuniform float alpha;\nvoid main() {\n	vec4 t_color = texture2D(texture, v_texcoord);\n	gl_FragColor = t_color.rgba * v_color;\n	gl_FragColor *= alpha;\n}";
    Shader.preCompile2D(0, 0x200, vs, ps, null);
};
var pShader = "attribute vec4 a_CornerTextureCoordinate;\n//------------------------------------------------------------------------------------------------------\n// \u9876\u70B9\u6570\u636E vertexBuffer \u4E2D\u7684\u6570\u636E\n//------------------------------------------------------------------------------------------------------\n// \u9876\u70B9\u4F4D\u7F6E x y z\nattribute vec3 a_Position;\n// \u9876\u70B9\u901F\u5EA6\nattribute vec3 a_Velocity;\n// \u9876\u70B9\u8D77\u59CB\u989C\u8272\nattribute vec4 a_StartColor;\n// \u9876\u70B9\u7ED3\u675F\u989C\u8272\nattribute vec4 a_EndColor;\n// \u89D2\u5EA6\uFF1F\nattribute vec3 a_SizeRotation;\n// \u534A\u5F84\nattribute vec2 a_Radius;\n// \u5F27\u5EA6\nattribute vec4 a_Radian;\n// \u751F\u547D\u5468\u671F\u7F29\u653E\u5EA6 \u53731.0 * 1.5 \u8868\u793A+50%\u5BFF\u547D\nattribute float a_AgeAddScale;\n// \u53D1\u51FA\u7684\u65F6\u95F4\nattribute float a_Time;\n//------------------------------------------------------------------------------------------------------\n// \u4F20\u9012\u7ED9\u7247\u6BB5\u7740\u8272\u5668\u7684\u53C2\u6570 \n//------------------------------------------------------------------------------------------------------\nvarying vec4 v_Color;\nvarying vec2 v_TextureCoordinate;\n//------------------------------------------------------------------------------------------------------\n// \u4F20\u9012\u8FDB\u6765\u7684\u5E38\u91CF\uFF0C\u6BD4\u5982u_CurrentTime\u5C31\u662F\u6BCF\u5E27\u90FD\u4F1A\u4F20\u9012\u8FDB\u6765\u7684\u5E38\u91CF\uFF0C\u8868\u793A\u5F53\u524D\u65F6\u95F4\n// \u7247\u6BB5\u7740\u8272\u5668\u548C\u9876\u70B9\u7740\u8272\u5668\u90FD\u4F1A\u7528\u5230\u7684\n//------------------------------------------------------------------------------------------------------\nuniform float u_CurrentTime;\nuniform float u_Duration;\nuniform float u_EndVelocity;\nuniform vec3 u_Gravity;\nuniform vec3 u_xxxx;\n\n\n#ifdef PARTICLE3D\n uniform mat4 u_WorldMat;\n uniform mat4 u_View;\n uniform mat4 u_Projection;\n uniform vec2 u_ViewportScale;\n#else\n uniform vec2 size;\n uniform mat4 mmat;\n uniform mat4 u_mmat;\n#endif\n\nvec4 ComputeParticlePosition(in vec3 position, in vec3 velocity,in float age,in float normalizedAge)\n{\n\n   float startVelocity = length(velocity);//\u8D77\u59CB\u6807\u91CF\u901F\u5EA6\n   float endVelocity = startVelocity * u_EndVelocity;//\u7ED3\u675F\u6807\u91CF\u901F\u5EA6\n\n   float velocityIntegral = startVelocity * normalizedAge +(endVelocity - startVelocity) * normalizedAge *normalizedAge/2.0;//\u8BA1\u7B97\u5F53\u524D\u901F\u5EA6\u7684\u6807\u91CF\uFF08\u5355\u4F4D\u7A7A\u95F4\uFF09\uFF0Cvt=v0*t+(1/2)*a*(t^2)\n   \n   vec3 addPosition = normalize(velocity) * velocityIntegral * u_Duration;//\u8BA1\u7B97\u53D7\u81EA\u8EAB\u901F\u5EA6\u5F71\u54CD\u7684\u4F4D\u7F6E\uFF0C\u8F6C\u6362\u6807\u91CF\u5230\u77E2\u91CF    \n   addPosition += u_Gravity * age * normalizedAge;//\u8BA1\u7B97\u53D7\u91CD\u529B\u5F71\u54CD\u7684\u4F4D\u7F6E\n   \n   float radius=mix(a_Radius.x, a_Radius.y, normalizedAge); //\u8BA1\u7B97\u7C92\u5B50\u53D7\u534A\u5F84\u548C\u89D2\u5EA6\u5F71\u54CD\uFF08\u65E0\u9700\u8BA1\u7B97\u89D2\u5EA6\u548C\u534A\u5F84\u65F6\uFF0C\u53EF\u7528\u5B8F\u5B9A\u4E49\u4F18\u5316\u5C4F\u853D\u6B64\u8BA1\u7B97\uFF09\n   float radianHorizontal =mix(a_Radian.x,a_Radian.z,normalizedAge);\n   float radianVertical =mix(a_Radian.y,a_Radian.w,normalizedAge);\n   \n   float r =cos(radianVertical)* radius;\n   addPosition.y += sin(radianVertical) * radius;\n\t\n   addPosition.x += cos(radianHorizontal) *r + u_xxxx.x;\n   addPosition.z += sin(radianHorizontal) *r;\n  \n   #ifdef PARTICLE3D\n   position+=addPosition;\n    return  u_Projection*u_View*u_WorldMat*(vec4(position, 1.0));\n   #else\n   addPosition.y=-addPosition.y;//2D\u7C92\u5B50\u4F4D\u7F6E\u66F4\u65B0\u9700\u8981\u53D6\u8D1F\uFF0C2D\u7C92\u5B50\u5750\u6807\u7CFBY\u8F74\u6B63\u5411\u671D\u4E0A\n   position+=addPosition;\n    return  vec4(position,1.0);\n   #endif\n}\n\nfloat ComputeParticleSize(in float startSize,in float endSize, in float normalizedAge)\n{    \n    float size = mix(startSize, endSize, normalizedAge);\n    \n\t#ifdef PARTICLE3D\n    //Project the size into screen coordinates.\n     return size * u_Projection[1][1];\n\t#else\n\t return size;\n\t#endif\n}\n\nmat2 ComputeParticleRotation(in float rot,in float age)\n{    \n    float rotation =rot * age;\n    //\u8BA1\u7B972x2\u65CB\u8F6C\u77E9\u9635.\n    float c = cos(rotation);\n    float s = sin(rotation);\n    return mat2(c, -s, s, c);\n}\n\nvec4 ComputeParticleColor(in vec4 startColor,in vec4 endColor,in float normalizedAge)\n{\n\tvec4 color=mix(startColor,endColor,normalizedAge);\n    //\u786C\u7F16\u7801\u8BBE\u7F6E\uFF0C\u4F7F\u7C92\u5B50\u6DE1\u5165\u5F88\u5FEB\uFF0C\u6DE1\u51FA\u5F88\u6162,6.7\u7684\u7F29\u653E\u56E0\u5B50\u628A\u7F6E\u5F52\u4E00\u57280\u52301\u4E4B\u95F4\uFF0C\u53EF\u4EE5\u8C37\u6B4Cx*(1-x)*(1-x)*6.7\u7684\u5236\u56FE\u8868\n    color.a *= normalizedAge * (1.0-normalizedAge) * (1.0-normalizedAge) * 6.7;\n   \n    return color;\n}\n\nvoid main()\n{\n   float age = u_CurrentTime - a_Time;\n   age *= 1.0 + a_AgeAddScale;\n   float normalizedAge = clamp(age / u_Duration,0.0,1.0);\n   gl_Position = ComputeParticlePosition(a_Position, a_Velocity, age, normalizedAge);//\u8BA1\u7B97\u7C92\u5B50\u4F4D\u7F6E\n   float pSize = ComputeParticleSize(a_SizeRotation.x,a_SizeRotation.y, normalizedAge);\n   mat2 rotation = ComputeParticleRotation(a_SizeRotation.z, age);\n\t\n   #ifdef PARTICLE3D\n\tgl_Position.xy += (rotation*a_CornerTextureCoordinate.xy) * pSize * u_ViewportScale;\n   #else\n    mat4 mat=u_mmat*mmat;\n    gl_Position=vec4((mat*gl_Position).xy,0.0,1.0);\n\tgl_Position.xy += (rotation*a_CornerTextureCoordinate.xy) * pSize*vec2(mat[0][0],mat[1][1]);\n    gl_Position=vec4((gl_Position.x/size.x-0.5)*2.0,(0.5-gl_Position.y/size.y)*2.0,0.0,1.0);\n   #endif\n   \n   v_Color = ComputeParticleColor(a_StartColor,a_EndColor, normalizedAge);\n   v_TextureCoordinate =a_CornerTextureCoordinate.zw;\n}\n";
static(ParticleShader, ['vs', function () { return this.vs = pShader; }, 'ps', function () { return this.ps = "#ifdef FSHIGHPRECISION\nprecision highp float;\n#else\nprecision mediump float;\n#endif\n\nvarying vec4 v_Color;\nvarying vec2 v_TextureCoordinate;\nuniform sampler2D u_texture;\n\nvoid main()\n{	\n	gl_FragColor=texture2D(u_texture,v_TextureCoordinate)*v_Color;\n	gl_FragColor.xyz *= v_Color.w;\n}"; }
]);





var TreeRender = (function (_super) {
    __extends(TreeRender, _super);
    function TreeRender() {
        _super.call(this);
    }
    Object.defineProperty(TreeRender.prototype, "mainComp", {
        get: function () {
            if (this._mainComp)
                return this._mainComp;
            if (this.parent == null) {
                return null;
            }
            this._mainComp = this.parent.parent.parent;
            return this._mainComp;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TreeRender.prototype, "parentRender", {
        get: function () {
            var data = this.data;
            if (data) {
                var parentData = data.parent;
                if (parentData) {
                    for (var i = 0; i < this.parent.numChildren; i++) {
                        var r = this.parent.getChildAt(i);
                        if (r instanceof TreeRender) {
                            if (r.data == parentData)
                                return r;
                        }
                    }
                }
            }
            return null;
        },
        enumerable: true,
        configurable: true
    });
    TreeRender.prototype.initEvent = function () {
        _super.prototype.initEvent.call(this);
        this.icon1.add_CLICK(this._onFolderClick, this);
        this.icon2.add_CLICK(this._onFolderClick, this);
        this.add_DOUBLECLICK(this._onFolderClick, this);
    };
    TreeRender.prototype.getData = function () {
        return this.data;
    };
    TreeRender.prototype._onFolderClick = function (e) {
        if (e.ctrlKey || e.shiftKey) {
            return;
        }
        if (this.data.numChildren == 0)
            return;
        var isOpen = !this.data.isOpen;
        if (!isOpen) {
            var dataList = this.dataList;
            for (var i in dataList) {
                var elseData = dataList[i];
                if (elseData.isInherit(this.data)) {
                    elseData.selected = false;
                }
            }
        }
        this.data.isOpen = isOpen;
        this.mainComp.fresh();
        e.stopPropagation();
    };
    TreeRender.prototype.updateAppearance = function () {
        _super.prototype.updateAppearance.call(this);
        if (this.data == null)
            return;
        this.updateAppearance_folderIcon();
    };
    TreeRender.prototype.updateAppearance_folderIcon = function () {
        this.icon1.index = this.data.isOpen ? 1 : 0;
        if (this.data.isDirectory) {
            if (this.data.numChildren > 0) {
                this.icon1.visible = true;
                if (this.data.isOpen) {
                    this.icon1.index = this.icon2.index = 1;
                }
                else {
                    this.icon1.index = this.icon2.index = 0;
                }
            }
            else {
                this.icon2.index = 0;
                this.icon1.visible = false;
            }
        }
        else {
            this.icon2.index = 2;
            this.icon1.visible = false;
        }
    };
    TreeRender.prototype.regListDrag = function (dataType, useLayerChange) {
        if (useLayerChange === void 0) { useLayerChange = false; }
        ListDragItem.reg(dataType, this, Callback.New(this.canDragStart, this), Callback.New(this.onDragDrop, this), Callback.New(this.onDragIn, this), Callback.New(this.onDragOut, this), useLayerChange, Callback.New(this.onToUp, this), Callback.New(this.onToDown, this));
    };
    TreeRender.prototype.canDragStart = function () {
        console.warn("\u672A\u5B9E\u73B0");
        return true;
    };
    TreeRender.prototype.onDragDrop = function (inItem) {
        console.warn("\u672A\u5B9E\u73B0");
    };
    TreeRender.prototype.onDragIn = function (inItem) {
        console.warn("\u672A\u5B9E\u73B0");
    };
    TreeRender.prototype.onDragOut = function () {
    };
    TreeRender.prototype.onToUp = function (inItem) {
        console.warn("\u672A\u5B9E\u73B0");
    };
    TreeRender.prototype.onToDown = function (inItem) {
        console.warn("\u672A\u5B9E\u73B0");
    };
    return TreeRender;
}(ListRender));
(function () {
    var blendFunType = [0x0, 0x1, 0x0300, 0x0301, 0x0306, 0x0307, 0x0302, 0x0303, 0x0304, 0x0305, 0x8001, 0x8002, 0x8003, 0x8004, 0x0308];
    var start = 8;
    var BlendModeCls = eval("BlendMode");
    var fns = [];
    var targetFns = [];
    for (var x in blendFunType) {
        for (var y in blendFunType) {
            BlendModeCls.TOINT["blend" + x + "-" + y] = start++;
            var blendF = fnsFunc(x, y);
            fns.push(blendF);
            targetFns.push(blendF);
        }
    }
    var oldBlendInit = BlendModeCls._init_;
    BlendModeCls._init_ = function (gl) {
        oldBlendInit.call(BlendModeCls, gl);
        BlendModeCls.fns = BlendModeCls.fns.concat(fns);
        BlendModeCls.targetFns = BlendModeCls.targetFns.concat(targetFns);
    };
    function fnsFunc(x, y) {
        var f = function (gl) {
            gl.blendFunc(blendFunType[x], blendFunType[y]);
        };
        return f;
    }
})();
var AsynTask = (function () {
    function AsynTask(onFin) {
        this._asynCount = 0;
        this._asynLength = 0;
        this._onFin = onFin;
    }
    AsynTask.prototype.execute = function (code) {
        this._asynLength++;
    };
    AsynTask.prototype.complete = function () {
        this._asynCount++;
        if (this._asynCount == this._asynLength) {
            this._onFin && this._onFin.run();
        }
    };
    return AsynTask;
}());
var ArrayUtils = (function () {
    function ArrayUtils() {
    }
    ArrayUtils.randOrder = function (arr) {
        var arrClone = arr.concat();
        var newArr = [];
        while (arrClone.length > 0) {
            var obj = arrClone.splice(MathUtils.rand(arrClone.length), 1)[0];
            newArr.push(obj);
        }
        var len = arr.length;
        for (var i = 0; i < len; i++) {
            arr[i] = newArr[i];
        }
    };
    ArrayUtils.insert = function (arr, index) {
        var arg = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            arg[_i - 2] = arguments[_i];
        }
        var returnIndex;
        if (index == -1) {
            returnIndex = arr.length;
            arr.push.apply(arr, arg);
        }
        else {
            returnIndex = index;
            arr.splice.apply(arr, [index, 0].concat(arg));
        }
        return returnIndex;
    };
    ArrayUtils.delete = function (arr, index) {
        return index == -1 ? arr.pop() : arr.splice(index, 1)[0];
    };
    ArrayUtils.remove = function (arr, obj) {
        var idx = arr.indexOf(obj);
        if (idx == -1)
            return null;
        return arr.splice(idx, 1)[0];
    };
    ArrayUtils.get = function (arr, index) {
        var index = index == -1 ? arr.length - 1 : index;
        return arr[index];
    };
    ArrayUtils.set = function (arr, index, paramValue) {
        function setValue(obj, paramValue) {
            for (var s in paramValue) {
                obj[s] = paramValue[s];
            }
        }
        if (index == -2) {
            var len = arr.length;
            for (var i = 0; i < len; i++) {
                setValue(arr[i], paramValue);
            }
            return arr;
        }
        else if (index == -1) {
            var obj = arr[arr.length - 1];
            setValue(obj, paramValue);
            return [obj];
        }
        else {
            var obj = arr[index];
            setValue(obj, paramValue);
            return [obj];
        }
    };
    ArrayUtils.insertToNullPosition = function (arr, obj) {
        var idx = ArrayUtils.getNullPosition(arr);
        arr[idx] = obj;
        return idx;
    };
    ArrayUtils.getNullPosition = function (arr) {
        var index = -1;
        for (var i = 0; i < arr.length; i++) {
            if (!arr[i]) {
                index = i;
                break;
            }
        }
        if (index == -1)
            index = arr.length;
        return index;
    };
    ArrayUtils.removeSameObject = function (arr) {
        var newArr = [];
        for (var i = arr.length - 1; i >= 0; i--) {
            var obj = arr[i];
            if (newArr.indexOf(obj) == -1) {
                newArr.push(obj);
            }
        }
        return newArr.reverse();
    };
    ;
    ArrayUtils.matchAttributes = function (arr, matchData, onlyOne, symbol, indexOfMode) {
        if (symbol === void 0) { symbol = "=="; }
        if (indexOfMode === void 0) { indexOfMode = false; }
        var matchs = [];
        for (var i in arr) {
            var obj = arr[i];
            if (!obj)
                continue;
            var isMatch = true;
            for (var s in matchData) {
                if ((symbol == "==" && obj[s] != matchData[s]) ||
                    (symbol == ">=" && obj[s] < matchData[s]) ||
                    (symbol == "<=" && obj[s] > matchData[s]) ||
                    (symbol == ">" && obj[s] <= matchData[s]) ||
                    (symbol == "<" && obj[s] >= matchData[s]) ||
                    (symbol == "!=" && obj[s] == matchData[s])) {
                    isMatch = false;
                    break;
                }
            }
            if (isMatch) {
                matchs.push(indexOfMode ? parseInt(i) : obj);
                if (onlyOne)
                    break;
            }
        }
        return matchs;
    };
    ;
    ArrayUtils.matchAttributesD2 = function (arr, attribute, matchData, onlyOne, symbol) {
        if (symbol === void 0) { symbol = "=="; }
        var matchs = [];
        for (var i in arr) {
            var obj = arr[i];
            var isMatch = true;
            if (!obj[attribute])
                continue;
            for (var s in matchData) {
                if ((symbol == "==" && obj[attribute][s] != matchData[s]) ||
                    (symbol == ">=" && obj[attribute][s] < matchData[s]) ||
                    (symbol == "<=" && obj[attribute][s] > matchData[s]) ||
                    (symbol == ">" && obj[attribute][s] <= matchData[s]) ||
                    (symbol == "<" && obj[attribute][s] >= matchData[s]) ||
                    (symbol == "!=" && obj[attribute][s] == matchData[s])) {
                    isMatch = false;
                    break;
                }
            }
            if (isMatch) {
                matchs.push(obj);
                if (onlyOne)
                    break;
            }
        }
        return matchs;
    };
    ;
    ArrayUtils.matchAttributesD3 = function (arr, attribute, attribute2, matchData, onlyOne, symbol) {
        if (symbol === void 0) { symbol = "=="; }
        var matchs = [];
        for (var i in arr) {
            var obj = arr[i];
            var isMatch = true;
            if (!obj[attribute])
                continue;
            if (!obj[attribute][attribute2])
                continue;
            for (var s in matchData) {
                if ((symbol == "==" && obj[attribute][attribute2][s] != matchData[s]) ||
                    (symbol == ">=" && obj[attribute][attribute2][s] < matchData[s]) ||
                    (symbol == "<=" && obj[attribute][attribute2][s] > matchData[s]) ||
                    (symbol == ">" && obj[attribute][attribute2][s] <= matchData[s]) ||
                    (symbol == "<" && obj[attribute][attribute2][s] >= matchData[s]) ||
                    (symbol == "!=" && obj[attribute][attribute2][s] == matchData[s])) {
                    isMatch = false;
                    break;
                }
            }
            if (isMatch) {
                matchs.push(obj);
                if (onlyOne)
                    break;
            }
        }
        return matchs;
    };
    ;
    ArrayUtils.getElementSize = function (arr, value) {
        var n = 0;
        for (var i in arr) {
            if (arr[i] == value)
                n++;
        }
        return n;
    };
    ArrayUtils.createObjects = function (objCls, size, onCreateOne, arr) {
        if (onCreateOne === void 0) { onCreateOne = null; }
        if (arr === void 0) { arr = null; }
        if (!arr)
            arr = [];
        for (var i = 0; i < size; i++) {
            var o = new objCls();
            onCreateOne && onCreateOne(i, o);
            arr.push(o);
        }
        return arr;
    };
    ArrayUtils.swap = function (arr, index1, index2) {
        var last = arr[index1];
        arr[index1] = arr[index2];
        arr[index2] = last;
    };
    ArrayUtils.adjustment = function (arr, element, index) {
        var idx = arr.indexOf(element);
        if (idx == -1)
            return;
        arr.splice(idx, 1);
        idx < index && index--;
        arr.splice(index + 1, 0, element);
    };
    ArrayUtils.sort = function (arr, attributeName, isAsc) {
        function order(a, b) {
            var aStr = a[attributeName];
            var bStr = b[attributeName];
            var min = Math.min(aStr.length, bStr.length);
            for (var i = 0; i < min; i++) {
                var code1 = aStr[i].toLocaleLowerCase().charCodeAt(0);
                var code2 = bStr[i].toLocaleLowerCase().charCodeAt(0);
                if (code1 == code2) {
                    continue;
                }
                return isAsc ? (code1 < code2 ? -1 : 1) : (code1 < code2 ? 1 : -1);
            }
            return -1;
        }
        arr.sort(order);
    };
    ;
    ArrayUtils.compare = function (aArr, bArr) {
        var appended = [];
        if (aArr == null)
            aArr = [];
        if (bArr == null)
            bArr = [];
        var subtract = bArr.concat();
        var aLen = aArr.length;
        for (var i = 0; i < aLen; i++) {
            var a = aArr[i];
            var idx = subtract.indexOf(a);
            if (idx != -1) {
                subtract.splice(idx, 1);
            }
            else {
                appended.push(a);
            }
        }
        return {
            appended: appended,
            subtract: subtract
        };
    };
    ArrayUtils.getTreeNodeArray = function (treeNode, childrenAttr, arrayList, checkIsOpen, isOpenAttr) {
        if (childrenAttr === void 0) { childrenAttr = "children"; }
        if (arrayList === void 0) { arrayList = null; }
        if (checkIsOpen === void 0) { checkIsOpen = false; }
        if (isOpenAttr === void 0) { isOpenAttr = "isOpen"; }
        if (!arrayList)
            arrayList = [];
        arrayList.push(treeNode);
        var children = treeNode[childrenAttr];
        if (!children)
            return arrayList;
        if (!checkIsOpen || (checkIsOpen && treeNode[isOpenAttr])) {
            var len = children.length;
            for (var i = 0; i < len; i++) {
                ArrayUtils.getTreeNodeArray(children[i], childrenAttr, arrayList, checkIsOpen, isOpenAttr);
            }
        }
        return arrayList;
    };
    return ArrayUtils;
}());
var EventUtils = (function () {
    function EventUtils() {
    }
    EventUtils.addEventListener = function (obj, type, callBack, isOnce) {
        if (isOnce === void 0) { isOnce = false; }
        if (!obj)
            return;
        var evIdx = obj["__evIdx"];
        var evTypes;
        if (evIdx != null) {
            evTypes = EventUtils.evList[evIdx];
        }
        else {
            evTypes = {};
            evIdx = ArrayUtils.insertToNullPosition(EventUtils.evList, evTypes);
            obj["__evIdx"] = evIdx;
        }
        var evArrs = evTypes[type];
        if (!evArrs)
            evTypes[type] = evArrs = [];
        var evArr = [callBack, isOnce];
        evArrs.push(evArr);
    };
    EventUtils.removeEventListener = function (obj, type, callBack) {
        if (!obj)
            return;
        var evIdx = obj["__evIdx"];
        if (evIdx != null) {
            var evTypes = EventUtils.evList[evIdx];
            var evArrs = evTypes[type];
            for (var i in evArrs) {
                var evArr = evArrs[i];
                if (evArr[0] == callBack) {
                    evArrs.splice(parseInt(i), 1);
                    break;
                }
            }
        }
    };
    EventUtils.happen = function (obj, type, args) {
        if (args === void 0) { args = null; }
        if (!obj)
            return;
        var evIdx = obj["__evIdx"];
        var happenFuncs = [];
        if (evIdx != null) {
            var evTypes = EventUtils.evList[evIdx];
            var evArrs = evTypes[type];
            if (!evArrs)
                return;
            for (var i = 0; i < evArrs.length; i++) {
                var evArr = evArrs[i];
                var callback = evArr[0];
                var isOnce = evArr[1];
                if (isOnce) {
                    evArrs.splice(i, 1);
                    i--;
                }
                happenFuncs.push(callback);
            }
            happenFuncs.forEach(function (callback, index, array) {
                args ? callback.runWith(args) : callback.run();
            });
        }
    };
    EventUtils.clear = function (obj, type) {
        if (type === void 0) { type = null; }
        if (!obj)
            return;
        var evIdx = obj["__evIdx"];
        if (evIdx != null) {
            EventUtils.evList[evIdx] = null;
            delete obj["__evIdx"];
        }
    };
    EventUtils.evList = [];
    return EventUtils;
}());
var ObjectUtils = (function () {
    function ObjectUtils() {
    }
    ObjectUtils.getInstanceID = function () {
        return ObjectUtils.idCount++;
    };
    ObjectUtils.getRandID = function () {
        return (new Date().getTime() - 1557554040401) + "_" + Math.random();
    };
    ObjectUtils.clone = function (form, to) {
        for (var i in form) {
            to[i] = form[i];
        }
    };
    ObjectUtils.cloneExcludeNonExistentAttribute = function (form, to) {
        for (var i in to) {
            to[i] = form[i];
        }
    };
    ObjectUtils.depthClone = function (o) {
        return JSON.parse(JSON.stringify(o));
    };
    ObjectUtils.same = function (a, b) {
        if ((a == null && b != null) || (a != null && b == null))
            return false;
        for (var i in a) {
            if (a[i] != b[i]) {
                return false;
            }
        }
        return true;
    };
    ObjectUtils.depthSame = function (a, b) {
        if ((a == null && b != null) || (a != null && b == null))
            return false;
        var aLen = 0, bLen = 0;
        for (var i in a) {
            aLen++;
        }
        for (var i in b) {
            bLen++;
        }
        if (bLen != aLen)
            return false;
        for (var i in a) {
            var aValue = a[i];
            if (typeof aValue == "boolean" || typeof aValue == "number" || typeof aValue == "string") {
                if (aValue != b[i]) {
                    return false;
                }
            }
            else {
                if (!ObjectUtils.depthSame(aValue, b[i])) {
                    return false;
                }
            }
        }
        return true;
    };
    ObjectUtils.assignment = function (a, b) {
        for (var i in b) {
            var value = b[i];
            var attrType = typeof value;
            if (attrType == "number" || attrType == "string" || attrType == "boolean") {
                a[i] = value;
            }
            else if (typeof a[i] == "function") {
                continue;
            }
            else {
                if (a[i]) {
                    this.assignment(a[i], value);
                }
            }
        }
    };
    ObjectUtils.reDefineGetSet = function (target, defineContent) {
        for (var i in defineContent) {
            var str = "\n            Object.defineProperty(" + target + ", \"" + i + "\", {\n                set: function (v) {\n                    this._" + i + " = v;\n                    defineContent." + i + ".apply(this,[v]);\n                },\n                get: function () {\n                    return this._" + i + "\n                }\n            });\n            ";
            eval(str);
        }
        var arr = target.split(".");
        if (arr.pop() == "prototype") {
            eval("setTimeout(function(){new " + arr.join(".") + "()},0);");
        }
    };
    ObjectUtils.redefinedEventFunc = function (clsName, types, toObjName) {
        var EvArr = ["hasListener", "event", "on", "once", "off", "offAll", "isMouseEvent"];
        var typesStr = JSON.stringify(types);
        for (var i in EvArr) {
            eval("\n                    " + clsName + ".prototype._" + EvArr[i] + " = " + clsName + ".prototype." + EvArr[i] + ";\n                    " + clsName + ".prototype." + EvArr[i] + " = function(type){\n                        if(" + typesStr + ".indexOf(type)!=-1){\n                            this." + toObjName + "." + EvArr[i] + ".apply(this." + toObjName + ",arguments);\n                        }\n                        else{\n                            this._" + EvArr[i] + ".apply(this,arguments);\n                        }\n                    }\n                ");
        }
    };
    ObjectUtils.idCount = 0;
    return ObjectUtils;
}());
var StringUtils = (function () {
    function StringUtils() {
    }
    StringUtils.getRealLength = function (str) {
        var realLength = 0, len = str.length, charCode = -1;
        for (var i = 0; i < len; i++) {
            charCode = str.charCodeAt(i);
            if (charCode >= 0 && charCode <= 128)
                realLength += 1;
            else
                realLength += 2;
        }
        return realLength;
    };
    StringUtils.clearHtmlTag = function (str) {
        return str.replace(/<(s|\/s)pa[^>]+>/g, "");
    };
    StringUtils.toHtmlEscape = function (t) {
        t = t.replace(/\</g, "〈");
        t = t.replace(/\>/g, "〉");
        t = t.replace(/&/g, "&amp;");
        t = t.replace(/ /g, "&nbsp;");
        return t;
    };
    StringUtils.getMiddleDiff = function (str1, str2) {
        var oldFirstEndIndex = 0;
        var newSccondStartIndex = 0;
        var shortLen = Math.min(str1.length, str2.length);
        for (var i = 0; i < shortLen; i++) {
            if (str1[i] == str2[i]) {
                oldFirstEndIndex = i + 1;
            }
            else {
                break;
            }
        }
        var nStr1 = str1.substr(oldFirstEndIndex);
        var nStr2 = str2.substr(oldFirstEndIndex);
        shortLen -= oldFirstEndIndex;
        for (var i = 0; i < shortLen; i++) {
            var oldIndex = nStr1.length - 1 - i;
            var newIndex = nStr2.length - 1 - i;
            if (nStr1[oldIndex] == nStr2[newIndex]) {
                newSccondStartIndex = i + 1;
            }
            else {
                break;
            }
        }
        return [oldFirstEndIndex, newSccondStartIndex];
    };
    ;
    return StringUtils;
}());
var Callback = (function () {
    function Callback(callbackFunc, caller, args) {
        if (args === void 0) { args = null; }
        this.delayRunSigns = [];
        this.callbackFunc = callbackFunc;
        this.caller = caller;
        this.args = args;
    }
    Callback.prototype.run = function () {
        var r = this.callbackFunc.apply(this.caller, this.args);
        return r;
    };
    Callback.prototype.runWith = function (addArgs) {
        var r = this.callbackFunc.apply(this.caller, this.args ? this.args.concat(addArgs) : addArgs);
        return r;
    };
    Callback.prototype.delayRun = function (delay, delayFunc, args) {
        if (delayFunc === void 0) { delayFunc = null; }
        if (args === void 0) { args = null; }
        var f = delayFunc ? delayFunc : setTimeout;
        this.delayRunSigns.push(f(function (callBack) {
            callBack.delayRunSigns.shift();
            args ? callBack.runWith(args) : callBack.run();
        }, delay, this));
        return this;
    };
    Callback.prototype.delayRunConver = function (delay, delayFunc, clearDelayFunc, args) {
        if (delayFunc === void 0) { delayFunc = null; }
        if (clearDelayFunc === void 0) { clearDelayFunc = null; }
        if (args === void 0) { args = null; }
        if (this.delayRunSign) {
            var f = clearDelayFunc ? clearDelayFunc : clearTimeout;
            f(this.delayRunSign);
        }
        this.delayRunSign = this.delayRun(delay, delayFunc, args);
        return this;
    };
    Callback.prototype.stopDealy = function (clearDelayFunc) {
        if (clearDelayFunc === void 0) { clearDelayFunc = null; }
        var f = clearDelayFunc ? clearDelayFunc : clearTimeout;
        if (this.delayRunSign) {
            f(this.delayRunSign);
            this.delayRunSign = null;
        }
        for (var i in this.delayRunSigns) {
            f(this.delayRunSigns[i]);
        }
        this.delayRunSigns.length = 0;
    };
    Callback.New = function (callbackFunc, caller, args) {
        if (args === void 0) { args = null; }
        var cb = new Callback(callbackFunc, caller, args);
        return cb;
    };
    Callback.CallLater = function (func, caller, args) {
        if (args === void 0) { args = null; }
        var f = typeof setFrameout != "undefined" ? setFrameout : setTimeout;
        var funccallLayerKey = func["_clk"];
        var callercallLayerKey = caller["_clk"];
        if (funccallLayerKey != null && callercallLayerKey != null) {
            var key = funccallLayerKey + callercallLayerKey * 100000000;
            var cb = Callback.callBacks[key];
            if (cb)
                return;
        }
        funccallLayerKey = func["_clk"] = ObjectUtils.getInstanceID();
        callercallLayerKey = caller["_clk"] = ObjectUtils.getInstanceID();
        var key = funccallLayerKey + callercallLayerKey * 100000000;
        var cb = Callback.New(function (func, caller, args, key) {
            if (args === void 0) { args = null; }
            delete Callback.callBacks[key];
            func.apply(caller, args);
        }, this).delayRun(0, null, [func, caller, args, key]);
        Callback.callBacks[key] = cb;
    };
    Callback.callBacks = [];
    return Callback;
}());
var PoolUtils = (function () {
    function PoolUtils(cls) {
        this.pools = [];
        this.cls = cls;
    }
    PoolUtils.prototype.free = function (obj) {
        this.pools.push(obj);
    };
    PoolUtils.prototype.takeout = function () {
        if (this.pools.length > 0) {
            return this.pools.shift();
        }
        return new this.cls();
    };
    return PoolUtils;
}());
var MathUtils = (function () {
    function MathUtils() {
    }
    MathUtils.angle2Radian = function (angle) { return angle * Math.PI / 180; };
    ;
    MathUtils.radian2Angle = function (radian) { return 180 * radian / Math.PI; };
    ;
    MathUtils.rand = function (n) {
        return Math.floor(Math.random() * n);
    };
    MathUtils.direction_360 = function (x_x1, x_y1, x_x2, x_y2) {
        var n_r = Math.PI / 2;
        if (x_x1 != x_x2) {
            n_r = Math.atan((x_y1 - x_y2) / (x_x1 - x_x2));
        }
        var n_jiaodu = n_r * 180 / Math.PI;
        if (x_x2 > x_x1) {
            if (x_y2 > x_y1) {
                n_jiaodu = Math.abs(n_jiaodu) + 90;
            }
            else {
                n_jiaodu = 90 - Math.abs(n_jiaodu);
            }
        }
        else {
            if (x_y2 > x_y1) {
                n_jiaodu = 90 - Math.abs(n_jiaodu) + 180;
            }
            else {
                n_jiaodu = Math.abs(n_jiaodu) + 270;
            }
        }
        if (n_jiaodu == 360) {
            n_jiaodu = 0;
        }
        return n_jiaodu;
    };
    MathUtils.fixIntDigit = function (s, fixDigit) {
        if (fixDigit === void 0) { fixDigit = 4; }
        var ss = s.toString();
        while (ss.length < fixDigit) {
            ss = "0" + ss;
        }
        return ss;
    };
    MathUtils.int = function (v) {
        var a = parseInt(v);
        if (isNaN(a))
            return 0;
        return a;
    };
    MathUtils.float = function (v) {
        var a = parseFloat(v);
        if (isNaN(a))
            return 0;
        return a;
    };
    MathUtils.inAngleRange = function (limitMax, limitMin, angle) {
        limitMax = limitMax + 360;
        limitMin = limitMin + 360;
        var angles = [angle, angle - 360, angle + 360];
        for (var i in angles) {
            var angle = angles[i];
            if (angle > limitMin && angle < limitMax) {
                return true;
            }
        }
        return false;
    };
    return MathUtils;
}());
var SyncTask = (function () {
    function SyncTask(taskName, func, arg, thisPtr, isConver, jumpQuere) {
        if (func === void 0) { func = null; }
        if (arg === void 0) { arg = null; }
        if (thisPtr === void 0) { thisPtr = null; }
        if (isConver === void 0) { isConver = false; }
        if (jumpQuere === void 0) { jumpQuere = false; }
        var taskList = SyncTask.taskLists[taskName];
        if (!taskList)
            taskList = SyncTask.taskLists[taskName] = [];
        if (isConver) {
            var sameTaskList = ArrayUtils.matchAttributes(taskList, { func: func }, false);
            while (sameTaskList.length > 0) {
                var idx = taskList.indexOf(sameTaskList.shift());
                taskList.splice(idx, 1);
            }
        }
        if (jumpQuere) {
            taskList.unshift(this);
        }
        else {
            taskList.push(this);
        }
        this.func = func;
        this.arg = arg;
        this.thisPtr = thisPtr;
        SyncTask.doTask(taskName);
    }
    SyncTask.prototype.execute = function (taskName) {
        SyncTask.taskExecuteing[taskName] = true;
        if (!this.func)
            return;
        this.thisPtr ? this.func.apply(this.thisPtr, this.arg) : this.func.apply(this, this.arg);
    };
    SyncTask.doTask = function (taskName) {
        if (SyncTask.taskExecuteing[taskName])
            return;
        var taskList = SyncTask.taskLists[taskName];
        if (taskList && taskList.length > 0)
            taskList.shift().execute(taskName);
    };
    SyncTask.taskOver = function (taskName) {
        SyncTask.taskExecuteing[taskName] = false;
        SyncTask.doTask(taskName);
    };
    SyncTask.clear = function (taskName) {
        delete SyncTask.taskExecuteing[taskName];
        delete SyncTask.taskLists[taskName];
    };
    SyncTask.taskLists = {};
    SyncTask.taskExecuteing = [];
    return SyncTask;
}());
var Scene = (function () {
    function Scene() {
        this.obstacleData = [];
        this.maskData = [];
        this.sceneObjects = [];
        this.gridSceneObjects = [];
        this.lastUpdateObsBridgeGrid = [];
        this.helpPoint = new Point();
    }
    Scene.parse = function (jsonObj, scene, gameData) {
        ObjectUtils.clone(jsonObj, scene);
        scene.sceneObjects = [];
        scene.gridWidth = Math.floor(scene.width / Config.SCENE_GRID_SIZE);
        scene.gridHeight = Math.floor(scene.height / Config.SCENE_GRID_SIZE);
        for (var x = 0; x < scene.gridWidth; x++) {
            scene.gridSceneObjects[x] = [];
            for (var y = 0; y < scene.gridHeight; y++) {
                scene.gridSceneObjects[x][y] = [];
            }
        }
        if (Config.EDIT_MODE) {
            scene.tileMaskData = [];
            scene.tileObstacleData = [];
        }
        var maskData = Config.EDIT_MODE ? scene.tileMaskData : scene.maskData;
        var obsData = Config.EDIT_MODE ? scene.tileObstacleData : scene.obstacleData;
        for (var i = 0; i < scene.LayerDatas.length; i++) {
            var layerData = scene.LayerDatas[i];
            if (layerData.p)
                continue;
            if (layerData.drawMode && layerData.dx == 0 && layerData.dy == 0 && layerData.xMove == 0 && layerData.yMove == 0
                && layerData.scaleX == 1 && layerData.scaleY == 1 && layerData.prospectsPerX == 1 && layerData.prospectsPerY == 1) {
                for (var x = 0; x < scene.gridWidth; x++) {
                    var tileDataW = layerData.tileData[x];
                    if (!tileDataW)
                        continue;
                    for (var y = 0; y < scene.gridHeight; y++) {
                        var layerTileData = tileDataW[y];
                        if (!layerTileData)
                            continue;
                        var tileData = gameData.tileList.data[layerTileData.texID];
                        if (!tileData)
                            continue;
                        var tileGridP = GameUtils.getGridPostion(new Point(layerTileData.x, layerTileData.y));
                        if (tileData.maskData[tileGridP.x] && tileData.maskData[tileGridP.x][tileGridP.y]) {
                            if (!maskData[x])
                                maskData[x] = [];
                            maskData[x][y] = true;
                        }
                        if (tileData.obstacleData[tileGridP.x] && tileData.obstacleData[tileGridP.x][tileGridP.y]) {
                            if (!obsData[x])
                                obsData[x] = [];
                            obsData[x][y] = true;
                        }
                    }
                }
            }
        }
    };
    Scene.getRealWidth = function (scene) {
        return { width: scene.gridWidth * Config.SCENE_GRID_SIZE, height: scene.gridHeight * Config.SCENE_GRID_SIZE };
    };
    Scene.prototype.getSceneObjectByID = function (soIndex) {
        var m = ArrayUtils.matchAttributes(this.sceneObjects, { index: soIndex }, true);
        return m[0];
    };
    Scene.prototype.isObstacle = function (p, except) {
        if (except === void 0) { except = null; }
        var map32 = GameUtils.getGridPostion(p);
        return this.isObstacleGrid(map32, except);
    };
    Scene.prototype.isObstacleGrid = function (gridP, except) {
        if (except === void 0) { except = null; }
        if (this.isOutsideByGrid(gridP)) {
            return true;
        }
        var gridStatus = this.gridDynamicObsStatus(gridP, except);
        if (gridStatus == 1) {
            return false;
        }
        else if (gridStatus == 2) {
            return true;
        }
        return this.isFixedObstacleGrid(gridP);
    };
    Scene.prototype.isFixedObstacleGrid = function (gridP) {
        if (this.obstacleData[gridP.x] && this.obstacleData[gridP.x][gridP.y]) {
            return true;
        }
        if (Config.EDIT_MODE && this.tileObstacleData[gridP.x] && this.tileObstacleData[gridP.x][gridP.y]) {
            return true;
        }
        return false;
    };
    Scene.prototype.isMask = function (p) {
        var map32 = GameUtils.getGridPostion(p);
        return this.isMaskGrid(map32);
    };
    Scene.prototype.isMaskGrid = function (gridP) {
        if (this.maskData[gridP.x] && this.maskData[gridP.x][gridP.y]) {
            return true;
        }
        return false;
    };
    Scene.prototype.isOutside = function (p) {
        if (p.x < 0 || p.x >= this.width || p.y < 0 || p.y >= this.height) {
            return true;
        }
        return false;
    };
    Scene.prototype.isOutsideByGrid = function (gridP) {
        if (gridP.x < 0 || gridP.x >= this.gridWidth || gridP.y < 0 || gridP.y >= this.gridHeight) {
            return true;
        }
        return false;
    };
    Scene.prototype.limitInside = function (p) {
        var wh = Scene.getRealWidth(this);
        wh.width -= 1;
        wh.height -= 1;
        if (p.x < 0) {
            p.x = 0;
        }
        else if (p.x > wh.width) {
            p.x = wh.width;
        }
        if (p.y < 0) {
            p.y = 0;
        }
        else if (p.y > wh.height) {
            p.y = wh.height;
        }
    };
    Scene.prototype.gridDynamicObsStatus = function (gridP, except) {
        if (except === void 0) { except = null; }
        if (!this.gridSceneObjects[gridP.x])
            return 0;
        var sos = this.gridSceneObjects[gridP.x][gridP.y];
        if (!sos)
            return 0;
        var len = sos.length;
        for (var i = 0; i < len; i++) {
            var so = sos[i];
            if (so == except)
                continue;
            if (so == null)
                continue;
            if (so.bridge)
                return 1;
            if (!so.bridge && !so.through && so.avatarID != 0)
                return 2;
        }
        return 0;
    };
    Scene.prototype.updateDynamicObsAndBridge = function (soc, inScene, posGrid) {
        if (posGrid === void 0) { posGrid = null; }
        if (Config.EDIT_MODE)
            return false;
        var nowGrid;
        if (posGrid != null) {
            nowGrid = new Point(posGrid.x, posGrid.y);
        }
        else {
            var nowP = new Point(soc.x, soc.y);
            nowGrid = GameUtils.getGridPostion(nowP, nowP);
        }
        var lastGrid = this.lastUpdateObsBridgeGrid[soc.index];
        if (lastGrid && nowGrid.x == lastGrid.x && nowGrid.y == lastGrid.y && inScene)
            return false;
        if (lastGrid) {
            var sos = this.gridSceneObjects[lastGrid.x][lastGrid.y];
            sos.splice(sos.indexOf(soc), 1);
            delete this.lastUpdateObsBridgeGrid[soc.index];
        }
        if (inScene) {
            var sos = this.gridSceneObjects[nowGrid.x][nowGrid.y];
            sos.push(soc);
            this.lastUpdateObsBridgeGrid[soc.index] = nowGrid;
            return true;
        }
        return false;
    };
    Scene.ignoreAttributes = ["gridSceneObjects", "lastUpdateObsBridgeGrid", "dynamiCalcLayer", "tileObstacleData", "tileMaskData"];
    return Scene;
}());
var Variable = (function () {
    function Variable(listener) {
        if (listener === void 0) { listener = null; }
        this.variables = [];
        this.switchs = [];
        this.strings = [];
        this.listener = listener;
    }
    Variable.prototype.getVariable = function (varID) {
        var v = this.variables[varID];
        return v == null ? 0 : v;
    };
    Variable.prototype.setVariable = function (varID, v) {
        this.variables[varID] = v;
        this.listener && this.listener.onVarChange(0, varID, v);
    };
    Variable.prototype.getSwitch = function (varID) {
        var v = this.switchs[varID];
        return v == null ? 0 : v;
    };
    Variable.prototype.setSwitch = function (varID, v) {
        this.switchs[varID] = v;
        this.listener && this.listener.onVarChange(1, varID, v);
    };
    Variable.prototype.getString = function (varID) {
        var v = this.strings[varID];
        return v == null ? "" : v;
    };
    Variable.prototype.setString = function (varID, v) {
        this.strings[varID] = v;
        this.listener && this.listener.onVarChange(2, varID, v);
    };
    Variable.splitDynamicText = function (str) {
        var reg = /\[\$(v|s|w)\d+\]|\[\@(v|s|w|p)\d+\]/g;
        var m = str.match(reg);
        if (!m)
            return [[0, str]];
        var startIndex = 0;
        var arr = [];
        for (var i = 0; i < m.length; i++) {
            var keyWord = m[i];
            var keyWordIndex = str.indexOf(keyWord, startIndex);
            if (startIndex != keyWordIndex) {
                arr.push([0, str.substr(startIndex, keyWordIndex - startIndex)]);
            }
            startIndex = keyWordIndex + keyWord.length;
            var firstKey = keyWord[1];
            var second = keyWord[2];
            var num = keyWord.substr(3, keyWord.length - 4);
            if (firstKey == "$") {
                if (second == "v") {
                    arr.push([1, num]);
                }
                else if (second == "w") {
                    arr.push([2, num]);
                }
                else {
                    arr.push([3, num]);
                }
            }
            else if (firstKey == "@") {
                if (second == "v") {
                    arr.push([4, num]);
                }
                else if (second == "w") {
                    arr.push([5, num]);
                }
                else if (second == "p") {
                    arr.push([7, num]);
                }
                else {
                    arr.push([6, num]);
                }
            }
        }
        if (startIndex != str.length) {
            arr.push([0, str.substr(startIndex)]);
        }
        return arr;
    };
    Variable.margeDynamicText = function (texts, player, trigger) {
        if (player === void 0) { player = null; }
        if (trigger === void 0) { trigger = null; }
        var len = texts.length;
        var str = "";
        for (var i = 0; i < len; i++) {
            var text = texts[i];
            var type = text[0];
            if (type >= 4 && !player)
                continue;
            if (type == 0) {
                str += text[1];
            }
            else if (type == 1) {
                str += ServerWorld.getWorldVariable(text[1]);
            }
            else if (type == 2) {
                str += ServerWorld.getWorldSwitch(text[1]);
            }
            else if (type == 3) {
                str += ServerWorld.getWorldString(text[1]);
            }
            else if (type == 4) {
                str += player.variable.getVariable(text[1]);
            }
            else if (type == 5) {
                str += player.variable.getSwitch(text[1]);
            }
            else if (type == 6) {
                str += player.variable.getString(text[1]);
            }
            else if (type == 7) {
                str += trigger.inputMessage[text[1]];
            }
        }
        return str;
    };
    Variable.prototype.getTransportableData = function () {
        var o = new Variable();
        o.variables = this.variables;
        o.switchs = this.switchs;
        o.strings = this.strings;
        return o;
    };
    return Variable;
}());
var OriginalData = (function () {
    function OriginalData() {
    }
    return OriginalData;
}());





var SceneLayerData = (function (_super) {
    __extends(SceneLayerData, _super);
    function SceneLayerData() {
        _super.apply(this, arguments);
        this.dx = 0;
        this.dy = 0;
        this.scaleX = 1;
        this.scaleY = 1;
        this.xMove = 0;
        this.yMove = 0;
        this.prospectsPerX = 1;
        this.prospectsPerY = 1;
        this.xLoop = false;
        this.yLoop = false;
        this.opacity = 1;
        this.blendMode = null;
        this.drawMode = false;
        this.tileData = [];
        this.img = null;
    }
    SceneLayerData.getTileData = function (layer, wGrid, hGrid) {
        var tileData = [];
        var tileTexIDs = {};
        for (var x = 0; x < wGrid; x++) {
            if (!layer.tileData[x])
                continue;
            if (!tileData[x])
                tileData[x] = [];
            for (var y = 0; y < hGrid; y++) {
                var oneTileData = layer.tileData[x][y];
                if (oneTileData) {
                    tileData[x][y] = {
                        texID: oneTileData.texID,
                        x: oneTileData.x,
                        y: oneTileData.y
                    };
                    if (oneTileData.texID && !tileTexIDs[oneTileData.texID]) {
                        tileTexIDs[oneTileData.texID] = true;
                    }
                }
            }
        }
        return [tileData, tileTexIDs];
    };
    SceneLayerData.clone = function () {
    };
    return SceneLayerData;
}(OriginalData));





var SceneObjectModelData = (function (_super) {
    __extends(SceneObjectModelData, _super);
    function SceneObjectModelData() {
        _super.apply(this, arguments);
        this.preLayer = [];
        this.varAttributes = [];
        this.serverInstanceClassName = SceneObjectModelData.SERVER_SCENE_OBJECT_CORE_CLASS;
        this.clientInstanceClassName = SceneObjectModelData.CLIENT_SCENE_OBJECT_CORE_CLASS;
    }
    SceneObjectModelData.getServerCode = function (modelData) {
        var serverVars = CustomAttributeSetting.getAPIRuntimes(modelData.varAttributes);
        var modelName = GameListData.getName(Common.sceneObjectModelList, modelData.id);
        var serverSoBaseCode = "/**\n * \u573A\u666F\u5BF9\u8C61\u6A21\u578B\uFF1A" + modelName + "\n */\nclass ServerSceneObject_" + modelData.id + " extends " + this.SERVER_SCENE_OBJECT_CORE_CLASS + " {\n" + serverVars + "    constructor(soData: SceneObject,presetCustomAttrs: { [varName: string]: { varType: number, value: any } } = null,player: ServerPlayer) {\n        super(soData,presetCustomAttrs,player);\n    }\n}";
        return { serverSoBaseCode: serverSoBaseCode };
    };
    SceneObjectModelData.getServerJsBaseCode = function (modelData) {
        return "var ServerSceneObject_" + modelData.id + " = (function (_super) {__extends(ServerSceneObject_" + modelData.id + ", _super);function ServerSceneObject_" + modelData.id + "(soData,presetCustomAttrs,player) {_super.apply(this, [soData,presetCustomAttrs,player]);}return ServerSceneObject_" + modelData.id + ";}(" + this.SERVER_SCENE_OBJECT_CORE_CLASS + "));";
    };
    SceneObjectModelData.getAllAPICodeInEditor = function (mode) {
        var list = Game.data.sceneObjectModelList;
        var codes = "";
        for (var i in list.data) {
            var model = list.data[i];
            if (!model)
                continue;
            if (EUIWindowSceneObjectModel.modelData && model.id == EUIWindowSceneObjectModel.modelData.id) {
                model = EUIWindowSceneObjectModel.modelData;
            }
            if (mode == 1) {
                var serverCode = this.getServerCode(model);
                codes += serverCode.serverSoBaseCode + "\n";
            }
            else if (mode == 2) {
                var clientCode = this.getClientCode(model);
                codes += clientCode.clientSoBaseCode + "\n";
            }
        }
        return codes;
    };
    SceneObjectModelData.getClientCode = function (modelData) {
        var clientVars = CustomAttributeSetting.getAPIRuntimes(modelData.varAttributes, true);
        var clientDisplayVars = "";
        for (var i in modelData.preLayer) {
            var preLayer = modelData.preLayer[i];
            if (preLayer.inEditorShowMode == 2)
                continue;
            var varTypeStr = null;
            if (preLayer.type <= 1) {
                continue;
            }
            else if (preLayer.type == 2) {
                var uiData = Common.uiList.data[preLayer.id];
                if (!uiData)
                    continue;
                if (uiData.uiDisplayData.instanceClassName) {
                    varTypeStr = uiData.uiDisplayData.instanceClassName + ";\n";
                }
                else {
                    varTypeStr = "GUI_" + preLayer.id + ";\n";
                }
            }
            else if (preLayer.type == 3) {
                varTypeStr = "UIRoot;\n";
            }
            else if (preLayer.type <= 5) {
                varTypeStr = "Animation;\n";
            }
            clientDisplayVars += "    " + preLayer.varName + ": " + varTypeStr;
        }
        var modelName = GameListData.getName(Common.sceneObjectModelList, modelData.id);
        var clientSoBaseCode = "/**\n * \u573A\u666F\u5BF9\u8C61\u6A21\u578B\uFF1A" + modelName + "\n */\nclass ClientSceneObject_" + modelData.id + " extends " + this.CLIENT_SCENE_OBJECT_CORE_CLASS + " {\n" + clientVars + clientDisplayVars + "    constructor(soData: SceneObject, scene: ClientScene) {\n        super(soData,scene);\n    }\n}";
        return { clientSoBaseCode: clientSoBaseCode };
    };
    SceneObjectModelData.getClientJsBaseCode = function (modelData) {
        return "var ClientSceneObject_" + modelData.id + " = (function (_super) {__extends(ClientSceneObject_" + modelData.id + ", _super);function ClientSceneObject_" + modelData.id + "(soData,scene) {_super.apply(this, [soData,scene]);}return ClientSceneObject_" + modelData.id + ";}(" + this.CLIENT_SCENE_OBJECT_CORE_CLASS + "));";
    };
    SceneObjectModelData.SERVER_SCENE_OBJECT_CORE_CLASS = "GameServerSceneObject_Core";
    SceneObjectModelData.CLIENT_SCENE_OBJECT_CORE_CLASS = "GameClientSceneObject_Core";
    SceneObjectModelData.TYPE_AVATAR_TYPE = 1;
    SceneObjectModelData.TYPE_UI_DESIGNATION = 2;
    SceneObjectModelData.TYPE_UI_TYPE = 3;
    SceneObjectModelData.TYPE_ANIMATION_DESIGNATION = 4;
    SceneObjectModelData.TYPE_ANIMATION_TYPE = 5;
    SceneObjectModelData.sceneObjectClass = {};
    return SceneObjectModelData;
}(OriginalData));





var TileData = (function (_super) {
    __extends(TileData, _super);
    function TileData() {
        _super.call(this);
        this.url = "";
        this.obstacleData = [];
        this.maskData = [];
        this.width = 0;
        this.height = 0;
    }
    return TileData;
}(OriginalData));





var UIData = (function (_super) {
    __extends(UIData, _super);
    function UIData() {
        _super.apply(this, arguments);
        this.uiDisplayData = new UIDisplayData();
        this.uiCommandData = new OriginalData();
    }
    UIData.init = function (item) {
        item.uiDisplayData.id = item.id;
    };
    return UIData;
}(OriginalData));
var GameListData = (function () {
    function GameListData(folder, listName, listData, listType, arrayModeIndex) {
        if (arrayModeIndex === void 0) { arrayModeIndex = null; }
        this.listData = {};
        this.data = [];
        this.folder = folder;
        this.listName = listName;
        this.listData = listData;
        this.listType = listType;
        this.arrayModeIndex = arrayModeIndex;
    }
    GameListData.getID = function (typeID, index) {
        return (typeID - 1) * 1000 + index;
    };
    GameListData.getType = function (id) {
        if (id == 0)
            return 1;
        return Math.floor((id - 1) / 1000) + 1;
    };
    GameListData.getLocalID = function (id) {
        return (id - 1) % 1000 + 1;
    };
    GameListData.getItem = function (gameListData, typeID, localID) {
        var id = GameListData.getID(typeID, localID);
        return gameListData.data[id];
    };
    GameListData.getItems = function (gameListData) {
        var arr = [];
        for (var i in gameListData.data) {
            var d = gameListData.data[i];
            if (d)
                arr.push(d);
        }
        return arr;
    };
    GameListData.getIDRange = function (typeID) {
        return { from: (typeID - 1) * 1000 + 1, to: (typeID - 1) * 1000 + 1000 };
    };
    GameListData.getName = function (gameListData, id) {
        if (!gameListData.listData)
            return null;
        var name;
        if (gameListData.hasType) {
            var typeID = GameListData.getType(id);
            var typeArr = gameListData.listData.list[typeID];
            if (!typeArr)
                return "";
            name = typeArr[GameListData.getLocalID(id)];
        }
        else {
            name = gameListData.listData.list[id];
        }
        return name != null ? name : "--/--";
    };
    GameListData.setName = function (gameListData, id, name) {
        if (!gameListData.listData)
            return null;
        if (gameListData.hasType) {
            var typeID = Math.floor((id - 1) / 1000) + 1;
            gameListData.listData.list[typeID][GameListData.getLocalID(id)] = name;
        }
        else {
            gameListData.listData.list[id] = name;
        }
    };
    GameListData.changeMaximum = function (cls, gameListData, typeID, currentListMaximum, setMaximum) {
        if (currentListMaximum < setMaximum) {
            if (gameListData.hasType) {
                if (!gameListData.listData.list[typeID])
                    gameListData.listData.list[typeID] = [];
            }
            var startID = GameListData.getID(typeID, currentListMaximum) + 1;
            var len = setMaximum - currentListMaximum;
            for (var i = 0; i < len; i++) {
                var itemData = new cls();
                var id = itemData.id = startID + i;
                gameListData.data[id] = itemData;
                if (gameListData.hasType) {
                    gameListData.listData.list[typeID][currentListMaximum + 1 + i] = "";
                }
                else {
                    gameListData.listData.list[currentListMaximum + 1 + i] = "";
                }
            }
        }
        else if (currentListMaximum > setMaximum) {
            var range = GameListData.getIDRange(typeID);
            var startID = range.from + setMaximum;
            for (var i = startID; i < range.to; i++) {
                gameListData.data[i] = null;
                if (gameListData.hasType) {
                    if (gameListData.listData.list[typeID]) {
                        gameListData.listData.list[typeID].length = setMaximum + 1;
                    }
                }
                else {
                    gameListData.listData.list.length = setMaximum + 1;
                }
            }
        }
    };
    GameListData.getLength = function (gameListData, typeID) {
        if (typeID === void 0) { typeID = null; }
        if (gameListData.hasType) {
            var list = gameListData.listData.list[typeID];
            return list ? list.length - 1 : 0;
        }
        else {
            return gameListData.listData.list.length - 1;
        }
    };
    GameListData.changeTypName = function (gameListData, typeID, name) {
        gameListData.listData.type[typeID] = name;
    };
    GameListData.getTypName = function (gameListData, typeID) {
        return gameListData.listData.type ? gameListData.listData.type[typeID] : null;
    };
    GameListData.setNewData = function (cls, gameListData, id, name) {
        if (id === void 0) { id = 0; }
        if (name === void 0) { name = ""; }
        var itemData = new cls();
        if (id == 0) {
            if (gameListData.hasType)
                return;
            var list = gameListData.listData.list;
            id = list.length;
        }
        itemData.id = id;
        this.setData(gameListData, id, itemData, name);
        return itemData;
    };
    GameListData.setData = function (gameListData, id, itemData, name) {
        if (id === void 0) { id = 0; }
        if (id == 0) {
            var list = gameListData.hasType ? gameListData.listData.list[typeID] : gameListData.listData.list;
            id = list.length;
        }
        if (gameListData.hasType) {
            var typeID = GameListData.getType(id);
            gameListData.listData.list[typeID][GameListData.getLocalID(id)] = name;
        }
        else {
            gameListData.listData.list[id] = name;
        }
        gameListData.data[id] = itemData;
    };
    GameListData.disposeData = function (gameListData, id) {
        if (gameListData.hasType) {
            var typeID = GameListData.getType(id);
            gameListData.listData.list[typeID][GameListData.getLocalID(id)] = null;
        }
        else {
            gameListData.listData.list[id] = null;
        }
        gameListData.data[id] = null;
    };
    GameListData.remove = function (gameListData, id, autoOrder) {
        if (autoOrder === void 0) { autoOrder = false; }
        var list;
        var index;
        if (gameListData.hasType) {
            var typeID = GameListData.getType(id);
            list = gameListData.listData.list[typeID];
            index = GameListData.getLocalID(id);
        }
        else {
            list = gameListData.listData.list;
            index = id;
        }
        list[index] = null;
        if (!autoOrder)
            return;
        list.splice(index, 1);
        gameListData.data.splice(index, 1);
        for (var i = id; i < gameListData.data.length; i++) {
            var data = gameListData.data[i];
            if (data)
                data.id = i;
        }
    };
    return GameListData;
}());
var GameData = (function () {
    function GameData() {
        this.customModuleDataList = [];
    }
    GameData.prototype.loadVariableList = function (onFin) {
        this.onLoadList(GameData.LIST_TYPE_VARIABLE, OriginalData, [], "asset/json/variable/", "variable.json", onFin);
    };
    GameData.prototype.loadSwitchList = function (onFin) {
        this.onLoadList(GameData.LIST_TYPE_SWITCH, OriginalData, [], "asset/json/variable/", "switch.json", onFin);
    };
    GameData.prototype.loadStringList = function (onFin) {
        this.onLoadList(GameData.LIST_TYPE_STRING, OriginalData, [], "asset/json/variable/", "string.json", onFin);
    };
    GameData.prototype.loadPlayerVariableList = function (onFin) {
        this.onLoadList(GameData.LIST_TYPE_PLAYER_VARIABLE, OriginalData, [], "asset/json/server/variable/", "variable.json", onFin);
    };
    GameData.prototype.loadPlayerSwitchList = function (onFin) {
        this.onLoadList(GameData.LIST_TYPE_PLAYER_SWITCH, OriginalData, [], "asset/json/server/variable/", "switch.json", onFin);
    };
    GameData.prototype.loadPlayerStringList = function (onFin) {
        this.onLoadList(GameData.LIST_TYPE_PLAYER_STRING, OriginalData, [], "asset/json/server/variable/", "string.json", onFin);
    };
    GameData.prototype.loadSceneList = function (onFin, itemNeedMethod) {
        if (itemNeedMethod === void 0) { itemNeedMethod = null; }
        this.onLoadList(GameData.LIST_TYPE_SCENE, SceneData, [
            { childAttribute: "mapData", path: "asset/json/scene/data/scene" },
            { childAttribute: "sceneObjectData", path: "asset/json/server/scene/s" }
        ], "asset/json/scene/", "sceneList.json", onFin, false, itemNeedMethod);
    };
    GameData.prototype.loadSceneObjectModelList = function (onFin, isServer) {
        if (isServer === void 0) { isServer = false; }
        this.onLoadList(GameData.LIST_TYPE_SCENE_OBJECT_MODEL, SceneObjectModelData, [
            { childAttribute: null, path: "asset/json/scene/model/som" }
        ], "asset/json/scene/", "sceneObjectModelList.json", onFin, false);
    };
    GameData.prototype.loadTileList = function (onFin) {
        this.onLoadList(GameData.LIST_TYPE_TILE, TileData, [
            { childAttribute: null, path: "asset/json/scene/tile/tile" }
        ], "asset/json/scene/", "tileList.json", onFin, false);
    };
    GameData.prototype.loadAvatarList = function (onFin) {
        this.onLoadList(GameData.LIST_TYPE_AVATAR, AvatarData, [
            { childAttribute: null, path: "asset/json/avatar/data/avatar" }
        ], "asset/json/avatar/", "avatarList.json", onFin, true, null, true);
    };
    GameData.prototype.loadAvatarActList = function (onFin) {
        this.onLoadList(GameData.LIST_TYPE_AVATAR_ACT, OriginalData, [], "asset/json/avatar/", "avatarActList.json", onFin, false);
    };
    GameData.prototype.loadAvatarRefObjList = function (onFin) {
        this.onLoadList(GameData.LIST_TYPE_AVATAR_REF_OBJ, AvatarRefObjData, [], "asset/json/avatar/", "avatarRefObjList.json", onFin, false);
    };
    GameData.prototype.loadCommonEventList = function (onFin) {
        this.onLoadList(GameData.LIST_TYPE_COMMON_EVENT, CommonEventData, [
            { childAttribute: null, path: "asset/json/server/command/data/ws" }
        ], "asset/json/server/command/", "worldCommand.json", onFin);
    };
    GameData.prototype.loadDialogList = function (onFin) {
        this.onLoadList(GameData.LIST_TYPE_DIALOG, DialogData, [
            { childAttribute: null, path: "asset/json/dialog/data/dialog" }
        ], "asset/json/dialog/", "dialogList.json", onFin, false);
    };
    GameData.prototype.loadAnimationList = function (onFin) {
        this.onLoadList(GameData.LIST_TYPE_ANIMATION, AnimationData, [
            { childAttribute: null, path: "asset/json/animation/data/ani" }
        ], "asset/json/animation/", "animationList.json", onFin);
    };
    GameData.prototype.loadAnimationSignalList = function (onFin) {
        this.onLoadList(GameData.LIST_TYPE_ANIMATION_SIGNAL, OriginalData, [], "asset/json/animation/", "animationSignalList.json", onFin, false);
    };
    GameData.prototype.loadUIList = function (onFin) {
        var childData = [{ childAttribute: "uiCommandData", path: "asset/json/server/ui/sui" }];
        childData.unshift({ childAttribute: "uiDisplayData", path: "asset/json/ui/data/ui" });
        this.onLoadList(GameData.LIST_TYPE_UI, UIData, childData, "asset/json/ui/", "uiList.json", onFin);
    };
    GameData.prototype.loadDataStructureList = function (onFin) {
        this.onLoadList(GameData.LIST_TYPE_DATA_STRUCTURE, CustomCompositeSetting, [], "asset/json/custom/", "dataStructure.json", onFin, true);
    };
    GameData.prototype.loadCustomModuleList = function (onFin) {
        var _this = this;
        this.onLoadList(GameData.LIST_TYPE_CUSTOM_MODULE, CustomCompositeSetting, [], "asset/json/custom/", "customModuleList.json", Callback.New(function () {
            var customSettingList = _this.customModuleList;
            var len = GameListData.getLength(customSettingList);
            var loadCount = len;
            if (loadCount == 0)
                onFin.run();
            for (var i = 1; i <= len; i++) {
                if (!customSettingList.data[i])
                    continue;
                _this.onLoadList(GameData.LIST_TYPE_CUSTOM_MODULE_DATA, CustomData, [
                    { childAttribute: null, path: "asset/json/custom/customModule/" + i + "/cm" }
                ], "asset/json/custom/customModule/", "customModuleDataList" + i + ".json", Callback.New(function () {
                    loadCount--;
                    if (loadCount == 0) {
                        onFin.run();
                    }
                }, _this), true, null, false, i);
            }
        }, this), false);
    };
    GameData.newCustomModuleDataList = function (index) {
        var gameListData = new GameListData("asset/json/custom/customModule/", "customModuleDataList" + index + ".json", { list: {}, type: {} }, GameData.LIST_TYPE_CUSTOM_MODULE_DATA, index);
        return gameListData;
    };
    GameData.prototype.loadGameAttributeConfig = function (onFin) {
        var _this = this;
        FileUtils.loadJsonFile("asset/json/custom/customGameAttribute.json", Callback.New(function (jsonObj) {
            _this.customGameAttribute = new CustomGameAttribute();
            ObjectUtils.clone(jsonObj, _this.customGameAttribute);
            onFin.run();
        }, this));
    };
    GameData.prototype.loadScript = function (mode, onFin, needSrc) {
        var _this = this;
        var urls = ["asset/json/server/script/script.json", "asset/json/script/script.json", "asset/json/script/scriptCommon.json"];
        var url = urls[mode];
        FileUtils.loadJsonFile(url, Callback.New(function (jsonObj) {
            if (mode == 0) {
                _this.serverScript = jsonObj;
            }
            else if (mode == 1) {
                _this.clientScript = jsonObj;
            }
            else {
                _this.commonScript = jsonObj;
            }
            if (!needSrc) {
                jsonObj.src = null;
            }
            onFin.run();
        }, this));
    };
    GameData.prototype.loadCustomEventType = function (onFin) {
        var _this = this;
        this.onLoadList(GameData.LIST_TYPE_CUSTOM_OBJECT_EVENT_TYPE, CustomEventType, [], "asset/json/custom/", "customObjectEventType.json", Callback.New(function () {
            _this.onLoadList(GameData.LIST_TYPE_CUSTOM_UI_EVENT_TYPE, CustomEventType, [], "asset/json/custom/", "customUIEventType.json", Callback.New(function () {
                this.onLoadList(GameData.LIST_TYPE_CUSTOM_SCENE_EVENT_TYPE, CustomEventType, [], "asset/json/custom/", "customSceneEventType.json", onFin, false);
            }, _this), false);
        }, this), false);
    };
    GameData.prototype.loadCustomCommandType = function (onFin) {
        this.onLoadList(GameData.LIST_TYPE_CUSTOM_COMMAND_TYPE, CustomCompositeSetting, [], "asset/json/custom/", "customCommandType.json", onFin, true);
    };
    GameData.prototype.loadCustomBehaviorType = function (onFin) {
        this.onLoadList(GameData.LIST_TYPE_CUSTOM_BEHAVIOR_TYPE, CustomCompositeSetting, [], "asset/json/custom/", "customBehaviorType.json", onFin, false);
    };
    GameData.prototype.loadScene = function (id, onFin) {
        this.onLoadOne(id, "sceneList", SceneData, [
            { childAttribute: "mapData", path: "asset/json/scene/data/scene" },
            { childAttribute: "sceneObjectData", path: "asset/json/server/scene/s" }
        ], "asset/json/scene/", "sceneList.json", false);
        this.onLoadOneOver(id, onFin, "sceneList");
    };
    GameData.prototype.loadTile = function (id, onFin) {
        this.onLoadOne(id, "tileList", TileData, [
            { childAttribute: null, path: "asset/json/scene/tile/tile" }
        ], "asset/json/scene/", "tileList.json");
        this.onLoadOneOver(id, onFin, "tileList");
    };
    GameData.prototype.loadAvatar = function (id, onFin) {
        this.onLoadOne(id, "avatarList", AvatarData, [
            { childAttribute: null, path: "asset/json/avatar/data/avatar" }
        ], "asset/json/avatar/", "avatarList.json");
        this.onLoadOneOver(id, onFin, "avatarList");
    };
    GameData.prototype.onLoadList = function (saveAttribute, childCls, childItems, folder, listName, onFin, hasType, itemNeedMethod, loadZero, arrayModeIndex) {
        var _this = this;
        if (hasType === void 0) { hasType = true; }
        if (itemNeedMethod === void 0) { itemNeedMethod = null; }
        if (loadZero === void 0) { loadZero = false; }
        if (arrayModeIndex === void 0) { arrayModeIndex = null; }
        FileUtils.loadJsonFile(folder + listName, new Callback(function (listData) {
            var gameListData = new GameListData(folder, listName, listData, saveAttribute, arrayModeIndex);
            if (arrayModeIndex == null) {
                _this[saveAttribute] = gameListData;
            }
            else {
                _this[saveAttribute][arrayModeIndex] = gameListData;
            }
            gameListData.hasType = hasType;
            var typeList = hasType ? listData.list : { 1: listData.list };
            for (var typeID in typeList) {
                var typeDatas = typeList[typeID];
                for (var i = 0; i < typeDatas.length; i++) {
                    var dataName = typeDatas[i];
                    if (loadZero && i == 0 && typeID == "1") { }
                    else if (dataName == null) {
                        continue;
                    }
                    var id = GameListData.getID(parseInt(typeID), i);
                    if (itemNeedMethod && !itemNeedMethod(id))
                        continue;
                    _this.onLoadOne(id, saveAttribute, childCls, childItems, folder, listName, hasType, listData, arrayModeIndex);
                }
            }
            new SyncTask(GameData.loadDataTask, function () {
                onFin.run();
                SyncTask.taskOver(GameData.loadDataTask);
            });
        }, this));
    };
    GameData.prototype.onLoadOne = function (id, saveAttribute, childCls, childItems, folder, listName, hasType, listData, arrayModeIndex) {
        if (hasType === void 0) { hasType = true; }
        if (listData === void 0) { listData = null; }
        if (arrayModeIndex === void 0) { arrayModeIndex = null; }
        var gameListData = this[saveAttribute];
        if (arrayModeIndex == null) {
            gameListData = this[saveAttribute];
        }
        else {
            gameListData = this[saveAttribute][arrayModeIndex];
        }
        if (gameListData == null) {
            if (hasType) {
                gameListData = new GameListData(folder, listName, { list: {}, type: {} }, saveAttribute, arrayModeIndex);
            }
            else {
                gameListData = new GameListData(folder, listName, { list: {} }, saveAttribute, arrayModeIndex);
            }
            gameListData.hasType = hasType;
            if (arrayModeIndex == null) {
                this[saveAttribute] = gameListData;
            }
            else {
                this[saveAttribute][arrayModeIndex] = gameListData;
            }
        }
        var gameData = gameListData.data[id] = new childCls();
        gameData.id = id;
        if (listData.data) {
            var attrData = listData.data[id];
            ObjectUtils.clone(attrData, gameData);
        }
        for (var c = 0; c < childItems.length; c++) {
            var childItem = childItems[c];
            new SyncTask(GameData.loadDataTask);
            FileUtils.loadJsonFile(childItem.path + id + ".json", new Callback(function (gameData, id, childAttribute, itemData) {
                if (!itemData) {
                    delete gameListData.data[id];
                    if (gameListData.hasType) {
                        gameListData.listData.list[GameListData.getType(id)][GameListData.getLocalID(id)] = null;
                    }
                    else {
                        gameListData.listData.list[id] = null;
                    }
                }
                else {
                    ObjectUtils.clone(itemData, childAttribute ? gameData[childAttribute] : gameData);
                    childAttribute ? gameData[childAttribute].id = id : gameData.id = id;
                }
                SyncTask.taskOver(GameData.loadDataTask);
            }, this, [gameData, id, childItem.childAttribute]));
        }
    };
    GameData.prototype.onLoadOneOver = function (id, onFin, saveAttribute) {
        new SyncTask(GameData.loadDataTask, function () {
            onFin.runWith([this[saveAttribute].data[id]]);
            SyncTask.taskOver(GameData.loadDataTask);
        }, [], this);
    };
    GameData.LIST_TYPE_VARIABLE = "variableNameList";
    GameData.LIST_TYPE_SWITCH = "switchNameList";
    GameData.LIST_TYPE_STRING = "stringNameList";
    GameData.LIST_TYPE_PLAYER_VARIABLE = "playerVariableNameList";
    GameData.LIST_TYPE_PLAYER_SWITCH = "playerSwitchNameList";
    GameData.LIST_TYPE_PLAYER_STRING = "playerStringNameList";
    GameData.LIST_TYPE_SCENE = "sceneList";
    GameData.LIST_TYPE_SCENE_OBJECT_MODEL = "sceneObjectModelList";
    GameData.LIST_TYPE_TILE = "tileList";
    GameData.LIST_TYPE_AVATAR = "avatarList";
    GameData.LIST_TYPE_AVATAR_ACT = "avatarActList";
    GameData.LIST_TYPE_AVATAR_REF_OBJ = "avatarRefObjList";
    GameData.LIST_TYPE_COMMON_EVENT = "commonEventList";
    GameData.LIST_TYPE_DIALOG = "dialogList";
    GameData.LIST_TYPE_ANIMATION = "animationList";
    GameData.LIST_TYPE_ANIMATION_SIGNAL = "animationSignalList";
    GameData.LIST_TYPE_UI = "uiList";
    GameData.LIST_TYPE_DATA_STRUCTURE = "dataStructureList";
    GameData.LIST_TYPE_CUSTOM_MODULE = "customModuleList";
    GameData.LIST_TYPE_CUSTOM_MODULE_DATA = "customModuleDataList";
    GameData.LIST_TYPE_CUSTOM_OBJECT_EVENT_TYPE = "customObjectEventTypeList";
    GameData.LIST_TYPE_CUSTOM_UI_EVENT_TYPE = "customUIEventTypeList";
    GameData.LIST_TYPE_CUSTOM_SCENE_EVENT_TYPE = "customSceneEventTypeList";
    GameData.LIST_TYPE_CUSTOM_COMMAND_TYPE = "customCommandTypeList";
    GameData.LIST_TYPE_CUSTOM_BEHAVIOR_TYPE = "customBehaviorTypeList";
    GameData.CUSTOM_ATTR_WORLD_DATA = 0;
    GameData.CUSTOM_ATTR_PLAYER_DATA = 1;
    GameData.CUSTOM_ATTR_SCENE_DATA = 2;
    GameData.CUSTOM_ATTR_SCENE_OBJECT_DATA = 3;
    GameData.loadDataTask = "GameData_loadDataTask";
    GameData.customModulePresetDatas = [];
    return GameData;
}());
var FileUtils = (function () {
    function FileUtils() {
    }
    FileUtils.init = function () {
        if (typeof window != "undefined") {
            FileUtils.loader = window["loader"];
            FileUtils.Handler = window["Handler"];
        }
        else {
            FileUtils.readFile = eval("readFile");
            FileUtils.nativePath = eval("nativePath");
        }
    };
    FileUtils.loadJsonFile = function (localURL, onFin) {
        var tail = (typeof window != "undefined") ? "?r=" + Math.random() : "";
        FileUtils.loadFile(localURL + tail, new Callback(function (text) {
            if (!text) {
                onFin.runWith([null]);
                return;
            }
            try {
                text = text.replace(/(\n|^)[ \t]*\/\/.*/g, "");
                var jsonObj = JSON.parse(text);
                if (typeof window != "undefined") {
                    loader.cacheRes(localURL, jsonObj);
                }
            }
            catch (e) {
                trace(localURL + " parse error.");
                jsonObj = null;
            }
            onFin.runWith([jsonObj]);
        }, this), true);
    };
    FileUtils.loadFile = function (localURL, onFin, isJson) {
        if (isJson === void 0) { isJson = false; }
        function onloaded(onFin, txt, localURL) {
            if (!txt) {
                trace(localURL + " not exist2.");
            }
            onFin.runWith([txt]);
        }
        if (typeof window != "undefined") {
            loader.load(localURL, this.Handler.create(this, function (onFin, localURL, txt) {
                onloaded(onFin, txt, localURL);
            }, [onFin, localURL]), null, Loader.TEXT, 0, isJson ? false : true);
        }
        else {
            var txt = this.readFile(this.nativePath + localURL);
            if (txt == "[no exist]")
                txt = null;
            onloaded(onFin, txt, localURL);
        }
    };
    FileUtils.save = function (dataObject, localURL, onFin, format) {
        if (format === void 0) { format = true; }
        var dataString = format ? JSON.stringify(dataObject, null, 4) : JSON.stringify(dataObject);
        new FileObject(localURL, function (fo) {
            fo[fo.exists ? "saveFile" : "createFile"](dataString, function () {
                onFin && onFin.runWith([true, fo.path]);
            }, function () {
                onFin && onFin.runWith([false, fo.path]);
            }, this);
        }, this, function () {
            onFin && onFin.runWith([false, localURL]);
        });
    };
    return FileUtils;
}());
var Common = (function () {
    function Common() {
    }
    Object.defineProperty(Common, "newestDBData", {
        get: function () {
            if (Config.EDIT_MODE) {
                return Editor.data.dbData ? Editor.data.dbData : Game.data;
            }
            else if (Config.IS_SERVER) {
                return ServerWorld.gameData;
            }
            else {
                return Game.data;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Common, "gameData", {
        get: function () {
            if (Config.IS_SERVER) {
                return ServerWorld.gameData;
            }
            else {
                return Game.data;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Common, "variableNameList", {
        get: function () {
            return this.getGameDataAttrValue(GameData.LIST_TYPE_VARIABLE);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Common, "switchNameList", {
        get: function () {
            return this.getGameDataAttrValue(GameData.LIST_TYPE_SWITCH);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Common, "stringNameList", {
        get: function () {
            return this.getGameDataAttrValue(GameData.LIST_TYPE_STRING);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Common, "playerVariableNameList", {
        get: function () {
            return this.getGameDataAttrValue(GameData.LIST_TYPE_PLAYER_VARIABLE);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Common, "playerSwitchNameList", {
        get: function () {
            return this.getGameDataAttrValue(GameData.LIST_TYPE_PLAYER_SWITCH);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Common, "playerStringNameList", {
        get: function () {
            return this.getGameDataAttrValue(GameData.LIST_TYPE_PLAYER_STRING);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Common, "sceneList", {
        get: function () {
            return this.getGameDataAttrValue(GameData.LIST_TYPE_SCENE);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Common, "sceneObjectModelList", {
        get: function () {
            return this.getGameDataAttrValue(GameData.LIST_TYPE_SCENE_OBJECT_MODEL);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Common, "tileList", {
        get: function () {
            return this.getGameDataAttrValue(GameData.LIST_TYPE_TILE);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Common, "avatarActList", {
        get: function () {
            return this.getGameDataAttrValue(GameData.LIST_TYPE_AVATAR_ACT);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Common, "avatarRefObjList", {
        get: function () {
            return this.getGameDataAttrValue(GameData.LIST_TYPE_AVATAR_REF_OBJ);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Common, "animationSignalList", {
        get: function () {
            return this.getGameDataAttrValue(GameData.LIST_TYPE_ANIMATION_SIGNAL);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Common, "dataStructureList", {
        get: function () {
            if (Config.EDIT_MODE) {
                return EUIWindowDataStructureConfig.dataStructureClone ? EUIWindowDataStructureConfig.dataStructureClone : Game.data.dataStructureList;
            }
            else if (Config.IS_SERVER) {
                return ServerWorld.gameData.dataStructureList;
            }
            else {
                return Game.data.dataStructureList;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Common, "customModuleList", {
        get: function () {
            if (Config.EDIT_MODE) {
                return EUIWindowDataStructureConfig.customModuleClone ? EUIWindowDataStructureConfig.customModuleClone : Game.data.customModuleList;
            }
            else if (Config.IS_SERVER) {
                return ServerWorld.gameData.customModuleList;
            }
            else {
                return Game.data.customModuleList;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Common, "customModuleDataList", {
        get: function () {
            return this.getNewestDBData(GameData.LIST_TYPE_CUSTOM_MODULE_DATA);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Common, "customSceneModelList", {
        get: function () {
            return null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Common, "customGameAttribute", {
        get: function () {
            if (Config.EDIT_MODE) {
                return Editor.data.dbData ? Editor.data.dbData.customGameAttribute : Game.data.customGameAttribute;
            }
            else if (Config.IS_SERVER) {
                return ServerWorld.gameData.customGameAttribute;
            }
            else {
                return Game.data.customGameAttribute;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Common, "avatarList", {
        get: function () {
            return this.getNewestDBData(GameData.LIST_TYPE_AVATAR);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Common, "commonEventList", {
        get: function () {
            return this.getNewestDBData(GameData.LIST_TYPE_COMMON_EVENT);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Common, "dialogList", {
        get: function () {
            return this.getNewestDBData(GameData.LIST_TYPE_DIALOG);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Common, "animationList", {
        get: function () {
            return this.getNewestDBData(GameData.LIST_TYPE_ANIMATION);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Common, "uiList", {
        get: function () {
            return this.getNewestDBData(GameData.LIST_TYPE_UI);
        },
        enumerable: true,
        configurable: true
    });
    Common.getGameDataAttrValue = function (attr) {
        if (Config.IS_SERVER) {
            return ServerWorld.gameData[attr];
        }
        else {
            return Game.data[attr];
        }
    };
    Common.getNewestDBData = function (attr) {
        if (Config.EDIT_MODE) {
            return Editor.data && Editor.data.dbData ? Editor.data.dbData[attr] : Game.data[attr];
        }
        else if (Config.IS_SERVER) {
            return ServerWorld.gameData[attr];
        }
        else {
            return Game.data[attr];
        }
    };
    return Common;
}());
var Const = (function () {
    function Const() {
    }
    Const.COMMAND_TRIGGER_TYPE_CONTINUE = 0;
    Const.COMMAND_TRIGGER_TYPE_SCENE_OBJECT_CLICK = 1;
    Const.COMMAND_TRIGGER_TYPE_SCENE_OBJECT_COLLIED = 2;
    Const.COMMAND_TRIGGER_TYPE_SCENE_OBJECT_UPDATE = 3;
    Const.COMMAND_TRIGGER_TYPE_IN_SCENE = 4;
    Const.COMMAND_TRIGGER_TYPE_UI_CLICK = 5;
    Const.COMMAND_TRIGGER_TYPE_CALL_COMMON_COMMAND = 6;
    return Const;
}());
var Player = (function () {
    function Player(dataCls) {
        if (dataCls === void 0) { dataCls = null; }
        if (dataCls)
            this.data = new dataCls();
        else {
            this.data = {};
        }
        ;
        if (Config.IS_SERVER) {
            this.variable = new Variable(this);
        }
    }
    return Player;
}());
var SceneObject = (function () {
    function SceneObject() {
        this.modelID = 1;
        this.index = 0;
        this.name = "";
        this.x = 0;
        this.y = 0;
        this.z = 0;
        this.avatarID = 1;
        this.avatarOri = 2;
        this.avatarAct = 1;
        this.avatarPlayInterval = 5;
        this.avatarFrame = 0;
        this.avatarAlpha = 1;
        this.avatarHue = 0;
        this.shadowEnable = false;
        this.shadowWidth = 30;
        this.shadowHeight = 15;
        this.shadowAlpha = 0.5;
        this.displayList = {};
        this.selectEnabled = true;
        this.fixedOrientation = false;
        this.onTop = 1;
        this.through = false;
        this.bridge = false;
        this.autoPlayEnable = true;
        this.scale = 1;
        this.speed = 200;
        this.touchType = 0;
        this.playerUID = 0;
        this.hasCommand = [];
    }
    SceneObject.EVENT_MOVE_OVER = "SceneObject_EVENT_MOVE_OVER";
    SceneObject.EVENT_JUMP_OVER = "SceneObject_EVENT_JUMP_OVER";
    SceneObject.compoundAttributes = ["displayList"];
    return SceneObject;
}());





var AvatarRefObjData = (function (_super) {
    __extends(AvatarRefObjData, _super);
    function AvatarRefObjData() {
        _super.apply(this, arguments);
        this.color = "#FFFFFF";
        this.line = false;
    }
    return AvatarRefObjData;
}(OriginalData));





var CustomData = (function (_super) {
    __extends(CustomData, _super);
    function CustomData() {
        _super.apply(this, arguments);
        this.attrs = {};
    }
    return CustomData;
}(OriginalData));





var MapData = (function (_super) {
    __extends(MapData, _super);
    function MapData() {
        _super.apply(this, arguments);
        this.serverInstanceClassName = MapData.SERVER_SCENE_CORE_CLASS;
        this.clientInstanceClassName = MapData.CLIENT_SCENE_CORE_CLASS;
    }
    MapData.SERVER_SCENE_CORE_CLASS = "GameServerScene";
    MapData.CLIENT_SCENE_CORE_CLASS = "GameClientScene";
    return MapData;
}(Scene));
var SceneObjectData = (function () {
    function SceneObjectData() {
        this.sceneObjects = [];
        this.customCommands = [];
        this.behaviors = [];
        this.customAttributes = [];
        this.events = [];
    }
    SceneObjectData.clone = function (so, sceneSoData) {
        var newData = {
            so: new SceneObject(),
            behavior: null,
            event: null,
            customAttribute: null
        };
        for (var i in newData.so) {
            newData.so[i] = so[i];
        }
        for (var i in SceneObject.compoundAttributes) {
            var attrName = SceneObject.compoundAttributes[i];
            newData.so[attrName] = ObjectUtils.depthClone(so[attrName]);
        }
        newData.event = ObjectUtils.depthClone(sceneSoData.events[so.index]);
        newData.behavior = ObjectUtils.depthClone(sceneSoData.behaviors[so.index]);
        newData.customAttribute = ObjectUtils.depthClone(sceneSoData.customAttributes[so.index]);
        return newData;
    };
    SceneObjectData.init = function (sceneObjectData, index) {
        sceneObjectData.behaviors[index] = [-1, 0, []];
        sceneObjectData.events[index] = {
            condition: [],
            customCommands: []
        };
        sceneObjectData.customAttributes[index] = {};
    };
    return SceneObjectData;
}());





var UICommandData = (function (_super) {
    __extends(UICommandData, _super);
    function UICommandData() {
        _super.apply(this, arguments);
        this.condition = [];
        this.click = [];
    }
    return UICommandData;
}(OriginalData));
var UIListItemData = (function () {
    function UIListItemData() {
        this._children = [];
        this._isOpen = true;
    }
    UIListItemData.prototype.getSaveData = function (includeData) {
        if (includeData === void 0) { includeData = false; }
        var dData = {};
        for (var i in this.uiNames) {
            dData[i] = this[i];
        }
        if (includeData)
            dData.data = this.data;
        var len = this._children.length;
        if (len > 0) {
            dData.children = [];
            for (var s = 0; s < this._children.length; s++) {
                var item = this._children[s];
                dData.children.push(item.getSaveData(includeData));
            }
        }
        dData.isOpen = this.isOpen;
        return dData;
    };
    UIListItemData.recoverySaveData = function (saveData) {
        var d = new UIListItemData();
        for (var i in saveData) {
            if (i == "children")
                continue;
            d[i] = saveData[i];
        }
        for (var i in saveData.children) {
            var saveDataChild = saveData.children[i];
            var dChild = UIListItemData.recoverySaveData(saveDataChild);
            d.addChild(dChild);
        }
        return d;
    };
    Object.defineProperty(UIListItemData.prototype, "isOpen", {
        get: function () { return this._isOpen; },
        set: function (v) {
            if (v != this._isOpen) {
                this._isOpen = v;
                EventUtils.happen(this, UIListItemData.EVENT_OPEN_CHANGE);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(UIListItemData.prototype, "uiNames", {
        get: function () {
            var _uiNames = [];
            var _attrs = [];
            for (var s in UIListItemData.uiListItemDataHelper) {
                _attrs.push(s);
            }
            for (var i in this) {
                if (_attrs.indexOf(i) != -1)
                    continue;
                _uiNames.push(i);
            }
            return _uiNames;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(UIListItemData.prototype, "parent", {
        get: function () { return this._parent; },
        enumerable: true,
        configurable: true
    });
    UIListItemData.prototype.addChild = function (item) { this._children.push(item); item._parent = this; };
    UIListItemData.prototype.addChildAt = function (item, index) { this._children.splice(index, 0, item); item._parent = this; };
    UIListItemData.prototype.removeChild = function (item) { this._children.splice(this._children.indexOf(item), 1); item._parent = null; };
    UIListItemData.prototype.removeChildAt = function (index) { var item = this._children.splice(index, 1)[0]; item._parent = null; };
    UIListItemData.prototype.removeAll = function () { for (var i in this._children) {
        this._children[i]._parent = null;
    } ; this._children.length = 0; };
    UIListItemData.prototype.getChildAt = function (index) { return this._children[index]; };
    UIListItemData.prototype.getChildIndex = function (item) { return this._children.indexOf(item); };
    Object.defineProperty(UIListItemData.prototype, "numChildren", {
        get: function () { return this._children.length; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(UIListItemData.prototype, "children", {
        get: function () { return this._children; },
        enumerable: true,
        configurable: true
    });
    UIListItemData.prototype.isInherit = function (data) {
        var p = this.parent;
        while (p) {
            if (p == data)
                return true;
            p = p._parent;
        }
        return false;
    };
    UIListItemData.prototype.getList = function (arr) {
        if (arr === void 0) { arr = null; }
        return ArrayUtils.getTreeNodeArray(this, "_children", arr);
    };
    Object.defineProperty(UIListItemData.prototype, "root", {
        get: function () {
            var p = this;
            while (true) {
                if (p._parent) {
                    p = p._parent;
                }
                else {
                    break;
                }
            }
            return p;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(UIListItemData.prototype, "depth", {
        get: function () {
            var p = this;
            var d = 0;
            while (1) {
                if (!p.parent)
                    break;
                d++;
                p = p.parent;
            }
            return d;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(UIListItemData.prototype, "isHideNode", {
        get: function () {
            var p = this.parent;
            while (1) {
                if (!p)
                    break;
                if (!p.isOpen)
                    return true;
                p = p.parent;
            }
            return false;
        },
        enumerable: true,
        configurable: true
    });
    UIListItemData.EVENT_SELECT_CHANGE = "UIListItemDataEVENT_SELECT_CHANGE";
    UIListItemData.EVENT_OPEN_CHANGE = "UIListItemDataEVENT_OPEN_CHANGE";
    UIListItemData.uiListItemDataHelper = new UIListItemData();
    return UIListItemData;
}());
var GameUtils = (function () {
    function GameUtils() {
    }
    GameUtils.getOriByIndex = function (index, oriMode) {
        if (oriMode === void 0) { oriMode = 8; }
        var oriMapping;
        switch (oriMode) {
            case 1:
                oriMapping = { 0: 4 };
                break;
            case 2:
                oriMapping = { 0: 4, 1: 6 };
                break;
            case 3:
                oriMapping = { 0: 4, 1: 2, 2: 8 };
                break;
            case 4:
                oriMapping = { 0: 2, 1: 4, 2: 6, 3: 8 };
                break;
            case 5:
                oriMapping = { 0: 2, 1: 1, 2: 4, 3: 7, 4: 8 };
                break;
            case 8:
                oriMapping = { 0: 4, 1: 7, 2: 8, 3: 9, 4: 6, 5: 3, 6: 2, 7: 1 };
                break;
        }
        return oriMapping[index];
    };
    GameUtils.getIndexByOri = function (ori, oriMode) {
        if (oriMode === void 0) { oriMode = 8; }
        var oriMapping;
        switch (oriMode) {
            case 1:
                oriMapping = { 1: 0, 2: 0, 3: 0, 4: 0, 6: 0, 7: 0, 8: 0, 9: 0 };
                break;
            case 2:
                oriMapping = { 1: 0, 2: 1, 3: 1, 4: 0, 6: 1, 7: 0, 8: 1, 9: 1 };
                break;
            case 3:
                oriMapping = { 1: 4, 2: 1, 3: 4, 4: 0, 6: 0, 7: 0, 8: 2, 9: 0 };
                break;
            case 4:
                oriMapping = { 1: 1, 2: 0, 3: 2, 4: 1, 6: 2, 7: 1, 8: 3, 9: 2 };
                break;
            case 5:
                oriMapping = { 1: 1, 2: 0, 3: 1, 4: 2, 6: 2, 7: 3, 8: 4, 9: 3 };
                break;
            case 8:
                oriMapping = { 1: 7, 2: 6, 3: 5, 4: 0, 6: 4, 7: 1, 8: 2, 9: 3 };
                break;
        }
        return oriMapping[ori];
    };
    GameUtils.getAssetOri = function (ori, oriMode) {
        if (oriMode === void 0) { oriMode = 8; }
        var oriMapping;
        switch (oriMode) {
            case 1:
                oriMapping = { 1: 4, 2: 4, 3: 4, 4: 4, 6: 4, 7: 4, 8: 4, 9: 4 };
                break;
            case 2:
                oriMapping = { 1: 4, 2: 6, 3: 6, 4: 4, 6: 6, 7: 4, 8: 6, 9: 6 };
                break;
            case 3:
                oriMapping = { 1: 4, 2: 2, 3: 4, 4: 4, 6: 4, 7: 4, 8: 8, 9: 4 };
                break;
            case 4:
                oriMapping = { 1: 4, 2: 2, 3: 6, 4: 4, 6: 6, 7: 4, 8: 8, 9: 6 };
                break;
            case 5:
                oriMapping = { 1: 1, 2: 2, 3: 1, 4: 4, 6: 4, 7: 7, 8: 8, 9: 7 };
                break;
            case 8:
                oriMapping = { 1: 1, 2: 2, 3: 3, 4: 4, 6: 6, 7: 7, 8: 8, 9: 9 };
                break;
        }
        return oriMapping[ori];
    };
    GameUtils.getOriByAngle = function (angle) {
        if (angle >= 337.5 || angle < 22.5) {
            return 8;
        }
        else if (angle >= 22.5 && angle < 67.5) {
            return 9;
        }
        else if (angle >= 67.5 && angle < 112.5) {
            return 6;
        }
        else if (angle >= 112.5 && angle < 157.5) {
            return 3;
        }
        else if (angle >= 157.5 && angle < 202.5) {
            return 2;
        }
        else if (angle >= 202.5 && angle < 247.5) {
            return 1;
        }
        else if (angle >= 247.5 && angle < 292.5) {
            return 4;
        }
        else if (angle >= 292.5 && angle < 337.5) {
            return 7;
        }
        return 2;
    };
    GameUtils.getAngleByOri = function (ori) {
        switch (ori) {
            case 1:
                return 225;
            case 2:
                return 180;
            case 3:
                return 145;
            case 4:
                return 270;
            case 6:
                return 90;
            case 7:
                return 315;
            case 8:
                return 0;
            case 9:
                return 45;
        }
    };
    GameUtils.getFlipOri = function (ori) {
        var mapping = { 1: 9, 2: 8, 3: 7, 4: 6, 6: 4, 7: 3, 8: 2, 9: 1 };
        return mapping[ori];
    };
    GameUtils.getGridPostion = function (p, helpP) {
        if (helpP === void 0) { helpP = null; }
        var rp = helpP;
        var s = Config.SCENE_GRID_SIZE;
        if (rp) {
            rp.x = Math.floor(p.x / s);
            rp.y = Math.floor(p.y / s);
        }
        else {
            rp = new Point(Math.floor(p.x / s), Math.floor(p.y / s));
        }
        return rp;
    };
    GameUtils.getGridCenter = function (p, helpP) {
        if (helpP === void 0) { helpP = null; }
        var rp = helpP;
        var s = Config.SCENE_GRID_SIZE;
        var h = Math.floor(Config.SCENE_GRID_SIZE / 2);
        if (rp) {
            rp.x = Math.floor(p.x / s) * s + h;
            rp.y = Math.floor(p.y / s) * s + h;
        }
        else {
            rp = new Point(Math.floor(p.x / s) * s + h, Math.floor(p.y / s) * s + h);
        }
        return rp;
    };
    GameUtils.twoPointHasObstacle = function (x_x1, x_y1, x_x2, x_y2, scene, except) {
        if (except === void 0) { except = null; }
        var actor_p1 = new Point(x_x1, x_y1);
        var actor_p2 = new Point(x_x2, x_y2);
        var n_jieduan = 16;
        var n_s_p1p2 = Point.distance(actor_p1, actor_p2);
        var n_s_xiang = [];
        var len = Math.floor(n_s_p1p2 / n_jieduan);
        for (var i = 1; i <= len; i++) {
            var n_new_x = (actor_p2.x - actor_p1.x) / (n_s_p1p2 / n_jieduan) * i + actor_p1.x;
            var n_new_y = (actor_p2.y - actor_p1.y) / (n_s_p1p2 / n_jieduan) * i + actor_p1.y;
            n_s_xiang.push(new Point(n_new_x, n_new_y));
        }
        n_s_xiang.push(new Point(x_x2, x_y2));
        for (var s in n_s_xiang) {
            if (scene.isObstacle(n_s_xiang[s], except)) {
                return true;
            }
        }
        return false;
    };
    GameUtils.getSameStateGrid = function (mapData, gridX, gridY, width, height, attributes, limit) {
        if (limit === void 0) { limit = 100; }
        var limit = 100;
        var limitRect = new Rectangle(Math.max(gridX - limit, 0), Math.max(gridY - limit, 0), Math.min(width, gridX + limit), Math.min(height, gridY + limit));
        var points = [];
        var firstGrid = mapData[gridX] ? mapData[gridX][gridY] : null;
        var gridHelpArr = [];
        for (var x = 0; x < width; x++) {
            gridHelpArr[x] = [];
        }
        var dir = [null, null, [8, 0, 1], null, [6, -1, 0], null, [4, 1, 0], null, [2, 0, -1]];
        var dirIndexes = [2, 4, 6, 8];
        var needSearchGrid = [];
        needSearchGrid.push({ gridX: gridX, gridY: gridY, from: 0 });
        var from = 0;
        while (1) {
            if (needSearchGrid.length == 0)
                break;
            var currentGridData = needSearchGrid.shift();
            gridX = currentGridData.gridX;
            gridY = currentGridData.gridY;
            if (gridHelpArr[gridX][gridY])
                continue;
            gridHelpArr[gridX][gridY] = true;
            var currentGrid = mapData[gridX] ? mapData[gridX][gridY] : null;
            if (currentGrid == firstGrid) { }
            else if (currentGrid && firstGrid) {
                var isSame;
                if (attributes) {
                    isSame = true;
                    for (var attr in attributes) {
                        var attribute = attributes[attr];
                        if (currentGrid[attribute] != firstGrid[attribute]) {
                            isSame = false;
                            break;
                        }
                    }
                }
                else {
                    isSame = currentGrid === firstGrid;
                }
                if (!isSame)
                    continue;
            }
            else {
                continue;
            }
            points.push(new Point(gridX, gridY));
            for (var d = 0; d < 4; d++) {
                var toDir = dirIndexes[d];
                var toDirData = dir[toDir];
                if (toDirData[0] == currentGridData.from)
                    continue;
                var toX = gridX + toDirData[1];
                var toY = gridY + toDirData[2];
                if (toX < limitRect.x || toX >= limitRect.width || toY < limitRect.y || toY >= limitRect.height)
                    continue;
                needSearchGrid.push({ gridX: toX, gridY: toY, from: toDir });
            }
        }
        return points;
    };
    GameUtils.getMendingGrids = function (grid1, grid2, per) {
        if (per === void 0) { per = 0.1; }
        var gridDetermine = [];
        var grids = [];
        for (var i = 0; i <= 1; i += 0.1) {
            var p = Point.interpolate(grid1, grid2, i);
            p.x = Math.floor(p.x);
            p.y = Math.floor(p.y);
            var xArr = gridDetermine[p.x];
            if (!xArr)
                xArr = gridDetermine[p.x] = [];
            if (xArr[p.y])
                continue;
            xArr[p.y] = true;
            if (grid1.x == p.x && grid1.y == p.y)
                continue;
            grids.push(p);
        }
        return grids;
    };
    GameUtils.getAutoFitSizePre = function (rect, canvasRect) {
        var xPer = canvasRect.width / rect.width;
        var yPer = canvasRect.height / rect.height;
        var per = Math.min(xPer, yPer);
        return per;
    };
    GameUtils.isInheritNode = function (node, parentNode) {
        var p = node.parent;
        while (p) {
            if (p == parentNode)
                return true;
            p = p.parent;
        }
        return false;
    };
    GameUtils.getAllChildren = function (node, arr) {
        if (arr === void 0) { arr = null; }
        if (!arr)
            arr = [];
        arr.push(node);
        var len = node.numChildren;
        for (var i = 0; i < len; i++) {
            this.getAllChildren(node.getChildAt(i), arr);
        }
        return arr;
    };
    GameUtils.getVarID = function (value) {
        if (value && value.toString().search(/\$[0-9]*/g) == 0) {
            var id = parseInt(value.toString().substr(1));
            return id;
        }
        return 0;
    };
    GameUtils.getTween = function (tweenID) {
        if (!tweenID)
            return [Ease.linearNone, "linearNone"];
        var arr = ["linearNone", "bounceIn", "bounceInOut", "bounceOut", "backIn",
            "backInOut", "backOut", "elasticIn", "elasticInOut", "elasticOut", "strongIn",
            "strongInOut", "strongOut", "sineIn", "sineInOut", "sineOut", "quintIn",
            "quintInOut", "quintOut", "quartIn", "quartInOut", "quartOut", "cubicIn",
            "cubicInOut", "cubicOut", "quadIn", "quadInOut", "quadOut", "expoIn", "expoInOut",
            "expoOut", "circIn", "circInOut", "circOut"];
        return [Ease[arr[tweenID]], arr[tweenID]];
    };
    GameUtils.getTweenLabels = function () {
        var tweenLabel = "无";
        for (var i = 1; i < GameUtils.tweenCount; i++) {
            var tweenData = GameUtils.getTween(i);
            tweenLabel += "," + tweenData[1];
        }
        return tweenLabel;
    };
    GameUtils.isLegalVarName = function (varName, headFont) {
        if (headFont === void 0) { headFont = true; }
        var reg = /([\$_a-zA-Z]|[\u4e00-\u9fa50-9a-zA-Z_$]){1,255}/g;
        var m = varName.match(reg);
        if (headFont && !isNaN(parseInt(varName[0])))
            return false;
        return m != null && m[0] == varName;
    };
    GameUtils.tweenCount = 34;
    return GameUtils;
}());
var IdentityObject = (function () {
    function IdentityObject() {
        this.id = ++IdentityObject.idCount;
    }
    IdentityObject.idCount = 0;
    return IdentityObject;
}());





var AnimationData = (function (_super) {
    __extends(AnimationData, _super);
    function AnimationData() {
        _super.apply(this, arguments);
        this.loop = false;
        this.showHitEffect = false;
        this.fps = 20;
        this.totalFrame = 0;
        this.imageSources = [null];
        this.layers = [];
        this.isParticle = false;
    }
    AnimationData.getAllLayers = function (data) {
        var layers = data.layers.concat();
        var index = 0;
        while (index < layers.length) {
            layers = layers.concat(layers[index].children);
            index++;
        }
        return layers;
    };
    return AnimationData;
}(OriginalData));
var AnimationItemType;
(function (AnimationItemType) {
    AnimationItemType[AnimationItemType["Target"] = 0] = "Target";
    AnimationItemType[AnimationItemType["Image"] = 1] = "Image";
    AnimationItemType[AnimationItemType["Animation"] = 2] = "Animation";
    AnimationItemType[AnimationItemType["Audio"] = 3] = "Audio";
})(AnimationItemType || (AnimationItemType = {}));
var CustomGameAttribute = (function () {
    function CustomGameAttribute() {
    }
    CustomGameAttribute.getAPIRuntime = function (gameAttr) {
    };
    return CustomGameAttribute;
}());





var ScriptData = (function (_super) {
    __extends(ScriptData, _super);
    function ScriptData() {
        _super.apply(this, arguments);
    }
    ScriptData.getAllGameScriptSourceInEditor = function (mode) {
        var arr = [Game.data.commonScript, Game.data.serverScript, Game.data.clientScript];
        var scriptData = arr[mode];
        var codes = "";
        for (var i in scriptData.src) {
            var classCode = scriptData.src[i];
            if (classCode) {
                codes += classCode + "\n";
            }
        }
        return codes;
    };
    return ScriptData;
}(OriginalData));
var AstarUtils = (function () {
    function AstarUtils() {
        this.openList = new Array();
        this.closeList = new Array();
        this.roadArr = new Array();
    }
    AstarUtils.moveTo = function (x_x1, x_y1, x_x2, x_y2, gridW, gridH, scene) {
        var GRID_SIZE = Config.SCENE_GRID_SIZE;
        var GRID_SIZE_HALF = Math.floor(Config.SCENE_GRID_SIZE / 2) - 1;
        var x_mapw = gridW;
        var x_maph = gridH;
        var n_fanwei_W = Math.floor(Config.WINDOW_WIDTH / GRID_SIZE) + 1;
        var n_fanwei_H = Math.floor(Config.WINDOW_HEIGHT / GRID_SIZE) + 1;
        var n_f_x1 = Math.floor(x_x1 / GRID_SIZE) - n_fanwei_W;
        var n_f_y1 = Math.floor(x_y1 / GRID_SIZE) - n_fanwei_H;
        var n_f_x2 = Math.floor(x_x1 / GRID_SIZE) + n_fanwei_W;
        var n_f_y2 = Math.floor(x_y1 / GRID_SIZE) + n_fanwei_H;
        if (Math.abs(x_x2 - x_x1) > n_fanwei_W * GRID_SIZE || Math.abs(x_y2 - x_y1) > n_fanwei_H * GRID_SIZE) {
            return null;
        }
        var mapmapmap = [];
        var this_kuai;
        n_f_x1 = n_f_x1 < 0 ? 0 : n_f_x1;
        n_f_y1 = n_f_y1 < 0 ? 0 : n_f_y1;
        n_f_x2 = n_f_x2 > x_mapw ? x_mapw : n_f_x2;
        n_f_y2 = n_f_y2 > x_maph ? x_maph : n_f_y2;
        var n_pianyi_X = n_f_x1 - 0;
        var n_pianyi_Y = n_f_y1 - 0;
        var yLen = (n_f_y2 - n_f_y1);
        var xLen = (n_f_x2 - n_f_x1);
        for (var y = 0; y < yLen; y++) {
            mapmapmap[y] = [];
            for (var x = 0; x < xLen; x++) {
                this_kuai = new AstarBox();
                mapmapmap[y].push(this_kuai);
                mapmapmap[y][x].px = x;
                mapmapmap[y][x].py = y;
                mapmapmap[y][x].go = 0;
            }
        }
        var n_obx, n_oby, i;
        var helpP = new Point();
        for (var _x = n_f_x1; _x < n_f_x2; _x++) {
            for (var _y = n_f_y1; _y < n_f_y2; _y++) {
                helpP.x = _x;
                helpP.y = _y;
                if (scene.isObstacleGrid(helpP)) {
                    mapmapmap[_y - n_pianyi_Y][_x - n_pianyi_X].go = 1;
                }
            }
        }
        var actor_go = mapmapmap[Math.floor(x_y1 / GRID_SIZE) - n_pianyi_Y][Math.floor(x_x1 / GRID_SIZE) - n_pianyi_X];
        var actor_to = mapmapmap[Math.floor(x_y2 / GRID_SIZE) - n_pianyi_Y][Math.floor(x_x2 / GRID_SIZE) - n_pianyi_X];
        var _ARoad = new AstarUtils();
        var roadList = _ARoad.searchRoad(actor_go, actor_to, mapmapmap);
        if (roadList.length < 1) {
            return null;
        }
        var roadLines = [];
        for (i = roadList.length - 1; i > 0; i--) {
            var n_px_real = roadList[i].px + n_pianyi_X;
            var n_py_real = roadList[i].py + n_pianyi_Y;
            roadLines.push([n_px_real * GRID_SIZE + GRID_SIZE_HALF, n_py_real * GRID_SIZE + GRID_SIZE_HALF]);
        }
        roadLines.push([x_x2, x_y2]);
        return roadLines;
    };
    AstarUtils.def_bigMoveTo = function (gridW, gridH, obsArr) {
        var n_f_x1 = 0;
        var n_f_y1 = 0;
        var n_f_x2 = gridW;
        var n_f_y2 = gridH;
        var mapmapmap = [];
        var this_kuai;
        var n_pianyi_X = n_f_x1 - 0;
        var n_pianyi_Y = n_f_y1 - 0;
        var yLen = (n_f_y2 - n_f_y1);
        var xLen = (n_f_x2 - n_f_x1);
        for (var y = 0; y <= yLen; y++) {
            mapmapmap[y] = [];
            for (var x = 0; x <= xLen; x++) {
                this_kuai = new AstarBox();
                mapmapmap[y].push(this_kuai);
                mapmapmap[y][x].px = x;
                mapmapmap[y][x].py = y;
                mapmapmap[y][x].go = 0;
            }
        }
        var n_obx, n_oby, i;
        for (var _x = n_f_x1; _x < n_f_x2; _x++) {
            for (var _y = n_f_y1; _y < n_f_y2; _y++) {
                if (obsArr[_x][_y]) {
                    mapmapmap[_y - n_pianyi_Y][_x - n_pianyi_X].go = 1;
                }
            }
        }
        this.big_mapmapmap = mapmapmap;
    };
    AstarUtils.bigMoveTo = function (x_x1, x_y1, x_x2, x_y2) {
        var GRID_SIZE = Config.SCENE_GRID_SIZE;
        var GRID_SIZE_HALF = Math.floor(Config.SCENE_GRID_SIZE / 2) - 1;
        var mapmapmap = this.big_mapmapmap;
        var actor_go = mapmapmap[Math.floor(x_y1 / GRID_SIZE)][Math.floor(x_x1 / GRID_SIZE)];
        var actor_to = mapmapmap[Math.floor(x_y2 / GRID_SIZE)][Math.floor(x_x2 / GRID_SIZE)];
        var _ARoad = new AstarUtils();
        var roadList = _ARoad.searchRoad(actor_go, actor_to, mapmapmap);
        if (roadList.length < 1) {
            return null;
        }
        var roadLines = [];
        for (var i = roadList.length - 1; i > 0; i--) {
            var n_px_real = roadList[i].px;
            var n_py_real = roadList[i].py;
            roadLines.push([n_px_real * GRID_SIZE + GRID_SIZE_HALF, n_py_real * GRID_SIZE + GRID_SIZE_HALF]);
        }
        roadLines.push([x_x2, x_y2]);
        return roadLines;
    };
    AstarUtils.prototype.searchRoad = function (start, end, map) {
        this.startPoint = start;
        this.endPoint = end;
        this.mapArr = map;
        this.w = this.mapArr[0].length - 1;
        this.h = this.mapArr.length - 1;
        this.openList.push(this.startPoint);
        var ix = 0;
        while (true) {
            ix++;
            if (this.openList.length < 1 || ix >= AstarUtils.ROAD_FIND_MAX) {
                return this.roadArr;
            }
            var thisPoint = this.openList.splice(this.getMinF(), 1)[0];
            if (thisPoint == this.endPoint) {
                while (thisPoint.father != this.startPoint.father) {
                    this.roadArr.push(thisPoint);
                    thisPoint = thisPoint.father;
                }
                return this.roadArr;
            }
            this.closeList.push(thisPoint);
            this.addAroundPoint(thisPoint);
        }
    };
    AstarUtils.prototype.addAroundPoint = function (thisPoint) {
        var thisPx = thisPoint.px;
        var thisPy = thisPoint.py;
        if (thisPx > 0 && this.mapArr[thisPy][thisPx - 1].go == 0) {
            if (!this.inArr(this.mapArr[thisPy][thisPx - 1], this.closeList)) {
                if (!this.inArr(this.mapArr[thisPy][thisPx - 1], this.openList)) {
                    this.setGHF(this.mapArr[thisPy][thisPx - 1], thisPoint, 10);
                    this.openList.push(this.mapArr[thisPy][thisPx - 1]);
                }
                else {
                    this.checkG(this.mapArr[thisPy][thisPx - 1], thisPoint);
                }
            }
            if (!Config.MOVE_4_ORI && thisPy > 0 && this.mapArr[thisPy - 1][thisPx - 1].go == 0 && this.mapArr[thisPy - 1][thisPx].go == 0) {
                if (!this.inArr(this.mapArr[thisPy - 1][thisPx - 1], this.closeList) && !this.inArr(this.mapArr[thisPy - 1][thisPx - 1], this.openList)) {
                    this.setGHF(this.mapArr[thisPy - 1][thisPx - 1], thisPoint, 14);
                    this.openList.push(this.mapArr[thisPy - 1][thisPx - 1]);
                }
            }
            if (!Config.MOVE_4_ORI && thisPy < this.h && this.mapArr[thisPy + 1][thisPx - 1].go == 0 && this.mapArr[thisPy + 1][thisPx].go == 0) {
                if (!this.inArr(this.mapArr[thisPy + 1][thisPx - 1], this.closeList) && !this.inArr(this.mapArr[thisPy + 1][thisPx - 1], this.openList)) {
                    this.setGHF(this.mapArr[thisPy + 1][thisPx - 1], thisPoint, 14);
                    this.openList.push(this.mapArr[thisPy + 1][thisPx - 1]);
                }
            }
        }
        if (thisPx < this.w && this.mapArr[thisPy][thisPx + 1].go == 0) {
            if (!this.inArr(this.mapArr[thisPy][thisPx + 1], this.closeList)) {
                if (!this.inArr(this.mapArr[thisPy][thisPx + 1], this.openList)) {
                    this.setGHF(this.mapArr[thisPy][thisPx + 1], thisPoint, 10);
                    this.openList.push(this.mapArr[thisPy][thisPx + 1]);
                }
                else {
                    this.checkG(this.mapArr[thisPy][thisPx + 1], thisPoint);
                }
            }
            if (!Config.MOVE_4_ORI && thisPy > 0 && this.mapArr[thisPy - 1][thisPx + 1].go == 0 && this.mapArr[thisPy - 1][thisPx].go == 0) {
                if (!this.inArr(this.mapArr[thisPy - 1][thisPx + 1], this.closeList) && !this.inArr(this.mapArr[thisPy - 1][thisPx + 1], this.openList)) {
                    this.setGHF(this.mapArr[thisPy - 1][thisPx + 1], thisPoint, 14);
                    this.openList.push(this.mapArr[thisPy - 1][thisPx + 1]);
                }
            }
            if (!Config.MOVE_4_ORI && thisPy < this.h && this.mapArr[thisPy + 1][thisPx + 1].go == 0 && this.mapArr[thisPy + 1][thisPx].go == 0) {
                if (!this.inArr(this.mapArr[thisPy + 1][thisPx + 1], this.closeList) && !this.inArr(this.mapArr[thisPy + 1][thisPx + 1], this.openList)) {
                    this.setGHF(this.mapArr[thisPy + 1][thisPx + 1], thisPoint, 14);
                    this.openList.push(this.mapArr[thisPy + 1][thisPx + 1]);
                }
            }
        }
        if (thisPy > 0 && this.mapArr[thisPy - 1][thisPx].go == 0) {
            if (!this.inArr(this.mapArr[thisPy - 1][thisPx], this.closeList)) {
                if (!this.inArr(this.mapArr[thisPy - 1][thisPx], this.openList)) {
                    this.setGHF(this.mapArr[thisPy - 1][thisPx], thisPoint, 10);
                    this.openList.push(this.mapArr[thisPy - 1][thisPx]);
                }
                else {
                    this.checkG(this.mapArr[thisPy - 1][thisPx], thisPoint);
                }
            }
        }
        if (thisPy < this.h && this.mapArr[thisPy + 1][thisPx].go == 0) {
            if (!this.inArr(this.mapArr[thisPy + 1][thisPx], this.closeList)) {
                if (!this.inArr(this.mapArr[thisPy + 1][thisPx], this.openList)) {
                    this.setGHF(this.mapArr[thisPy + 1][thisPx], thisPoint, 10);
                    this.openList.push(this.mapArr[thisPy + 1][thisPx]);
                }
                else {
                    this.checkG(this.mapArr[thisPy + 1][thisPx], thisPoint);
                }
            }
        }
    };
    AstarUtils.prototype.inArr = function (obj, arr) {
        for (var m in arr) {
            var mc = arr[m];
            if (obj == mc) {
                return true;
            }
        }
        return false;
    };
    AstarUtils.prototype.setGHF = function (point, thisPoint, G) {
        if (!thisPoint.G) {
            thisPoint.G = 0;
        }
        point.G = thisPoint.G + G;
        point.H = (Math.abs(point.px - this.endPoint.px) + Math.abs(point.py - this.endPoint.py)) * 10;
        point.F = point.H + point.G;
        point.father = thisPoint;
    };
    AstarUtils.prototype.checkG = function (chkPoint, thisPoint) {
        var newG = thisPoint.G + 10;
        if (newG <= chkPoint.G) {
            chkPoint.G = newG;
            chkPoint.F = chkPoint.H + newG;
            chkPoint.father = thisPoint;
        }
    };
    AstarUtils.prototype.getMinF = function () {
        var tmpF = 100000000;
        var id = 0;
        var rid;
        for (var m in this.openList) {
            var mc = this.openList[m];
            if (mc.F < tmpF) {
                tmpF = mc.F;
                rid = id;
            }
            id++;
        }
        return rid;
    };
    AstarUtils.ROAD_FIND_MAX = 200;
    return AstarUtils;
}());
var AstarBox = (function () {
    function AstarBox() {
    }
    return AstarBox;
}());
var Condition = (function () {
    function Condition() {
    }
    return Condition;
}());





var SceneData = (function (_super) {
    __extends(SceneData, _super);
    function SceneData() {
        _super.apply(this, arguments);
        this.mapData = new MapData();
        this.sceneObjectData = new SceneObjectData();
    }
    return SceneData;
}(OriginalData));





var UIDisplayData = (function (_super) {
    __extends(UIDisplayData, _super);
    function UIDisplayData() {
        _super.apply(this, arguments);
        this.root = {
            children: []
        };
    }
    UIDisplayData.init = function (data, runScriptDomain) {
        if (!data)
            return;
        var baseCode = "var GUI_" + data.id + " = (function (_super) {__extends(GUI_" + data.id + ", _super);function GUI_" + data.id + "(isRoot) {if (isRoot === void 0) { isRoot = true; };_super.apply(this, [isRoot," + data.id + "]);\n        var data = Game.data.uiList.data[" + data.id + "];if(!data)return;GameUI.parse(data.uiDisplayData,false,null," + data.id + ",this);}return GUI_" + data.id + ";}(UIComponent.UIRoot));";
        baseCode += "var ListItem_" + data.id + " = (function (_super) {__extends(ListItem_" + data.id + ", _super);function ListItem_" + data.id + "() {_super.apply(this);}return ListItem_" + data.id + ";}(UIListItemData));";
        try {
            runScriptDomain.eval(baseCode);
        }
        catch (e) {
            alert("Initialization ui-" + data.id + " base code error!");
        }
    };
    UIDisplayData.getAllBaseCode = function (uiList) {
        var runtimeCode = "";
        for (var typeID = 1; typeID <= 16; typeID++) {
            var len = GameListData.getLength(uiList, typeID);
            for (var s = 1; s <= len; s++) {
                var uiData = GameListData.getItem(uiList, typeID, s);
                if (!uiData)
                    continue;
                uiData.uiDisplayData.id = GameListData.getID(typeID, s);
                runtimeCode += UIDisplayData.getBaseCode(uiData.uiDisplayData, uiList) + "\n";
            }
        }
        return runtimeCode;
    };
    UIDisplayData.getBaseCode = function (data, uiList) {
        var varAttributes = "";
        var listItemVarAttributes = "";
        var nameMapping = {};
        var compItemList = ArrayUtils.getTreeNodeArray(data.root, "children");
        compItemList.shift();
        var listItemTypeMapping = {
            UIBitmap: "string",
            UIString: "string",
            UIVariable: "number",
            UIAvatar: "number",
            UIAnimation: "number",
            UIInput: "string",
            UICheckBox: "boolean",
            UISwitch: "number",
            UITabBox: "string",
            UISlider: "number",
            UIGUI: "number",
            UIList: "UIListItemData[]"
        };
        for (var i = 0; i < compItemList.length; i++) {
            var compItem = compItemList[i];
            if (nameMapping[compItem.name])
                continue;
            nameMapping[compItem.name] = true;
            var type = compItem.type;
            if (type == "UIGUI") {
                if (!uiList.data[compItem.guiID])
                    continue;
                if (compItem.instanceClassName) {
                    type = compItem.instanceClassName;
                }
                else {
                    type = "GUI_" + compItem.guiID;
                }
            }
            else {
                type = "" + type;
            }
            varAttributes += "   " + compItem.name + ":" + type + ";";
            var listItemType = listItemTypeMapping[compItem.type];
            if (listItemType) {
                listItemVarAttributes += "   " + compItem.name + ":" + listItemType + ";";
                if (i != compItemList.length - 1)
                    listItemVarAttributes += "\n";
            }
            if (i != compItemList.length - 1)
                varAttributes += "\n";
        }
        var name = GameListData.getName(uiList, data.id);
        var runtimeCode = "\n/**\n * " + data.id + "-" + name + " [BASE]\n */\nclass GUI_" + data.id + " extends UIRoot {\n" + varAttributes + "\n}";
        runtimeCode += "\nclass ListItem_" + data.id + " extends UIListItemData {\n" + listItemVarAttributes + "\n}";
        return runtimeCode;
    };
    return UIDisplayData;
}(OriginalData));
var CustomAttributeSetting = (function () {
    function CustomAttributeSetting() {
    }
    CustomAttributeSetting.init = function (data) {
        data.id = ObjectUtils.getRandID();
        data.varName = "未命名变量";
        data.varType = 0;
        data.compData = { compType: 0, compParam: {} };
        data.defaultValue = "";
        data.hideMode = false;
        data.useCommand = false;
        data.onlyPointTo = false;
        data.moduleID = 1;
        data.dataStructureID = 1;
        data.arrayMode = false;
        data.arrayLength = 100;
        data.arrayAllowDelete = false;
        data.arrayAllowSwap = false;
        data.arrayAllowUpdate = false;
        data.accessMode = 0;
        data.syncMode = 0;
        data.attrTips = "";
        data.preview = false;
    };
    CustomAttributeSetting.getAPIRuntimes = function (varAttrs, jurisdictionRestriction, indent) {
        if (jurisdictionRestriction === void 0) { jurisdictionRestriction = false; }
        if (indent === void 0) { indent = "    "; }
        var code = "";
        for (var i in varAttrs) {
            var attr = varAttrs[i];
            if (jurisdictionRestriction && attr.accessMode == 0)
                continue;
            code += indent + this.getAPIRuntime(attr) + "\n";
        }
        return code;
    };
    CustomAttributeSetting.getAPIRuntime = function (attr, isStatic) {
        if (isStatic === void 0) { isStatic = false; }
        var varTypeStr = "";
        switch (attr.varType) {
            case 0:
                varTypeStr = "number";
                break;
            case 1:
                varTypeStr = "string";
                break;
            case 2:
                varTypeStr = "boolean";
                break;
            case 3:
                varTypeStr = CustomCompositeSetting.getVarTypeInEditorCode(0, attr.dataStructureID);
                break;
            case 4:
                varTypeStr = CustomCompositeSetting.getVarTypeInEditorCode(1, attr.moduleID);
                break;
        }
        if (attr.arrayMode) {
            varTypeStr += "[] = [];";
        }
        else {
            if (attr.varType == 0) {
                varTypeStr += " = " + MathUtils.float(attr.defaultValue) + ";";
            }
            else if (attr.varType == 1) {
                varTypeStr += " = \"" + attr.defaultValue + "\";";
            }
            else if (attr.varType == 2) {
                varTypeStr += " = " + (attr.defaultValue ? "true" : "false") + ";";
            }
            else {
                varTypeStr += ";";
            }
        }
        return "" + (isStatic ? "static " : "") + attr.varName + ": " + varTypeStr;
    };
    CustomAttributeSetting.getTypeName = function (data) {
        var arr = ["数值", "字符串", "布尔值", "{自定义数据结构}", "{自定义模块}"];
        var str = arr[data.varType];
        if (data.varType == 3) {
            var name = GameListData.getName(Common.dataStructureList, data.dataStructureID);
            str = "<" + data.dataStructureID + "-" + name + ">";
        }
        else if (data.varType == 4) {
            var name = GameListData.getName(Common.customModuleList, data.moduleID);
            str = "\u3010" + data.moduleID + "-" + name + "\u3011";
        }
        if (data.arrayMode) {
            str += "[]";
        }
        return str;
    };
    CustomAttributeSetting.getSerializeAttrType = function (data, arrayEnabled) {
        if (arrayEnabled === void 0) { arrayEnabled = true; }
        var serializeAttrType = data.varType;
        if (serializeAttrType == 4 && !data.onlyPointTo)
            serializeAttrType += 1;
        if (data.arrayMode && arrayEnabled)
            serializeAttrType += 6;
        return serializeAttrType;
    };
    CustomAttributeSetting.formatCustomData = function (myCustomAttributes, attrPerSettings) {
        if (!(attrPerSettings instanceof Array)) {
            attrPerSettings = CustomCompositeSetting.getAllAttributes(attrPerSettings, false);
        }
        var newestDataStructureList = Common.dataStructureList;
        var newestCustomModuleList = Common.customModuleList;
        var customModuleDataList = Common.customModuleDataList;
        if (!myCustomAttributes)
            myCustomAttributes = {};
        for (var i in attrPerSettings) {
            var attrPerSetting = attrPerSettings[i];
            var perVarName = attrPerSetting.varName;
            if (myCustomAttributes[perVarName] == null) {
                myCustomAttributes[perVarName] = CustomAttributeSetting.formatCustomDefaultValue(attrPerSetting, true);
            }
        }
        for (var myVarName in myCustomAttributes) {
            var m = ArrayUtils.matchAttributes(attrPerSettings, { varName: myVarName }, true);
            var perAttr = m[0];
            if (!perAttr) {
                delete myCustomAttributes[myVarName];
                continue;
            }
            var myAttr = myCustomAttributes[myVarName];
            if (!myAttr) {
                continue;
            }
            var mySerializeAttrType = myAttr.varType;
            var perSerializeAttrType = CustomAttributeSetting.getSerializeAttrType(perAttr);
            if (perSerializeAttrType != mySerializeAttrType) {
                myCustomAttributes[myVarName] = CustomAttributeSetting.formatCustomDefaultValue(perAttr, true);
            }
            else {
                if (mySerializeAttrType == CustomAttributeSetting.ATTR_TYPE_STRUCTURE || mySerializeAttrType == CustomAttributeSetting.ATTR_TYPE_STRUCTURE_ID_ARRAY) {
                    var dataStructure = newestDataStructureList.data[perAttr.dataStructureID];
                    if (!dataStructure) {
                        delete myCustomAttributes[myVarName];
                        continue;
                    }
                    var _attrPerSettings = CustomCompositeSetting.getAllAttributes(dataStructure, false);
                    var myAttrValue;
                    if (mySerializeAttrType == CustomAttributeSetting.ATTR_TYPE_STRUCTURE_ID_ARRAY) {
                        var valueArr = myAttr.value;
                        for (var i in valueArr) {
                            myAttrValue = valueArr[i];
                            CustomAttributeSetting.formatCustomData(myAttrValue, _attrPerSettings);
                        }
                    }
                    else {
                        myAttrValue = myAttr.value;
                        CustomAttributeSetting.formatCustomData(myAttrValue, _attrPerSettings);
                    }
                }
                else if (mySerializeAttrType == CustomAttributeSetting.ATTR_TYPE_MODULE_CLONE || mySerializeAttrType == CustomAttributeSetting.ATTR_TYPE_MODULE_CLONE_ARRAY) {
                    var customModule = newestCustomModuleList.data[perAttr.moduleID];
                    if (!customModule) {
                        delete myCustomAttributes[myVarName];
                        continue;
                    }
                    var _attrPerSettings = CustomCompositeSetting.getAllAttributes(customModule, false);
                    var myAttrValue;
                    if (mySerializeAttrType == CustomAttributeSetting.ATTR_TYPE_MODULE_CLONE_ARRAY) {
                        var valueDataArr = myAttr.value;
                        for (var i in valueDataArr) {
                            myAttrValue = valueDataArr[i].data;
                            CustomAttributeSetting.formatCustomData(myAttrValue, _attrPerSettings);
                        }
                    }
                    else {
                        myAttrValue = myAttr.value.data;
                        CustomAttributeSetting.formatCustomData(myAttrValue, _attrPerSettings);
                    }
                }
            }
        }
        return myCustomAttributes;
    };
    CustomAttributeSetting.formatCustomDefaultValue = function (varAttrSetting, arrayEnabled) {
        var newestDataStructureList = Common.dataStructureList;
        var newestCustomModuleList = Common.customModuleList;
        var customModuleDataList = Common.customModuleDataList;
        var perSerializeAttrType = CustomAttributeSetting.getSerializeAttrType(varAttrSetting, arrayEnabled);
        if (perSerializeAttrType >= CustomAttributeSetting.ATTR_TYPE_NUMBER_ARRAY) {
            return { varType: perSerializeAttrType, value: [] };
        }
        else {
            if (perSerializeAttrType == CustomAttributeSetting.ATTR_TYPE_NUMBER || perSerializeAttrType == CustomAttributeSetting.ATTR_TYPE_MODULE_ID) {
                return { varType: perSerializeAttrType, value: MathUtils.float(varAttrSetting.defaultValue) };
            }
            else if (perSerializeAttrType == CustomAttributeSetting.ATTR_TYPE_STRING) {
                return { varType: perSerializeAttrType, value: varAttrSetting.defaultValue };
            }
            else if (perSerializeAttrType == CustomAttributeSetting.ATTR_TYPE_BOOLEAN) {
                return { varType: perSerializeAttrType, value: (MathUtils.int(varAttrSetting.defaultValue)) ? true : false };
            }
            else if (perSerializeAttrType == CustomAttributeSetting.ATTR_TYPE_STRUCTURE) {
                var dataStructureID = varAttrSetting.dataStructureID;
                if (dataStructureID > 0) {
                    var dataSreucture = newestDataStructureList.data[dataStructureID];
                    if (dataSreucture) {
                        var attrObjs = {};
                        var dsAttrs = CustomCompositeSetting.getAllAttributes(dataSreucture);
                        for (var i in dsAttrs) {
                            var dsAttr = dsAttrs[i];
                            var typeValue = CustomAttributeSetting.formatCustomDefaultValue(dsAttr.attr, true);
                            if (typeValue) {
                                attrObjs[dsAttr.attr.varName] = typeValue;
                            }
                        }
                        return { varType: perSerializeAttrType, value: attrObjs };
                    }
                }
                return null;
            }
            else {
                if (varAttrSetting.onlyPointTo) {
                    return { varType: perSerializeAttrType, value: varAttrSetting.defaultValue };
                }
                else {
                    var moduleID = varAttrSetting.moduleID;
                    if (moduleID > 0) {
                        var moduleSetting = newestCustomModuleList.data[moduleID];
                        if (moduleSetting) {
                            var mAttrObjs = { varType: perSerializeAttrType, value: { id: varAttrSetting.moduleID, data: {} } };
                            var dsAttrs = CustomCompositeSetting.getAllAttributes(moduleSetting);
                            for (var i in dsAttrs) {
                                var dsAttr = dsAttrs[i];
                                var moduleDataID = MathUtils.int(varAttrSetting.defaultValue);
                                if (moduleDataID == 0)
                                    moduleDataID = 1;
                                mAttrObjs.value.id = moduleDataID;
                                var moduleData = customModuleDataList[moduleID].data[moduleDataID];
                                if (moduleData) {
                                    CustomAttributeSetting.formatCustomModuleFromDataBasePereset(moduleData, mAttrObjs.value);
                                }
                                else {
                                    var typeValue = CustomAttributeSetting.formatCustomDefaultValue(dsAttr.attr, true);
                                    if (typeValue) {
                                        mAttrObjs.value.data[dsAttr.attr.varName] = typeValue;
                                    }
                                }
                            }
                            return mAttrObjs;
                        }
                    }
                    return null;
                }
            }
        }
    };
    CustomAttributeSetting.formatCustomModuleFromDataBasePereset = function (moduleData, myValue) {
        if (!moduleData) {
            myValue.data = null;
            return;
        }
        myValue.data = ObjectUtils.depthClone(moduleData.attrs);
    };
    CustomAttributeSetting.serializeCustomData = function (typeValue, attrPerSettings) {
        if (!typeValue)
            typeValue = {};
        this.formatCustomData(typeValue, attrPerSettings);
        if (!(attrPerSettings instanceof Array)) {
            attrPerSettings = CustomCompositeSetting.getAllAttributes(attrPerSettings, false);
        }
        var attrSettings = attrPerSettings;
        var target = {};
        this.installAttributeFromEditorSet(target, typeValue, attrSettings);
        var arr = [];
        for (var i in attrSettings) {
            var varName = attrSettings[i].varName;
            arr.push(target[varName]);
        }
        return arr;
    };
    CustomAttributeSetting.installAttributeFromEditorSet = function (target, editorSetAttrs, attrSettings, readOnly, jurisdictionRestriction, customAttrMode) {
        if (readOnly === void 0) { readOnly = false; }
        if (jurisdictionRestriction === void 0) { jurisdictionRestriction = false; }
        if (customAttrMode === void 0) { customAttrMode = -1; }
        var customModuleList = Common.customModuleList;
        for (var s in attrSettings) {
            var attrSetting = attrSettings[s];
            var varName = attrSetting.varName;
            var editorSetAttr = editorSetAttrs[varName];
            if (jurisdictionRestriction && attrSetting.accessMode == 0) {
                continue;
            }
            if (!editorSetAttr) {
                trace("error " + varName + " installAttributeFromEditorSet!!! 一般不应该存在没有编辑器预设的数据，在保存时就全部格式化了。");
                continue;
            }
            var value = attrSetting.arrayMode && Array.isArray(editorSetAttr.value) ? editorSetAttr.value.concat() : editorSetAttr.value;
            if (attrSetting.varType == 0) {
                setTargetAttr(target, varName, value, attrSetting);
            }
            else if (attrSetting.varType == 1) {
                setTargetAttr(target, varName, value, attrSetting);
            }
            else if (attrSetting.varType == 2) {
                setTargetAttr(target, varName, value, attrSetting);
            }
            else if (attrSetting.varType == 3) {
                var ds = Common.dataStructureList.data[attrSetting.dataStructureID];
                if (ds) {
                    var dsAttrSettings = CustomCompositeSetting.getAllAttributes(ds, false);
                    if (attrSetting.arrayMode) {
                        var dsArrObj = [];
                        setTargetAttr(target, varName, dsArrObj, attrSetting, true);
                        for (var i = 0; i < value.length; i++) {
                            var dsObj = {};
                            dsArrObj[i] = dsObj;
                            this.installAttributeFromEditorSet(dsObj, value[i], dsAttrSettings, readOnly, jurisdictionRestriction, customAttrMode);
                        }
                    }
                    else {
                        var dsObj = {};
                        setTargetAttr(target, varName, dsObj, attrSetting, true);
                        this.installAttributeFromEditorSet(dsObj, editorSetAttr.value, dsAttrSettings, readOnly, jurisdictionRestriction, customAttrMode);
                    }
                }
            }
            else if (attrSetting.varType == 4) {
                var customModuleSetting = customModuleList.data[attrSetting.moduleID];
                var customModule = Common.customModuleDataList[attrSetting.moduleID];
                if (customModuleSetting && customModule) {
                    if (attrSetting.onlyPointTo) {
                        var moduleDatas = GameData.customModulePresetDatas[attrSetting.moduleID];
                        if (moduleDatas) {
                            if (attrSetting.arrayMode) {
                                var mdArrObj = [];
                                setTargetAttr(target, varName, mdArrObj, attrSetting, true);
                                for (var i = 0; i < value.length; i++) {
                                    var dataModel = moduleDatas[value[i]];
                                    mdArrObj[i] = dataModel;
                                }
                            }
                            else {
                                var dataModel = moduleDatas[editorSetAttr.value];
                                target[varName] = dataModel;
                            }
                        }
                    }
                    else {
                        var mdAttrSettings = CustomCompositeSetting.getAllAttributes(customModuleSetting, false);
                        if (attrSetting.arrayMode) {
                            var mdArrObj = [];
                            setTargetAttr(target, varName, mdArrObj, attrSetting, true);
                            for (var i = 0; i < value.length; i++) {
                                var preSetValue = value[i];
                                var moduleData = customModule.data[preSetValue.id];
                                if (moduleData) {
                                    var mdObj = {};
                                    mdArrObj[i] = mdObj;
                                    mdObj.id = preSetValue.id;
                                    this.installAttributeFromEditorSet(mdObj, preSetValue.data, mdAttrSettings, readOnly, jurisdictionRestriction, customAttrMode);
                                }
                            }
                        }
                        else {
                            var moduleData = customModule.data[editorSetAttr.value.id];
                            if (moduleData) {
                                var mdObj = {};
                                setTargetAttr(target, varName, mdObj, attrSetting, true);
                                mdObj.id = editorSetAttr.value.id;
                                this.installAttributeFromEditorSet(mdObj, editorSetAttr.value.data, mdAttrSettings, readOnly, jurisdictionRestriction, customAttrMode);
                            }
                        }
                    }
                }
            }
        }
        function setTargetAttr(target, varName, value, attrSetting, dataStructorMode) {
            if (dataStructorMode === void 0) { dataStructorMode = false; }
            target[varName] = value;
        }
    };
    CustomAttributeSetting.installAttributeFromRecordData = function (target, recordDataAttrs, attrSettings) {
        if (recordDataAttrs == null)
            return;
        var varTypeMapping = ["number", "string", "boolean"];
        for (var i in attrSettings) {
            var attrSetting = attrSettings[i];
            var varName = attrSetting.varName;
            var recordValue = recordDataAttrs[varName];
            var recordValueType = typeof recordValue;
            if (recordValue == null) {
                continue;
            }
            if (attrSetting.varType <= 2) {
                var varTypeOf = varTypeMapping[attrSetting.varType];
                if (attrSetting.arrayMode) {
                    if (recordValue instanceof Array) {
                        var targetArr = target[varName];
                        for (var s in recordValue) {
                            var recordArrValue = recordValue[s];
                            if (recordArrValue == null)
                                continue;
                            if (typeof recordArrValue == varTypeOf) {
                                targetArr[s] = recordValue[s];
                            }
                        }
                    }
                }
                else {
                    if (recordValueType == varTypeOf) {
                        target[varName] = recordValue;
                    }
                }
            }
            else if (attrSetting.varType == 3) {
                var ds = Common.dataStructureList.data[attrSetting.dataStructureID];
                if (ds) {
                    var dsAttrSettings = CustomCompositeSetting.getAllAttributes(ds, false);
                    if (attrSetting.arrayMode) {
                        if (recordValue instanceof Array) {
                            var targetArr = target[varName];
                            for (var s in recordValue) {
                                var recordArrValue = recordValue[s];
                                if (recordArrValue == null) {
                                    targetArr[s] = null;
                                }
                                else if (!(recordArrValue instanceof Array || !(recordArrValue instanceof Object))) {
                                    var newObj = targetArr[s] = {};
                                    this.installAttributeFromRecordData(newObj, recordArrValue, dsAttrSettings);
                                }
                            }
                        }
                    }
                    else {
                        if (!(recordValue instanceof Array || !(recordValue instanceof Object))) {
                            this.installAttributeFromRecordData(target[varName], recordValue, dsAttrSettings);
                        }
                    }
                }
            }
            else if (attrSetting.varType == 4) {
                var customModuleSetting = Common.customModuleList.data[attrSetting.moduleID];
                var customModule = Common.customModuleDataList[attrSetting.moduleID];
                if (customModuleSetting && customModule) {
                    if (attrSetting.onlyPointTo) {
                        var moduleDatas = GameData.customModulePresetDatas[attrSetting.moduleID];
                        if (moduleDatas) {
                            if (attrSetting.arrayMode) {
                            }
                            else {
                            }
                        }
                    }
                    else {
                        var mdAttrSettings = CustomCompositeSetting.getAllAttributes(customModuleSetting, false);
                        if (attrSetting.arrayMode) {
                            if (recordValue instanceof Array) {
                                var targetArr = target[varName];
                                for (var s in recordValue) {
                                    var recordArrValue = recordValue[s];
                                    if (recordArrValue == null) {
                                        targetArr[s] = null;
                                    }
                                    else {
                                        var moduleData = customModule.data[recordArrValue.id];
                                        if (moduleData) {
                                            var mdObj = targetArr[s] = { id: recordArrValue.id };
                                            this.installAttributeFromRecordData(mdObj, recordArrValue, mdAttrSettings);
                                        }
                                    }
                                }
                            }
                        }
                        else {
                            var moduleData = customModule.data[recordValue.id];
                            if (moduleData) {
                                this.installAttributeFromRecordData(target[varName], recordValue, mdAttrSettings);
                            }
                        }
                    }
                }
            }
        }
    };
    CustomAttributeSetting.createVarTypeAttrsByValue = function (attrSetting, values) {
        var editAttrSetting = {};
        CustomAttributeSetting.formatCustomData(editAttrSetting, attrSetting);
        docreateVarTypeAttrsByValue(editAttrSetting, values, attrSetting);
        function docreateVarTypeAttrsByValue(editAttrSetting, values, attrSetting) {
            var orderAttrs = CustomCompositeSetting.getAllAttributes(attrSetting, false);
            for (var i = 0; i < orderAttrs.length; i++) {
                var cusAttr = orderAttrs[i];
                var varName = cusAttr.varName;
                var value = values[i];
                if (value == null)
                    continue;
                var typeValue = editAttrSetting[varName];
                if (typeValue.varType >= CustomAttributeSetting.ATTR_TYPE_NUMBER_ARRAY && !Array.isArray(value))
                    continue;
                if (typeValue.varType == CustomAttributeSetting.ATTR_TYPE_NUMBER) {
                    typeValue.value = MathUtils.float(value);
                }
                else if (typeValue.varType == CustomAttributeSetting.ATTR_TYPE_STRING) {
                    typeValue.value = String(value);
                }
                else if (typeValue.varType == CustomAttributeSetting.ATTR_TYPE_BOOLEAN) {
                    typeValue.value = value ? true : false;
                }
                else if (typeValue.varType == CustomAttributeSetting.ATTR_TYPE_STRUCTURE) {
                    var typeValueV = typeValue.value;
                    var ds = Common.dataStructureList.data[cusAttr.dataStructureID];
                    if (ds)
                        docreateVarTypeAttrsByValue(typeValueV, value, ds);
                }
                else if (typeValue.varType == CustomAttributeSetting.ATTR_TYPE_MODULE_ID) {
                }
                else if (typeValue.varType == CustomAttributeSetting.ATTR_TYPE_MODULE_CLONE) {
                    var typeValueV = typeValue.value ? typeValue.value.data : null;
                    var customModuleSetting = Common.customModuleList.data[cusAttr.moduleID];
                    var customModule = Common.customModuleDataList[cusAttr.moduleID];
                    if (customModuleSetting && customModule) {
                        docreateVarTypeAttrsByValue(typeValueV, value, customModuleSetting);
                    }
                }
                else if (typeValue.varType == CustomAttributeSetting.ATTR_TYPE_NUMBER_ARRAY) {
                    for (var s in typeValue.value) {
                        typeValue.value[s].value = MathUtils.float(value[s]);
                    }
                }
                else if (typeValue.varType == CustomAttributeSetting.ATTR_TYPE_STRING_ARRAY) {
                    for (var s in typeValue.value) {
                        typeValue.value[s].value = String(value[s]);
                    }
                }
                else if (typeValue.varType == CustomAttributeSetting.ATTR_TYPE_BOOLEAN_ARRAY) {
                    for (var s in typeValue.value) {
                        typeValue.value[s].value = value[s] ? true : false;
                    }
                }
                else if (typeValue.varType == CustomAttributeSetting.ATTR_TYPE_STRUCTURE_ID_ARRAY) {
                    var typeArr = typeValue.value;
                    var ds = Common.dataStructureList.data[cusAttr.dataStructureID];
                    if (ds) {
                        for (var s in typeArr) {
                            var typeValueV = typeArr[s].value;
                            docreateVarTypeAttrsByValue(typeValueV, value[s], ds);
                        }
                    }
                }
                else if (typeValue.varType == CustomAttributeSetting.ATTR_TYPE_MODULE_ID_ARRAY) {
                }
                else if (typeValue.varType == CustomAttributeSetting.ATTR_TYPE_MODULE_CLONE_ARRAY) {
                    var typeArr = typeValue.value;
                    var customModuleSetting = Common.customModuleList.data[cusAttr.moduleID];
                    var customModule = Common.customModuleDataList[cusAttr.moduleID];
                    if (customModuleSetting && customModule) {
                        for (var s in typeArr) {
                            var typeValueV = typeArr[s].value ? typeValue.value[s].value.data : null;
                            docreateVarTypeAttrsByValue(typeValueV, value[s], customModuleSetting);
                        }
                    }
                }
            }
        }
        return editAttrSetting;
    };
    CustomAttributeSetting.ATTR_TYPE_NUMBER = 0;
    CustomAttributeSetting.ATTR_TYPE_STRING = 1;
    CustomAttributeSetting.ATTR_TYPE_BOOLEAN = 2;
    CustomAttributeSetting.ATTR_TYPE_STRUCTURE = 3;
    CustomAttributeSetting.ATTR_TYPE_MODULE_ID = 4;
    CustomAttributeSetting.ATTR_TYPE_MODULE_CLONE = 5;
    CustomAttributeSetting.ATTR_TYPE_NUMBER_ARRAY = 6;
    CustomAttributeSetting.ATTR_TYPE_STRING_ARRAY = 7;
    CustomAttributeSetting.ATTR_TYPE_BOOLEAN_ARRAY = 8;
    CustomAttributeSetting.ATTR_TYPE_STRUCTURE_ID_ARRAY = 9;
    CustomAttributeSetting.ATTR_TYPE_MODULE_ID_ARRAY = 10;
    CustomAttributeSetting.ATTR_TYPE_MODULE_CLONE_ARRAY = 11;
    return CustomAttributeSetting;
}());
var Config = (function () {
    function Config() {
        this.customConfig = {};
    }
    Config.init = function () {
        Config.IS_SERVER = typeof window == "undefined";
        Config.SCENE_GRID_SIZE = Math.min(512, Config.SCENE_GRID_SIZE);
        if (!Config.IS_SERVER) {
            Config.TILE_SPLIT_SIZE = Math.floor(512 / Config.SCENE_GRID_SIZE) * Config.SCENE_GRID_SIZE;
            var per = GameUtils.getAutoFitSizePre(new Rectangle(0, 0, Config.WINDOW_WIDTH, Config.WINDOW_HEIGHT), new Rectangle(0, 0, stage.width, stage.height));
            var displayWidth = Math.floor(Config.WINDOW_WIDTH * per);
            var displayHeight = Math.floor(Config.WINDOW_HEIGHT * per);
            if (Config.TILE_SPLIT_SIZE > displayWidth || Config.TILE_SPLIT_SIZE > displayHeight) {
                Config.TILE_SPLIT_SIZE = Math.min(displayWidth, displayHeight);
            }
            var p = 2;
            while (1) {
                p *= 2;
                if (p > Config.TILE_SPLIT_SIZE) {
                    break;
                }
            }
            Config.TILE_SPLIT_SIZE = p / 2;
        }
    };
    Config.saveAttrs = [];
    Config.DEBUG_OBSTACLE = false;
    Config.JSON_PATH = "asset/json";
    Config.JSON_CONFIG = Config.JSON_PATH + "/config.json";
    Config.SCENE_BY_DRAWLINES_MAX = 500;
    return Config;
}());





var AvatarData = (function (_super) {
    __extends(AvatarData, _super);
    function AvatarData() {
        _super.apply(this, arguments);
        this.picUrls = ["asset/editor/image/empty.png"];
        this.oriMode = 4;
        this.refObjs = {};
        this.parts = [{ id: 0, showOnEditor: true, mouseEventEnabledInEditor: true }];
        this.actionListArr = [{
                id: 1,
                frameImageInfo: []
            }];
    }
    return AvatarData;
}(OriginalData));





var CommonEventData = (function (_super) {
    __extends(CommonEventData, _super);
    function CommonEventData() {
        _super.apply(this, arguments);
        this.allowClient = false;
        this.conditionSwitch = 1;
        this.updateMode = false;
        this.commands = [];
    }
    return CommonEventData;
}(OriginalData));





var CustomCompositeSetting = (function (_super) {
    __extends(CustomCompositeSetting, _super);
    function CustomCompositeSetting() {
        _super.apply(this, arguments);
    }
    CustomCompositeSetting.init = function (data) {
        var block = new CustomCompositeBlock();
        CustomCompositeBlock.init(block);
        data.blockList = [block];
    };
    CustomCompositeSetting.runCode = function (gameData) {
        CustomCompositeSetting.runCodeByList(gameData.dataStructureList, 0, gameData);
        CustomCompositeSetting.runCodeByList(gameData.customModuleList, 1, gameData);
        CustomCompositeSetting.runWorldData();
        CustomCompositeSetting.runCodeByItem(gameData.customGameAttribute.playerAttributeSetting, 3, gameData);
        CustomCompositeSetting.createPresetCustomModuleDatas();
    };
    CustomCompositeSetting.runCodeByList = function (list, mode, gameData) {
        var dsItems = GameListData.getItems(list);
        for (var i in dsItems) {
            var dsItem = dsItems[i];
            CustomCompositeSetting.runCodeByItem(dsItem, mode, gameData);
        }
    };
    CustomCompositeSetting.createPresetCustomModuleDatas = function () {
        var customModuleList = Common.customModuleList;
        var customModuleDataList = Common.customModuleDataList;
        for (var i in customModuleList.data) {
            var moduleIndex = parseInt(i);
            var cmSetting = customModuleList.data[moduleIndex];
            if (cmSetting) {
                var singleModuleDataArr = GameData.customModulePresetDatas[moduleIndex] = [];
                var cmDatas = customModuleDataList[moduleIndex].data;
                var attrSettings = CustomCompositeSetting.getAllAttributes(cmSetting, false);
                for (var s in cmDatas) {
                    var dataID = parseInt(s);
                    var cmData = cmDatas[dataID];
                    if (cmData) {
                        var cmObj = {};
                        cmObj.id = dataID;
                        singleModuleDataArr[dataID] = cmObj;
                        CustomAttributeSetting.installAttributeFromEditorSet(cmObj, cmData.attrs, attrSettings, true, !Config.IS_SERVER);
                    }
                }
            }
        }
    };
    CustomCompositeSetting.runCodeByItem = function (dsItem, mode, gameData) {
        var attrs = CustomCompositeSetting.getAllAttributes(dsItem, false);
        var classVarName = this.getVarTypeInEditorCode(mode, dsItem.id);
        if (classVarName == "any")
            return;
        var vars = "";
        var dsCls = "var " + classVarName + " = function(){" + vars;
        for (var i in attrs) {
            var attr = attrs[i];
            if (!Config.IS_SERVER && attr.accessMode == 0)
                continue;
            if (attr.arrayMode) {
                dsCls += "this." + attr.varName + " = [];";
            }
            else {
                if (attr.defaultValue) {
                    if (attr.varType == 0) {
                        dsCls += "this." + attr.varName + " = " + MathUtils.float(attr.defaultValue) + ";";
                    }
                    else if (attr.varType == 1) {
                        if (attr.defaultValue.length >= 2 && attr.defaultValue[0] == "\"" && attr.defaultValue[attr.defaultValue.length - 1] == "\"") {
                            dsCls += "this." + attr.varName + " = " + attr.defaultValue + ";";
                        }
                        else {
                            dsCls += "this." + attr.varName + " = \"" + attr.defaultValue + "\";";
                        }
                    }
                    else if (attr.varType == 2) {
                        dsCls += "this." + attr.varName + " = " + (attr.defaultValue ? "true" : "false") + ";";
                    }
                }
                if (attr.varType == 3) {
                    if (gameData.dataStructureList.data[attr.dataStructureID]) {
                        var dataStructureCls = this.getVarTypeInEditorCode(0, attr.dataStructureID);
                        if (dataStructureCls != "any")
                            dsCls += "this." + attr.varName + " = new " + dataStructureCls + ";";
                    }
                }
                else if (attr.varType == 4) {
                    if (gameData.customModuleList.data[attr.moduleID]) {
                        var customCls = this.getVarTypeInEditorCode(1, attr.moduleID);
                        if (customCls != "any")
                            dsCls += "this." + attr.varName + " = new " + customCls + ";";
                    }
                }
            }
        }
        dsCls += "}";
        globalThis.eval(dsCls);
    };
    CustomCompositeSetting.runWorldData = function () {
        var customGameAttribute = Common.customGameAttribute;
        globalThis.WorldData = {};
        var attrSettings = CustomCompositeSetting.getAllAttributes(customGameAttribute.worldAttributeSetting, false);
        CustomAttributeSetting.installAttributeFromEditorSet(globalThis.WorldData, customGameAttribute.worldAttributeConfig.attrs, attrSettings, false, !Config.IS_SERVER, GameData.CUSTOM_ATTR_WORLD_DATA);
        if (!Config.EDIT_MODE) {
            if (Config.IS_SERVER) {
                ServerWorld.data = globalThis.WorldData;
                CustomAttributeSetting.installAttributeFromRecordData(ServerWorld.data, ServerSql.recordWorldData, attrSettings);
                ServerSql.recordWorldData = null;
            }
            else {
                ClientWorld.data = globalThis.WorldData;
            }
        }
    };
    CustomCompositeSetting.getAllAttributes = function (data, dsAttrMode) {
        if (dsAttrMode === void 0) { dsAttrMode = true; }
        var len = data.blockList.length;
        var arr = [];
        for (var i = 0; i < len; i++) {
            var block = data.blockList[i];
            var aLen = block.blockAttrs.length;
            for (var s = 0; s < aLen; s++) {
                if (dsAttrMode) {
                    arr.push(block.blockAttrs[s]);
                }
                else {
                    arr.push(block.blockAttrs[s].attr);
                }
            }
        }
        return arr;
    };
    CustomCompositeSetting.getAllAPIRunetime = function (mode, limitJurisdiction) {
        if (limitJurisdiction === void 0) { limitJurisdiction = false; }
        if (mode == 0 || mode == 1 || mode == 4) {
            var lists = [Common.dataStructureList, Common.customModuleList, null, null, null];
            var nameHeads = ["DataStructure", "Module", null, null, "SceneModel"];
            var list = lists[mode];
            var datas = GameListData.getItems(list);
            var runtimeStr = "";
            var len = datas.length;
            for (var i = 0; i < len; i++) {
                var data = datas[i];
                runtimeStr += this.getAPIRuntime(mode, data, limitJurisdiction);
                if (i != len - 1)
                    runtimeStr += "\n";
            }
            return runtimeStr;
        }
        else if (mode == 2) {
            return this.getAPIRuntime(mode, Common.customGameAttribute.worldAttributeSetting, limitJurisdiction, true);
        }
        else if (mode == 3) {
            return this.getAPIRuntime(mode, Common.customGameAttribute.playerAttributeSetting, limitJurisdiction);
        }
        return "";
    };
    CustomCompositeSetting.getAPIRuntime = function (mode, cSetting, limitJurisdiction, isStatic) {
        if (limitJurisdiction === void 0) { limitJurisdiction = false; }
        if (isStatic === void 0) { isStatic = false; }
        var attrs = CustomCompositeSetting.getAllAttributes(cSetting, false);
        var len = attrs.length;
        var className = this.getVarTypeInEditorCode(mode, cSetting.id);
        if (className == "any")
            return "";
        var runtimeStr = (cSetting.id ? "/**\n * #" + cSetting.id + "\n */\n" : "") + "class " + className + " {\n";
        if (mode == 1) {
            runtimeStr += "    id:number;\n";
        }
        for (var i = 0; i < len; i++) {
            var attr = attrs[i];
            if (!limitJurisdiction || attr.accessMode != 0) {
                var varStr = CustomAttributeSetting.getAPIRuntime(attr, isStatic);
                runtimeStr += "    " + varStr;
                runtimeStr += "\n";
            }
        }
        runtimeStr += "}";
        return runtimeStr;
    };
    CustomCompositeSetting.getVarTypeInEditorCode = function (mode, id) {
        if (mode == 0 || mode == 1 || mode == 4) {
            var lists = [Common.dataStructureList, Common.customModuleList, null, null, null];
            var nameHeads = ["DataStructure", "Module", null, null, "SceneModel"];
            if (id == -1)
                return nameHeads[mode];
            var list = lists[mode];
            var cSetting = list.data[id];
            if (cSetting) {
                var settingName = GameListData.getName(list, id);
                return nameHeads[mode] + "_" + settingName;
            }
            else {
                return "any";
            }
        }
        else if (mode == 2) {
            return "WorldData";
        }
        else if (mode == 3) {
            return "PlayerData";
        }
    };
    return CustomCompositeSetting;
}(OriginalData));
var CustomCompositeBlock = (function () {
    function CustomCompositeBlock() {
    }
    CustomCompositeBlock.init = function (data) {
        data.name = "未命名块";
        data.blockAttrs = [];
        data.blockCondition = [];
        data.blockHeight = 300;
        data.autoOrder = true;
    };
    return CustomCompositeBlock;
}());
var CustomCompositeAttributeSetting = (function () {
    function CustomCompositeAttributeSetting() {
    }
    CustomCompositeAttributeSetting.init = function (data) {
        data.attr = new CustomAttributeSetting();
        CustomAttributeSetting.init(data.attr);
        data.attrConditions = [];
        data.x = data.y = 0;
        data.width = 200;
        data.height = 32;
    };
    return CustomCompositeAttributeSetting;
}());





var CustomEventType = (function (_super) {
    __extends(CustomEventType, _super);
    function CustomEventType() {
        _super.apply(this, arguments);
    }
    return CustomEventType;
}(OriginalData));





var DialogData = (function (_super) {
    __extends(DialogData, _super);
    function DialogData() {
        _super.call(this);
        this.option = {
            x: 132,
            y: 189,
            width: 310,
            height: 40,
            color: "#FFFFFF",
            fontSize: 24,
            leading: 3,
            align: "1",
            valign: "top"
        };
        this.optionBox = {
            x: 100,
            y: 161,
            width: 375,
            height: 87,
            column: 2,
            columnSpaceing: 5,
            rowSpaceing: 5,
            image1: "asset/image/ui/Kelvin 287_3.png",
            image2: "asset/image/ui/Kelvin 285_3.png",
            overSe: "asset/audio/se/btn.mp3,1,1",
            overVolume: 1,
            overPitch: 1,
            clickSe: "asset/audio/se/over_btn.mp3,1,1",
            clickVolume: 1,
            clikcPitch: 1
        };
        this.dialogBox = {
            x: 39,
            y: 492,
            width: 926,
            height: 193,
            skin: "asset/image/ui/Kelvin 70_1.png"
        };
        this.headBox = {
            x: 51,
            y: 512,
            width: 142,
            height: 142,
            skin: Config.EDIT_MODE ? Editor.URL_UNKNOW_IMAGE : ""
        };
        this.dialog = {
            x: 207,
            y: 559,
            width: 726,
            height: 125,
            color: "#FFFFFF",
            fontSize: 24,
            leading: 6,
            align: "0",
        };
        this.nameBox = {
            x: 208,
            y: 515,
            width: 123,
            height: 28,
            color: "#FFFF00",
            fontSize: 24,
            leading: 3,
            align: "1",
        };
    }
    return DialogData;
}(OriginalData));
!function(){var r;!function(r){function n(r){return f?new f(r):new Array(r)}function o(r){return f?new f(r):r}function t(r){for(var o=r.length/2,t=n(o),e=0;e<o;e++){var a=parseInt(r.substr(2*e,2),16);if(isNaN(a))throw Error("invalid hex data");t[e]=a}return t}function e(r){for(var n=r.length,o="",t=0;t<n;t++){var e=255&r[t],a=e.toString(16);e<16&&(a="0"+a),o+=a}return o}function a(r){var n=window.TextEncoder;if(n)return(new n).encode(r);for(var t=[],e=0,a=0,i=encodeURI(r),c=i.length;e<c;){var f=i.charCodeAt(e);if(37==f){var s=i.substr(e+1,2);f=parseInt(s,16),e+=3}else e++;t[a++]=f}return o(t)}function i(r){for(var n=r.length,o="",t=0;t<n;t++){var e=r[t],a=e.toString(16);e<16&&(a="0"+a),o+="%"+a}return decodeURIComponent(o)}function c(r){r.style.cssText="position:absolute;top:-999px"}var f=window.Uint8Array;r.hexToBytes=t,r.bytesToHex=e,r.strToBytes=a,r.bytesToStr=i,r.hideDom=c}(r||(r={}));var n;!function(r){function n(){return"Worker"in window}function o(n){t.__asmjs_cb=s;var o=n+"asmjs.js",e=document.createElement("script");e.onerror=function(){r.onerror("script load fail")},e.src=o,document.body.appendChild(e)}function e(r,n,o){u.hash(r,n,o)}function a(r,n,o,t,e,a,i){u.config.apply(this,arguments)}function i(){u.stop()}function c(){u.free()}function f(){u&&(u.unload(),u=null)}function s(n,o){"onload"==n&&(u=o),r[n](o)}var u;r.check=n,r.load=o,r.hash=e,r.config=a,r.stop=i,r.free=c,r.unload=f}(n||(n={}));var o;!function(n){function o(){return v()>=18}function e(n){t.__flash_cb=u;var o=n+"flash.swf";m=l(o),r.hideDom(m)}function a(n,o,t){var e=r.bytesToHex(n),a=r.bytesToHex(o);m.hash(e,a,t)}function i(r,n,o,t,e,a,i){m.config.apply(m,arguments)}function c(){m.cancel()}function f(){m.free(),m=null}function s(){document.body.removeChild(m),m=null}function u(o,t){"oncomplete"==o&&(t=r.hexToBytes(t));try{n[o](t)}catch(e){throw e}}function l(r){var n=document.createElement("div"),o="_"+(1e6*Math.random()|0);r=encodeURI(r),n.innerHTML=p?"<object id="+o+" classid=clsid:D27CDB6E-AE6D-11cf-96B8-444553540000><param name=movie value="+r+"><param name=allowScriptAccess value=always></object>":"<embed id="+o+" name="+o+" src="+r+" type=application/x-shockwave-flash allowScriptAccess=always></embed>";var t=n.firstChild;return document.body.appendChild(t),t}function h(){var r=navigator.plugins;if(r){var n=r["Shockwave Flash"];if(n){var o=n.description;if(o)return+o.match(w)}}}function d(){var r=window.ActiveXObject;if(r){var n="";try{n=new r("ShockwaveFlash.ShockwaveFlash").GetVariable("$version").replace(",",".")}catch(o){return}return+n.match(w)}}function v(){var r=h();return r>0?r:(r=d(),r>0?(p=!0,r):0)}var m,p;n.check=o,n.load=e,n.hash=a,n.config=i,n.stop=c,n.free=f,n.unload=s;var w=/\d+\.\d+/}(o||(o={}));var t;!function(t){function e(){for(var r=f(),n={},o=0;o<r.length;o++)n[r[o]]=!0;var t=navigator.userAgent;return/Chrome|Firefox|Edge|Safari/.test(t)&&"asmjs"in n?"asmjs":"flash"in n?"flash":null}function a(r,n){if(r)switch(arguments.length){case 1:return r();case 2:return r(n)}}function i(){k&&(clearTimeout(k),k=0)}function c(r,n,o){if(T<2)throw Error("scrypt not loaded");if(T<4)throw Error("scrypt not configed");if(5==T)throw Error("scrypt is running");if(T=5,o=o||B,r=r||[],n=n||[],r.length>j)throw Error("pass.length > maxPassLen");if(n.length>A)throw Error("salt.length > maxSaltLen");if(o>B)throw Error("dkLen > maxDkLen");x.hash(r,n,o)}function f(){if(!E){E=[];for(var r in b)b[r].check()&&E.push(r)}return E}function s(r){if(!(T>=1)){if(!r&&(r=e(),!r))throw Error("no available mod");if(x=b[r],!x)throw Error("unsupported mod: "+r);x.onload=function(){i(),a(t.onload)},x.onerror=function(r){h(),a(t.onerror,r)},x.onready=function(){T=4,a(t.onready)},x.onprogress=function(r){a(t.onprogress,r)},x.oncomplete=function(r){T=4,a(t.onprogress,1),a(t.oncomplete,r)},i(),k=setTimeout(function(){h(),a(t.onerror,"load timeout")},L),T=1,x.load(S)}}function u(){x.stop(),T=4}function l(){4==T&&(x.free(),T=2)}function h(){0!=T&&(x.unload(),T=0),i()}function d(r,n,o){if(!r)throw Error("config() takes at least 1 argument");var t=0|r.N;if(!(1<t&&t<=8388608))throw Error("param N out of range (1 < N <= 2^23)");if(t&t-1)throw Error("param N must be power of 2");var e=0|r.r;if(!(0<e&&e<256))throw Error("param r out of range (0 < r < 256)");var a=0|r.P;if(!(0<a&&a<256))throw Error("param P out of range (0 < P < 256)");var i=t*e*128;if(i>1073741824)throw Error("memory limit exceeded (N * r * 128 > 1G)");if(n){var c=n.maxPassLen;if(null==c)c=j;else if(c<=0)throw Error("invalid maxPassLen");var f=n.maxSaltLen;if(null==f)f=A;else if(f<=0)throw Error("invalid maxSaltLen");var s=n.maxDkLen;if(null==s)s=B;else if(s<=0)throw Error("invalid maxDkLen");var u=n.maxThread;if(null==u)u=C;else if(u<=0)throw Error("invalid maxThread");o||(j=0|c,A=0|f,B=0|s,C=0|u)}if(!o){var l=Math.ceil(a/C),h=Math.ceil(a/l);x.config(t,e,a,h,j,A,B),T=3}}function v(n){return r.strToBytes(n)}function m(n){return r.bytesToStr(n)}function p(n){if(n.length%2)throw Error("invalid hex length");return r.hexToBytes(n)}function w(n){return r.bytesToHex(n)}function g(r){/\/$/.test(r)||(r+="/"),S=r}function y(r){L=r}var x,E,b={asmjs:n,flash:o},T=0,S="",k=0,L=3e4,j=64,A=64,B=64,C=1;t.hash=c,t.getAvailableMod=f,t.load=s,t.stop=u,t.free=l,t.unload=h,t.config=d,t.strToBin=v,t.binToStr=m,t.hexToBin=p,t.binToHex=w,t.setResPath=g,t.setResTimeout=y,window.scrypt=t}(t||(t={}))}();
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var Neo;
(function (Neo) {
    var UintVariable = (function () {
        function UintVariable(bits) {
            if (typeof bits === "number") {
                if (bits <= 0 || bits % 32 != 0)
                    throw new RangeError();
                this._bits = new Uint32Array(bits / 32);
            }
            else if (bits instanceof Uint8Array) {
                if (bits.length == 0 || bits.length % 4 != 0)
                    throw new RangeError();
                if (bits.byteOffset % 4 == 0) {
                    this._bits = new Uint32Array(bits.buffer, bits.byteOffset, bits.length / 4);
                }
                else {
                    var bits_new = new Uint8Array(bits);
                    this._bits = new Uint32Array(bits_new.buffer);
                }
            }
            else if (bits instanceof Uint32Array) {
                this._bits = bits;
            }
            else if (bits instanceof Array) {
                if (bits.length == 0)
                    throw new RangeError();
                this._bits = new Uint32Array(bits);
            }
        }
        Object.defineProperty(UintVariable.prototype, "bits", {
            get: function () {
                return this._bits;
            },
            enumerable: true,
            configurable: true
        });
        UintVariable.prototype.compareTo = function (other) {
            var max = Math.max(this._bits.length, other._bits.length);
            for (var i = max - 1; i >= 0; i--)
                if ((this._bits[i] || 0) > (other._bits[i] || 0))
                    return 1;
                else if ((this._bits[i] || 0) < (other._bits[i] || 0))
                    return -1;
            return 0;
        };
        UintVariable.prototype.equals = function (other) {
            var max = Math.max(this._bits.length, other._bits.length);
            for (var i = 0; i < max; i++)
                if ((this._bits[i] || 0) != (other._bits[i] || 0))
                    return false;
            return true;
        };
        UintVariable.prototype.toString = function () {
            var s = "";
            for (var i = this._bits.length * 32 - 4; i >= 0; i -= 4)
                s += ((this._bits[i >>> 5] >>> (i % 32)) & 0xf).toString(16);
            return s;
        };
        return UintVariable;
    } ());
    Neo.UintVariable = UintVariable;
})(Neo || (Neo = {}));
var Neo;
(function (Neo) {
    var _max, _min;
    var Uint64 = (function (_super) {
        __extends(Uint64, _super);
        function Uint64(low, high) {
            if (low === void 0) { low = 0; }
            if (high === void 0) { high = 0; }
            return _super.call(this, [low, high]) || this;
        }
        Object.defineProperty(Uint64, "MaxValue", {
            get: function () { return _max || (_max = new Uint64(0xffffffff, 0xffffffff)); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Uint64, "MinValue", {
            get: function () { return _min || (_min = new Uint64()); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Uint64, "Zero", {
            get: function () { return Uint64.MinValue; },
            enumerable: true,
            configurable: true
        });
        Uint64.prototype.add = function (other) {
            var low = this._bits[0] + other._bits[0];
            var high = this._bits[1] + other._bits[1] + (low > 0xffffffff ? 1 : 0);
            return new Uint64(low, high);
        };
        Uint64.prototype.and = function (other) {
            if (typeof other === "number") {
                return this.and(new Uint64(other));
            }
            else {
                var bits = new Uint32Array(this._bits.length);
                for (var i = 0; i < bits.length; i++)
                    bits[i] = this._bits[i] & other._bits[i];
                return new Uint64(bits[0], bits[1]);
            }
        };
        Uint64.prototype.leftShift = function (shift) {
            if (shift == 0)
                return this;
            var shift_units = shift >>> 5;
            shift = shift & 0x1f;
            var bits = new Uint32Array(this._bits.length);
            for (var i = shift_units; i < bits.length; i++)
                if (shift == 0)
                    bits[i] = this._bits[i - shift_units];
                else
                    bits[i] = this._bits[i - shift_units] << shift | this._bits[i - shift_units - 1] >>> (32 - shift);
            return new Uint64(bits[0], bits[1]);
        };
        Uint64.prototype.not = function () {
            var bits = new Uint32Array(this._bits.length);
            for (var i = 0; i < bits.length; i++)
                bits[i] = ~this._bits[i];
            return new Uint64(bits[0], bits[1]);
        };
        Uint64.prototype.or = function (other) {
            if (typeof other === "number") {
                return this.or(new Uint64(other));
            }
            else {
                var bits = new Uint32Array(this._bits.length);
                for (var i = 0; i < bits.length; i++)
                    bits[i] = this._bits[i] | other._bits[i];
                return new Uint64(bits[0], bits[1]);
            }
        };
        Uint64.parse = function (str) {
            var bi = Neo.BigInteger.parse(str);
            if (bi.bitLength() > 64)
                throw new RangeError();
            var array = new Uint32Array(bi.toUint8Array(true, 8).buffer);
            return new Uint64(array[0], array[1]);
        };
        Uint64.prototype.rightShift = function (shift) {
            if (shift == 0)
                return this;
            var shift_units = shift >>> 5;
            shift = shift & 0x1f;
            var bits = new Uint32Array(this._bits.length);
            for (var i = 0; i < bits.length - shift_units; i++)
                if (shift == 0)
                    bits[i] = this._bits[i + shift_units];
                else
                    bits[i] = this._bits[i + shift_units] >>> shift | this._bits[i + shift_units + 1] << (32 - shift);
            return new Uint64(bits[0], bits[1]);
        };
        Uint64.prototype.subtract = function (other) {
            var low = this._bits[0] - other._bits[0];
            var high = this._bits[1] - other._bits[1] - (this._bits[0] < other._bits[0] ? 1 : 0);
            return new Uint64(low, high);
        };
        Uint64.prototype.toInt32 = function () {
            return this._bits[0] | 0;
        };
        Uint64.prototype.toNumber = function () {
            return this._bits[0] + this._bits[1] * Math.pow(2, 32);
        };
        Uint64.prototype.toString = function () {
            return (new Neo.BigInteger(this._bits.buffer)).toString();
        };
        Uint64.prototype.toUint32 = function () {
            return this._bits[0];
        };
        Uint64.prototype.xor = function (other) {
            if (typeof other === "number") {
                return this.xor(new Uint64(other));
            }
            else {
                var bits = new Uint32Array(this._bits.length);
                for (var i = 0; i < bits.length; i++)
                    bits[i] = this._bits[i] ^ other._bits[i];
                return new Uint64(bits[0], bits[1]);
            }
        };
        return Uint64;
    } (Neo.UintVariable));
    Neo.Uint64 = Uint64;
})(Neo || (Neo = {}));
var Neo;
(function (Neo) {
    var DB = 26;
    var DM = (1 << DB) - 1;
    var DV = DM + 1;
    var _minusone, _one, _zero;
    var BigInteger = (function () {
        function BigInteger(value) {
            this._sign = 0;
            this._bits = new Array();
            if (typeof value === "number") {
                if (!isFinite(value) || isNaN(value))
                    throw new RangeError();
                var parts = BigInteger.getDoubleParts(value);
                if (parts.man.equals(Neo.Uint64.Zero) || parts.exp <= -64)
                    return;
                if (parts.exp <= 0) {
                    this.fromUint64(parts.man.rightShift(-parts.exp), parts.sign);
                }
                else if (parts.exp <= 11) {
                    this.fromUint64(parts.man.leftShift(parts.exp), parts.sign);
                }
                else {
                    parts.man = parts.man.leftShift(11);
                    parts.exp -= 11;
                    var units = Math.ceil((parts.exp + 64) / DB);
                    var cu = Math.ceil(parts.exp / DB);
                    var cbit = cu * DB - parts.exp;
                    for (var i = cu; i < units; i++)
                        this._bits[i] = parts.man.rightShift(cbit + (i - cu) * DB).toUint32() & DM;
                    if (cbit > 0)
                        this._bits[cu - 1] = (parts.man.toUint32() << (DB - cbit)) & DM;
                    this._sign = parts.sign;
                    this.clamp();
                }
            }
            else if (typeof value === "string") {
                this.fromString(value);
            }
            else if (value instanceof Uint8Array) {
                this.fromUint8Array(value);
            }
            else if (value instanceof ArrayBuffer) {
                this.fromUint8Array(new Uint8Array(value));
            }
        }
        Object.defineProperty(BigInteger, "MinusOne", {
            get: function () { return _minusone || (_minusone = new BigInteger(-1)); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BigInteger, "One", {
            get: function () { return _one || (_one = new BigInteger(1)); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BigInteger, "Zero", {
            get: function () { return _zero || (_zero = new BigInteger(0)); },
            enumerable: true,
            configurable: true
        });
        BigInteger.add = function (x, y) {
            var bi_x = typeof x === "number" ? new BigInteger(x) : x;
            var bi_y = typeof y === "number" ? new BigInteger(y) : y;
            if (bi_x._sign == 0)
                return bi_y;
            if (bi_y._sign == 0)
                return bi_x;
            if ((bi_x._sign > 0) != (bi_y._sign > 0))
                return BigInteger.subtract(bi_x, bi_y.negate());
            var bits_r = new Array();
            BigInteger.addTo(bi_x._bits, bi_y._bits, bits_r);
            return BigInteger.create(bi_x._sign, bits_r);
        };
        BigInteger.prototype.add = function (other) {
            return BigInteger.add(this, other);
        };
        BigInteger.addTo = function (x, y, r) {
            if (x.length < y.length) {
                var t = x;
                x = y;
                y = t;
            }
            var c = 0, i = 0;
            while (i < y.length) {
                c += x[i] + y[i];
                r[i++] = c & DM;
                c >>>= DB;
            }
            while (i < x.length) {
                c += x[i];
                r[i++] = c & DM;
                c >>>= DB;
            }
            if (c > 0)
                r[i] = c;
        };
        BigInteger.prototype.bitLength = function () {
            var l = this._bits.length;
            if (l == 0)
                return 0;
            return --l * DB + BigInteger.bitLengthInternal(this._bits[l]);
        };
        BigInteger.bitLengthInternal = function (w) {
            return (w < 1 << 15 ? (w < 1 << 7
                ? (w < 1 << 3 ? (w < 1 << 1
                    ? (w < 1 << 0 ? (w < 0 ? 32 : 0) : 1)
                    : (w < 1 << 2 ? 2 : 3)) : (w < 1 << 5
                        ? (w < 1 << 4 ? 4 : 5)
                        : (w < 1 << 6 ? 6 : 7)))
                : (w < 1 << 11
                    ? (w < 1 << 9 ? (w < 1 << 8 ? 8 : 9) : (w < 1 << 10 ? 10 : 11))
                    : (w < 1 << 13 ? (w < 1 << 12 ? 12 : 13) : (w < 1 << 14 ? 14 : 15)))) : (w < 1 << 23 ? (w < 1 << 19
                        ? (w < 1 << 17 ? (w < 1 << 16 ? 16 : 17) : (w < 1 << 18 ? 18 : 19))
                        : (w < 1 << 21 ? (w < 1 << 20 ? 20 : 21) : (w < 1 << 22 ? 22 : 23))) : (w < 1 << 27
                            ? (w < 1 << 25 ? (w < 1 << 24 ? 24 : 25) : (w < 1 << 26 ? 26 : 27))
                            : (w < 1 << 29 ? (w < 1 << 28 ? 28 : 29) : (w < 1 << 30 ? 30 : 31)))));
        };
        BigInteger.prototype.clamp = function () {
            var l = this._bits.length;
            while (l > 0 && (this._bits[--l] | 0) == 0)
                this._bits.pop();
            while (l > 0)
                this._bits[--l] |= 0;
            if (this._bits.length == 0)
                this._sign = 0;
        };
        BigInteger.compare = function (x, y) {
            var bi_x = typeof x === "number" ? new BigInteger(x) : x;
            var bi_y = typeof y === "number" ? new BigInteger(y) : y;
            if (bi_x._sign >= 0 && bi_y._sign < 0)
                return +1;
            if (bi_x._sign < 0 && bi_y._sign >= 0)
                return -1;
            var c = BigInteger.compareAbs(bi_x, bi_y);
            return bi_x._sign < 0 ? -c : c;
        };
        BigInteger.compareAbs = function (x, y) {
            if (x._bits.length > y._bits.length)
                return +1;
            if (x._bits.length < y._bits.length)
                return -1;
            for (var i = x._bits.length - 1; i >= 0; i--)
                if (x._bits[i] > y._bits[i])
                    return +1;
                else if (x._bits[i] < y._bits[i])
                    return -1;
            return 0;
        };
        BigInteger.prototype.compareTo = function (other) {
            return BigInteger.compare(this, other);
        };
        BigInteger.create = function (sign, bits, clamp) {
            if (clamp === void 0) { clamp = false; }
            var bi = Object.create(BigInteger.prototype);
            bi._sign = sign;
            bi._bits = bits;
            if (clamp)
                bi.clamp();
            return bi;
        };
        BigInteger.divide = function (x, y) {
            var bi_x = typeof x === "number" ? new BigInteger(x) : x;
            var bi_y = typeof y === "number" ? new BigInteger(y) : y;
            return BigInteger.divRem(bi_x, bi_y).result;
        };
        BigInteger.prototype.divide = function (other) {
            return BigInteger.divide(this, other);
        };
        BigInteger.divRem = function (x, y) {
            var bi_x = typeof x === "number" ? new BigInteger(x) : x;
            var bi_y = typeof y === "number" ? new BigInteger(y) : y;
            if (bi_y._sign == 0)
                throw new RangeError();
            if (bi_x._sign == 0)
                return { result: BigInteger.Zero, remainder: BigInteger.Zero };
            if (bi_y._sign == 1 && bi_y._bits == null)
                return { result: bi_x, remainder: BigInteger.Zero };
            if (bi_y._sign == -1 && bi_y._bits == null)
                return { result: bi_x.negate(), remainder: BigInteger.Zero };
            var sign_result = (bi_x._sign > 0) == (bi_y._sign > 0) ? +1 : -1;
            var c = BigInteger.compareAbs(bi_x, bi_y);
            if (c == 0)
                return { result: sign_result > 0 ? BigInteger.One : BigInteger.MinusOne, remainder: BigInteger.Zero };
            if (c < 0)
                return { result: BigInteger.Zero, remainder: bi_x };
            var bits_result = new Array();
            var bits_rem = new Array();
            Array.copy(bi_x._bits, 0, bits_rem, 0, bi_x._bits.length);
            var df = bi_y._bits[bi_y._bits.length - 1];
            for (var i = bi_x._bits.length - 1; i >= bi_y._bits.length - 1; i--) {
                var offset = i - bi_y._bits.length + 1;
                var d = bits_rem[i] + (bits_rem[i + 1] || 0) * DV;
                var max = Math.floor(d / df);
                if (max > DM)
                    max = DM;
                var min = 0;
                while (min != max) {
                    var bits_sub_1 = new Array(offset + bi_y._bits.length);
                    for (var i_1 = 0; i_1 < offset; i_1++)
                        bits_sub_1[i_1] = 0;
                    bits_result[offset] = Math.ceil((min + max) / 2);
                    BigInteger.multiplyTo(bi_y._bits, [bits_result[offset]], bits_sub_1, offset);
                    if (BigInteger.subtractTo(bits_rem, bits_sub_1))
                        max = bits_result[offset] - 1;
                    else
                        min = bits_result[offset];
                }
                var bits_sub = new Array(offset + bi_y._bits.length);
                for (var i_2 = 0; i_2 < offset; i_2++)
                    bits_sub[i_2] = 0;
                bits_result[offset] = min;
                BigInteger.multiplyTo(bi_y._bits, [bits_result[offset]], bits_sub, offset);
                BigInteger.subtractTo(bits_rem, bits_sub, bits_rem);
            }
            return { result: BigInteger.create(sign_result, bits_result, true), remainder: BigInteger.create(bi_x._sign, bits_rem, true) };
        };
        BigInteger.equals = function (x, y) {
            var bi_x = typeof x === "number" ? new BigInteger(x) : x;
            var bi_y = typeof y === "number" ? new BigInteger(y) : y;
            if (bi_x._sign != bi_y._sign)
                return false;
            if (bi_x._bits.length != bi_y._bits.length)
                return false;
            for (var i = 0; i < bi_x._bits.length; i++)
                if (bi_x._bits[i] != bi_y._bits[i])
                    return false;
            return true;
        };
        BigInteger.prototype.equals = function (other) {
            return BigInteger.equals(this, other);
        };
        BigInteger.fromString = function (str, radix) {
            if (radix === void 0) { radix = 10; }
            var bi = Object.create(BigInteger.prototype);
            bi.fromString(str, radix);
            return bi;
        };
        BigInteger.prototype.fromString = function (str, radix) {
            if (radix === void 0) { radix = 10; }
            if (radix < 2 || radix > 36)
                throw new RangeError();
            if (str.length == 0) {
                this._sign == 0;
                this._bits = [];
                return;
            }
            var bits_radix = [radix];
            var bits_a = [0];
            var first = str.charCodeAt(0);
            var withsign = first == 0x2b || first == 0x2d;
            this._sign = first == 0x2d ? -1 : +1;
            this._bits = [];
            for (var i = withsign ? 1 : 0; i < str.length; i++) {
                bits_a[0] = str.charCodeAt(i);
                if (bits_a[0] >= 0x30 && bits_a[0] <= 0x39)
                    bits_a[0] -= 0x30;
                else if (bits_a[0] >= 0x41 && bits_a[0] <= 0x5a)
                    bits_a[0] -= 0x37;
                else if (bits_a[0] >= 0x61 && bits_a[0] <= 0x7a)
                    bits_a[0] -= 0x57;
                else
                    throw new RangeError();
                var bits_temp = new Array();
                BigInteger.multiplyTo(this._bits, bits_radix, bits_temp);
                BigInteger.addTo(bits_temp, bits_a, this._bits);
            }
            this.clamp();
        };
        BigInteger.fromUint8Array = function (arr, sign, littleEndian) {
            if (sign === void 0) { sign = 1; }
            if (littleEndian === void 0) { littleEndian = true; }
            var bi = Object.create(BigInteger.prototype);
            bi.fromUint8Array(arr, sign, littleEndian);
            return bi;
        };
        BigInteger.prototype.fromUint8Array = function (arr, sign, littleEndian) {
            if (sign === void 0) { sign = 1; }
            if (littleEndian === void 0) { littleEndian = true; }
            if (!littleEndian) {
                var arr_new = new Uint8Array(arr.length);
                for (var i = 0; i < arr.length; i++)
                    arr_new[arr.length - 1 - i] = arr[i];
                arr = arr_new;
            }
            var actual_length = BigInteger.getActualLength(arr);
            var bits = actual_length * 8;
            var units = Math.ceil(bits / DB);
            this._bits = [];
            for (var i = 0; i < units; i++) {
                var cb = i * DB;
                var cu = Math.floor(cb / 8);
                cb %= 8;
                this._bits[i] = ((arr[cu] | arr[cu + 1] << 8 | arr[cu + 2] << 16 | arr[cu + 3] << 24) >>> cb) & DM;
            }
            this._sign = sign < 0 ? -1 : +1;
            this.clamp();
        };
        BigInteger.prototype.fromUint64 = function (i, sign) {
            while (i.bits[0] != 0 || i.bits[1] != 0) {
                this._bits.push(i.toUint32() & DM);
                i = i.rightShift(DB);
            }
            this._sign = sign;
            this.clamp();
        };
        BigInteger.getActualLength = function (arr) {
            var actual_length = arr.length;
            for (var i = arr.length - 1; i >= 0; i--)
                if (arr[i] != 0) {
                    actual_length = i + 1;
                    break;
                }
            return actual_length;
        };
        BigInteger.getDoubleParts = function (dbl) {
            var uu = new Uint32Array(2);
            new Float64Array(uu.buffer)[0] = dbl;
            var result = {
                sign: 1 - ((uu[1] >>> 30) & 2),
                man: new Neo.Uint64(uu[0], uu[1] & 0x000FFFFF),
                exp: (uu[1] >>> 20) & 0x7FF,
                fFinite: true
            };
            if (result.exp == 0) {
                if (!result.man.equals(Neo.Uint64.Zero))
                    result.exp = -1074;
            }
            else if (result.exp == 0x7FF) {
                result.fFinite = false;
            }
            else {
                result.man = result.man.or(new Neo.Uint64(0, 0x00100000));
                result.exp -= 1075;
            }
            return result;
        };
        BigInteger.prototype.getLowestSetBit = function () {
            if (this._sign == 0)
                return -1;
            var w = 0;
            while (this._bits[w] == 0)
                w++;
            for (var x = 0; x < DB; x++)
                if ((this._bits[w] & 1 << x) > 0)
                    return x + w * DB;
        };
        BigInteger.prototype.isEven = function () {
            if (this._sign == 0)
                return true;
            return (this._bits[0] & 1) == 0;
        };
        BigInteger.prototype.isZero = function () {
            return this._sign == 0;
        };
        BigInteger.prototype.leftShift = function (shift) {
            if (shift == 0)
                return this;
            var shift_units = Math.floor(shift / DB);
            shift %= DB;
            var bits_new = new Array(this._bits.length + shift_units);
            if (shift == 0) {
                for (var i = 0; i < this._bits.length; i++)
                    bits_new[i + shift_units] = this._bits[i];
            }
            else {
                for (var i = shift_units; i < bits_new.length; i++)
                    bits_new[i] = (this._bits[i - shift_units] << shift | this._bits[i - shift_units - 1] >>> (DB - shift)) & DM;
                bits_new[bits_new.length] = this._bits[this._bits.length - 1] >>> (DB - shift) & DM;
            }
            return BigInteger.create(this._sign, bits_new, true);
        };
        BigInteger.mod = function (x, y) {
            var bi_x = typeof x === "number" ? new BigInteger(x) : x;
            var bi_y = typeof y === "number" ? new BigInteger(y) : y;
            var bi_new = BigInteger.divRem(bi_x, bi_y).remainder;
            if (bi_new._sign < 0)
                bi_new = BigInteger.add(bi_new, bi_y);
            return bi_new;
        };
        BigInteger.prototype.mod = function (other) {
            return BigInteger.mod(this, other);
        };
        BigInteger.modInverse = function (value, modulus) {
            var a = typeof value === "number" ? new BigInteger(value) : value;
            var n = typeof modulus === "number" ? new BigInteger(modulus) : modulus;
            var i = n, v = BigInteger.Zero, d = BigInteger.One;
            while (a._sign > 0) {
                var t = BigInteger.divRem(i, a);
                var x = d;
                i = a;
                a = t.remainder;
                d = v.subtract(t.result.multiply(x));
                v = x;
            }
            return BigInteger.mod(v, n);
        };
        BigInteger.prototype.modInverse = function (modulus) {
            return BigInteger.modInverse(this, modulus);
        };
        BigInteger.modPow = function (value, exponent, modulus) {
            var bi_v = typeof value === "number" ? new BigInteger(value) : value;
            var bi_e = typeof exponent === "number" ? new BigInteger(exponent) : exponent;
            var bi_m = typeof modulus === "number" ? new BigInteger(modulus) : modulus;
            if (bi_e._sign < 0 || bi_m._sign == 0)
                throw new RangeError();
            if (Math.abs(bi_m._sign) == 1 && bi_m._bits == null)
                return BigInteger.Zero;
            var h = bi_e.bitLength();
            var bi_new = BigInteger.One;
            for (var i = 0; i < h; i++) {
                if (i > 0)
                    bi_v = BigInteger.multiply(bi_v, bi_v);
                bi_v = bi_v.remainder(bi_m);
                if (bi_e.testBit(i))
                    bi_new = BigInteger.multiply(bi_v, bi_new).remainder(bi_m);
            }
            if (bi_new._sign < 0)
                bi_new = BigInteger.add(bi_new, bi_m);
            return bi_new;
        };
        BigInteger.prototype.modPow = function (exponent, modulus) {
            return BigInteger.modPow(this, exponent, modulus);
        };
        BigInteger.multiply = function (x, y) {
            var bi_x = typeof x === "number" ? new BigInteger(x) : x;
            var bi_y = typeof y === "number" ? new BigInteger(y) : y;
            if (bi_x._sign == 0)
                return bi_x;
            if (bi_y._sign == 0)
                return bi_y;
            if (bi_x._sign == 1 && bi_x._bits == null)
                return bi_y;
            if (bi_x._sign == -1 && bi_x._bits == null)
                return bi_y.negate();
            if (bi_y._sign == 1 && bi_y._bits == null)
                return bi_x;
            if (bi_y._sign == -1 && bi_y._bits == null)
                return bi_x.negate();
            var bits_r = new Array();
            BigInteger.multiplyTo(bi_x._bits, bi_y._bits, bits_r);
            return BigInteger.create((bi_x._sign > 0) == (bi_y._sign > 0) ? +1 : -1, bits_r);
        };
        BigInteger.prototype.multiply = function (other) {
            return BigInteger.multiply(this, other);
        };
        BigInteger.multiplyTo = function (x, y, r, offset) {
            if (offset === void 0) { offset = 0; }
            if (x.length > y.length) {
                var t = x;
                x = y;
                y = t;
            }
            for (var i = x.length + y.length - 2; i >= 0; i--)
                r[i + offset] = 0;
            for (var i = 0; i < x.length; i++) {
                if (x[i] == 0)
                    continue;
                for (var j = 0; j < y.length; j++) {
                    var c = x[i] * y[j];
                    if (c == 0)
                        continue;
                    var k = i + j;
                    do {
                        c += r[k + offset] || 0;
                        r[k + offset] = c & DM;
                        c = Math.floor(c / DV);
                        k++;
                    } while (c > 0);
                }
            }
        };
        BigInteger.prototype.negate = function () {
            return BigInteger.create(-this._sign, this._bits);
        };
        BigInteger.parse = function (str) {
            return BigInteger.fromString(str);
        };
        BigInteger.pow = function (value, exponent) {
            var bi_v = typeof value === "number" ? new BigInteger(value) : value;
            if (exponent < 0 || exponent > 0x7fffffff)
                throw new RangeError();
            if (exponent == 0)
                return BigInteger.One;
            if (exponent == 1)
                return bi_v;
            if (bi_v._sign == 0)
                return bi_v;
            if (bi_v._bits.length == 1) {
                if (bi_v._bits[0] == 1)
                    return bi_v;
                if (bi_v._bits[0] == -1)
                    return (exponent & 1) != 0 ? bi_v : BigInteger.One;
            }
            var h = BigInteger.bitLengthInternal(exponent);
            var bi_new = BigInteger.One;
            for (var i = 0; i < h; i++) {
                var e = 1 << i;
                if (e > 1)
                    bi_v = BigInteger.multiply(bi_v, bi_v);
                if ((exponent & e) != 0)
                    bi_new = BigInteger.multiply(bi_v, bi_new);
            }
            return bi_new;
        };
        BigInteger.prototype.pow = function (exponent) {
            return BigInteger.pow(this, exponent);
        };
        BigInteger.random = function (bitLength, rng) {
            if (bitLength == 0)
                return BigInteger.Zero;
            var bytes = new Uint8Array(Math.ceil(bitLength / 8));
            if (rng == null) {
                for (var i = 0; i < bytes.length; i++)
                    bytes[i] = Math.random() * 256;
            }
            else {
                rng.getRandomValues(bytes);
            }
            bytes[bytes.length - 1] &= 0xff >>> (8 - bitLength % 8);
            return new BigInteger(bytes);
        };
        BigInteger.remainder = function (x, y) {
            var bi_x = typeof x === "number" ? new BigInteger(x) : x;
            var bi_y = typeof y === "number" ? new BigInteger(y) : y;
            return BigInteger.divRem(bi_x, bi_y).remainder;
        };
        BigInteger.prototype.remainder = function (other) {
            return BigInteger.remainder(this, other);
        };
        BigInteger.prototype.rightShift = function (shift) {
            if (shift == 0)
                return this;
            var shift_units = Math.floor(shift / DB);
            shift %= DB;
            if (this._bits.length <= shift_units)
                return BigInteger.Zero;
            var bits_new = new Array(this._bits.length - shift_units);
            if (shift == 0) {
                for (var i = 0; i < bits_new.length; i++)
                    bits_new[i] = this._bits[i + shift_units];
            }
            else {
                for (var i = 0; i < bits_new.length; i++)
                    bits_new[i] = (this._bits[i + shift_units] >>> shift | this._bits[i + shift_units + 1] << (DB - shift)) & DM;
            }
            return BigInteger.create(this._sign, bits_new, true);
        };
        BigInteger.prototype.sign = function () {
            return this._sign;
        };
        BigInteger.subtract = function (x, y) {
            var bi_x = typeof x === "number" ? new BigInteger(x) : x;
            var bi_y = typeof y === "number" ? new BigInteger(y) : y;
            if (bi_x._sign == 0)
                return bi_y.negate();
            if (bi_y._sign == 0)
                return bi_x;
            if ((bi_x._sign > 0) != (bi_y._sign > 0))
                return BigInteger.add(bi_x, bi_y.negate());
            var c = BigInteger.compareAbs(bi_x, bi_y);
            if (c == 0)
                return BigInteger.Zero;
            if (c < 0)
                return BigInteger.subtract(bi_y, bi_x).negate();
            var bits_r = new Array();
            BigInteger.subtractTo(bi_x._bits, bi_y._bits, bits_r);
            return BigInteger.create(bi_x._sign, bits_r, true);
        };
        BigInteger.prototype.subtract = function (other) {
            return BigInteger.subtract(this, other);
        };
        BigInteger.subtractTo = function (x, y, r) {
            if (r == null)
                r = [];
            var l = Math.min(x.length, y.length);
            var c = 0, i = 0;
            while (i < l) {
                c += x[i] - y[i];
                r[i++] = c & DM;
                c >>= DB;
            }
            if (x.length < y.length)
                while (i < y.length) {
                    c -= y[i];
                    r[i++] = c & DM;
                    c >>= DB;
                }
            else
                while (i < x.length) {
                    c += x[i];
                    r[i++] = c & DM;
                    c >>= DB;
                }
            return c < 0;
        };
        BigInteger.prototype.testBit = function (n) {
            var units = Math.floor(n / DB);
            if (this._bits.length <= units)
                return false;
            return (this._bits[units] & (1 << (n %= DB))) != 0;
        };
        BigInteger.prototype.toInt32 = function () {
            if (this._sign == 0)
                return 0;
            if (this._bits.length == 1)
                return this._bits[0] * this._sign;
            return ((this._bits[0] | this._bits[1] * DV) & 0x7fffffff) * this._sign;
        };
        BigInteger.prototype.toString = function (radix) {
            if (radix === void 0) { radix = 10; }
            if (this._sign == 0)
                return "0";
            if (radix < 2 || radix > 36)
                throw new RangeError();
            var s = "";
            for (var bi = this; bi._sign != 0;) {
                var r = BigInteger.divRem(bi, radix);
                var rem = Math.abs(r.remainder.toInt32());
                if (rem < 10)
                    rem += 0x30;
                else
                    rem += 0x57;
                s = String.fromCharCode(rem) + s;
                bi = r.result;
            }
            if (this._sign < 0)
                s = "-" + s;
            return s;
        };
        BigInteger.prototype.toUint8Array = function (littleEndian, length) {
            if (littleEndian === void 0) { littleEndian = true; }
            if (this._sign == 0)
                return new Uint8Array(length || 1);
            var cb = Math.ceil(this._bits.length * DB / 8);
            var array = new Uint8Array(length || cb);
            for (var i = 0; i < array.length; i++) {
                var offset = littleEndian ? i : array.length - 1 - i;
                var cbits = i * 8;
                var cu = Math.floor(cbits / DB);
                cbits %= DB;
                if (DB - cbits < 8)
                    array[offset] = (this._bits[cu] >>> cbits | this._bits[cu + 1] << (DB - cbits)) & 0xff;
                else
                    array[offset] = this._bits[cu] >>> cbits & 0xff;
            }
            length = length || BigInteger.getActualLength(array);
            if (length < array.length)
                array = array.subarray(0, length);
            return array;
        };
        return BigInteger;
    } ());
    Neo.BigInteger = BigInteger;
})(Neo || (Neo = {}));
var Neo;
(function (Neo) {
    var D = 100000000;
    var _max, _minus, _min, _one, _satoshi;
    var Fixed8 = (function () {
        function Fixed8(data) {
            this.data = data;
            if (data.bits[1] >= 0x80000000 && (data.bits[0] != 0xffffffff || data.bits[1] != 0xffffffff))
                throw new RangeError();
        }
        Object.defineProperty(Fixed8, "MaxValue", {
            get: function () { return _max || (_max = new Fixed8(new Neo.Uint64(0xffffffff, 0x7fffffff))); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Fixed8, "MinusOne", {
            get: function () { return _minus || (_minus = new Fixed8(new Neo.Uint64(0xffffffff, 0xffffffff))); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Fixed8, "MinValue", {
            get: function () { return _min || (_min = new Fixed8(Neo.Uint64.MinValue)); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Fixed8, "One", {
            get: function () { return _one || (_one = Fixed8.fromNumber(1)); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Fixed8, "Satoshi", {
            get: function () { return _satoshi || (_satoshi = new Fixed8(new Neo.Uint64(1))); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Fixed8, "Zero", {
            get: function () { return Fixed8.MinValue; },
            enumerable: true,
            configurable: true
        });
        Fixed8.prototype.add = function (other) {
            var result = this.data.add(other.data);
            if (result.compareTo(this.data) < 0)
                throw new Error();
            return new Fixed8(result);
        };
        Fixed8.prototype.compareTo = function (other) {
            return this.data.compareTo(other.data);
        };
        Fixed8.prototype.equals = function (other) {
            return this.data.equals(other.data);
        };
        Fixed8.fromNumber = function (value) {
            if (value < 0)
                throw new RangeError();
            value *= D;
            if (value >= 0x8000000000000000)
                throw new RangeError();
            var array = new Uint32Array((new Neo.BigInteger(value)).toUint8Array(true, 8).buffer);
            return new Fixed8(new Neo.Uint64(array[0], array[1]));
        };
        Fixed8.prototype.getData = function () {
            return this.data;
        };
        Fixed8.max = function (first) {
            var others = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                others[_i - 1] = arguments[_i];
            }
            for (var i = 0; i < others.length; i++)
                if (first.compareTo(others[i]) < 0)
                    first = others[i];
            return first;
        };
        Fixed8.min = function (first) {
            var others = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                others[_i - 1] = arguments[_i];
            }
            for (var i = 0; i < others.length; i++)
                if (first.compareTo(others[i]) > 0)
                    first = others[i];
            return first;
        };
        Fixed8.parse = function (str) {
            var dot = str.indexOf('.');
            var digits = dot >= 0 ? str.length - dot - 1 : 0;
            str = str.replace('.', '');
            if (digits > 8)
                str = str.substr(0, str.length - digits + 8);
            else if (digits < 8)
                for (var i = digits; i < 8; i++)
                    str += '0';
            return new Fixed8(Neo.Uint64.parse(str));
        };
        Fixed8.prototype.subtract = function (other) {
            if (this.data.compareTo(other.data) < 0)
                throw new Error();
            return new Fixed8(this.data.subtract(other.data));
        };
        Fixed8.prototype.toString = function () {
            var str = this.data.toString();
            while (str.length <= 8)
                str = '0' + str;
            str = str.substr(0, str.length - 8) + '.' + str.substr(str.length - 8);
            var e = 0;
            for (var i = str.length - 1; i >= 0; i--)
                if (str[i] == '0')
                    e++;
                else
                    break;
            str = str.substr(0, str.length - e);
            if (str[str.length - 1] == '.')
                str = str.substr(0, str.length - 1);
            return str;
        };
        Fixed8.prototype.deserialize = function (reader) {
            this.data = reader.readUint64();
        };
        Fixed8.prototype.serialize = function (writer) {
            writer.writeUint64(this.getData());
        };
        return Fixed8;
    } ());
    Neo.Fixed8 = Fixed8;
})(Neo || (Neo = {}));
Array.copy = function (src, srcOffset, dst, dstOffset, count) {
    for (var i = 0; i < count; i++)
        dst[i + dstOffset] = src[i + srcOffset];
};
Array.fromArray = function (arr) {
    var array = new Array(arr.length);
    for (var i = 0; i < array.length; i++)
        array[i] = arr[i];
    return array;
};
Uint8Array.fromArrayBuffer = function (buffer) {
    if (buffer instanceof Uint8Array)
        return buffer;
    else if (buffer instanceof ArrayBuffer)
        return new Uint8Array(buffer);
    else {
        var view = buffer;
        return new Uint8Array(view.buffer, view.byteOffset, view.byteLength);
    }
};
String.prototype.hexToBytes = function () {
    if ((this.length & 1) != 0)
        throw new RangeError();
    var str = this;
    if (this.length >= 2 && this[0] == '0' && this[1] == 'x')
        str = this.substr(2);
    var bytes = new Uint8Array(str.length / 2);
    for (var i = 0; i < bytes.length; i++) {
        bytes[i] = parseInt(str.substr(i * 2, 2), 16);
    }
    return bytes;
};
ArrayBuffer.prototype.slice = ArrayBuffer.prototype.slice || function (begin, end) {
    if (end === void 0) { end = this.byteLength; }
    if (begin < 0)
        begin += this.byteLength;
    if (begin < 0)
        begin = 0;
    if (end < 0)
        end += this.byteLength;
    if (end > this.byteLength)
        end = this.byteLength;
    var length = end - begin;
    if (length < 0)
        length = 0;
    var src = new Uint8Array(this);
    var dst = new Uint8Array(length);
    for (var i = 0; i < length; i++)
        dst[i] = src[i + begin];
    return dst.buffer;
};
Uint8Array.prototype.toHexString = function () {
    var s = "";
    for (var i = 0; i < this.length; i++) {
        s += (this[i] >>> 4).toString(16);
        s += (this[i] & 0xf).toString(16);
    }
    return s;
};
Uint8Array.prototype.clone = function () {
    var u8 = new Uint8Array(this.length);
    for (var i = 0; i < this.length; i++)
        u8[i] = this[i];
    return u8;
};
void function () {
    function fillArray(value, start, end) {
        if (start === void 0) { start = 0; }
        if (end === void 0) { end = this.length; }
        if (start < 0)
            start += this.length;
        if (start < 0)
            start = 0;
        if (start >= this.length)
            return this;
        if (end < 0)
            end += this.length;
        if (end < 0)
            return this;
        if (end > this.length)
            end = this.length;
        for (var i = start; i < end; i++)
            this[i] = value;
        return this;
    }
    Array.prototype.fill = Array.prototype.fill || fillArray;
    Int8Array.prototype.fill = Int8Array.prototype.fill || fillArray;
    Int16Array.prototype.fill = Int16Array.prototype.fill || fillArray;
    Int32Array.prototype.fill = Int32Array.prototype.fill || fillArray;
    Uint8Array.prototype.fill = Uint8Array.prototype.fill || fillArray;
    Uint16Array.prototype.fill = Uint16Array.prototype.fill || fillArray;
    Uint32Array.prototype.fill = Uint32Array.prototype.fill || fillArray;
} ();
var NeoMap = (function () {
    function NeoMap() {
        this._map = new Object();
        this._size = 0;
    }
    Object.defineProperty(NeoMap.prototype, "size", {
        get: function () { return this._size; },
        enumerable: true,
        configurable: true
    });
    NeoMap.prototype.clear = function () {
        for (var key in this._map)
            delete this._map[key];
        this._size = 0;
    };
    NeoMap.prototype.delete = function (key) {
        if (!this._map.hasOwnProperty(key))
            return false;
        this._size--;
        return delete this._map[key];
    };
    NeoMap.prototype.forEach = function (callback) {
        for (var key in this._map)
            callback(this._map[key], key, this);
    };
    NeoMap.prototype.get = function (key) {
        return this._map[key];
    };
    NeoMap.prototype.has = function (key) {
        return this._map.hasOwnProperty(key);
    };
    NeoMap.prototype.set = function (key, value) {
        if (!this._map.hasOwnProperty(key))
            this._size++;
        this._map[key] = value;
    };
    return NeoMap;
} ());
var PromiseState;
(function (PromiseState) {
    PromiseState[PromiseState["pending"] = 0] = "pending";
    PromiseState[PromiseState["fulfilled"] = 1] = "fulfilled";
    PromiseState[PromiseState["rejected"] = 2] = "rejected";
})(PromiseState || (PromiseState = {}));
var NeoPromise = (function () {
    function NeoPromise(executor) {
        this._state = PromiseState.pending;
        this._callback_attached = false;
        if (executor != null)
            executor(this.resolve.bind(this), this.reject.bind(this));
    }
    NeoPromise.all = function (iterable) {
        return new NeoPromise(function (resolve, reject) {
            if (iterable.length == 0) {
                resolve([]);
                return;
            }
            var results = new Array(iterable.length);
            var rejected = false;
            var onFulfilled = function (result) {
                results[this._tag] = result;
                for (var i = 0; i < iterable.length; i++)
                    if (iterable[i]._state != PromiseState.fulfilled)
                        return;
                resolve(results);
            };
            var onRejected = function (reason) {
                if (!rejected) {
                    rejected = true;
                    reject(reason);
                }
            };
            for (var i = 0; i < iterable.length; i++) {
                iterable[i]._tag = i;
                iterable[i].then(onFulfilled, onRejected);
            }
        });
    };
    NeoPromise.prototype.catch = function (onRejected) {
        return this.then(null, onRejected);
    };
    NeoPromise.prototype.checkState = function () {
        if (this._state != PromiseState.pending && this._callback_attached) {
            var callback = this._state == PromiseState.fulfilled ? this._onFulfilled : this._onRejected;
            var arg = this._state == PromiseState.fulfilled ? this._value : this._reason;
            var value = void 0, reason = void 0;
            try {
                value = callback == null ? this : callback.call(this, arg);
            }
            catch (ex) {
                reason = ex;
            }
            if (this._next_promise == null) {
                if (reason != null)
                    return NeoPromise.reject(reason);
                else if (value instanceof NeoPromise)
                    return value;
                else
                    return NeoPromise.resolve(value);
            }
            else {
                if (reason != null)
                    this._next_promise.reject(reason);
                else if (value instanceof NeoPromise)
                    value.then(this.resolve.bind(this._next_promise), this.reject.bind(this._next_promise));
                else
                    this._next_promise.resolve(value);
            }
        }
    };
    NeoPromise.prototype.reject = function (reason) {
        this._state = PromiseState.rejected;
        this._reason = reason;
        this.checkState();
    };
    NeoPromise.reject = function (reason) {
        return new NeoPromise(function (resolve, reject) { return reject(reason); });
    };
    NeoPromise.prototype.resolve = function (value) {
        this._state = PromiseState.fulfilled;
        this._value = value;
        this.checkState();
    };
    NeoPromise.resolve = function (value) {
        if (value instanceof NeoPromise)
            return value;
        return new NeoPromise(function (resolve, reject) { return resolve(value); });
    };
    NeoPromise.prototype.then = function (onFulfilled, onRejected) {
        this._onFulfilled = onFulfilled;
        this._onRejected = onRejected;
        this._callback_attached = true;
        if (this._state == PromiseState.pending) {
            this._next_promise = new NeoPromise(null);
            return this._next_promise;
        }
        else {
            return this.checkState();
        }
    };
    return NeoPromise;
} ());
var Neo;
(function (Neo) {
    var _zero;
    var Uint160 = (function (_super) {
        __extends(Uint160, _super);
        function Uint160(value) {
            var _this = this;
            if (value == null)
                value = new ArrayBuffer(20);
            if (value.byteLength != 20)
                throw new RangeError();
            _this = _super.call(this, new Uint32Array(value)) || this;
            return _this;
        }
        Object.defineProperty(Uint160, "Zero", {
            get: function () { return _zero || (_zero = new Uint160()); },
            enumerable: true,
            configurable: true
        });
        Uint160.parse = function (str) {
            if (str.length != 40)
                throw new RangeError();
            var x = str.hexToBytes();
            var y = new Uint8Array(x.length);
            for (var i = 0; i < y.length; i++)
                y[i] = x[x.length - i - 1];
            return new Uint160(y.buffer);
        };
        return Uint160;
    } (Neo.UintVariable));
    Neo.Uint160 = Uint160;
})(Neo || (Neo = {}));
var Neo;
(function (Neo) {
    var _zero;
    var Uint256 = (function (_super) {
        __extends(Uint256, _super);
        function Uint256(value) {
            var _this = this;
            if (value == null)
                value = new ArrayBuffer(32);
            if (value.byteLength != 32)
                throw new RangeError();
            _this = _super.call(this, new Uint32Array(value)) || this;
            return _this;
        }
        Object.defineProperty(Uint256, "Zero", {
            get: function () { return _zero || (_zero = new Uint256()); },
            enumerable: true,
            configurable: true
        });
        Uint256.parse = function (str) {
            if (str.length != 64)
                throw new RangeError();
            var x = str.hexToBytes();
            var y = new Uint8Array(x.length);
            for (var i = 0; i < y.length; i++)
                y[i] = x[x.length - i - 1];
            return new Uint256(y.buffer);
        };
        return Uint256;
    } (Neo.UintVariable));
    Neo.Uint256 = Uint256;
})(Neo || (Neo = {}));
var ThinNeo;
(function (ThinNeo) {
    var contract = (function () {
        function contract() {
            this.parameters = [{ "name": "parameter0", "type": "Signature" }];
            this.deployed = false;
        }
        return contract;
    } ());
    ThinNeo.contract = contract;
    var nep6account = (function () {
        function nep6account() {
        }
        nep6account.prototype.getPrivateKey = function (scrypt, password, callback) {
            var _this = this;
            var cb = function (i, r) {
                if (i == "finish") {
                    var bytes = r;
                    var pkey = ThinNeo.Helper.GetPublicKeyFromPrivateKey(bytes);
                    var address = ThinNeo.Helper.GetAddressFromPublicKey(pkey);
                    if (address == _this.address) {
                        callback(i, r);
                    }
                    else {
                        callback("error", "checkerror");
                    }
                }
                else {
                    callback(i, r);
                }
            };
            ThinNeo.Helper.GetPrivateKeyFromNep2(this.nep2key, password, scrypt.N, scrypt.r, scrypt.p, cb);
        };
        return nep6account;
    } ());
    ThinNeo.nep6account = nep6account;
    var nep6ScryptParameters = (function () {
        function nep6ScryptParameters() {
        }
        return nep6ScryptParameters;
    } ());
    ThinNeo.nep6ScryptParameters = nep6ScryptParameters;
    var nep6wallet = (function () {
        function nep6wallet() {
        }
        nep6wallet.prototype.fromJsonStr = function (jsonstr) {
            var json = JSON.parse(jsonstr);
            this.scrypt = new nep6ScryptParameters();
            this.scrypt.N = json.scrypt.n;
            this.scrypt.r = json.scrypt.r;
            this.scrypt.p = json.scrypt.p;
            this.accounts = [];
            for (var i = 0; i < json.accounts.length; i++) {
                var acc = json.accounts[i];
                var localacc = new nep6account();
                localacc.address = acc.address;
                localacc.nep2key = acc.key;
                localacc.contract = acc.contract;
                if (localacc.contract == null || localacc.contract.script == null) {
                    localacc.nep2key = null;
                }
                else {
                    var ss = localacc.contract.script.hexToBytes();
                    if (ss.length != 35 || ss[0] != 33 || ss[34] != 172) {
                        localacc.nep2key = null;
                    }
                }
                if (acc.key == undefined)
                    localacc.nep2key = null;
                this.accounts.push(localacc);
            }
        };
        nep6wallet.prototype.toJson = function () {
            var obj = {};
            obj["name"] = null;
            obj["version"] = "1.0";
            obj["scrypt"] = {
                "n": this.scrypt.N,
                "r": this.scrypt.r,
                "p": this.scrypt.p
            };
            var accounts = [];
            for (var i = 0; i < this.accounts.length; i++) {
                var acc = this.accounts[0];
                var jsonacc = {};
                jsonacc["address"] = acc.address;
                jsonacc["label"] = null;
                jsonacc["isDefault"] = false;
                jsonacc["lock"] = false;
                jsonacc["key"] = acc.nep2key;
                jsonacc["extra"] = null;
                jsonacc["contract"] = acc.contract;
                accounts.push(jsonacc);
            }
            obj["accounts"] = accounts;
            obj["extra"] = null;
            return obj;
        };
        return nep6wallet;
    } ());
    ThinNeo.nep6wallet = nep6wallet;
})(ThinNeo || (ThinNeo = {}));
var ThinNeo;
(function (ThinNeo) {
    var Base64 = (function () {
        function Base64() {
        }
        Base64.init = function () {
            if (Base64.binited)
                return;
            Base64.lookup = [];
            Base64.revLookup = [];
            for (var i = 0, len = Base64.code.length; i < len; ++i) {
                Base64.lookup[i] = Base64.code[i];
                Base64.revLookup[Base64.code.charCodeAt(i)] = i;
            }
            Base64.revLookup['-'.charCodeAt(0)] = 62;
            Base64.revLookup['_'.charCodeAt(0)] = 63;
            Base64.binited = true;
        };
        Base64.placeHoldersCount = function (b64) {
            var len = b64.length;
            if (len % 4 > 0) {
                throw new Error('Invalid string. Length must be a multiple of 4');
            }
            return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0;
        };
        Base64.byteLength = function (b64) {
            return (b64.length * 3 / 4) - Base64.placeHoldersCount(b64);
        };
        Base64.toByteArray = function (b64) {
            Base64.init();
            var i, l, tmp, placeHolders, arr;
            var len = b64.length;
            placeHolders = Base64.placeHoldersCount(b64);
            arr = new Uint8Array((len * 3 / 4) - placeHolders);
            l = placeHolders > 0 ? len - 4 : len;
            var L = 0;
            for (i = 0; i < l; i += 4) {
                tmp = (Base64.revLookup[b64.charCodeAt(i)] << 18) | (Base64.revLookup[b64.charCodeAt(i + 1)] << 12) | (Base64.revLookup[b64.charCodeAt(i + 2)] << 6) | Base64.revLookup[b64.charCodeAt(i + 3)];
                arr[L++] = (tmp >> 16) & 0xFF;
                arr[L++] = (tmp >> 8) & 0xFF;
                arr[L++] = tmp & 0xFF;
            }
            if (placeHolders === 2) {
                tmp = (Base64.revLookup[b64.charCodeAt(i)] << 2) | (Base64.revLookup[b64.charCodeAt(i + 1)] >> 4);
                arr[L++] = tmp & 0xFF;
            }
            else if (placeHolders === 1) {
                tmp = (Base64.revLookup[b64.charCodeAt(i)] << 10) | (Base64.revLookup[b64.charCodeAt(i + 1)] << 4) | (Base64.revLookup[b64.charCodeAt(i + 2)] >> 2);
                arr[L++] = (tmp >> 8) & 0xFF;
                arr[L++] = tmp & 0xFF;
            }
            return arr;
        };
        Base64.tripletToBase64 = function (num) {
            return Base64.lookup[num >> 18 & 0x3F] + Base64.lookup[num >> 12 & 0x3F] + Base64.lookup[num >> 6 & 0x3F] + Base64.lookup[num & 0x3F];
        };
        Base64.encodeChunk = function (uint8, start, end) {
            var tmp;
            var output = [];
            for (var i = start; i < end; i += 3) {
                tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);
                output.push(Base64.tripletToBase64(tmp));
            }
            return output.join('');
        };
        Base64.fromByteArray = function (uint8) {
            Base64.init();
            var tmp;
            var len = uint8.length;
            var extraBytes = len % 3;
            var output = '';
            var parts = [];
            var maxChunkLength = 16383;
            for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
                parts.push(Base64.encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)));
            }
            if (extraBytes === 1) {
                tmp = uint8[len - 1];
                output += Base64.lookup[tmp >> 2];
                output += Base64.lookup[(tmp << 4) & 0x3F];
                output += '==';
            }
            else if (extraBytes === 2) {
                tmp = (uint8[len - 2] << 8) + (uint8[len - 1]);
                output += Base64.lookup[tmp >> 10];
                output += Base64.lookup[(tmp >> 4) & 0x3F];
                output += Base64.lookup[(tmp << 2) & 0x3F];
                output += '=';
            }
            parts.push(output);
            return parts.join('');
        };
        Base64.lookup = [];
        Base64.revLookup = [];
        Base64.code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
        Base64.binited = false;
        return Base64;
    } ());
    ThinNeo.Base64 = Base64;
})(ThinNeo || (ThinNeo = {}));
var ThinNeo;
(function (ThinNeo) {
    var scrypt_loaded = false;
    var Helper = (function () {
        function Helper() {
        }
        Helper.GetPrivateKeyFromWIF = function (wif) {
            if (wif == null)
                throw new Error("null wif");
            var data = Neo.Cryptography.Base58.decode(wif);
            if (data.length != 38 || data[0] != 0x80 || data[33] != 0x01)
                throw new Error("wif length or tag is error");
            var sum = data.subarray(data.length - 4, data.length);
            var realdata = data.subarray(0, data.length - 4);
            var _checksum = Neo.Cryptography.Sha256.computeHash(realdata);
            var checksum = new Uint8Array(Neo.Cryptography.Sha256.computeHash(_checksum));
            var sumcalc = checksum.subarray(0, 4);
            for (var i = 0; i < 4; i++) {
                if (sum[i] != sumcalc[i])
                    throw new Error("the sum is not match.");
            }
            var privateKey = data.subarray(1, 1 + 32);
            return privateKey;
        };
        Helper.GetWifFromPrivateKey = function (prikey) {
            var data = new Uint8Array(38);
            data[0] = 0x80;
            data[33] = 0x01;
            for (var i = 0; i < 32; i++) {
                data[i + 1] = prikey[i];
            }
            var realdata = data.subarray(0, data.length - 4);
            var _checksum = Neo.Cryptography.Sha256.computeHash(realdata);
            var checksum = new Uint8Array(Neo.Cryptography.Sha256.computeHash(_checksum));
            for (var i = 0; i < 4; i++) {
                data[34 + i] = checksum[i];
            }
            var wif = Neo.Cryptography.Base58.encode(data);
            return wif;
        };
        Helper.GetPublicKeyFromPrivateKey = function (privateKey) {
            var pkey = Neo.Cryptography.ECPoint.multiply(Neo.Cryptography.ECCurve.secp256r1.G, privateKey);
            return pkey.encodePoint(true);
        };
        Helper.Hash160 = function (data) {
            var hash1 = Neo.Cryptography.Sha256.computeHash(data);
            var hash2 = Neo.Cryptography.RIPEMD160.computeHash(hash1);
            return new Uint8Array(hash2);
        };
        Helper.GetAddressCheckScriptFromPublicKey = function (publicKey) {
            var script = new Uint8Array(publicKey.length + 2);
            script[0] = publicKey.length;
            for (var i = 0; i < publicKey.length; i++) {
                script[i + 1] = publicKey[i];
            }
            ;
            script[script.length - 1] = 172;
            return script;
        };
        Helper.GetPublicKeyScriptHashFromPublicKey = function (publicKey) {
            var script = Helper.GetAddressCheckScriptFromPublicKey(publicKey);
            var scripthash = Neo.Cryptography.Sha256.computeHash(script);
            scripthash = Neo.Cryptography.RIPEMD160.computeHash(scripthash);
            return new Uint8Array(scripthash);
        };
        Helper.GetScriptHashFromScript = function (script) {
            var scripthash = Neo.Cryptography.Sha256.computeHash(script);
            scripthash = Neo.Cryptography.RIPEMD160.computeHash(scripthash);
            return new Uint8Array(scripthash);
        };
        Helper.GetAddressFromScriptHash = function (scripthash) {
            var data = new Uint8Array(scripthash.length + 1);
            data[0] = 0x17;
            for (var i = 0; i < scripthash.length; i++) {
                data[i + 1] = scripthash[i];
            }
            var hash = Neo.Cryptography.Sha256.computeHash(data);
            hash = Neo.Cryptography.Sha256.computeHash(hash);
            var hashu8 = new Uint8Array(hash, 0, 4);
            var alldata = new Uint8Array(data.length + 4);
            for (var i = 0; i < data.length; i++) {
                alldata[i] = data[i];
            }
            for (var i = 0; i < 4; i++) {
                alldata[data.length + i] = hashu8[i];
            }
            return Neo.Cryptography.Base58.encode(alldata);
        };
        Helper.GetAddressFromPublicKey = function (publicKey) {
            var scripthash = Helper.GetPublicKeyScriptHashFromPublicKey(publicKey);
            return Helper.GetAddressFromScriptHash(scripthash);
        };
        Helper.GetPublicKeyScriptHash_FromAddress = function (address) {
            var array = Neo.Cryptography.Base58.decode(address);
            var salt = array.subarray(0, 1);
            var hash = array.subarray(1, 1 + 20);
            var check = array.subarray(21, 21 + 4);
            var checkdata = array.subarray(0, 21);
            var hashd = Neo.Cryptography.Sha256.computeHash(checkdata);
            hashd = Neo.Cryptography.Sha256.computeHash(hashd);
            var hashd = hashd.slice(0, 4);
            var checked = new Uint8Array(hashd);
            for (var i = 0; i < 4; i++) {
                if (checked[i] != check[i]) {
                    throw new Error("the sum is not match.");
                }
            }
            return hash.clone();
        };
        Helper.Sign = function (message, privateKey) {
            var PublicKey = Neo.Cryptography.ECPoint.multiply(Neo.Cryptography.ECCurve.secp256r1.G, privateKey);
            var pubkey = PublicKey.encodePoint(false).subarray(1, 64);
            var key = new Neo.Cryptography.ECDsaCryptoKey(PublicKey, privateKey);
            var ecdsa = new Neo.Cryptography.ECDsa(key);
            {
                return new Uint8Array(ecdsa.sign(message));
            }
        };
        Helper.VerifySignature = function (message, signature, pubkey) {
            var PublicKey = Neo.Cryptography.ECPoint.decodePoint(pubkey, Neo.Cryptography.ECCurve.secp256r1);
            var usepk = PublicKey.encodePoint(false).subarray(1, 64);
            var key = new Neo.Cryptography.ECDsaCryptoKey(PublicKey);
            var ecdsa = new Neo.Cryptography.ECDsa(key);
            {
                return ecdsa.verify(message, signature);
            }
        };
        Helper.String2Bytes = function (str) {
            var back = [];
            var byteSize = 0;
            for (var i = 0; i < str.length; i++) {
                var code = str.charCodeAt(i);
                if (0x00 <= code && code <= 0x7f) {
                    byteSize += 1;
                    back.push(code);
                }
                else if (0x80 <= code && code <= 0x7ff) {
                    byteSize += 2;
                    back.push((192 | (31 & (code >> 6))));
                    back.push((128 | (63 & code)));
                }
                else if ((0x800 <= code && code <= 0xd7ff)
                    || (0xe000 <= code && code <= 0xffff)) {
                    byteSize += 3;
                    back.push((224 | (15 & (code >> 12))));
                    back.push((128 | (63 & (code >> 6))));
                    back.push((128 | (63 & code)));
                }
            }
            var uarr = new Uint8Array(back.length);
            for (i = 0; i < back.length; i++) {
                uarr[i] = back[i] & 0xff;
            }
            return uarr;
        };
        Helper.Bytes2String = function (_arr) {
            var UTF = '';
            for (var i = 0; i < _arr.length; i++) {
                var one = _arr[i].toString(2), v = one.match(/^1+?(?=0)/);
                if (v && one.length == 8) {
                    var bytesLength = v[0].length;
                    var store = _arr[i].toString(2).slice(7 - bytesLength);
                    for (var st = 1; st < bytesLength; st++) {
                        store += _arr[st + i].toString(2).slice(2);
                    }
                    UTF += String.fromCharCode(parseInt(store, 2));
                    i += bytesLength - 1;
                }
                else {
                    UTF += String.fromCharCode(_arr[i]);
                }
            }
            return UTF;
        };
        Helper.Aes256Encrypt = function (src, key) {
            var srcs = CryptoJS.enc.Utf8.parse(src);
            var keys = CryptoJS.enc.Utf8.parse(key);
            var encryptedkey = CryptoJS.AES.encrypt(srcs, keys, {
                mode: CryptoJS.mode.ECB,
                padding: CryptoJS.pad.NoPadding
            });
            return encryptedkey.ciphertext.toString();
        };
        Helper.Aes256Encrypt_u8 = function (src, key) {
            var srcs = CryptoJS.enc.Utf8.parse("1234123412341234");
            srcs.sigBytes = src.length;
            srcs.words = new Array(src.length / 4);
            for (var i = 0; i < src.length / 4; i++) {
                srcs.words[i] = src[i * 4 + 3] + src[i * 4 + 2] * 256 + src[i * 4 + 1] * 256 * 256 + src[i * 4 + 0] * 256 * 256 * 256;
            }
            var keys = CryptoJS.enc.Utf8.parse("1234123412341234");
            keys.sigBytes = key.length;
            keys.words = new Array(key.length / 4);
            for (var i = 0; i < key.length / 4; i++) {
                keys.words[i] = key[i * 4 + 3] + key[i * 4 + 2] * 256 + key[i * 4 + 1] * 256 * 256 + key[i * 4 + 0] * 256 * 256 * 256;
            }
            var encryptedkey = CryptoJS.AES.encrypt(srcs, keys, {
                mode: CryptoJS.mode.ECB,
                padding: CryptoJS.pad.NoPadding
            });
            var str = encryptedkey.ciphertext.toString();
            return str.hexToBytes();
        };
        Helper.Aes256Decrypt_u8 = function (encryptedkey, key) {
            var keys = CryptoJS.enc.Utf8.parse("1234123412341234");
            keys.sigBytes = key.length;
            keys.words = new Array(key.length / 4);
            for (var i = 0; i < key.length / 4; i++) {
                keys.words[i] = key[i * 4 + 3] + key[i * 4 + 2] * 256 + key[i * 4 + 1] * 256 * 256 + key[i * 4 + 0] * 256 * 256 * 256;
            }
            var base64key = ThinNeo.Base64.fromByteArray(encryptedkey);
            var srcs = CryptoJS.AES.decrypt(base64key, keys, {
                mode: CryptoJS.mode.ECB,
                padding: CryptoJS.pad.NoPadding
            });
            var str = srcs.toString();
            return str.hexToBytes();
        };
        Helper.GetNep2FromPrivateKey = function (prikey, passphrase, n, r, p, callback) {
            if (n === void 0) { n = 16384; }
            if (r === void 0) { r = 8; }
            if (p === void 0) { p = 8; }
            var pp = scrypt.getAvailableMod();
            scrypt.setResPath('asset');//'SDK-BlockChain/neo/lib'
            var addresshash = null;
            var ready = function () {
                var param = {
                    N: n,
                    r: r,
                    P: p
                };
                var opt = {
                    maxPassLen: 32,
                    maxSaltLen: 32,
                    maxDkLen: 64,
                    maxThread: 4
                };
                try {
                    scrypt.config(param, opt);
                }
                catch (err) {
                    console.warn('config err: ', err);
                }
            };
            scrypt.onload = function () {
                console.log("scrypt.onload");
                scrypt_loaded = true;
                ready();
            };
            scrypt.onerror = function (err) {
                console.warn('scrypt err:', err);
                callback("error", err);
            };
            scrypt.oncomplete = function (dk) {
                console.log('done', scrypt.binToHex(dk));
                var u8dk = new Uint8Array(dk);
                var derivedhalf1 = u8dk.subarray(0, 32);
                var derivedhalf2 = u8dk.subarray(32, 64);
                var u8xor = new Uint8Array(32);
                for (var i = 0; i < 32; i++) {
                    u8xor[i] = prikey[i] ^ derivedhalf1[i];
                }
                var encryptedkey = Helper.Aes256Encrypt_u8(u8xor, derivedhalf2);
                var buffer = new Uint8Array(39);
                buffer[0] = 0x01;
                buffer[1] = 0x42;
                buffer[2] = 0xe0;
                for (var i = 3; i < 3 + 4; i++) {
                    buffer[i] = addresshash[i - 3];
                }
                for (var i = 7; i < 32 + 7; i++) {
                    buffer[i] = encryptedkey[i - 7];
                }
                var b1 = Neo.Cryptography.Sha256.computeHash(buffer);
                b1 = Neo.Cryptography.Sha256.computeHash(b1);
                var u8hash = new Uint8Array(b1);
                var outbuf = new Uint8Array(39 + 4);
                for (var i = 0; i < 39; i++) {
                    outbuf[i] = buffer[i];
                }
                for (var i = 39; i < 39 + 4; i++) {
                    outbuf[i] = u8hash[i - 39];
                }
                var base58str = Neo.Cryptography.Base58.encode(outbuf);
                callback("finish", base58str);
            };
            scrypt.onprogress = function (percent) {
                console.log('onprogress');
            };
            scrypt.onready = function () {
                var pubkey = Helper.GetPublicKeyFromPrivateKey(prikey);
                var script_hash = Helper.GetPublicKeyScriptHashFromPublicKey(pubkey);
                var address = Helper.GetAddressFromScriptHash(script_hash);
                var addrbin = scrypt.strToBin(address);
                var b1 = Neo.Cryptography.Sha256.computeHash(addrbin);
                b1 = Neo.Cryptography.Sha256.computeHash(b1);
                var b2 = new Uint8Array(b1);
                addresshash = b2.subarray(0, 4);
                var passbin = scrypt.strToBin(passphrase);
                scrypt.hash(passbin, addresshash, 64);
            };
            if (scrypt_loaded == false) {
                scrypt.load("asmjs");
            }
            else {
                ready();
            }
            return;
        };
        Helper.GetPrivateKeyFromNep2 = function (nep2, passphrase, n, r, p, callback) {
            if (n === void 0) { n = 16384; }
            if (r === void 0) { r = 8; }
            if (p === void 0) { p = 8; }
            var data = Neo.Cryptography.Base58.decode(nep2);
            if (data.length != 39 + 4) {
                callback("error", "data.length error");
                return;
            }
            if (data[0] != 0x01 || data[1] != 0x42 || data[2] != 0xe0) {
                callback("error", "dataheader error");
                return;
            }
            var hash = data.subarray(39, 39 + 4);
            var buffer = data.subarray(0, 39);
            var b1 = Neo.Cryptography.Sha256.computeHash(buffer);
            b1 = Neo.Cryptography.Sha256.computeHash(b1);
            var u8hash = new Uint8Array(b1);
            for (var i = 0; i < 4; i++) {
                if (u8hash[i] != hash[i]) {
                    callback("error", "data hash error");
                    return;
                }
            }
            var addresshash = buffer.subarray(3, 3 + 4);
            var encryptedkey = buffer.subarray(7, 7 + 32);
            var pp = scrypt.getAvailableMod();
           scrypt.setResPath('asset');//'SDK-BlockChain/neo/lib'
            var ready = function () {
                var param = {
                    N: n,
                    r: r,
                    P: p
                };
                var opt = {
                    maxPassLen: 32,
                    maxSaltLen: 32,
                    maxDkLen: 64,
                    maxThread: 4
                };
                try {
                    scrypt.config(param, opt);
                }
                catch (err) {
                    console.warn('config err: ', err);
                }
            };
            scrypt.onload = function () {
                console.log("scrypt.onload");
                scrypt_loaded = true;
                ready();
            };
            scrypt.oncomplete = function (dk) {
                console.log('done', scrypt.binToHex(dk));
                var u8dk = new Uint8Array(dk);
                var derivedhalf1 = u8dk.subarray(0, 32);
                var derivedhalf2 = u8dk.subarray(32, 64);
                var u8xor = Helper.Aes256Decrypt_u8(encryptedkey, derivedhalf2);
                var prikey = new Uint8Array(u8xor.length);
                for (var i = 0; i < 32; i++) {
                    prikey[i] = u8xor[i] ^ derivedhalf1[i];
                }
                var pubkey = Helper.GetPublicKeyFromPrivateKey(prikey);
                var script_hash = Helper.GetPublicKeyScriptHashFromPublicKey(pubkey);
                var address = Helper.GetAddressFromScriptHash(script_hash);
                var addrbin = scrypt.strToBin(address);
                var b1 = Neo.Cryptography.Sha256.computeHash(addrbin);
                b1 = Neo.Cryptography.Sha256.computeHash(b1);
                var b2 = new Uint8Array(b1);
                var addresshashgot = b2.subarray(0, 4);
                for (var i = 0; i < 4; i++) {
                    if (addresshash[i] != b2[i]) {
                        callback("error", "nep2 hash not match.");
                        return;
                    }
                }
                callback("finish", prikey);
            };
            scrypt.onerror = function (err) {
                console.warn('scrypt err:', err);
                callback("error", err);
            };
            scrypt.onprogress = function (percent) {
                console.log('onprogress');
            };
            scrypt.onready = function () {
                var passbin = scrypt.strToBin(passphrase);
                scrypt.hash(passbin, addresshash, 64);
            };
            if (scrypt_loaded == false) {
                scrypt.load("asmjs");
            }
            else {
                ready();
            }
        };
        return Helper;
    } ());
    ThinNeo.Helper = Helper;
})(ThinNeo || (ThinNeo = {}));
var ThinNeo;
(function (ThinNeo) {
    var OpCode;
    (function (OpCode) {
        OpCode[OpCode["PUSH0"] = 0] = "PUSH0";
        OpCode[OpCode["PUSHF"] = 0] = "PUSHF";
        OpCode[OpCode["PUSHBYTES1"] = 1] = "PUSHBYTES1";
        OpCode[OpCode["PUSHBYTES75"] = 75] = "PUSHBYTES75";
        OpCode[OpCode["PUSHDATA1"] = 76] = "PUSHDATA1";
        OpCode[OpCode["PUSHDATA2"] = 77] = "PUSHDATA2";
        OpCode[OpCode["PUSHDATA4"] = 78] = "PUSHDATA4";
        OpCode[OpCode["PUSHM1"] = 79] = "PUSHM1";
        OpCode[OpCode["PUSH1"] = 81] = "PUSH1";
        OpCode[OpCode["PUSHT"] = 81] = "PUSHT";
        OpCode[OpCode["PUSH2"] = 82] = "PUSH2";
        OpCode[OpCode["PUSH3"] = 83] = "PUSH3";
        OpCode[OpCode["PUSH4"] = 84] = "PUSH4";
        OpCode[OpCode["PUSH5"] = 85] = "PUSH5";
        OpCode[OpCode["PUSH6"] = 86] = "PUSH6";
        OpCode[OpCode["PUSH7"] = 87] = "PUSH7";
        OpCode[OpCode["PUSH8"] = 88] = "PUSH8";
        OpCode[OpCode["PUSH9"] = 89] = "PUSH9";
        OpCode[OpCode["PUSH10"] = 90] = "PUSH10";
        OpCode[OpCode["PUSH11"] = 91] = "PUSH11";
        OpCode[OpCode["PUSH12"] = 92] = "PUSH12";
        OpCode[OpCode["PUSH13"] = 93] = "PUSH13";
        OpCode[OpCode["PUSH14"] = 94] = "PUSH14";
        OpCode[OpCode["PUSH15"] = 95] = "PUSH15";
        OpCode[OpCode["PUSH16"] = 96] = "PUSH16";
        OpCode[OpCode["NOP"] = 97] = "NOP";
        OpCode[OpCode["JMP"] = 98] = "JMP";
        OpCode[OpCode["JMPIF"] = 99] = "JMPIF";
        OpCode[OpCode["JMPIFNOT"] = 100] = "JMPIFNOT";
        OpCode[OpCode["CALL"] = 101] = "CALL";
        OpCode[OpCode["RET"] = 102] = "RET";
        OpCode[OpCode["APPCALL"] = 103] = "APPCALL";
        OpCode[OpCode["SYSCALL"] = 104] = "SYSCALL";
        OpCode[OpCode["TAILCALL"] = 105] = "TAILCALL";
        OpCode[OpCode["DUPFROMALTSTACK"] = 106] = "DUPFROMALTSTACK";
        OpCode[OpCode["TOALTSTACK"] = 107] = "TOALTSTACK";
        OpCode[OpCode["FROMALTSTACK"] = 108] = "FROMALTSTACK";
        OpCode[OpCode["XDROP"] = 109] = "XDROP";
        OpCode[OpCode["XSWAP"] = 114] = "XSWAP";
        OpCode[OpCode["XTUCK"] = 115] = "XTUCK";
        OpCode[OpCode["DEPTH"] = 116] = "DEPTH";
        OpCode[OpCode["DROP"] = 117] = "DROP";
        OpCode[OpCode["DUP"] = 118] = "DUP";
        OpCode[OpCode["NIP"] = 119] = "NIP";
        OpCode[OpCode["OVER"] = 120] = "OVER";
        OpCode[OpCode["PICK"] = 121] = "PICK";
        OpCode[OpCode["ROLL"] = 122] = "ROLL";
        OpCode[OpCode["ROT"] = 123] = "ROT";
        OpCode[OpCode["SWAP"] = 124] = "SWAP";
        OpCode[OpCode["TUCK"] = 125] = "TUCK";
        OpCode[OpCode["CAT"] = 126] = "CAT";
        OpCode[OpCode["SUBSTR"] = 127] = "SUBSTR";
        OpCode[OpCode["LEFT"] = 128] = "LEFT";
        OpCode[OpCode["RIGHT"] = 129] = "RIGHT";
        OpCode[OpCode["SIZE"] = 130] = "SIZE";
        OpCode[OpCode["INVERT"] = 131] = "INVERT";
        OpCode[OpCode["AND"] = 132] = "AND";
        OpCode[OpCode["OR"] = 133] = "OR";
        OpCode[OpCode["XOR"] = 134] = "XOR";
        OpCode[OpCode["EQUAL"] = 135] = "EQUAL";
        OpCode[OpCode["INC"] = 139] = "INC";
        OpCode[OpCode["DEC"] = 140] = "DEC";
        OpCode[OpCode["SIGN"] = 141] = "SIGN";
        OpCode[OpCode["NEGATE"] = 143] = "NEGATE";
        OpCode[OpCode["ABS"] = 144] = "ABS";
        OpCode[OpCode["NOT"] = 145] = "NOT";
        OpCode[OpCode["NZ"] = 146] = "NZ";
        OpCode[OpCode["ADD"] = 147] = "ADD";
        OpCode[OpCode["SUB"] = 148] = "SUB";
        OpCode[OpCode["MUL"] = 149] = "MUL";
        OpCode[OpCode["DIV"] = 150] = "DIV";
        OpCode[OpCode["MOD"] = 151] = "MOD";
        OpCode[OpCode["SHL"] = 152] = "SHL";
        OpCode[OpCode["SHR"] = 153] = "SHR";
        OpCode[OpCode["BOOLAND"] = 154] = "BOOLAND";
        OpCode[OpCode["BOOLOR"] = 155] = "BOOLOR";
        OpCode[OpCode["NUMEQUAL"] = 156] = "NUMEQUAL";
        OpCode[OpCode["NUMNOTEQUAL"] = 158] = "NUMNOTEQUAL";
        OpCode[OpCode["LT"] = 159] = "LT";
        OpCode[OpCode["GT"] = 160] = "GT";
        OpCode[OpCode["LTE"] = 161] = "LTE";
        OpCode[OpCode["GTE"] = 162] = "GTE";
        OpCode[OpCode["MIN"] = 163] = "MIN";
        OpCode[OpCode["MAX"] = 164] = "MAX";
        OpCode[OpCode["WITHIN"] = 165] = "WITHIN";
        OpCode[OpCode["SHA1"] = 167] = "SHA1";
        OpCode[OpCode["SHA256"] = 168] = "SHA256";
        OpCode[OpCode["HASH160"] = 169] = "HASH160";
        OpCode[OpCode["HASH256"] = 170] = "HASH256";
        OpCode[OpCode["CSHARPSTRHASH32"] = 171] = "CSHARPSTRHASH32";
        OpCode[OpCode["JAVAHASH32"] = 173] = "JAVAHASH32";
        OpCode[OpCode["CHECKSIG"] = 172] = "CHECKSIG";
        OpCode[OpCode["CHECKMULTISIG"] = 174] = "CHECKMULTISIG";
        OpCode[OpCode["ARRAYSIZE"] = 192] = "ARRAYSIZE";
        OpCode[OpCode["PACK"] = 193] = "PACK";
        OpCode[OpCode["UNPACK"] = 194] = "UNPACK";
        OpCode[OpCode["PICKITEM"] = 195] = "PICKITEM";
        OpCode[OpCode["SETITEM"] = 196] = "SETITEM";
        OpCode[OpCode["NEWARRAY"] = 197] = "NEWARRAY";
        OpCode[OpCode["NEWSTRUCT"] = 198] = "NEWSTRUCT";
        OpCode[OpCode["SWITCH"] = 208] = "SWITCH";
        OpCode[OpCode["THROW"] = 240] = "THROW";
        OpCode[OpCode["THROWIFNOT"] = 241] = "THROWIFNOT";
    })(OpCode = ThinNeo.OpCode || (ThinNeo.OpCode = {}));
})(ThinNeo || (ThinNeo = {}));
var ThinNeo;
(function (ThinNeo) {
    var ScriptBuilder = (function () {
        function ScriptBuilder() {
            this.Offset = 0;
            this.writer = [];
        }
        ScriptBuilder.prototype._WriteUint8 = function (num) {
            this.writer.push(num);
            this.Offset++;
        };
        ScriptBuilder.prototype._WriteUint16 = function (num) {
            var buf = new Uint8Array(2);
            var d = new DataView(buf.buffer, 0, 2);
            d.setUint16(0, num, true);
            this.writer.push(buf[0]);
            this.writer.push(buf[1]);
            this.Offset += 2;
        };
        ScriptBuilder.prototype._WriteUint32 = function (num) {
            var buf = new Uint8Array(4);
            var d = new DataView(buf.buffer, 0, 4);
            d.setUint32(0, num, true);
            this.writer.push(buf[0]);
            this.writer.push(buf[1]);
            this.writer.push(buf[2]);
            this.writer.push(buf[3]);
            this.Offset += 4;
        };
        ScriptBuilder.prototype._WriteUint8Array = function (nums) {
            for (var i = 0; i < nums.length; i++)
                this.writer.push(nums[i]);
            this.Offset += nums.length;
        };
        ScriptBuilder.prototype._ConvertInt16ToBytes = function (num) {
            var buf = new Uint8Array(2);
            var d = new DataView(buf.buffer, 0, 2);
            d.setInt16(0, num, true);
            return buf;
        };
        ScriptBuilder.prototype.Emit = function (op, arg) {
            if (arg === void 0) { arg = null; }
            this._WriteUint8(op);
            if (arg != null)
                this._WriteUint8Array(arg);
            return this;
        };
        ScriptBuilder.prototype.EmitAppCall = function (scriptHash, useTailCall) {
            if (useTailCall === void 0) { useTailCall = false; }
            if (scriptHash.length != 20)
                throw new Error("error scriptHash length");
            return this.Emit(useTailCall ? ThinNeo.OpCode.TAILCALL : ThinNeo.OpCode.APPCALL, scriptHash);
        };
        ScriptBuilder.prototype.EmitJump = function (op, offset) {
            if (op != ThinNeo.OpCode.JMP && op != ThinNeo.OpCode.JMPIF && op != ThinNeo.OpCode.JMPIFNOT && op != ThinNeo.OpCode.CALL)
                throw new Error("ArgumentException");
            return this.Emit(op, this._ConvertInt16ToBytes(offset));
        };
        ScriptBuilder.prototype.EmitPushNumber = function (number) {
            var i32 = number.toInt32();
            if (i32 == -1)
                return this.Emit(ThinNeo.OpCode.PUSHM1);
            if (i32 == 0)
                return this.Emit(ThinNeo.OpCode.PUSH0);
            if (i32 > 0 && i32 <= 16)
                return this.Emit(ThinNeo.OpCode.PUSH1 - 1 + i32);
            return this.EmitPushBytes(number.toUint8Array(true));
        };
        ScriptBuilder.prototype.EmitPushBool = function (data) {
            return this.Emit(data ? ThinNeo.OpCode.PUSHT : ThinNeo.OpCode.PUSHF);
        };
        ScriptBuilder.prototype.EmitPushBytes = function (data) {
            if (data == null)
                throw new Error("ArgumentNullException");
            if (data.length <= ThinNeo.OpCode.PUSHBYTES75) {
                this._WriteUint8(data.length);
                this._WriteUint8Array(data);
            }
            else if (data.length < 0x100) {
                this.Emit(ThinNeo.OpCode.PUSHDATA1);
                this._WriteUint8(data.length);
                this._WriteUint8Array(data);
            }
            else if (data.length < 0x10000) {
                this.Emit(ThinNeo.OpCode.PUSHDATA2);
                this._WriteUint16(data.length);
                this._WriteUint8Array(data);
            }
            else {
                this.Emit(ThinNeo.OpCode.PUSHDATA4);
                this._WriteUint32(data.length);
                this._WriteUint8Array(data);
            }
            return this;
        };
        ScriptBuilder.prototype.EmitPushString = function (data) {
            return this.EmitPushBytes(ThinNeo.Helper.String2Bytes(data));
        };
        ScriptBuilder.prototype.EmitSysCall = function (api) {
            if (api == null)
                throw new Error("ArgumentNullException");
            var api_bytes = ThinNeo.Helper.String2Bytes(api);
            if (api_bytes.length == 0 || api_bytes.length > 252)
                throw new Error("ArgumentException");
            var arg = new Uint8Array(api_bytes.length + 1);
            arg[0] = api_bytes.length;
            for (var i = 0; i < api_bytes.length; i++) {
                arg[i + 1] = api_bytes[i];
            }
            return this.Emit(ThinNeo.OpCode.SYSCALL, arg);
        };
        ScriptBuilder.prototype.ToArray = function () {
            var array = new Uint8Array(this.writer.length);
            for (var i = 0; i < this.writer.length; i++) {
                array[i] = this.writer[i];
            }
            return array;
        };
        ScriptBuilder.prototype.EmitParamJson = function (param) {
            if (typeof param === "number") {
                this.EmitPushNumber(new Neo.BigInteger(param));
            }
            else if (typeof param === "boolean") {
                this.EmitPushBool(param);
            }
            else if (typeof param === "object") {
                var list = param;
                for (var i = list.length - 1; i >= 0; i--) {
                    this.EmitParamJson(list[i]);
                }
                this.EmitPushNumber(new Neo.BigInteger(list.length));
                this.Emit(ThinNeo.OpCode.PACK);
            }
            else if (typeof param === "string") {
                var str = param;
                if (str[0] != '(')
                    throw new Error("must start with:(str) or (hex) or (hexrev) or (addr)or(int)");
                if (str.indexOf("(string)") == 0) {
                    this.EmitPushString(str.substr(8));
                }
                if (str.indexOf("(str)") == 0) {
                    this.EmitPushString(str.substr(5));
                }
                else if (str.indexOf("(bytes)") == 0) {
                    var hex = str.substr(7).hexToBytes();
                    this.EmitPushBytes(hex);
                }
                else if (str.indexOf("([])") == 0) {
                    var hex = str.substr(4).hexToBytes();
                    this.EmitPushBytes(hex);
                }
                else if (str.indexOf("(address)") == 0) {
                    var addr = (str.substr(9));
                    var hex = ThinNeo.Helper.GetPublicKeyScriptHash_FromAddress(addr);
                    this.EmitPushBytes(hex);
                }
                else if (str.indexOf("(addr)") == 0) {
                    var addr = (str.substr(6));
                    var hex = ThinNeo.Helper.GetPublicKeyScriptHash_FromAddress(addr);
                    this.EmitPushBytes(hex);
                }
                else if (str.indexOf("(integer)") == 0) {
                    var num = new Neo.BigInteger(str.substr(9));
                    this.EmitPushNumber(num);
                }
                else if (str.indexOf("(int)") == 0) {
                    var num = new Neo.BigInteger(str.substr(5));
                    this.EmitPushNumber(num);
                }
                else if (str.indexOf("(hexinteger)") == 0) {
                    var hex = str.substr(12).hexToBytes();
                    this.EmitPushBytes(hex.reverse());
                }
                else if (str.indexOf("(hexint)") == 0) {
                    var hex = str.substr(8).hexToBytes();
                    this.EmitPushBytes(hex.reverse());
                }
                else if (str.indexOf("(hex)") == 0) {
                    var hex = str.substr(5).hexToBytes();
                    this.EmitPushBytes(hex.reverse());
                }
                else if (str.indexOf("(int256)") == 0 || str.indexOf("(hex256)") == 0) {
                    var hex = str.substr(8).hexToBytes();
                    if (hex.length != 32)
                        throw new Error("not a int256");
                    this.EmitPushBytes(hex.reverse());
                }
                else if (str.indexOf("(int160)") == 0 || str.indexOf("(hex160)") == 0) {
                    var hex = str.substr(8).hexToBytes();
                    if (hex.length != 20)
                        throw new Error("not a int160");
                    this.EmitPushBytes(hex.reverse());
                }
                else
                    throw new Error("must start with:(str) or (hex) or (hexbig) or (addr) or(int)");
            }
            else {
                throw new Error("error type:" + typeof param);
            }
            return this;
        };
        return ScriptBuilder;
    } ());
    ThinNeo.ScriptBuilder = ScriptBuilder;
})(ThinNeo || (ThinNeo = {}));
var ThinNeo;
(function (ThinNeo) {
    var TransactionType;
    (function (TransactionType) {
        TransactionType[TransactionType["MinerTransaction"] = 0] = "MinerTransaction";
        TransactionType[TransactionType["IssueTransaction"] = 1] = "IssueTransaction";
        TransactionType[TransactionType["ClaimTransaction"] = 2] = "ClaimTransaction";
        TransactionType[TransactionType["EnrollmentTransaction"] = 32] = "EnrollmentTransaction";
        TransactionType[TransactionType["RegisterTransaction"] = 64] = "RegisterTransaction";
        TransactionType[TransactionType["ContractTransaction"] = 128] = "ContractTransaction";
        TransactionType[TransactionType["PublishTransaction"] = 208] = "PublishTransaction";
        TransactionType[TransactionType["InvocationTransaction"] = 209] = "InvocationTransaction";
    })(TransactionType = ThinNeo.TransactionType || (ThinNeo.TransactionType = {}));
    var TransactionAttributeUsage;
    (function (TransactionAttributeUsage) {
        TransactionAttributeUsage[TransactionAttributeUsage["ContractHash"] = 0] = "ContractHash";
        TransactionAttributeUsage[TransactionAttributeUsage["ECDH02"] = 2] = "ECDH02";
        TransactionAttributeUsage[TransactionAttributeUsage["ECDH03"] = 3] = "ECDH03";
        TransactionAttributeUsage[TransactionAttributeUsage["Script"] = 32] = "Script";
        TransactionAttributeUsage[TransactionAttributeUsage["Vote"] = 48] = "Vote";
        TransactionAttributeUsage[TransactionAttributeUsage["DescriptionUrl"] = 129] = "DescriptionUrl";
        TransactionAttributeUsage[TransactionAttributeUsage["Description"] = 144] = "Description";
        TransactionAttributeUsage[TransactionAttributeUsage["Hash1"] = 161] = "Hash1";
        TransactionAttributeUsage[TransactionAttributeUsage["Hash2"] = 162] = "Hash2";
        TransactionAttributeUsage[TransactionAttributeUsage["Hash3"] = 163] = "Hash3";
        TransactionAttributeUsage[TransactionAttributeUsage["Hash4"] = 164] = "Hash4";
        TransactionAttributeUsage[TransactionAttributeUsage["Hash5"] = 165] = "Hash5";
        TransactionAttributeUsage[TransactionAttributeUsage["Hash6"] = 166] = "Hash6";
        TransactionAttributeUsage[TransactionAttributeUsage["Hash7"] = 167] = "Hash7";
        TransactionAttributeUsage[TransactionAttributeUsage["Hash8"] = 168] = "Hash8";
        TransactionAttributeUsage[TransactionAttributeUsage["Hash9"] = 169] = "Hash9";
        TransactionAttributeUsage[TransactionAttributeUsage["Hash10"] = 170] = "Hash10";
        TransactionAttributeUsage[TransactionAttributeUsage["Hash11"] = 171] = "Hash11";
        TransactionAttributeUsage[TransactionAttributeUsage["Hash12"] = 172] = "Hash12";
        TransactionAttributeUsage[TransactionAttributeUsage["Hash13"] = 173] = "Hash13";
        TransactionAttributeUsage[TransactionAttributeUsage["Hash14"] = 174] = "Hash14";
        TransactionAttributeUsage[TransactionAttributeUsage["Hash15"] = 175] = "Hash15";
        TransactionAttributeUsage[TransactionAttributeUsage["Remark"] = 240] = "Remark";
        TransactionAttributeUsage[TransactionAttributeUsage["Remark1"] = 241] = "Remark1";
        TransactionAttributeUsage[TransactionAttributeUsage["Remark2"] = 242] = "Remark2";
        TransactionAttributeUsage[TransactionAttributeUsage["Remark3"] = 243] = "Remark3";
        TransactionAttributeUsage[TransactionAttributeUsage["Remark4"] = 244] = "Remark4";
        TransactionAttributeUsage[TransactionAttributeUsage["Remark5"] = 245] = "Remark5";
        TransactionAttributeUsage[TransactionAttributeUsage["Remark6"] = 246] = "Remark6";
        TransactionAttributeUsage[TransactionAttributeUsage["Remark7"] = 247] = "Remark7";
        TransactionAttributeUsage[TransactionAttributeUsage["Remark8"] = 248] = "Remark8";
        TransactionAttributeUsage[TransactionAttributeUsage["Remark9"] = 249] = "Remark9";
        TransactionAttributeUsage[TransactionAttributeUsage["Remark10"] = 250] = "Remark10";
        TransactionAttributeUsage[TransactionAttributeUsage["Remark11"] = 251] = "Remark11";
        TransactionAttributeUsage[TransactionAttributeUsage["Remark12"] = 252] = "Remark12";
        TransactionAttributeUsage[TransactionAttributeUsage["Remark13"] = 253] = "Remark13";
        TransactionAttributeUsage[TransactionAttributeUsage["Remark14"] = 254] = "Remark14";
        TransactionAttributeUsage[TransactionAttributeUsage["Remark15"] = 255] = "Remark15";
    })(TransactionAttributeUsage = ThinNeo.TransactionAttributeUsage || (ThinNeo.TransactionAttributeUsage = {}));
    var Attribute = (function () {
        function Attribute() {
        }
        return Attribute;
    } ());
    ThinNeo.Attribute = Attribute;
    var TransactionOutput = (function () {
        function TransactionOutput() {
        }
        return TransactionOutput;
    } ());
    ThinNeo.TransactionOutput = TransactionOutput;
    var TransactionInput = (function () {
        function TransactionInput() {
        }
        return TransactionInput;
    } ());
    ThinNeo.TransactionInput = TransactionInput;
    var Witness = (function () {
        function Witness() {
        }
        Object.defineProperty(Witness.prototype, "Address", {
            get: function () {
                var hash = ThinNeo.Helper.GetScriptHashFromScript(this.VerificationScript);
                return ThinNeo.Helper.GetAddressFromScriptHash(hash);
            },
            enumerable: true,
            configurable: true
        });
        return Witness;
    } ());
    ThinNeo.Witness = Witness;
    var InvokeTransData = (function () {
        function InvokeTransData() {
        }
        InvokeTransData.prototype.Serialize = function (trans, writer) {
            writer.writeVarBytes(this.script.buffer);
            if (trans.version >= 1) {
                writer.writeUint64(this.gas.getData());
            }
        };
        InvokeTransData.prototype.Deserialize = function (trans, reader) {
            var buf = reader.readVarBytes(10000000);
            this.script = new Uint8Array(buf, 0, buf.byteLength);
            if (trans.version >= 1) {
                this.gas = new Neo.Fixed8(reader.readUint64());
            }
        };
        return InvokeTransData;
    } ());
    ThinNeo.InvokeTransData = InvokeTransData;
    var ClaimTransData = (function () {
        function ClaimTransData() {
        }
        ClaimTransData.prototype.Serialize = function (trans, writer) {
            writer.writeVarInt(this.claims.length);
            for (var i = 0; i < this.claims.length; i++) {
                writer.write(this.claims[i].hash, 0, 32);
                writer.writeUint16(this.claims[i].index);
            }
        };
        ClaimTransData.prototype.Deserialize = function (trans, reader) {
            var countClaims = reader.readVarInt();
            this.claims = [];
            for (var i = 0; i < countClaims; i++) {
                this.claims.push(new TransactionInput());
                var arr = reader.readBytes(32);
                this.claims[i].hash = new Uint8Array(arr, 0, arr.byteLength);
                this.claims[i].index = reader.readUint16();
            }
        };
        return ClaimTransData;
    } ());
    ThinNeo.ClaimTransData = ClaimTransData;
    var MinerTransData = (function () {
        function MinerTransData() {
        }
        MinerTransData.prototype.Serialize = function (trans, writer) {
            writer.writeUint32(this.nonce);
        };
        MinerTransData.prototype.Deserialize = function (trans, reader) {
            this.nonce = reader.readUint32();
        };
        return MinerTransData;
    } ());
    ThinNeo.MinerTransData = MinerTransData;
    var Transaction = (function () {
        function Transaction() {
        }
        Transaction.prototype.SerializeUnsigned = function (writer) {
            writer.writeByte(this.type);
            writer.writeByte(this.version);
            if (this.type == TransactionType.ContractTransaction ||
                this.type == TransactionType.IssueTransaction) {
            }
            else if (this.type == TransactionType.InvocationTransaction) {
                this.extdata.Serialize(this, writer);
            }
            else if (this.type == TransactionType.ClaimTransaction) {
                this.extdata.Serialize(this, writer);
            }
            else if (this.type == TransactionType.MinerTransaction) {
                this.extdata.Serialize(this, writer);
            }
            else {
                throw new Error("未编写针对这个交易类型的代码");
            }
            var countAttributes = this.attributes.length;
            writer.writeVarInt(countAttributes);
            for (var i = 0; i < countAttributes; i++) {
                var attributeData = this.attributes[i].data;
                var Usage = this.attributes[i].usage;
                writer.writeByte(Usage);
                if (Usage == TransactionAttributeUsage.ContractHash || Usage == TransactionAttributeUsage.Vote || (Usage >= TransactionAttributeUsage.Hash1 && Usage <= TransactionAttributeUsage.Hash15)) {
                    writer.write(attributeData.buffer, 0, 32);
                }
                else if (Usage == TransactionAttributeUsage.ECDH02 || Usage == TransactionAttributeUsage.ECDH03) {
                    writer.write(attributeData.buffer, 1, 32);
                }
                else if (Usage == TransactionAttributeUsage.Script) {
                    writer.write(attributeData.buffer, 0, 20);
                }
                else if (Usage == TransactionAttributeUsage.DescriptionUrl) {
                    var len = attributeData.length;
                    writer.writeByte(len);
                    writer.write(attributeData.buffer, 0, len);
                }
                else if (Usage == TransactionAttributeUsage.Description || Usage >= TransactionAttributeUsage.Remark) {
                    var len = attributeData.length;
                    writer.writeVarInt(len);
                    writer.write(attributeData.buffer, 0, len);
                }
                else
                    throw new Error();
            }
            var countInputs = this.inputs.length;
            writer.writeVarInt(countInputs);
            for (var i = 0; i < countInputs; i++) {
                writer.write(this.inputs[i].hash, 0, 32);
                writer.writeUint16(this.inputs[i].index);
            }
            var countOutputs = this.outputs.length;
            writer.writeVarInt(countOutputs);
            for (var i = 0; i < countOutputs; i++) {
                var item = this.outputs[i];
                writer.write(item.assetId.buffer, 0, 32);
                writer.writeUint64(item.value.getData());
                writer.write(item.toAddress.buffer, 0, 20);
            }
        };
        Transaction.prototype.Serialize = function (writer) {
            this.SerializeUnsigned(writer);
            var witnesscount = this.witnesses.length;
            writer.writeVarInt(witnesscount);
            for (var i = 0; i < witnesscount; i++) {
                var _witness = this.witnesses[i];
                writer.writeVarBytes(_witness.InvocationScript.buffer);
                writer.writeVarBytes(_witness.VerificationScript.buffer);
            }
        };
        Transaction.prototype.DeserializeUnsigned = function (ms) {
            this.type = ms.readByte();
            this.version = ms.readByte();
            if (this.type == TransactionType.ContractTransaction
                || this.type == TransactionType.IssueTransaction) {
                this.extdata = null;
            }
            else if (this.type == TransactionType.InvocationTransaction) {
                this.extdata = new InvokeTransData();
            }
            else if (this.type == TransactionType.ClaimTransaction) {
                this.extdata = new ClaimTransData();
            }
            else if (this.type == TransactionType.MinerTransaction) {
                this.extdata = new MinerTransData();
            }
            else {
                throw new Error("未编写针对这个交易类型的代码");
            }
            if (this.extdata != null) {
                this.extdata.Deserialize(this, ms);
            }
            var countAttributes = ms.readVarInt();
            this.attributes = [];
            for (var i = 0; i < countAttributes; i++) {
                var attributeData = null;
                var Usage = ms.readByte();
                if (Usage == TransactionAttributeUsage.ContractHash || Usage == TransactionAttributeUsage.Vote || (Usage >= TransactionAttributeUsage.Hash1 && Usage <= TransactionAttributeUsage.Hash15)) {
                    var arr = ms.readBytes(32);
                    attributeData = new Uint8Array(arr, 0, arr.byteLength);
                }
                else if (Usage == TransactionAttributeUsage.ECDH02 || Usage == TransactionAttributeUsage.ECDH03) {
                    var arr = ms.readBytes(32);
                    var data = new Uint8Array(arr, 0, arr.byteLength);
                    attributeData = new Uint8Array(33);
                    attributeData[0] = Usage;
                    for (var i = 0; i < 32; i++) {
                        attributeData[i + 1] = data[i];
                    }
                }
                else if (Usage == TransactionAttributeUsage.Script) {
                    var arr = ms.readBytes(20);
                    attributeData = new Uint8Array(arr, 0, arr.byteLength);
                }
                else if (Usage == TransactionAttributeUsage.DescriptionUrl) {
                    var len = ms.readByte();
                    var arr = ms.readBytes(len);
                    attributeData = new Uint8Array(arr, 0, arr.byteLength);
                }
                else if (Usage == TransactionAttributeUsage.Description || Usage >= TransactionAttributeUsage.Remark) {
                    var len = ms.readVarInt(65535);
                    var arr = ms.readBytes(len);
                    attributeData = new Uint8Array(arr, 0, arr.byteLength);
                }
                else
                    throw new Error();
                var attr = new Attribute();
                attr.usage = Usage;
                attr.data = attributeData;
                this.attributes.push(attr);
            }
            var countInputs = ms.readVarInt();
            this.inputs = [];
            for (var i = 0; i < countInputs; i++) {
                this.inputs.push(new TransactionInput());
                var arr = ms.readBytes(32);
                this.inputs[i].hash = new Uint8Array(arr, 0, arr.byteLength);
                this.inputs[i].index = ms.readUint16();
            }
            var countOutputs = ms.readVarInt();
            this.outputs = [];
            for (var i = 0; i < countOutputs; i++) {
                this.outputs.push(new TransactionOutput());
                var outp = this.outputs[i];
                var arr = ms.readBytes(32);
                var assetid = new Uint8Array(arr, 0, arr.byteLength);
                var value = new Neo.Fixed8(ms.readUint64());
                var arr = ms.readBytes(20);
                var scripthash = new Uint8Array(arr, 0, arr.byteLength);
                outp.assetId = assetid;
                outp.value = value;
                outp.toAddress = scripthash;
                this.outputs[i] = outp;
            }
        };
        Transaction.prototype.Deserialize = function (ms) {
            this.DeserializeUnsigned(ms);
            if (ms.canRead() > 0) {
                var witnesscount = ms.readVarInt();
                this.witnesses = [];
                for (var i = 0; i < witnesscount; i++) {
                    this.witnesses.push(new Witness());
                    this.witnesses[i].InvocationScript = new Uint8Array(ms.readVarBytes()).clone();
                    this.witnesses[i].VerificationScript = new Uint8Array(ms.readVarBytes()).clone();
                }
            }
        };
        Transaction.prototype.GetMessage = function () {
            var ms = new Neo.IO.MemoryStream();
            var writer = new Neo.IO.BinaryWriter(ms);
            this.SerializeUnsigned(writer);
            var arr = ms.toArray();
            var msg = new Uint8Array(arr, 0, arr.byteLength);
            return msg;
        };
        Transaction.prototype.GetRawData = function () {
            var ms = new Neo.IO.MemoryStream();
            var writer = new Neo.IO.BinaryWriter(ms);
            this.Serialize(writer);
            var arr = ms.toArray();
            var msg = new Uint8Array(arr, 0, arr.byteLength);
            return msg;
        };
        Transaction.prototype.AddWitness = function (signdata, pubkey, addrs) {
            {
                var msg = this.GetMessage();
                var bsign = ThinNeo.Helper.VerifySignature(msg, signdata, pubkey);
                if (bsign == false)
                    throw new Error("wrong sign");
                var addr = ThinNeo.Helper.GetAddressFromPublicKey(pubkey);
                if (addr != addrs)
                    throw new Error("wrong script");
            }
            var vscript = ThinNeo.Helper.GetAddressCheckScriptFromPublicKey(pubkey);
            var sb = new ThinNeo.ScriptBuilder();
            sb.EmitPushBytes(signdata);
            var iscript = sb.ToArray();
            this.AddWitnessScript(vscript, iscript);
        };
        Transaction.prototype.AddWitnessScript = function (vscript, iscript) {
            var scripthash = ThinNeo.Helper.GetScriptHashFromScript(vscript);
            if (this.witnesses == null)
                this.witnesses = [];
            var newwit = new Witness();
            newwit.VerificationScript = vscript;
            newwit.InvocationScript = iscript;
            for (var i = 0; i < this.witnesses.length; i++) {
                if (this.witnesses[i].Address == newwit.Address)
                    throw new Error("alread have this witness");
            }
            this.witnesses.push(newwit);
        };
        Transaction.prototype.GetHash = function () {
            var msg = this.GetMessage();
            var data = Neo.Cryptography.Sha256.computeHash(msg);
            data = Neo.Cryptography.Sha256.computeHash(data);
            return new Uint8Array(data, 0, data.byteLength);
        };
        return Transaction;
    } ());
    ThinNeo.Transaction = Transaction;
})(ThinNeo || (ThinNeo = {}));
var Neo;
(function (Neo) {
    var Cryptography;
    (function (Cryptography) {
        var Aes = (function () {
            function Aes(key, iv) {
                this._Ke = [];
                this._Kd = [];
                this._lastCipherblock = new Uint8Array(16);
                var rounds = Aes.numberOfRounds[key.byteLength];
                if (rounds == null) {
                    throw new RangeError('invalid key size (must be length 16, 24 or 32)');
                }
                if (iv.byteLength != 16) {
                    throw new RangeError('initialation vector iv must be of length 16');
                }
                for (var i = 0; i <= rounds; i++) {
                    this._Ke.push([0, 0, 0, 0]);
                    this._Kd.push([0, 0, 0, 0]);
                }
                var roundKeyCount = (rounds + 1) * 4;
                var KC = key.byteLength / 4;
                var tk = Aes.convertToInt32(Uint8Array.fromArrayBuffer(key));
                var index;
                for (var i = 0; i < KC; i++) {
                    index = i >> 2;
                    this._Ke[index][i % 4] = tk[i];
                    this._Kd[rounds - index][i % 4] = tk[i];
                }
                var rconpointer = 0;
                var t = KC, tt;
                while (t < roundKeyCount) {
                    tt = tk[KC - 1];
                    tk[0] ^= ((Aes.S[(tt >> 16) & 0xFF] << 24) ^
                        (Aes.S[(tt >> 8) & 0xFF] << 16) ^
                        (Aes.S[tt & 0xFF] << 8) ^
                        Aes.S[(tt >> 24) & 0xFF] ^
                        (Aes.rcon[rconpointer] << 24));
                    rconpointer += 1;
                    if (KC != 8) {
                        for (var i = 1; i < KC; i++) {
                            tk[i] ^= tk[i - 1];
                        }
                    }
                    else {
                        for (var i = 1; i < (KC / 2); i++) {
                            tk[i] ^= tk[i - 1];
                        }
                        tt = tk[(KC / 2) - 1];
                        tk[KC / 2] ^= (Aes.S[tt & 0xFF] ^
                            (Aes.S[(tt >> 8) & 0xFF] << 8) ^
                            (Aes.S[(tt >> 16) & 0xFF] << 16) ^
                            (Aes.S[(tt >> 24) & 0xFF] << 24));
                        for (var i = (KC / 2) + 1; i < KC; i++) {
                            tk[i] ^= tk[i - 1];
                        }
                    }
                    var i = 0;
                    while (i < KC && t < roundKeyCount) {
                        var r_1 = t >> 2;
                        var c_1 = t % 4;
                        this._Ke[r_1][c_1] = tk[i];
                        this._Kd[rounds - r_1][c_1] = tk[i++];
                        t++;
                    }
                }
                for (var r = 1; r < rounds; r++) {
                    for (var c = 0; c < 4; c++) {
                        tt = this._Kd[r][c];
                        this._Kd[r][c] = (Aes.U1[(tt >> 24) & 0xFF] ^
                            Aes.U2[(tt >> 16) & 0xFF] ^
                            Aes.U3[(tt >> 8) & 0xFF] ^
                            Aes.U4[tt & 0xFF]);
                    }
                }
                this._lastCipherblock.set(Uint8Array.fromArrayBuffer(iv));
            }
            Object.defineProperty(Aes.prototype, "mode", {
                get: function () {
                    return "CBC";
                },
                enumerable: true,
                configurable: true
            });
            Aes.convertToInt32 = function (bytes) {
                var result = [];
                for (var i = 0; i < bytes.length; i += 4) {
                    result.push((bytes[i] << 24) |
                        (bytes[i + 1] << 16) |
                        (bytes[i + 2] << 8) |
                        bytes[i + 3]);
                }
                return result;
            };
            Aes.prototype.decrypt = function (ciphertext) {
                if (ciphertext.byteLength == 0 || ciphertext.byteLength % 16 != 0)
                    throw new RangeError();
                var plaintext = new Uint8Array(ciphertext.byteLength);
                var ciphertext_view = Uint8Array.fromArrayBuffer(ciphertext);
                for (var i = 0; i < ciphertext_view.length; i += 16)
                    this.decryptBlock(ciphertext_view.subarray(i, i + 16), plaintext.subarray(i, i + 16));
                return plaintext.buffer.slice(0, plaintext.length - plaintext[plaintext.length - 1]);
            };
            Aes.prototype.decryptBlock = function (ciphertext, plaintext) {
                if (ciphertext.length != 16 || plaintext.length != 16)
                    throw new RangeError();
                var rounds = this._Kd.length - 1;
                var a = [0, 0, 0, 0];
                var t = Aes.convertToInt32(ciphertext);
                for (var i = 0; i < 4; i++) {
                    t[i] ^= this._Kd[0][i];
                }
                for (var r = 1; r < rounds; r++) {
                    for (var i = 0; i < 4; i++) {
                        a[i] = (Aes.T5[(t[i] >> 24) & 0xff] ^
                            Aes.T6[(t[(i + 3) % 4] >> 16) & 0xff] ^
                            Aes.T7[(t[(i + 2) % 4] >> 8) & 0xff] ^
                            Aes.T8[t[(i + 1) % 4] & 0xff] ^
                            this._Kd[r][i]);
                    }
                    t = a.slice(0);
                }
                for (var i = 0; i < 4; i++) {
                    var tt = this._Kd[rounds][i];
                    plaintext[4 * i] = (Aes.Si[(t[i] >> 24) & 0xff] ^ (tt >> 24)) & 0xff;
                    plaintext[4 * i + 1] = (Aes.Si[(t[(i + 3) % 4] >> 16) & 0xff] ^ (tt >> 16)) & 0xff;
                    plaintext[4 * i + 2] = (Aes.Si[(t[(i + 2) % 4] >> 8) & 0xff] ^ (tt >> 8)) & 0xff;
                    plaintext[4 * i + 3] = (Aes.Si[t[(i + 1) % 4] & 0xff] ^ tt) & 0xff;
                }
                for (var i = 0; i < 16; i++) {
                    plaintext[i] ^= this._lastCipherblock[i];
                }
                Array.copy(ciphertext, 0, this._lastCipherblock, 0, ciphertext.length);
            };
            Aes.prototype.encrypt = function (plaintext) {
                var block_count = Math.ceil((plaintext.byteLength + 1) / 16);
                var ciphertext = new Uint8Array(block_count * 16);
                var plaintext_view = Uint8Array.fromArrayBuffer(plaintext);
                for (var i = 0; i < block_count - 1; i++)
                    this.encryptBlock(plaintext_view.subarray(i * 16, (i + 1) * 16), ciphertext.subarray(i * 16, (i + 1) * 16));
                var padding = ciphertext.length - plaintext.byteLength;
                var final_block = new Uint8Array(16);
                final_block.fill(padding);
                if (padding < 16)
                    Array.copy(plaintext_view, ciphertext.length - 16, final_block, 0, 16 - padding);
                this.encryptBlock(final_block, ciphertext.subarray(ciphertext.length - 16));
                return ciphertext.buffer;
            };
            Aes.prototype.encryptBlock = function (plaintext, ciphertext) {
                if (plaintext.length != 16 || ciphertext.length != 16)
                    throw new RangeError();
                var precipherblock = new Uint8Array(plaintext.length);
                for (var i = 0; i < precipherblock.length; i++) {
                    precipherblock[i] = plaintext[i] ^ this._lastCipherblock[i];
                }
                var rounds = this._Ke.length - 1;
                var a = [0, 0, 0, 0];
                var t = Aes.convertToInt32(precipherblock);
                for (var i = 0; i < 4; i++) {
                    t[i] ^= this._Ke[0][i];
                }
                for (var r = 1; r < rounds; r++) {
                    for (var i = 0; i < 4; i++) {
                        a[i] = (Aes.T1[(t[i] >> 24) & 0xff] ^
                            Aes.T2[(t[(i + 1) % 4] >> 16) & 0xff] ^
                            Aes.T3[(t[(i + 2) % 4] >> 8) & 0xff] ^
                            Aes.T4[t[(i + 3) % 4] & 0xff] ^
                            this._Ke[r][i]);
                    }
                    t = a.slice(0);
                }
                for (var i = 0; i < 4; i++) {
                    var tt = this._Ke[rounds][i];
                    ciphertext[4 * i] = (Aes.S[(t[i] >> 24) & 0xff] ^ (tt >> 24)) & 0xff;
                    ciphertext[4 * i + 1] = (Aes.S[(t[(i + 1) % 4] >> 16) & 0xff] ^ (tt >> 16)) & 0xff;
                    ciphertext[4 * i + 2] = (Aes.S[(t[(i + 2) % 4] >> 8) & 0xff] ^ (tt >> 8)) & 0xff;
                    ciphertext[4 * i + 3] = (Aes.S[t[(i + 3) % 4] & 0xff] ^ tt) & 0xff;
                }
                Array.copy(ciphertext, 0, this._lastCipherblock, 0, ciphertext.length);
            };
            Aes.numberOfRounds = { 16: 10, 24: 12, 32: 14 };
            Aes.rcon = [0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91];
            Aes.S = [0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76, 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, 0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15, 0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75, 0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84, 0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf, 0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8, 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, 0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73, 0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb, 0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79, 0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08, 0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a, 0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e, 0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf, 0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16];
            Aes.Si = [0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb, 0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb, 0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e, 0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25, 0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92, 0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84, 0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06, 0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b, 0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73, 0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e, 0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b, 0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4, 0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f, 0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef, 0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61, 0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d];
            Aes.T1 = [0xc66363a5, 0xf87c7c84, 0xee777799, 0xf67b7b8d, 0xfff2f20d, 0xd66b6bbd, 0xde6f6fb1, 0x91c5c554, 0x60303050, 0x02010103, 0xce6767a9, 0x562b2b7d, 0xe7fefe19, 0xb5d7d762, 0x4dababe6, 0xec76769a, 0x8fcaca45, 0x1f82829d, 0x89c9c940, 0xfa7d7d87, 0xeffafa15, 0xb25959eb, 0x8e4747c9, 0xfbf0f00b, 0x41adadec, 0xb3d4d467, 0x5fa2a2fd, 0x45afafea, 0x239c9cbf, 0x53a4a4f7, 0xe4727296, 0x9bc0c05b, 0x75b7b7c2, 0xe1fdfd1c, 0x3d9393ae, 0x4c26266a, 0x6c36365a, 0x7e3f3f41, 0xf5f7f702, 0x83cccc4f, 0x6834345c, 0x51a5a5f4, 0xd1e5e534, 0xf9f1f108, 0xe2717193, 0xabd8d873, 0x62313153, 0x2a15153f, 0x0804040c, 0x95c7c752, 0x46232365, 0x9dc3c35e, 0x30181828, 0x379696a1, 0x0a05050f, 0x2f9a9ab5, 0x0e070709, 0x24121236, 0x1b80809b, 0xdfe2e23d, 0xcdebeb26, 0x4e272769, 0x7fb2b2cd, 0xea75759f, 0x1209091b, 0x1d83839e, 0x582c2c74, 0x341a1a2e, 0x361b1b2d, 0xdc6e6eb2, 0xb45a5aee, 0x5ba0a0fb, 0xa45252f6, 0x763b3b4d, 0xb7d6d661, 0x7db3b3ce, 0x5229297b, 0xdde3e33e, 0x5e2f2f71, 0x13848497, 0xa65353f5, 0xb9d1d168, 0x00000000, 0xc1eded2c, 0x40202060, 0xe3fcfc1f, 0x79b1b1c8, 0xb65b5bed, 0xd46a6abe, 0x8dcbcb46, 0x67bebed9, 0x7239394b, 0x944a4ade, 0x984c4cd4, 0xb05858e8, 0x85cfcf4a, 0xbbd0d06b, 0xc5efef2a, 0x4faaaae5, 0xedfbfb16, 0x864343c5, 0x9a4d4dd7, 0x66333355, 0x11858594, 0x8a4545cf, 0xe9f9f910, 0x04020206, 0xfe7f7f81, 0xa05050f0, 0x783c3c44, 0x259f9fba, 0x4ba8a8e3, 0xa25151f3, 0x5da3a3fe, 0x804040c0, 0x058f8f8a, 0x3f9292ad, 0x219d9dbc, 0x70383848, 0xf1f5f504, 0x63bcbcdf, 0x77b6b6c1, 0xafdada75, 0x42212163, 0x20101030, 0xe5ffff1a, 0xfdf3f30e, 0xbfd2d26d, 0x81cdcd4c, 0x180c0c14, 0x26131335, 0xc3ecec2f, 0xbe5f5fe1, 0x359797a2, 0x884444cc, 0x2e171739, 0x93c4c457, 0x55a7a7f2, 0xfc7e7e82, 0x7a3d3d47, 0xc86464ac, 0xba5d5de7, 0x3219192b, 0xe6737395, 0xc06060a0, 0x19818198, 0x9e4f4fd1, 0xa3dcdc7f, 0x44222266, 0x542a2a7e, 0x3b9090ab, 0x0b888883, 0x8c4646ca, 0xc7eeee29, 0x6bb8b8d3, 0x2814143c, 0xa7dede79, 0xbc5e5ee2, 0x160b0b1d, 0xaddbdb76, 0xdbe0e03b, 0x64323256, 0x743a3a4e, 0x140a0a1e, 0x924949db, 0x0c06060a, 0x4824246c, 0xb85c5ce4, 0x9fc2c25d, 0xbdd3d36e, 0x43acacef, 0xc46262a6, 0x399191a8, 0x319595a4, 0xd3e4e437, 0xf279798b, 0xd5e7e732, 0x8bc8c843, 0x6e373759, 0xda6d6db7, 0x018d8d8c, 0xb1d5d564, 0x9c4e4ed2, 0x49a9a9e0, 0xd86c6cb4, 0xac5656fa, 0xf3f4f407, 0xcfeaea25, 0xca6565af, 0xf47a7a8e, 0x47aeaee9, 0x10080818, 0x6fbabad5, 0xf0787888, 0x4a25256f, 0x5c2e2e72, 0x381c1c24, 0x57a6a6f1, 0x73b4b4c7, 0x97c6c651, 0xcbe8e823, 0xa1dddd7c, 0xe874749c, 0x3e1f1f21, 0x964b4bdd, 0x61bdbddc, 0x0d8b8b86, 0x0f8a8a85, 0xe0707090, 0x7c3e3e42, 0x71b5b5c4, 0xcc6666aa, 0x904848d8, 0x06030305, 0xf7f6f601, 0x1c0e0e12, 0xc26161a3, 0x6a35355f, 0xae5757f9, 0x69b9b9d0, 0x17868691, 0x99c1c158, 0x3a1d1d27, 0x279e9eb9, 0xd9e1e138, 0xebf8f813, 0x2b9898b3, 0x22111133, 0xd26969bb, 0xa9d9d970, 0x078e8e89, 0x339494a7, 0x2d9b9bb6, 0x3c1e1e22, 0x15878792, 0xc9e9e920, 0x87cece49, 0xaa5555ff, 0x50282878, 0xa5dfdf7a, 0x038c8c8f, 0x59a1a1f8, 0x09898980, 0x1a0d0d17, 0x65bfbfda, 0xd7e6e631, 0x844242c6, 0xd06868b8, 0x824141c3, 0x299999b0, 0x5a2d2d77, 0x1e0f0f11, 0x7bb0b0cb, 0xa85454fc, 0x6dbbbbd6, 0x2c16163a];
            Aes.T2 = [0xa5c66363, 0x84f87c7c, 0x99ee7777, 0x8df67b7b, 0x0dfff2f2, 0xbdd66b6b, 0xb1de6f6f, 0x5491c5c5, 0x50603030, 0x03020101, 0xa9ce6767, 0x7d562b2b, 0x19e7fefe, 0x62b5d7d7, 0xe64dabab, 0x9aec7676, 0x458fcaca, 0x9d1f8282, 0x4089c9c9, 0x87fa7d7d, 0x15effafa, 0xebb25959, 0xc98e4747, 0x0bfbf0f0, 0xec41adad, 0x67b3d4d4, 0xfd5fa2a2, 0xea45afaf, 0xbf239c9c, 0xf753a4a4, 0x96e47272, 0x5b9bc0c0, 0xc275b7b7, 0x1ce1fdfd, 0xae3d9393, 0x6a4c2626, 0x5a6c3636, 0x417e3f3f, 0x02f5f7f7, 0x4f83cccc, 0x5c683434, 0xf451a5a5, 0x34d1e5e5, 0x08f9f1f1, 0x93e27171, 0x73abd8d8, 0x53623131, 0x3f2a1515, 0x0c080404, 0x5295c7c7, 0x65462323, 0x5e9dc3c3, 0x28301818, 0xa1379696, 0x0f0a0505, 0xb52f9a9a, 0x090e0707, 0x36241212, 0x9b1b8080, 0x3ddfe2e2, 0x26cdebeb, 0x694e2727, 0xcd7fb2b2, 0x9fea7575, 0x1b120909, 0x9e1d8383, 0x74582c2c, 0x2e341a1a, 0x2d361b1b, 0xb2dc6e6e, 0xeeb45a5a, 0xfb5ba0a0, 0xf6a45252, 0x4d763b3b, 0x61b7d6d6, 0xce7db3b3, 0x7b522929, 0x3edde3e3, 0x715e2f2f, 0x97138484, 0xf5a65353, 0x68b9d1d1, 0x00000000, 0x2cc1eded, 0x60402020, 0x1fe3fcfc, 0xc879b1b1, 0xedb65b5b, 0xbed46a6a, 0x468dcbcb, 0xd967bebe, 0x4b723939, 0xde944a4a, 0xd4984c4c, 0xe8b05858, 0x4a85cfcf, 0x6bbbd0d0, 0x2ac5efef, 0xe54faaaa, 0x16edfbfb, 0xc5864343, 0xd79a4d4d, 0x55663333, 0x94118585, 0xcf8a4545, 0x10e9f9f9, 0x06040202, 0x81fe7f7f, 0xf0a05050, 0x44783c3c, 0xba259f9f, 0xe34ba8a8, 0xf3a25151, 0xfe5da3a3, 0xc0804040, 0x8a058f8f, 0xad3f9292, 0xbc219d9d, 0x48703838, 0x04f1f5f5, 0xdf63bcbc, 0xc177b6b6, 0x75afdada, 0x63422121, 0x30201010, 0x1ae5ffff, 0x0efdf3f3, 0x6dbfd2d2, 0x4c81cdcd, 0x14180c0c, 0x35261313, 0x2fc3ecec, 0xe1be5f5f, 0xa2359797, 0xcc884444, 0x392e1717, 0x5793c4c4, 0xf255a7a7, 0x82fc7e7e, 0x477a3d3d, 0xacc86464, 0xe7ba5d5d, 0x2b321919, 0x95e67373, 0xa0c06060, 0x98198181, 0xd19e4f4f, 0x7fa3dcdc, 0x66442222, 0x7e542a2a, 0xab3b9090, 0x830b8888, 0xca8c4646, 0x29c7eeee, 0xd36bb8b8, 0x3c281414, 0x79a7dede, 0xe2bc5e5e, 0x1d160b0b, 0x76addbdb, 0x3bdbe0e0, 0x56643232, 0x4e743a3a, 0x1e140a0a, 0xdb924949, 0x0a0c0606, 0x6c482424, 0xe4b85c5c, 0x5d9fc2c2, 0x6ebdd3d3, 0xef43acac, 0xa6c46262, 0xa8399191, 0xa4319595, 0x37d3e4e4, 0x8bf27979, 0x32d5e7e7, 0x438bc8c8, 0x596e3737, 0xb7da6d6d, 0x8c018d8d, 0x64b1d5d5, 0xd29c4e4e, 0xe049a9a9, 0xb4d86c6c, 0xfaac5656, 0x07f3f4f4, 0x25cfeaea, 0xafca6565, 0x8ef47a7a, 0xe947aeae, 0x18100808, 0xd56fbaba, 0x88f07878, 0x6f4a2525, 0x725c2e2e, 0x24381c1c, 0xf157a6a6, 0xc773b4b4, 0x5197c6c6, 0x23cbe8e8, 0x7ca1dddd, 0x9ce87474, 0x213e1f1f, 0xdd964b4b, 0xdc61bdbd, 0x860d8b8b, 0x850f8a8a, 0x90e07070, 0x427c3e3e, 0xc471b5b5, 0xaacc6666, 0xd8904848, 0x05060303, 0x01f7f6f6, 0x121c0e0e, 0xa3c26161, 0x5f6a3535, 0xf9ae5757, 0xd069b9b9, 0x91178686, 0x5899c1c1, 0x273a1d1d, 0xb9279e9e, 0x38d9e1e1, 0x13ebf8f8, 0xb32b9898, 0x33221111, 0xbbd26969, 0x70a9d9d9, 0x89078e8e, 0xa7339494, 0xb62d9b9b, 0x223c1e1e, 0x92158787, 0x20c9e9e9, 0x4987cece, 0xffaa5555, 0x78502828, 0x7aa5dfdf, 0x8f038c8c, 0xf859a1a1, 0x80098989, 0x171a0d0d, 0xda65bfbf, 0x31d7e6e6, 0xc6844242, 0xb8d06868, 0xc3824141, 0xb0299999, 0x775a2d2d, 0x111e0f0f, 0xcb7bb0b0, 0xfca85454, 0xd66dbbbb, 0x3a2c1616];
            Aes.T3 = [0x63a5c663, 0x7c84f87c, 0x7799ee77, 0x7b8df67b, 0xf20dfff2, 0x6bbdd66b, 0x6fb1de6f, 0xc55491c5, 0x30506030, 0x01030201, 0x67a9ce67, 0x2b7d562b, 0xfe19e7fe, 0xd762b5d7, 0xabe64dab, 0x769aec76, 0xca458fca, 0x829d1f82, 0xc94089c9, 0x7d87fa7d, 0xfa15effa, 0x59ebb259, 0x47c98e47, 0xf00bfbf0, 0xadec41ad, 0xd467b3d4, 0xa2fd5fa2, 0xafea45af, 0x9cbf239c, 0xa4f753a4, 0x7296e472, 0xc05b9bc0, 0xb7c275b7, 0xfd1ce1fd, 0x93ae3d93, 0x266a4c26, 0x365a6c36, 0x3f417e3f, 0xf702f5f7, 0xcc4f83cc, 0x345c6834, 0xa5f451a5, 0xe534d1e5, 0xf108f9f1, 0x7193e271, 0xd873abd8, 0x31536231, 0x153f2a15, 0x040c0804, 0xc75295c7, 0x23654623, 0xc35e9dc3, 0x18283018, 0x96a13796, 0x050f0a05, 0x9ab52f9a, 0x07090e07, 0x12362412, 0x809b1b80, 0xe23ddfe2, 0xeb26cdeb, 0x27694e27, 0xb2cd7fb2, 0x759fea75, 0x091b1209, 0x839e1d83, 0x2c74582c, 0x1a2e341a, 0x1b2d361b, 0x6eb2dc6e, 0x5aeeb45a, 0xa0fb5ba0, 0x52f6a452, 0x3b4d763b, 0xd661b7d6, 0xb3ce7db3, 0x297b5229, 0xe33edde3, 0x2f715e2f, 0x84971384, 0x53f5a653, 0xd168b9d1, 0x00000000, 0xed2cc1ed, 0x20604020, 0xfc1fe3fc, 0xb1c879b1, 0x5bedb65b, 0x6abed46a, 0xcb468dcb, 0xbed967be, 0x394b7239, 0x4ade944a, 0x4cd4984c, 0x58e8b058, 0xcf4a85cf, 0xd06bbbd0, 0xef2ac5ef, 0xaae54faa, 0xfb16edfb, 0x43c58643, 0x4dd79a4d, 0x33556633, 0x85941185, 0x45cf8a45, 0xf910e9f9, 0x02060402, 0x7f81fe7f, 0x50f0a050, 0x3c44783c, 0x9fba259f, 0xa8e34ba8, 0x51f3a251, 0xa3fe5da3, 0x40c08040, 0x8f8a058f, 0x92ad3f92, 0x9dbc219d, 0x38487038, 0xf504f1f5, 0xbcdf63bc, 0xb6c177b6, 0xda75afda, 0x21634221, 0x10302010, 0xff1ae5ff, 0xf30efdf3, 0xd26dbfd2, 0xcd4c81cd, 0x0c14180c, 0x13352613, 0xec2fc3ec, 0x5fe1be5f, 0x97a23597, 0x44cc8844, 0x17392e17, 0xc45793c4, 0xa7f255a7, 0x7e82fc7e, 0x3d477a3d, 0x64acc864, 0x5de7ba5d, 0x192b3219, 0x7395e673, 0x60a0c060, 0x81981981, 0x4fd19e4f, 0xdc7fa3dc, 0x22664422, 0x2a7e542a, 0x90ab3b90, 0x88830b88, 0x46ca8c46, 0xee29c7ee, 0xb8d36bb8, 0x143c2814, 0xde79a7de, 0x5ee2bc5e, 0x0b1d160b, 0xdb76addb, 0xe03bdbe0, 0x32566432, 0x3a4e743a, 0x0a1e140a, 0x49db9249, 0x060a0c06, 0x246c4824, 0x5ce4b85c, 0xc25d9fc2, 0xd36ebdd3, 0xacef43ac, 0x62a6c462, 0x91a83991, 0x95a43195, 0xe437d3e4, 0x798bf279, 0xe732d5e7, 0xc8438bc8, 0x37596e37, 0x6db7da6d, 0x8d8c018d, 0xd564b1d5, 0x4ed29c4e, 0xa9e049a9, 0x6cb4d86c, 0x56faac56, 0xf407f3f4, 0xea25cfea, 0x65afca65, 0x7a8ef47a, 0xaee947ae, 0x08181008, 0xbad56fba, 0x7888f078, 0x256f4a25, 0x2e725c2e, 0x1c24381c, 0xa6f157a6, 0xb4c773b4, 0xc65197c6, 0xe823cbe8, 0xdd7ca1dd, 0x749ce874, 0x1f213e1f, 0x4bdd964b, 0xbddc61bd, 0x8b860d8b, 0x8a850f8a, 0x7090e070, 0x3e427c3e, 0xb5c471b5, 0x66aacc66, 0x48d89048, 0x03050603, 0xf601f7f6, 0x0e121c0e, 0x61a3c261, 0x355f6a35, 0x57f9ae57, 0xb9d069b9, 0x86911786, 0xc15899c1, 0x1d273a1d, 0x9eb9279e, 0xe138d9e1, 0xf813ebf8, 0x98b32b98, 0x11332211, 0x69bbd269, 0xd970a9d9, 0x8e89078e, 0x94a73394, 0x9bb62d9b, 0x1e223c1e, 0x87921587, 0xe920c9e9, 0xce4987ce, 0x55ffaa55, 0x28785028, 0xdf7aa5df, 0x8c8f038c, 0xa1f859a1, 0x89800989, 0x0d171a0d, 0xbfda65bf, 0xe631d7e6, 0x42c68442, 0x68b8d068, 0x41c38241, 0x99b02999, 0x2d775a2d, 0x0f111e0f, 0xb0cb7bb0, 0x54fca854, 0xbbd66dbb, 0x163a2c16];
            Aes.T4 = [0x6363a5c6, 0x7c7c84f8, 0x777799ee, 0x7b7b8df6, 0xf2f20dff, 0x6b6bbdd6, 0x6f6fb1de, 0xc5c55491, 0x30305060, 0x01010302, 0x6767a9ce, 0x2b2b7d56, 0xfefe19e7, 0xd7d762b5, 0xababe64d, 0x76769aec, 0xcaca458f, 0x82829d1f, 0xc9c94089, 0x7d7d87fa, 0xfafa15ef, 0x5959ebb2, 0x4747c98e, 0xf0f00bfb, 0xadadec41, 0xd4d467b3, 0xa2a2fd5f, 0xafafea45, 0x9c9cbf23, 0xa4a4f753, 0x727296e4, 0xc0c05b9b, 0xb7b7c275, 0xfdfd1ce1, 0x9393ae3d, 0x26266a4c, 0x36365a6c, 0x3f3f417e, 0xf7f702f5, 0xcccc4f83, 0x34345c68, 0xa5a5f451, 0xe5e534d1, 0xf1f108f9, 0x717193e2, 0xd8d873ab, 0x31315362, 0x15153f2a, 0x04040c08, 0xc7c75295, 0x23236546, 0xc3c35e9d, 0x18182830, 0x9696a137, 0x05050f0a, 0x9a9ab52f, 0x0707090e, 0x12123624, 0x80809b1b, 0xe2e23ddf, 0xebeb26cd, 0x2727694e, 0xb2b2cd7f, 0x75759fea, 0x09091b12, 0x83839e1d, 0x2c2c7458, 0x1a1a2e34, 0x1b1b2d36, 0x6e6eb2dc, 0x5a5aeeb4, 0xa0a0fb5b, 0x5252f6a4, 0x3b3b4d76, 0xd6d661b7, 0xb3b3ce7d, 0x29297b52, 0xe3e33edd, 0x2f2f715e, 0x84849713, 0x5353f5a6, 0xd1d168b9, 0x00000000, 0xeded2cc1, 0x20206040, 0xfcfc1fe3, 0xb1b1c879, 0x5b5bedb6, 0x6a6abed4, 0xcbcb468d, 0xbebed967, 0x39394b72, 0x4a4ade94, 0x4c4cd498, 0x5858e8b0, 0xcfcf4a85, 0xd0d06bbb, 0xefef2ac5, 0xaaaae54f, 0xfbfb16ed, 0x4343c586, 0x4d4dd79a, 0x33335566, 0x85859411, 0x4545cf8a, 0xf9f910e9, 0x02020604, 0x7f7f81fe, 0x5050f0a0, 0x3c3c4478, 0x9f9fba25, 0xa8a8e34b, 0x5151f3a2, 0xa3a3fe5d, 0x4040c080, 0x8f8f8a05, 0x9292ad3f, 0x9d9dbc21, 0x38384870, 0xf5f504f1, 0xbcbcdf63, 0xb6b6c177, 0xdada75af, 0x21216342, 0x10103020, 0xffff1ae5, 0xf3f30efd, 0xd2d26dbf, 0xcdcd4c81, 0x0c0c1418, 0x13133526, 0xecec2fc3, 0x5f5fe1be, 0x9797a235, 0x4444cc88, 0x1717392e, 0xc4c45793, 0xa7a7f255, 0x7e7e82fc, 0x3d3d477a, 0x6464acc8, 0x5d5de7ba, 0x19192b32, 0x737395e6, 0x6060a0c0, 0x81819819, 0x4f4fd19e, 0xdcdc7fa3, 0x22226644, 0x2a2a7e54, 0x9090ab3b, 0x8888830b, 0x4646ca8c, 0xeeee29c7, 0xb8b8d36b, 0x14143c28, 0xdede79a7, 0x5e5ee2bc, 0x0b0b1d16, 0xdbdb76ad, 0xe0e03bdb, 0x32325664, 0x3a3a4e74, 0x0a0a1e14, 0x4949db92, 0x06060a0c, 0x24246c48, 0x5c5ce4b8, 0xc2c25d9f, 0xd3d36ebd, 0xacacef43, 0x6262a6c4, 0x9191a839, 0x9595a431, 0xe4e437d3, 0x79798bf2, 0xe7e732d5, 0xc8c8438b, 0x3737596e, 0x6d6db7da, 0x8d8d8c01, 0xd5d564b1, 0x4e4ed29c, 0xa9a9e049, 0x6c6cb4d8, 0x5656faac, 0xf4f407f3, 0xeaea25cf, 0x6565afca, 0x7a7a8ef4, 0xaeaee947, 0x08081810, 0xbabad56f, 0x787888f0, 0x25256f4a, 0x2e2e725c, 0x1c1c2438, 0xa6a6f157, 0xb4b4c773, 0xc6c65197, 0xe8e823cb, 0xdddd7ca1, 0x74749ce8, 0x1f1f213e, 0x4b4bdd96, 0xbdbddc61, 0x8b8b860d, 0x8a8a850f, 0x707090e0, 0x3e3e427c, 0xb5b5c471, 0x6666aacc, 0x4848d890, 0x03030506, 0xf6f601f7, 0x0e0e121c, 0x6161a3c2, 0x35355f6a, 0x5757f9ae, 0xb9b9d069, 0x86869117, 0xc1c15899, 0x1d1d273a, 0x9e9eb927, 0xe1e138d9, 0xf8f813eb, 0x9898b32b, 0x11113322, 0x6969bbd2, 0xd9d970a9, 0x8e8e8907, 0x9494a733, 0x9b9bb62d, 0x1e1e223c, 0x87879215, 0xe9e920c9, 0xcece4987, 0x5555ffaa, 0x28287850, 0xdfdf7aa5, 0x8c8c8f03, 0xa1a1f859, 0x89898009, 0x0d0d171a, 0xbfbfda65, 0xe6e631d7, 0x4242c684, 0x6868b8d0, 0x4141c382, 0x9999b029, 0x2d2d775a, 0x0f0f111e, 0xb0b0cb7b, 0x5454fca8, 0xbbbbd66d, 0x16163a2c];
            Aes.T5 = [0x51f4a750, 0x7e416553, 0x1a17a4c3, 0x3a275e96, 0x3bab6bcb, 0x1f9d45f1, 0xacfa58ab, 0x4be30393, 0x2030fa55, 0xad766df6, 0x88cc7691, 0xf5024c25, 0x4fe5d7fc, 0xc52acbd7, 0x26354480, 0xb562a38f, 0xdeb15a49, 0x25ba1b67, 0x45ea0e98, 0x5dfec0e1, 0xc32f7502, 0x814cf012, 0x8d4697a3, 0x6bd3f9c6, 0x038f5fe7, 0x15929c95, 0xbf6d7aeb, 0x955259da, 0xd4be832d, 0x587421d3, 0x49e06929, 0x8ec9c844, 0x75c2896a, 0xf48e7978, 0x99583e6b, 0x27b971dd, 0xbee14fb6, 0xf088ad17, 0xc920ac66, 0x7dce3ab4, 0x63df4a18, 0xe51a3182, 0x97513360, 0x62537f45, 0xb16477e0, 0xbb6bae84, 0xfe81a01c, 0xf9082b94, 0x70486858, 0x8f45fd19, 0x94de6c87, 0x527bf8b7, 0xab73d323, 0x724b02e2, 0xe31f8f57, 0x6655ab2a, 0xb2eb2807, 0x2fb5c203, 0x86c57b9a, 0xd33708a5, 0x302887f2, 0x23bfa5b2, 0x02036aba, 0xed16825c, 0x8acf1c2b, 0xa779b492, 0xf307f2f0, 0x4e69e2a1, 0x65daf4cd, 0x0605bed5, 0xd134621f, 0xc4a6fe8a, 0x342e539d, 0xa2f355a0, 0x058ae132, 0xa4f6eb75, 0x0b83ec39, 0x4060efaa, 0x5e719f06, 0xbd6e1051, 0x3e218af9, 0x96dd063d, 0xdd3e05ae, 0x4de6bd46, 0x91548db5, 0x71c45d05, 0x0406d46f, 0x605015ff, 0x1998fb24, 0xd6bde997, 0x894043cc, 0x67d99e77, 0xb0e842bd, 0x07898b88, 0xe7195b38, 0x79c8eedb, 0xa17c0a47, 0x7c420fe9, 0xf8841ec9, 0x00000000, 0x09808683, 0x322bed48, 0x1e1170ac, 0x6c5a724e, 0xfd0efffb, 0x0f853856, 0x3daed51e, 0x362d3927, 0x0a0fd964, 0x685ca621, 0x9b5b54d1, 0x24362e3a, 0x0c0a67b1, 0x9357e70f, 0xb4ee96d2, 0x1b9b919e, 0x80c0c54f, 0x61dc20a2, 0x5a774b69, 0x1c121a16, 0xe293ba0a, 0xc0a02ae5, 0x3c22e043, 0x121b171d, 0x0e090d0b, 0xf28bc7ad, 0x2db6a8b9, 0x141ea9c8, 0x57f11985, 0xaf75074c, 0xee99ddbb, 0xa37f60fd, 0xf701269f, 0x5c72f5bc, 0x44663bc5, 0x5bfb7e34, 0x8b432976, 0xcb23c6dc, 0xb6edfc68, 0xb8e4f163, 0xd731dcca, 0x42638510, 0x13972240, 0x84c61120, 0x854a247d, 0xd2bb3df8, 0xaef93211, 0xc729a16d, 0x1d9e2f4b, 0xdcb230f3, 0x0d8652ec, 0x77c1e3d0, 0x2bb3166c, 0xa970b999, 0x119448fa, 0x47e96422, 0xa8fc8cc4, 0xa0f03f1a, 0x567d2cd8, 0x223390ef, 0x87494ec7, 0xd938d1c1, 0x8ccaa2fe, 0x98d40b36, 0xa6f581cf, 0xa57ade28, 0xdab78e26, 0x3fadbfa4, 0x2c3a9de4, 0x5078920d, 0x6a5fcc9b, 0x547e4662, 0xf68d13c2, 0x90d8b8e8, 0x2e39f75e, 0x82c3aff5, 0x9f5d80be, 0x69d0937c, 0x6fd52da9, 0xcf2512b3, 0xc8ac993b, 0x10187da7, 0xe89c636e, 0xdb3bbb7b, 0xcd267809, 0x6e5918f4, 0xec9ab701, 0x834f9aa8, 0xe6956e65, 0xaaffe67e, 0x21bccf08, 0xef15e8e6, 0xbae79bd9, 0x4a6f36ce, 0xea9f09d4, 0x29b07cd6, 0x31a4b2af, 0x2a3f2331, 0xc6a59430, 0x35a266c0, 0x744ebc37, 0xfc82caa6, 0xe090d0b0, 0x33a7d815, 0xf104984a, 0x41ecdaf7, 0x7fcd500e, 0x1791f62f, 0x764dd68d, 0x43efb04d, 0xccaa4d54, 0xe49604df, 0x9ed1b5e3, 0x4c6a881b, 0xc12c1fb8, 0x4665517f, 0x9d5eea04, 0x018c355d, 0xfa877473, 0xfb0b412e, 0xb3671d5a, 0x92dbd252, 0xe9105633, 0x6dd64713, 0x9ad7618c, 0x37a10c7a, 0x59f8148e, 0xeb133c89, 0xcea927ee, 0xb761c935, 0xe11ce5ed, 0x7a47b13c, 0x9cd2df59, 0x55f2733f, 0x1814ce79, 0x73c737bf, 0x53f7cdea, 0x5ffdaa5b, 0xdf3d6f14, 0x7844db86, 0xcaaff381, 0xb968c43e, 0x3824342c, 0xc2a3405f, 0x161dc372, 0xbce2250c, 0x283c498b, 0xff0d9541, 0x39a80171, 0x080cb3de, 0xd8b4e49c, 0x6456c190, 0x7bcb8461, 0xd532b670, 0x486c5c74, 0xd0b85742];
            Aes.T6 = [0x5051f4a7, 0x537e4165, 0xc31a17a4, 0x963a275e, 0xcb3bab6b, 0xf11f9d45, 0xabacfa58, 0x934be303, 0x552030fa, 0xf6ad766d, 0x9188cc76, 0x25f5024c, 0xfc4fe5d7, 0xd7c52acb, 0x80263544, 0x8fb562a3, 0x49deb15a, 0x6725ba1b, 0x9845ea0e, 0xe15dfec0, 0x02c32f75, 0x12814cf0, 0xa38d4697, 0xc66bd3f9, 0xe7038f5f, 0x9515929c, 0xebbf6d7a, 0xda955259, 0x2dd4be83, 0xd3587421, 0x2949e069, 0x448ec9c8, 0x6a75c289, 0x78f48e79, 0x6b99583e, 0xdd27b971, 0xb6bee14f, 0x17f088ad, 0x66c920ac, 0xb47dce3a, 0x1863df4a, 0x82e51a31, 0x60975133, 0x4562537f, 0xe0b16477, 0x84bb6bae, 0x1cfe81a0, 0x94f9082b, 0x58704868, 0x198f45fd, 0x8794de6c, 0xb7527bf8, 0x23ab73d3, 0xe2724b02, 0x57e31f8f, 0x2a6655ab, 0x07b2eb28, 0x032fb5c2, 0x9a86c57b, 0xa5d33708, 0xf2302887, 0xb223bfa5, 0xba02036a, 0x5ced1682, 0x2b8acf1c, 0x92a779b4, 0xf0f307f2, 0xa14e69e2, 0xcd65daf4, 0xd50605be, 0x1fd13462, 0x8ac4a6fe, 0x9d342e53, 0xa0a2f355, 0x32058ae1, 0x75a4f6eb, 0x390b83ec, 0xaa4060ef, 0x065e719f, 0x51bd6e10, 0xf93e218a, 0x3d96dd06, 0xaedd3e05, 0x464de6bd, 0xb591548d, 0x0571c45d, 0x6f0406d4, 0xff605015, 0x241998fb, 0x97d6bde9, 0xcc894043, 0x7767d99e, 0xbdb0e842, 0x8807898b, 0x38e7195b, 0xdb79c8ee, 0x47a17c0a, 0xe97c420f, 0xc9f8841e, 0x00000000, 0x83098086, 0x48322bed, 0xac1e1170, 0x4e6c5a72, 0xfbfd0eff, 0x560f8538, 0x1e3daed5, 0x27362d39, 0x640a0fd9, 0x21685ca6, 0xd19b5b54, 0x3a24362e, 0xb10c0a67, 0x0f9357e7, 0xd2b4ee96, 0x9e1b9b91, 0x4f80c0c5, 0xa261dc20, 0x695a774b, 0x161c121a, 0x0ae293ba, 0xe5c0a02a, 0x433c22e0, 0x1d121b17, 0x0b0e090d, 0xadf28bc7, 0xb92db6a8, 0xc8141ea9, 0x8557f119, 0x4caf7507, 0xbbee99dd, 0xfda37f60, 0x9ff70126, 0xbc5c72f5, 0xc544663b, 0x345bfb7e, 0x768b4329, 0xdccb23c6, 0x68b6edfc, 0x63b8e4f1, 0xcad731dc, 0x10426385, 0x40139722, 0x2084c611, 0x7d854a24, 0xf8d2bb3d, 0x11aef932, 0x6dc729a1, 0x4b1d9e2f, 0xf3dcb230, 0xec0d8652, 0xd077c1e3, 0x6c2bb316, 0x99a970b9, 0xfa119448, 0x2247e964, 0xc4a8fc8c, 0x1aa0f03f, 0xd8567d2c, 0xef223390, 0xc787494e, 0xc1d938d1, 0xfe8ccaa2, 0x3698d40b, 0xcfa6f581, 0x28a57ade, 0x26dab78e, 0xa43fadbf, 0xe42c3a9d, 0x0d507892, 0x9b6a5fcc, 0x62547e46, 0xc2f68d13, 0xe890d8b8, 0x5e2e39f7, 0xf582c3af, 0xbe9f5d80, 0x7c69d093, 0xa96fd52d, 0xb3cf2512, 0x3bc8ac99, 0xa710187d, 0x6ee89c63, 0x7bdb3bbb, 0x09cd2678, 0xf46e5918, 0x01ec9ab7, 0xa8834f9a, 0x65e6956e, 0x7eaaffe6, 0x0821bccf, 0xe6ef15e8, 0xd9bae79b, 0xce4a6f36, 0xd4ea9f09, 0xd629b07c, 0xaf31a4b2, 0x312a3f23, 0x30c6a594, 0xc035a266, 0x37744ebc, 0xa6fc82ca, 0xb0e090d0, 0x1533a7d8, 0x4af10498, 0xf741ecda, 0x0e7fcd50, 0x2f1791f6, 0x8d764dd6, 0x4d43efb0, 0x54ccaa4d, 0xdfe49604, 0xe39ed1b5, 0x1b4c6a88, 0xb8c12c1f, 0x7f466551, 0x049d5eea, 0x5d018c35, 0x73fa8774, 0x2efb0b41, 0x5ab3671d, 0x5292dbd2, 0x33e91056, 0x136dd647, 0x8c9ad761, 0x7a37a10c, 0x8e59f814, 0x89eb133c, 0xeecea927, 0x35b761c9, 0xede11ce5, 0x3c7a47b1, 0x599cd2df, 0x3f55f273, 0x791814ce, 0xbf73c737, 0xea53f7cd, 0x5b5ffdaa, 0x14df3d6f, 0x867844db, 0x81caaff3, 0x3eb968c4, 0x2c382434, 0x5fc2a340, 0x72161dc3, 0x0cbce225, 0x8b283c49, 0x41ff0d95, 0x7139a801, 0xde080cb3, 0x9cd8b4e4, 0x906456c1, 0x617bcb84, 0x70d532b6, 0x74486c5c, 0x42d0b857];
            Aes.T7 = [0xa75051f4, 0x65537e41, 0xa4c31a17, 0x5e963a27, 0x6bcb3bab, 0x45f11f9d, 0x58abacfa, 0x03934be3, 0xfa552030, 0x6df6ad76, 0x769188cc, 0x4c25f502, 0xd7fc4fe5, 0xcbd7c52a, 0x44802635, 0xa38fb562, 0x5a49deb1, 0x1b6725ba, 0x0e9845ea, 0xc0e15dfe, 0x7502c32f, 0xf012814c, 0x97a38d46, 0xf9c66bd3, 0x5fe7038f, 0x9c951592, 0x7aebbf6d, 0x59da9552, 0x832dd4be, 0x21d35874, 0x692949e0, 0xc8448ec9, 0x896a75c2, 0x7978f48e, 0x3e6b9958, 0x71dd27b9, 0x4fb6bee1, 0xad17f088, 0xac66c920, 0x3ab47dce, 0x4a1863df, 0x3182e51a, 0x33609751, 0x7f456253, 0x77e0b164, 0xae84bb6b, 0xa01cfe81, 0x2b94f908, 0x68587048, 0xfd198f45, 0x6c8794de, 0xf8b7527b, 0xd323ab73, 0x02e2724b, 0x8f57e31f, 0xab2a6655, 0x2807b2eb, 0xc2032fb5, 0x7b9a86c5, 0x08a5d337, 0x87f23028, 0xa5b223bf, 0x6aba0203, 0x825ced16, 0x1c2b8acf, 0xb492a779, 0xf2f0f307, 0xe2a14e69, 0xf4cd65da, 0xbed50605, 0x621fd134, 0xfe8ac4a6, 0x539d342e, 0x55a0a2f3, 0xe132058a, 0xeb75a4f6, 0xec390b83, 0xefaa4060, 0x9f065e71, 0x1051bd6e, 0x8af93e21, 0x063d96dd, 0x05aedd3e, 0xbd464de6, 0x8db59154, 0x5d0571c4, 0xd46f0406, 0x15ff6050, 0xfb241998, 0xe997d6bd, 0x43cc8940, 0x9e7767d9, 0x42bdb0e8, 0x8b880789, 0x5b38e719, 0xeedb79c8, 0x0a47a17c, 0x0fe97c42, 0x1ec9f884, 0x00000000, 0x86830980, 0xed48322b, 0x70ac1e11, 0x724e6c5a, 0xfffbfd0e, 0x38560f85, 0xd51e3dae, 0x3927362d, 0xd9640a0f, 0xa621685c, 0x54d19b5b, 0x2e3a2436, 0x67b10c0a, 0xe70f9357, 0x96d2b4ee, 0x919e1b9b, 0xc54f80c0, 0x20a261dc, 0x4b695a77, 0x1a161c12, 0xba0ae293, 0x2ae5c0a0, 0xe0433c22, 0x171d121b, 0x0d0b0e09, 0xc7adf28b, 0xa8b92db6, 0xa9c8141e, 0x198557f1, 0x074caf75, 0xddbbee99, 0x60fda37f, 0x269ff701, 0xf5bc5c72, 0x3bc54466, 0x7e345bfb, 0x29768b43, 0xc6dccb23, 0xfc68b6ed, 0xf163b8e4, 0xdccad731, 0x85104263, 0x22401397, 0x112084c6, 0x247d854a, 0x3df8d2bb, 0x3211aef9, 0xa16dc729, 0x2f4b1d9e, 0x30f3dcb2, 0x52ec0d86, 0xe3d077c1, 0x166c2bb3, 0xb999a970, 0x48fa1194, 0x642247e9, 0x8cc4a8fc, 0x3f1aa0f0, 0x2cd8567d, 0x90ef2233, 0x4ec78749, 0xd1c1d938, 0xa2fe8cca, 0x0b3698d4, 0x81cfa6f5, 0xde28a57a, 0x8e26dab7, 0xbfa43fad, 0x9de42c3a, 0x920d5078, 0xcc9b6a5f, 0x4662547e, 0x13c2f68d, 0xb8e890d8, 0xf75e2e39, 0xaff582c3, 0x80be9f5d, 0x937c69d0, 0x2da96fd5, 0x12b3cf25, 0x993bc8ac, 0x7da71018, 0x636ee89c, 0xbb7bdb3b, 0x7809cd26, 0x18f46e59, 0xb701ec9a, 0x9aa8834f, 0x6e65e695, 0xe67eaaff, 0xcf0821bc, 0xe8e6ef15, 0x9bd9bae7, 0x36ce4a6f, 0x09d4ea9f, 0x7cd629b0, 0xb2af31a4, 0x23312a3f, 0x9430c6a5, 0x66c035a2, 0xbc37744e, 0xcaa6fc82, 0xd0b0e090, 0xd81533a7, 0x984af104, 0xdaf741ec, 0x500e7fcd, 0xf62f1791, 0xd68d764d, 0xb04d43ef, 0x4d54ccaa, 0x04dfe496, 0xb5e39ed1, 0x881b4c6a, 0x1fb8c12c, 0x517f4665, 0xea049d5e, 0x355d018c, 0x7473fa87, 0x412efb0b, 0x1d5ab367, 0xd25292db, 0x5633e910, 0x47136dd6, 0x618c9ad7, 0x0c7a37a1, 0x148e59f8, 0x3c89eb13, 0x27eecea9, 0xc935b761, 0xe5ede11c, 0xb13c7a47, 0xdf599cd2, 0x733f55f2, 0xce791814, 0x37bf73c7, 0xcdea53f7, 0xaa5b5ffd, 0x6f14df3d, 0xdb867844, 0xf381caaf, 0xc43eb968, 0x342c3824, 0x405fc2a3, 0xc372161d, 0x250cbce2, 0x498b283c, 0x9541ff0d, 0x017139a8, 0xb3de080c, 0xe49cd8b4, 0xc1906456, 0x84617bcb, 0xb670d532, 0x5c74486c, 0x5742d0b8];
            Aes.T8 = [0xf4a75051, 0x4165537e, 0x17a4c31a, 0x275e963a, 0xab6bcb3b, 0x9d45f11f, 0xfa58abac, 0xe303934b, 0x30fa5520, 0x766df6ad, 0xcc769188, 0x024c25f5, 0xe5d7fc4f, 0x2acbd7c5, 0x35448026, 0x62a38fb5, 0xb15a49de, 0xba1b6725, 0xea0e9845, 0xfec0e15d, 0x2f7502c3, 0x4cf01281, 0x4697a38d, 0xd3f9c66b, 0x8f5fe703, 0x929c9515, 0x6d7aebbf, 0x5259da95, 0xbe832dd4, 0x7421d358, 0xe0692949, 0xc9c8448e, 0xc2896a75, 0x8e7978f4, 0x583e6b99, 0xb971dd27, 0xe14fb6be, 0x88ad17f0, 0x20ac66c9, 0xce3ab47d, 0xdf4a1863, 0x1a3182e5, 0x51336097, 0x537f4562, 0x6477e0b1, 0x6bae84bb, 0x81a01cfe, 0x082b94f9, 0x48685870, 0x45fd198f, 0xde6c8794, 0x7bf8b752, 0x73d323ab, 0x4b02e272, 0x1f8f57e3, 0x55ab2a66, 0xeb2807b2, 0xb5c2032f, 0xc57b9a86, 0x3708a5d3, 0x2887f230, 0xbfa5b223, 0x036aba02, 0x16825ced, 0xcf1c2b8a, 0x79b492a7, 0x07f2f0f3, 0x69e2a14e, 0xdaf4cd65, 0x05bed506, 0x34621fd1, 0xa6fe8ac4, 0x2e539d34, 0xf355a0a2, 0x8ae13205, 0xf6eb75a4, 0x83ec390b, 0x60efaa40, 0x719f065e, 0x6e1051bd, 0x218af93e, 0xdd063d96, 0x3e05aedd, 0xe6bd464d, 0x548db591, 0xc45d0571, 0x06d46f04, 0x5015ff60, 0x98fb2419, 0xbde997d6, 0x4043cc89, 0xd99e7767, 0xe842bdb0, 0x898b8807, 0x195b38e7, 0xc8eedb79, 0x7c0a47a1, 0x420fe97c, 0x841ec9f8, 0x00000000, 0x80868309, 0x2bed4832, 0x1170ac1e, 0x5a724e6c, 0x0efffbfd, 0x8538560f, 0xaed51e3d, 0x2d392736, 0x0fd9640a, 0x5ca62168, 0x5b54d19b, 0x362e3a24, 0x0a67b10c, 0x57e70f93, 0xee96d2b4, 0x9b919e1b, 0xc0c54f80, 0xdc20a261, 0x774b695a, 0x121a161c, 0x93ba0ae2, 0xa02ae5c0, 0x22e0433c, 0x1b171d12, 0x090d0b0e, 0x8bc7adf2, 0xb6a8b92d, 0x1ea9c814, 0xf1198557, 0x75074caf, 0x99ddbbee, 0x7f60fda3, 0x01269ff7, 0x72f5bc5c, 0x663bc544, 0xfb7e345b, 0x4329768b, 0x23c6dccb, 0xedfc68b6, 0xe4f163b8, 0x31dccad7, 0x63851042, 0x97224013, 0xc6112084, 0x4a247d85, 0xbb3df8d2, 0xf93211ae, 0x29a16dc7, 0x9e2f4b1d, 0xb230f3dc, 0x8652ec0d, 0xc1e3d077, 0xb3166c2b, 0x70b999a9, 0x9448fa11, 0xe9642247, 0xfc8cc4a8, 0xf03f1aa0, 0x7d2cd856, 0x3390ef22, 0x494ec787, 0x38d1c1d9, 0xcaa2fe8c, 0xd40b3698, 0xf581cfa6, 0x7ade28a5, 0xb78e26da, 0xadbfa43f, 0x3a9de42c, 0x78920d50, 0x5fcc9b6a, 0x7e466254, 0x8d13c2f6, 0xd8b8e890, 0x39f75e2e, 0xc3aff582, 0x5d80be9f, 0xd0937c69, 0xd52da96f, 0x2512b3cf, 0xac993bc8, 0x187da710, 0x9c636ee8, 0x3bbb7bdb, 0x267809cd, 0x5918f46e, 0x9ab701ec, 0x4f9aa883, 0x956e65e6, 0xffe67eaa, 0xbccf0821, 0x15e8e6ef, 0xe79bd9ba, 0x6f36ce4a, 0x9f09d4ea, 0xb07cd629, 0xa4b2af31, 0x3f23312a, 0xa59430c6, 0xa266c035, 0x4ebc3774, 0x82caa6fc, 0x90d0b0e0, 0xa7d81533, 0x04984af1, 0xecdaf741, 0xcd500e7f, 0x91f62f17, 0x4dd68d76, 0xefb04d43, 0xaa4d54cc, 0x9604dfe4, 0xd1b5e39e, 0x6a881b4c, 0x2c1fb8c1, 0x65517f46, 0x5eea049d, 0x8c355d01, 0x877473fa, 0x0b412efb, 0x671d5ab3, 0xdbd25292, 0x105633e9, 0xd647136d, 0xd7618c9a, 0xa10c7a37, 0xf8148e59, 0x133c89eb, 0xa927eece, 0x61c935b7, 0x1ce5ede1, 0x47b13c7a, 0xd2df599c, 0xf2733f55, 0x14ce7918, 0xc737bf73, 0xf7cdea53, 0xfdaa5b5f, 0x3d6f14df, 0x44db8678, 0xaff381ca, 0x68c43eb9, 0x24342c38, 0xa3405fc2, 0x1dc37216, 0xe2250cbc, 0x3c498b28, 0x0d9541ff, 0xa8017139, 0x0cb3de08, 0xb4e49cd8, 0x56c19064, 0xcb84617b, 0x32b670d5, 0x6c5c7448, 0xb85742d0];
            Aes.U1 = [0x00000000, 0x0e090d0b, 0x1c121a16, 0x121b171d, 0x3824342c, 0x362d3927, 0x24362e3a, 0x2a3f2331, 0x70486858, 0x7e416553, 0x6c5a724e, 0x62537f45, 0x486c5c74, 0x4665517f, 0x547e4662, 0x5a774b69, 0xe090d0b0, 0xee99ddbb, 0xfc82caa6, 0xf28bc7ad, 0xd8b4e49c, 0xd6bde997, 0xc4a6fe8a, 0xcaaff381, 0x90d8b8e8, 0x9ed1b5e3, 0x8ccaa2fe, 0x82c3aff5, 0xa8fc8cc4, 0xa6f581cf, 0xb4ee96d2, 0xbae79bd9, 0xdb3bbb7b, 0xd532b670, 0xc729a16d, 0xc920ac66, 0xe31f8f57, 0xed16825c, 0xff0d9541, 0xf104984a, 0xab73d323, 0xa57ade28, 0xb761c935, 0xb968c43e, 0x9357e70f, 0x9d5eea04, 0x8f45fd19, 0x814cf012, 0x3bab6bcb, 0x35a266c0, 0x27b971dd, 0x29b07cd6, 0x038f5fe7, 0x0d8652ec, 0x1f9d45f1, 0x119448fa, 0x4be30393, 0x45ea0e98, 0x57f11985, 0x59f8148e, 0x73c737bf, 0x7dce3ab4, 0x6fd52da9, 0x61dc20a2, 0xad766df6, 0xa37f60fd, 0xb16477e0, 0xbf6d7aeb, 0x955259da, 0x9b5b54d1, 0x894043cc, 0x87494ec7, 0xdd3e05ae, 0xd33708a5, 0xc12c1fb8, 0xcf2512b3, 0xe51a3182, 0xeb133c89, 0xf9082b94, 0xf701269f, 0x4de6bd46, 0x43efb04d, 0x51f4a750, 0x5ffdaa5b, 0x75c2896a, 0x7bcb8461, 0x69d0937c, 0x67d99e77, 0x3daed51e, 0x33a7d815, 0x21bccf08, 0x2fb5c203, 0x058ae132, 0x0b83ec39, 0x1998fb24, 0x1791f62f, 0x764dd68d, 0x7844db86, 0x6a5fcc9b, 0x6456c190, 0x4e69e2a1, 0x4060efaa, 0x527bf8b7, 0x5c72f5bc, 0x0605bed5, 0x080cb3de, 0x1a17a4c3, 0x141ea9c8, 0x3e218af9, 0x302887f2, 0x223390ef, 0x2c3a9de4, 0x96dd063d, 0x98d40b36, 0x8acf1c2b, 0x84c61120, 0xaef93211, 0xa0f03f1a, 0xb2eb2807, 0xbce2250c, 0xe6956e65, 0xe89c636e, 0xfa877473, 0xf48e7978, 0xdeb15a49, 0xd0b85742, 0xc2a3405f, 0xccaa4d54, 0x41ecdaf7, 0x4fe5d7fc, 0x5dfec0e1, 0x53f7cdea, 0x79c8eedb, 0x77c1e3d0, 0x65daf4cd, 0x6bd3f9c6, 0x31a4b2af, 0x3fadbfa4, 0x2db6a8b9, 0x23bfa5b2, 0x09808683, 0x07898b88, 0x15929c95, 0x1b9b919e, 0xa17c0a47, 0xaf75074c, 0xbd6e1051, 0xb3671d5a, 0x99583e6b, 0x97513360, 0x854a247d, 0x8b432976, 0xd134621f, 0xdf3d6f14, 0xcd267809, 0xc32f7502, 0xe9105633, 0xe7195b38, 0xf5024c25, 0xfb0b412e, 0x9ad7618c, 0x94de6c87, 0x86c57b9a, 0x88cc7691, 0xa2f355a0, 0xacfa58ab, 0xbee14fb6, 0xb0e842bd, 0xea9f09d4, 0xe49604df, 0xf68d13c2, 0xf8841ec9, 0xd2bb3df8, 0xdcb230f3, 0xcea927ee, 0xc0a02ae5, 0x7a47b13c, 0x744ebc37, 0x6655ab2a, 0x685ca621, 0x42638510, 0x4c6a881b, 0x5e719f06, 0x5078920d, 0x0a0fd964, 0x0406d46f, 0x161dc372, 0x1814ce79, 0x322bed48, 0x3c22e043, 0x2e39f75e, 0x2030fa55, 0xec9ab701, 0xe293ba0a, 0xf088ad17, 0xfe81a01c, 0xd4be832d, 0xdab78e26, 0xc8ac993b, 0xc6a59430, 0x9cd2df59, 0x92dbd252, 0x80c0c54f, 0x8ec9c844, 0xa4f6eb75, 0xaaffe67e, 0xb8e4f163, 0xb6edfc68, 0x0c0a67b1, 0x02036aba, 0x10187da7, 0x1e1170ac, 0x342e539d, 0x3a275e96, 0x283c498b, 0x26354480, 0x7c420fe9, 0x724b02e2, 0x605015ff, 0x6e5918f4, 0x44663bc5, 0x4a6f36ce, 0x587421d3, 0x567d2cd8, 0x37a10c7a, 0x39a80171, 0x2bb3166c, 0x25ba1b67, 0x0f853856, 0x018c355d, 0x13972240, 0x1d9e2f4b, 0x47e96422, 0x49e06929, 0x5bfb7e34, 0x55f2733f, 0x7fcd500e, 0x71c45d05, 0x63df4a18, 0x6dd64713, 0xd731dcca, 0xd938d1c1, 0xcb23c6dc, 0xc52acbd7, 0xef15e8e6, 0xe11ce5ed, 0xf307f2f0, 0xfd0efffb, 0xa779b492, 0xa970b999, 0xbb6bae84, 0xb562a38f, 0x9f5d80be, 0x91548db5, 0x834f9aa8, 0x8d4697a3];
            Aes.U2 = [0x00000000, 0x0b0e090d, 0x161c121a, 0x1d121b17, 0x2c382434, 0x27362d39, 0x3a24362e, 0x312a3f23, 0x58704868, 0x537e4165, 0x4e6c5a72, 0x4562537f, 0x74486c5c, 0x7f466551, 0x62547e46, 0x695a774b, 0xb0e090d0, 0xbbee99dd, 0xa6fc82ca, 0xadf28bc7, 0x9cd8b4e4, 0x97d6bde9, 0x8ac4a6fe, 0x81caaff3, 0xe890d8b8, 0xe39ed1b5, 0xfe8ccaa2, 0xf582c3af, 0xc4a8fc8c, 0xcfa6f581, 0xd2b4ee96, 0xd9bae79b, 0x7bdb3bbb, 0x70d532b6, 0x6dc729a1, 0x66c920ac, 0x57e31f8f, 0x5ced1682, 0x41ff0d95, 0x4af10498, 0x23ab73d3, 0x28a57ade, 0x35b761c9, 0x3eb968c4, 0x0f9357e7, 0x049d5eea, 0x198f45fd, 0x12814cf0, 0xcb3bab6b, 0xc035a266, 0xdd27b971, 0xd629b07c, 0xe7038f5f, 0xec0d8652, 0xf11f9d45, 0xfa119448, 0x934be303, 0x9845ea0e, 0x8557f119, 0x8e59f814, 0xbf73c737, 0xb47dce3a, 0xa96fd52d, 0xa261dc20, 0xf6ad766d, 0xfda37f60, 0xe0b16477, 0xebbf6d7a, 0xda955259, 0xd19b5b54, 0xcc894043, 0xc787494e, 0xaedd3e05, 0xa5d33708, 0xb8c12c1f, 0xb3cf2512, 0x82e51a31, 0x89eb133c, 0x94f9082b, 0x9ff70126, 0x464de6bd, 0x4d43efb0, 0x5051f4a7, 0x5b5ffdaa, 0x6a75c289, 0x617bcb84, 0x7c69d093, 0x7767d99e, 0x1e3daed5, 0x1533a7d8, 0x0821bccf, 0x032fb5c2, 0x32058ae1, 0x390b83ec, 0x241998fb, 0x2f1791f6, 0x8d764dd6, 0x867844db, 0x9b6a5fcc, 0x906456c1, 0xa14e69e2, 0xaa4060ef, 0xb7527bf8, 0xbc5c72f5, 0xd50605be, 0xde080cb3, 0xc31a17a4, 0xc8141ea9, 0xf93e218a, 0xf2302887, 0xef223390, 0xe42c3a9d, 0x3d96dd06, 0x3698d40b, 0x2b8acf1c, 0x2084c611, 0x11aef932, 0x1aa0f03f, 0x07b2eb28, 0x0cbce225, 0x65e6956e, 0x6ee89c63, 0x73fa8774, 0x78f48e79, 0x49deb15a, 0x42d0b857, 0x5fc2a340, 0x54ccaa4d, 0xf741ecda, 0xfc4fe5d7, 0xe15dfec0, 0xea53f7cd, 0xdb79c8ee, 0xd077c1e3, 0xcd65daf4, 0xc66bd3f9, 0xaf31a4b2, 0xa43fadbf, 0xb92db6a8, 0xb223bfa5, 0x83098086, 0x8807898b, 0x9515929c, 0x9e1b9b91, 0x47a17c0a, 0x4caf7507, 0x51bd6e10, 0x5ab3671d, 0x6b99583e, 0x60975133, 0x7d854a24, 0x768b4329, 0x1fd13462, 0x14df3d6f, 0x09cd2678, 0x02c32f75, 0x33e91056, 0x38e7195b, 0x25f5024c, 0x2efb0b41, 0x8c9ad761, 0x8794de6c, 0x9a86c57b, 0x9188cc76, 0xa0a2f355, 0xabacfa58, 0xb6bee14f, 0xbdb0e842, 0xd4ea9f09, 0xdfe49604, 0xc2f68d13, 0xc9f8841e, 0xf8d2bb3d, 0xf3dcb230, 0xeecea927, 0xe5c0a02a, 0x3c7a47b1, 0x37744ebc, 0x2a6655ab, 0x21685ca6, 0x10426385, 0x1b4c6a88, 0x065e719f, 0x0d507892, 0x640a0fd9, 0x6f0406d4, 0x72161dc3, 0x791814ce, 0x48322bed, 0x433c22e0, 0x5e2e39f7, 0x552030fa, 0x01ec9ab7, 0x0ae293ba, 0x17f088ad, 0x1cfe81a0, 0x2dd4be83, 0x26dab78e, 0x3bc8ac99, 0x30c6a594, 0x599cd2df, 0x5292dbd2, 0x4f80c0c5, 0x448ec9c8, 0x75a4f6eb, 0x7eaaffe6, 0x63b8e4f1, 0x68b6edfc, 0xb10c0a67, 0xba02036a, 0xa710187d, 0xac1e1170, 0x9d342e53, 0x963a275e, 0x8b283c49, 0x80263544, 0xe97c420f, 0xe2724b02, 0xff605015, 0xf46e5918, 0xc544663b, 0xce4a6f36, 0xd3587421, 0xd8567d2c, 0x7a37a10c, 0x7139a801, 0x6c2bb316, 0x6725ba1b, 0x560f8538, 0x5d018c35, 0x40139722, 0x4b1d9e2f, 0x2247e964, 0x2949e069, 0x345bfb7e, 0x3f55f273, 0x0e7fcd50, 0x0571c45d, 0x1863df4a, 0x136dd647, 0xcad731dc, 0xc1d938d1, 0xdccb23c6, 0xd7c52acb, 0xe6ef15e8, 0xede11ce5, 0xf0f307f2, 0xfbfd0eff, 0x92a779b4, 0x99a970b9, 0x84bb6bae, 0x8fb562a3, 0xbe9f5d80, 0xb591548d, 0xa8834f9a, 0xa38d4697];
            Aes.U3 = [0x00000000, 0x0d0b0e09, 0x1a161c12, 0x171d121b, 0x342c3824, 0x3927362d, 0x2e3a2436, 0x23312a3f, 0x68587048, 0x65537e41, 0x724e6c5a, 0x7f456253, 0x5c74486c, 0x517f4665, 0x4662547e, 0x4b695a77, 0xd0b0e090, 0xddbbee99, 0xcaa6fc82, 0xc7adf28b, 0xe49cd8b4, 0xe997d6bd, 0xfe8ac4a6, 0xf381caaf, 0xb8e890d8, 0xb5e39ed1, 0xa2fe8cca, 0xaff582c3, 0x8cc4a8fc, 0x81cfa6f5, 0x96d2b4ee, 0x9bd9bae7, 0xbb7bdb3b, 0xb670d532, 0xa16dc729, 0xac66c920, 0x8f57e31f, 0x825ced16, 0x9541ff0d, 0x984af104, 0xd323ab73, 0xde28a57a, 0xc935b761, 0xc43eb968, 0xe70f9357, 0xea049d5e, 0xfd198f45, 0xf012814c, 0x6bcb3bab, 0x66c035a2, 0x71dd27b9, 0x7cd629b0, 0x5fe7038f, 0x52ec0d86, 0x45f11f9d, 0x48fa1194, 0x03934be3, 0x0e9845ea, 0x198557f1, 0x148e59f8, 0x37bf73c7, 0x3ab47dce, 0x2da96fd5, 0x20a261dc, 0x6df6ad76, 0x60fda37f, 0x77e0b164, 0x7aebbf6d, 0x59da9552, 0x54d19b5b, 0x43cc8940, 0x4ec78749, 0x05aedd3e, 0x08a5d337, 0x1fb8c12c, 0x12b3cf25, 0x3182e51a, 0x3c89eb13, 0x2b94f908, 0x269ff701, 0xbd464de6, 0xb04d43ef, 0xa75051f4, 0xaa5b5ffd, 0x896a75c2, 0x84617bcb, 0x937c69d0, 0x9e7767d9, 0xd51e3dae, 0xd81533a7, 0xcf0821bc, 0xc2032fb5, 0xe132058a, 0xec390b83, 0xfb241998, 0xf62f1791, 0xd68d764d, 0xdb867844, 0xcc9b6a5f, 0xc1906456, 0xe2a14e69, 0xefaa4060, 0xf8b7527b, 0xf5bc5c72, 0xbed50605, 0xb3de080c, 0xa4c31a17, 0xa9c8141e, 0x8af93e21, 0x87f23028, 0x90ef2233, 0x9de42c3a, 0x063d96dd, 0x0b3698d4, 0x1c2b8acf, 0x112084c6, 0x3211aef9, 0x3f1aa0f0, 0x2807b2eb, 0x250cbce2, 0x6e65e695, 0x636ee89c, 0x7473fa87, 0x7978f48e, 0x5a49deb1, 0x5742d0b8, 0x405fc2a3, 0x4d54ccaa, 0xdaf741ec, 0xd7fc4fe5, 0xc0e15dfe, 0xcdea53f7, 0xeedb79c8, 0xe3d077c1, 0xf4cd65da, 0xf9c66bd3, 0xb2af31a4, 0xbfa43fad, 0xa8b92db6, 0xa5b223bf, 0x86830980, 0x8b880789, 0x9c951592, 0x919e1b9b, 0x0a47a17c, 0x074caf75, 0x1051bd6e, 0x1d5ab367, 0x3e6b9958, 0x33609751, 0x247d854a, 0x29768b43, 0x621fd134, 0x6f14df3d, 0x7809cd26, 0x7502c32f, 0x5633e910, 0x5b38e719, 0x4c25f502, 0x412efb0b, 0x618c9ad7, 0x6c8794de, 0x7b9a86c5, 0x769188cc, 0x55a0a2f3, 0x58abacfa, 0x4fb6bee1, 0x42bdb0e8, 0x09d4ea9f, 0x04dfe496, 0x13c2f68d, 0x1ec9f884, 0x3df8d2bb, 0x30f3dcb2, 0x27eecea9, 0x2ae5c0a0, 0xb13c7a47, 0xbc37744e, 0xab2a6655, 0xa621685c, 0x85104263, 0x881b4c6a, 0x9f065e71, 0x920d5078, 0xd9640a0f, 0xd46f0406, 0xc372161d, 0xce791814, 0xed48322b, 0xe0433c22, 0xf75e2e39, 0xfa552030, 0xb701ec9a, 0xba0ae293, 0xad17f088, 0xa01cfe81, 0x832dd4be, 0x8e26dab7, 0x993bc8ac, 0x9430c6a5, 0xdf599cd2, 0xd25292db, 0xc54f80c0, 0xc8448ec9, 0xeb75a4f6, 0xe67eaaff, 0xf163b8e4, 0xfc68b6ed, 0x67b10c0a, 0x6aba0203, 0x7da71018, 0x70ac1e11, 0x539d342e, 0x5e963a27, 0x498b283c, 0x44802635, 0x0fe97c42, 0x02e2724b, 0x15ff6050, 0x18f46e59, 0x3bc54466, 0x36ce4a6f, 0x21d35874, 0x2cd8567d, 0x0c7a37a1, 0x017139a8, 0x166c2bb3, 0x1b6725ba, 0x38560f85, 0x355d018c, 0x22401397, 0x2f4b1d9e, 0x642247e9, 0x692949e0, 0x7e345bfb, 0x733f55f2, 0x500e7fcd, 0x5d0571c4, 0x4a1863df, 0x47136dd6, 0xdccad731, 0xd1c1d938, 0xc6dccb23, 0xcbd7c52a, 0xe8e6ef15, 0xe5ede11c, 0xf2f0f307, 0xfffbfd0e, 0xb492a779, 0xb999a970, 0xae84bb6b, 0xa38fb562, 0x80be9f5d, 0x8db59154, 0x9aa8834f, 0x97a38d46];
            Aes.U4 = [0x00000000, 0x090d0b0e, 0x121a161c, 0x1b171d12, 0x24342c38, 0x2d392736, 0x362e3a24, 0x3f23312a, 0x48685870, 0x4165537e, 0x5a724e6c, 0x537f4562, 0x6c5c7448, 0x65517f46, 0x7e466254, 0x774b695a, 0x90d0b0e0, 0x99ddbbee, 0x82caa6fc, 0x8bc7adf2, 0xb4e49cd8, 0xbde997d6, 0xa6fe8ac4, 0xaff381ca, 0xd8b8e890, 0xd1b5e39e, 0xcaa2fe8c, 0xc3aff582, 0xfc8cc4a8, 0xf581cfa6, 0xee96d2b4, 0xe79bd9ba, 0x3bbb7bdb, 0x32b670d5, 0x29a16dc7, 0x20ac66c9, 0x1f8f57e3, 0x16825ced, 0x0d9541ff, 0x04984af1, 0x73d323ab, 0x7ade28a5, 0x61c935b7, 0x68c43eb9, 0x57e70f93, 0x5eea049d, 0x45fd198f, 0x4cf01281, 0xab6bcb3b, 0xa266c035, 0xb971dd27, 0xb07cd629, 0x8f5fe703, 0x8652ec0d, 0x9d45f11f, 0x9448fa11, 0xe303934b, 0xea0e9845, 0xf1198557, 0xf8148e59, 0xc737bf73, 0xce3ab47d, 0xd52da96f, 0xdc20a261, 0x766df6ad, 0x7f60fda3, 0x6477e0b1, 0x6d7aebbf, 0x5259da95, 0x5b54d19b, 0x4043cc89, 0x494ec787, 0x3e05aedd, 0x3708a5d3, 0x2c1fb8c1, 0x2512b3cf, 0x1a3182e5, 0x133c89eb, 0x082b94f9, 0x01269ff7, 0xe6bd464d, 0xefb04d43, 0xf4a75051, 0xfdaa5b5f, 0xc2896a75, 0xcb84617b, 0xd0937c69, 0xd99e7767, 0xaed51e3d, 0xa7d81533, 0xbccf0821, 0xb5c2032f, 0x8ae13205, 0x83ec390b, 0x98fb2419, 0x91f62f17, 0x4dd68d76, 0x44db8678, 0x5fcc9b6a, 0x56c19064, 0x69e2a14e, 0x60efaa40, 0x7bf8b752, 0x72f5bc5c, 0x05bed506, 0x0cb3de08, 0x17a4c31a, 0x1ea9c814, 0x218af93e, 0x2887f230, 0x3390ef22, 0x3a9de42c, 0xdd063d96, 0xd40b3698, 0xcf1c2b8a, 0xc6112084, 0xf93211ae, 0xf03f1aa0, 0xeb2807b2, 0xe2250cbc, 0x956e65e6, 0x9c636ee8, 0x877473fa, 0x8e7978f4, 0xb15a49de, 0xb85742d0, 0xa3405fc2, 0xaa4d54cc, 0xecdaf741, 0xe5d7fc4f, 0xfec0e15d, 0xf7cdea53, 0xc8eedb79, 0xc1e3d077, 0xdaf4cd65, 0xd3f9c66b, 0xa4b2af31, 0xadbfa43f, 0xb6a8b92d, 0xbfa5b223, 0x80868309, 0x898b8807, 0x929c9515, 0x9b919e1b, 0x7c0a47a1, 0x75074caf, 0x6e1051bd, 0x671d5ab3, 0x583e6b99, 0x51336097, 0x4a247d85, 0x4329768b, 0x34621fd1, 0x3d6f14df, 0x267809cd, 0x2f7502c3, 0x105633e9, 0x195b38e7, 0x024c25f5, 0x0b412efb, 0xd7618c9a, 0xde6c8794, 0xc57b9a86, 0xcc769188, 0xf355a0a2, 0xfa58abac, 0xe14fb6be, 0xe842bdb0, 0x9f09d4ea, 0x9604dfe4, 0x8d13c2f6, 0x841ec9f8, 0xbb3df8d2, 0xb230f3dc, 0xa927eece, 0xa02ae5c0, 0x47b13c7a, 0x4ebc3774, 0x55ab2a66, 0x5ca62168, 0x63851042, 0x6a881b4c, 0x719f065e, 0x78920d50, 0x0fd9640a, 0x06d46f04, 0x1dc37216, 0x14ce7918, 0x2bed4832, 0x22e0433c, 0x39f75e2e, 0x30fa5520, 0x9ab701ec, 0x93ba0ae2, 0x88ad17f0, 0x81a01cfe, 0xbe832dd4, 0xb78e26da, 0xac993bc8, 0xa59430c6, 0xd2df599c, 0xdbd25292, 0xc0c54f80, 0xc9c8448e, 0xf6eb75a4, 0xffe67eaa, 0xe4f163b8, 0xedfc68b6, 0x0a67b10c, 0x036aba02, 0x187da710, 0x1170ac1e, 0x2e539d34, 0x275e963a, 0x3c498b28, 0x35448026, 0x420fe97c, 0x4b02e272, 0x5015ff60, 0x5918f46e, 0x663bc544, 0x6f36ce4a, 0x7421d358, 0x7d2cd856, 0xa10c7a37, 0xa8017139, 0xb3166c2b, 0xba1b6725, 0x8538560f, 0x8c355d01, 0x97224013, 0x9e2f4b1d, 0xe9642247, 0xe0692949, 0xfb7e345b, 0xf2733f55, 0xcd500e7f, 0xc45d0571, 0xdf4a1863, 0xd647136d, 0x31dccad7, 0x38d1c1d9, 0x23c6dccb, 0x2acbd7c5, 0x15e8e6ef, 0x1ce5ede1, 0x07f2f0f3, 0x0efffbfd, 0x79b492a7, 0x70b999a9, 0x6bae84bb, 0x62a38fb5, 0x5d80be9f, 0x548db591, 0x4f9aa883, 0x4697a38d];
            return Aes;
        } ());
        Cryptography.Aes = Aes;
    })(Cryptography = Neo.Cryptography || (Neo.Cryptography = {}));
})(Neo || (Neo = {}));
var Neo;
(function (Neo) {
    var Cryptography;
    (function (Cryptography) {
        var Base58 = (function () {
            function Base58() {
            }
            Base58.decode = function (input) {
                var bi = Neo.BigInteger.Zero;
                for (var i = input.length - 1; i >= 0; i--) {
                    var index = Base58.Alphabet.indexOf(input[i]);
                    if (index == -1)
                        throw new RangeError();
                    bi = Neo.BigInteger.add(bi, Neo.BigInteger.multiply(Neo.BigInteger.pow(Base58.Alphabet.length, input.length - 1 - i), index));
                }
                var bytes = bi.toUint8Array();
                var leadingZeros = 0;
                for (var i = 0; i < input.length && input[i] == Base58.Alphabet[0]; i++) {
                    leadingZeros++;
                }
                var tmp = new Uint8Array(bytes.length + leadingZeros);
                for (var i = 0; i < bytes.length; i++)
                    tmp[i + leadingZeros] = bytes[bytes.length - 1 - i];
                return tmp;
            };
            Base58.encode = function (input) {
                var value = Neo.BigInteger.fromUint8Array(input, 1, false);
                var s = "";
                while (!value.isZero()) {
                    var r = Neo.BigInteger.divRem(value, Base58.Alphabet.length);
                    s = Base58.Alphabet[r.remainder.toInt32()] + s;
                    value = r.result;
                }
                for (var i = 0; i < input.length; i++) {
                    if (input[i] == 0)
                        s = Base58.Alphabet[0] + s;
                    else
                        break;
                }
                return s;
            };
            Base58.Alphabet = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
            return Base58;
        } ());
        Cryptography.Base58 = Base58;
    })(Cryptography = Neo.Cryptography || (Neo.Cryptography = {}));
})(Neo || (Neo = {}));
var Neo;
(function (Neo) {
    var Cryptography;
    (function (Cryptography) {
        var CryptoKey = (function () {
            function CryptoKey(type, extractable, algorithm, usages) {
                this.type = type;
                this.extractable = extractable;
                this.algorithm = algorithm;
                this.usages = usages;
            }
            return CryptoKey;
        } ());
        Cryptography.CryptoKey = CryptoKey;
        var AesCryptoKey = (function (_super) {
            __extends(AesCryptoKey, _super);
            function AesCryptoKey(_key_bytes) {
                var _this = _super.call(this, "secret", true, { name: "AES-CBC", length: _key_bytes.length * 8 }, ["encrypt", "decrypt"]) || this;
                _this._key_bytes = _key_bytes;
                return _this;
            }
            AesCryptoKey.create = function (length) {
                if (length != 128 && length != 192 && length != 256)
                    throw new RangeError();
                var key = new AesCryptoKey(new Uint8Array(length / 8));
                window.crypto.getRandomValues(key._key_bytes);
                return key;
            };
            AesCryptoKey.prototype.export = function () {
                return this._key_bytes;
            };
            AesCryptoKey.import = function (keyData) {
                if (keyData.byteLength != 16 && keyData.byteLength != 24 && keyData.byteLength != 32)
                    throw new RangeError();
                return new AesCryptoKey(Uint8Array.fromArrayBuffer(keyData));
            };
            return AesCryptoKey;
        } (Neo.Cryptography.CryptoKey));
        Cryptography.AesCryptoKey = AesCryptoKey;
        var ECDsaCryptoKey = (function (_super) {
            __extends(ECDsaCryptoKey, _super);
            function ECDsaCryptoKey(publicKey, privateKey) {
                var _this = _super.call(this, privateKey == null ? "public" : "private", true, { name: "ECDSA", namedCurve: "P-256" }, [privateKey == null ? "verify" : "sign"]) || this;
                _this.publicKey = publicKey;
                _this.privateKey = privateKey;
                return _this;
            }
            return ECDsaCryptoKey;
        } (CryptoKey));
        Cryptography.ECDsaCryptoKey = ECDsaCryptoKey;
    })(Cryptography = Neo.Cryptography || (Neo.Cryptography = {}));
})(Neo || (Neo = {}));
var Neo;
(function (Neo) {
    var Cryptography;
    (function (Cryptography) {
        var _secp256k1;
        var _secp256r1;
        var ECCurve = (function () {
            function ECCurve(Q, A, B, N, G) {
                this.Q = Q;
                this.A = new Cryptography.ECFieldElement(A, this);
                this.B = new Cryptography.ECFieldElement(B, this);
                this.N = N;
                this.Infinity = new Cryptography.ECPoint(null, null, this);
                this.G = Cryptography.ECPoint.decodePoint(G, this);
            }
            Object.defineProperty(ECCurve, "secp256k1", {
                get: function () {
                    return _secp256k1 || (_secp256k1 = new ECCurve(Neo.BigInteger.fromString("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F", 16), Neo.BigInteger.Zero, new Neo.BigInteger(7), Neo.BigInteger.fromString("FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141", 16), ("04" + "79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798" + "483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8").hexToBytes()));
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(ECCurve, "secp256r1", {
                get: function () {
                    return _secp256r1 || (_secp256r1 = new ECCurve(Neo.BigInteger.fromString("FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF", 16), Neo.BigInteger.fromString("FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC", 16), Neo.BigInteger.fromString("5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B", 16), Neo.BigInteger.fromString("FFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551", 16), ("04" + "6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296" + "4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5").hexToBytes()));
                },
                enumerable: true,
                configurable: true
            });
            return ECCurve;
        } ());
        Cryptography.ECCurve = ECCurve;
    })(Cryptography = Neo.Cryptography || (Neo.Cryptography = {}));
})(Neo || (Neo = {}));
var Neo;
(function (Neo) {
    var Cryptography;
    (function (Cryptography) {
        var ECDsa = (function () {
            function ECDsa(key) {
                this.key = key;
            }
            ECDsa.calculateE = function (n, message) {
                return Neo.BigInteger.fromUint8Array(new Uint8Array(Cryptography.Sha256.computeHash(message)), 1, false);
            };
            ECDsa.generateKey = function (curve) {
                var prikey = new Uint8Array(32);
                window.crypto.getRandomValues(prikey);
                var pubkey = Cryptography.ECPoint.multiply(curve.G, prikey);
                return {
                    privateKey: new Cryptography.ECDsaCryptoKey(pubkey, prikey),
                    publicKey: new Cryptography.ECDsaCryptoKey(pubkey)
                };
            };
            ECDsa.prototype.sign = function (message) {
                if (this.key.privateKey == null)
                    throw new Error();
                var e = ECDsa.calculateE(this.key.publicKey.curve.N, message);
                var d = Neo.BigInteger.fromUint8Array(this.key.privateKey, 1, false);
                var r, s;
                do {
                    var k = void 0;
                    do {
                        do {
                            k = Neo.BigInteger.random(this.key.publicKey.curve.N.bitLength(), window.crypto);
                        } while (k.sign() == 0 || k.compareTo(this.key.publicKey.curve.N) >= 0);
                        var p = Cryptography.ECPoint.multiply(this.key.publicKey.curve.G, k);
                        var x = p.x.value;
                        r = x.mod(this.key.publicKey.curve.N);
                    } while (r.sign() == 0);
                    s = k.modInverse(this.key.publicKey.curve.N).multiply(e.add(d.multiply(r))).mod(this.key.publicKey.curve.N);
                    if (s.compareTo(this.key.publicKey.curve.N.divide(2)) > 0) {
                        s = this.key.publicKey.curve.N.subtract(s);
                    }
                } while (s.sign() == 0);
                var arr = new Uint8Array(64);
                Array.copy(r.toUint8Array(false, 32), 0, arr, 0, 32);
                Array.copy(s.toUint8Array(false, 32), 0, arr, 32, 32);
                return arr.buffer;
            };
            ECDsa.sumOfTwoMultiplies = function (P, k, Q, l) {
                var m = Math.max(k.bitLength(), l.bitLength());
                var Z = Cryptography.ECPoint.add(P, Q);
                var R = P.curve.Infinity;
                for (var i = m - 1; i >= 0; --i) {
                    R = R.twice();
                    if (k.testBit(i)) {
                        if (l.testBit(i))
                            R = Cryptography.ECPoint.add(R, Z);
                        else
                            R = Cryptography.ECPoint.add(R, P);
                    }
                    else {
                        if (l.testBit(i))
                            R = Cryptography.ECPoint.add(R, Q);
                    }
                }
                return R;
            };
            ECDsa.prototype.verify = function (message, signature) {
                var arr = Uint8Array.fromArrayBuffer(signature);
                var r = Neo.BigInteger.fromUint8Array(arr.subarray(0, 32), 1, false);
                var s = Neo.BigInteger.fromUint8Array(arr.subarray(32, 64), 1, false);
                if (r.compareTo(this.key.publicKey.curve.N) >= 0 || s.compareTo(this.key.publicKey.curve.N) >= 0)
                    return false;
                var e = ECDsa.calculateE(this.key.publicKey.curve.N, message);
                var c = s.modInverse(this.key.publicKey.curve.N);
                var u1 = e.multiply(c).mod(this.key.publicKey.curve.N);
                var u2 = r.multiply(c).mod(this.key.publicKey.curve.N);
                var point = ECDsa.sumOfTwoMultiplies(this.key.publicKey.curve.G, u1, this.key.publicKey, u2);
                var v = point.x.value.mod(this.key.publicKey.curve.N);
                return v.equals(r);
            };
            return ECDsa;
        } ());
        Cryptography.ECDsa = ECDsa;
    })(Cryptography = Neo.Cryptography || (Neo.Cryptography = {}));
})(Neo || (Neo = {}));
var Neo;
(function (Neo) {
    var Cryptography;
    (function (Cryptography) {
        var ECFieldElement = (function () {
            function ECFieldElement(value, curve) {
                this.value = value;
                this.curve = curve;
                if (Neo.BigInteger.compare(value, curve.Q) >= 0)
                    throw new RangeError("x value too large in field element");
            }
            ECFieldElement.prototype.add = function (other) {
                return new ECFieldElement(this.value.add(other.value).mod(this.curve.Q), this.curve);
            };
            ECFieldElement.prototype.compareTo = function (other) {
                if (this === other)
                    return 0;
                return this.value.compareTo(other.value);
            };
            ECFieldElement.prototype.divide = function (other) {
                return new ECFieldElement(this.value.multiply(other.value.modInverse(this.curve.Q)).mod(this.curve.Q), this.curve);
            };
            ECFieldElement.prototype.equals = function (other) {
                return this.value.equals(other.value);
            };
            ECFieldElement.fastLucasSequence = function (p, P, Q, k) {
                var n = k.bitLength();
                var s = k.getLowestSetBit();
                console.assert(k.testBit(s));
                var Uh = Neo.BigInteger.One;
                var Vl = new Neo.BigInteger(2);
                var Vh = P;
                var Ql = Neo.BigInteger.One;
                var Qh = Neo.BigInteger.One;
                for (var j = n - 1; j >= s + 1; --j) {
                    Ql = Neo.BigInteger.mod(Neo.BigInteger.multiply(Ql, Qh), p);
                    if (k.testBit(j)) {
                        Qh = Ql.multiply(Q).mod(p);
                        Uh = Uh.multiply(Vh).mod(p);
                        Vl = Vh.multiply(Vl).subtract(P.multiply(Ql)).mod(p);
                        Vh = Vh.multiply(Vh).subtract(Qh.leftShift(1)).mod(p);
                    }
                    else {
                        Qh = Ql;
                        Uh = Uh.multiply(Vl).subtract(Ql).mod(p);
                        Vh = Vh.multiply(Vl).subtract(P.multiply(Ql)).mod(p);
                        Vl = Vl.multiply(Vl).subtract(Ql.leftShift(1)).mod(p);
                    }
                }
                Ql = Ql.multiply(Qh).mod(p);
                Qh = Ql.multiply(Q).mod(p);
                Uh = Uh.multiply(Vl).subtract(Ql).mod(p);
                Vl = Vh.multiply(Vl).subtract(P.multiply(Ql)).mod(p);
                Ql = Ql.multiply(Qh).mod(p);
                for (var j = 1; j <= s; ++j) {
                    Uh = Uh.multiply(Vl).multiply(p);
                    Vl = Vl.multiply(Vl).subtract(Ql.leftShift(1)).mod(p);
                    Ql = Ql.multiply(Ql).mod(p);
                }
                return [Uh, Vl];
            };
            ECFieldElement.prototype.multiply = function (other) {
                return new ECFieldElement(this.value.multiply(other.value).mod(this.curve.Q), this.curve);
            };
            ECFieldElement.prototype.negate = function () {
                return new ECFieldElement(this.value.negate().mod(this.curve.Q), this.curve);
            };
            ECFieldElement.prototype.sqrt = function () {
                if (this.curve.Q.testBit(1)) {
                    var z = new ECFieldElement(Neo.BigInteger.modPow(this.value, this.curve.Q.rightShift(2).add(1), this.curve.Q), this.curve);
                    return z.square().equals(this) ? z : null;
                }
                var qMinusOne = this.curve.Q.subtract(1);
                var legendreExponent = qMinusOne.rightShift(1);
                if (Neo.BigInteger.modPow(this.value, legendreExponent, this.curve.Q).equals(1))
                    return null;
                var u = qMinusOne.rightShift(2);
                var k = u.leftShift(1).add(1);
                var Q = this.value;
                var fourQ = Q.leftShift(2).mod(this.curve.Q);
                var U, V;
                do {
                    var P = void 0;
                    do {
                        P = Neo.BigInteger.random(this.curve.Q.bitLength());
                    } while (P.compareTo(this.curve.Q) >= 0 || !Neo.BigInteger.modPow(P.multiply(P).subtract(fourQ), legendreExponent, this.curve.Q).equals(qMinusOne));
                    var result = ECFieldElement.fastLucasSequence(this.curve.Q, P, Q, k);
                    U = result[0];
                    V = result[1];
                    if (V.multiply(V).mod(this.curve.Q).equals(fourQ)) {
                        if (V.testBit(0)) {
                            V = V.add(this.curve.Q);
                        }
                        V = V.rightShift(1);
                        console.assert(V.multiply(V).mod(this.curve.Q).equals(this.value));
                        return new ECFieldElement(V, this.curve);
                    }
                } while (U.equals(Neo.BigInteger.One) || U.equals(qMinusOne));
                return null;
            };
            ECFieldElement.prototype.square = function () {
                return new ECFieldElement(this.value.multiply(this.value).mod(this.curve.Q), this.curve);
            };
            ECFieldElement.prototype.subtract = function (other) {
                return new ECFieldElement(this.value.subtract(other.value).mod(this.curve.Q), this.curve);
            };
            return ECFieldElement;
        } ());
        Cryptography.ECFieldElement = ECFieldElement;
    })(Cryptography = Neo.Cryptography || (Neo.Cryptography = {}));
})(Neo || (Neo = {}));
var Neo;
(function (Neo) {
    var Cryptography;
    (function (Cryptography) {
        var ECPoint = (function () {
            function ECPoint(x, y, curve) {
                this.x = x;
                this.y = y;
                this.curve = curve;
                if ((x == null) != (y == null))
                    throw new RangeError("Exactly one of the field elements is null");
            }
            ECPoint.add = function (x, y) {
                if (x.isInfinity())
                    return y;
                if (y.isInfinity())
                    return x;
                if (x.x.equals(y.x)) {
                    if (x.y.equals(y.y))
                        return x.twice();
                    console.assert(x.y.equals(y.y.negate()));
                    return x.curve.Infinity;
                }
                var gamma = y.y.subtract(x.y).divide(y.x.subtract(x.x));
                var x3 = gamma.square().subtract(x.x).subtract(y.x);
                var y3 = gamma.multiply(x.x.subtract(x3)).subtract(x.y);
                return new ECPoint(x3, y3, x.curve);
            };
            ECPoint.prototype.compareTo = function (other) {
                if (this === other)
                    return 0;
                var result = this.x.compareTo(other.x);
                if (result != 0)
                    return result;
                return this.y.compareTo(other.y);
            };
            ECPoint.decodePoint = function (encoded, curve) {
                var p;
                var expectedLength = Math.ceil(curve.Q.bitLength() / 8);
                switch (encoded[0]) {
                    case 0x00:
                        {
                            if (encoded.length != 1)
                                throw new RangeError("Incorrect length for infinity encoding");
                            p = curve.Infinity;
                            break;
                        }
                    case 0x02:
                    case 0x03:
                        {
                            if (encoded.length != (expectedLength + 1))
                                throw new RangeError("Incorrect length for compressed encoding");
                            var yTilde = encoded[0] & 1;
                            var X1 = Neo.BigInteger.fromUint8Array(encoded.subarray(1), 1, false);
                            p = ECPoint.decompressPoint(yTilde, X1, curve);
                            break;
                        }
                    case 0x04:
                    case 0x06:
                    case 0x07:
                        {
                            if (encoded.length != (2 * expectedLength + 1))
                                throw new RangeError("Incorrect length for uncompressed/hybrid encoding");
                            var X1 = Neo.BigInteger.fromUint8Array(encoded.subarray(1, 1 + expectedLength), 1, false);
                            var Y1 = Neo.BigInteger.fromUint8Array(encoded.subarray(1 + expectedLength), 1, false);
                            p = new ECPoint(new Cryptography.ECFieldElement(X1, curve), new Cryptography.ECFieldElement(Y1, curve), curve);
                            break;
                        }
                    default:
                        throw new RangeError("Invalid point encoding " + encoded[0]);
                }
                return p;
            };
            ECPoint.decompressPoint = function (yTilde, X1, curve) {
                var x = new Cryptography.ECFieldElement(X1, curve);
                var alpha = x.multiply(x.square().add(curve.A)).add(curve.B);
                var beta = alpha.sqrt();
                if (beta == null)
                    throw new RangeError("Invalid point compression");
                var betaValue = beta.value;
                var bit0 = betaValue.isEven() ? 0 : 1;
                if (bit0 != yTilde) {
                    beta = new Cryptography.ECFieldElement(curve.Q.subtract(betaValue), curve);
                }
                return new ECPoint(x, beta, curve);
            };
            ECPoint.deserializeFrom = function (reader, curve) {
                var expectedLength = Math.floor((curve.Q.bitLength() + 7) / 8);
                var array = new Uint8Array(1 + expectedLength * 2);
                array[0] = reader.readByte();
                switch (array[0]) {
                    case 0x00:
                        return curve.Infinity;
                    case 0x02:
                    case 0x03:
                        reader.read(array.buffer, 1, expectedLength);
                        return ECPoint.decodePoint(new Uint8Array(array.buffer, 0, 33), curve);
                    case 0x04:
                    case 0x06:
                    case 0x07:
                        reader.read(array.buffer, 1, expectedLength * 2);
                        return ECPoint.decodePoint(array, curve);
                    default:
                        throw new Error("Invalid point encoding " + array[0]);
                }
            };
            ECPoint.prototype.encodePoint = function (commpressed) {
                if (this.isInfinity())
                    return new Uint8Array(1);
                var data;
                if (commpressed) {
                    data = new Uint8Array(33);
                }
                else {
                    data = new Uint8Array(65);
                    var yBytes = this.y.value.toUint8Array();
                    for (var i = 0; i < yBytes.length; i++)
                        data[65 - yBytes.length + i] = yBytes[yBytes.length - 1 - i];
                }
                var xBytes = this.x.value.toUint8Array();
                for (var i = 0; i < xBytes.length; i++)
                    data[33 - xBytes.length + i] = xBytes[xBytes.length - 1 - i];
                data[0] = commpressed ? this.y.value.isEven() ? 0x02 : 0x03 : 0x04;
                return data;
            };
            ECPoint.prototype.equals = function (other) {
                if (this === other)
                    return true;
                if (null === other)
                    return false;
                if (this.isInfinity && other.isInfinity)
                    return true;
                if (this.isInfinity || other.isInfinity)
                    return false;
                return this.x.equals(other.x) && this.y.equals(other.y);
            };
            ECPoint.fromUint8Array = function (arr, curve) {
                switch (arr.length) {
                    case 33:
                    case 65:
                        return ECPoint.decodePoint(arr, curve);
                    case 64:
                    case 72:
                        {
                            var arr_new = new Uint8Array(65);
                            arr_new[0] = 0x04;
                            arr_new.set(arr.subarray(arr.length - 64), 1);
                            return ECPoint.decodePoint(arr_new, curve);
                        }
                    case 96:
                    case 104:
                        {
                            var arr_new = new Uint8Array(65);
                            arr_new[0] = 0x04;
                            arr_new.set(arr.subarray(arr.length - 96, arr.length - 32), 1);
                            return ECPoint.decodePoint(arr_new, curve);
                        }
                    default:
                        throw new RangeError();
                }
            };
            ECPoint.prototype.isInfinity = function () {
                return this.x == null && this.y == null;
            };
            ECPoint.multiply = function (p, n) {
                var k = n instanceof Uint8Array ? Neo.BigInteger.fromUint8Array(n, 1, false) : n;
                if (p.isInfinity())
                    return p;
                if (k.isZero())
                    return p.curve.Infinity;
                var m = k.bitLength();
                var width;
                var reqPreCompLen;
                if (m < 13) {
                    width = 2;
                    reqPreCompLen = 1;
                }
                else if (m < 41) {
                    width = 3;
                    reqPreCompLen = 2;
                }
                else if (m < 121) {
                    width = 4;
                    reqPreCompLen = 4;
                }
                else if (m < 337) {
                    width = 5;
                    reqPreCompLen = 8;
                }
                else if (m < 897) {
                    width = 6;
                    reqPreCompLen = 16;
                }
                else if (m < 2305) {
                    width = 7;
                    reqPreCompLen = 32;
                }
                else {
                    width = 8;
                    reqPreCompLen = 127;
                }
                var preCompLen = 1;
                var preComp = [p];
                var twiceP = p.twice();
                if (preCompLen < reqPreCompLen) {
                    var oldPreComp = preComp;
                    preComp = new Array(reqPreCompLen);
                    for (var i = 0; i < preCompLen; i++)
                        preComp[i] = oldPreComp[i];
                    for (var i = preCompLen; i < reqPreCompLen; i++) {
                        preComp[i] = ECPoint.add(twiceP, preComp[i - 1]);
                    }
                }
                var wnaf = ECPoint.windowNaf(width, k);
                var l = wnaf.length;
                var q = p.curve.Infinity;
                for (var i = l - 1; i >= 0; i--) {
                    q = q.twice();
                    if (wnaf[i] != 0) {
                        if (wnaf[i] > 0) {
                            q = ECPoint.add(q, preComp[Math.floor((wnaf[i] - 1) / 2)]);
                        }
                        else {
                            q = ECPoint.subtract(q, preComp[Math.floor((-wnaf[i] - 1) / 2)]);
                        }
                    }
                }
                return q;
            };
            ECPoint.prototype.negate = function () {
                return new ECPoint(this.x, this.y.negate(), this.curve);
            };
            ECPoint.parse = function (str, curve) {
                return ECPoint.decodePoint(str.hexToBytes(), curve);
            };
            ECPoint.subtract = function (x, y) {
                if (y.isInfinity())
                    return x;
                return ECPoint.add(x, y.negate());
            };
            ECPoint.prototype.toString = function () {
                return this.encodePoint(true).toHexString();
            };
            ECPoint.prototype.twice = function () {
                if (this.isInfinity())
                    return this;
                if (this.y.value.sign() == 0)
                    return this.curve.Infinity;
                var TWO = new Cryptography.ECFieldElement(new Neo.BigInteger(2), this.curve);
                var THREE = new Cryptography.ECFieldElement(new Neo.BigInteger(3), this.curve);
                var gamma = this.x.square().multiply(THREE).add(this.curve.A).divide(this.y.multiply(TWO));
                var x3 = gamma.square().subtract(this.x.multiply(TWO));
                var y3 = gamma.multiply(this.x.subtract(x3)).subtract(this.y);
                return new ECPoint(x3, y3, this.curve);
            };
            ECPoint.windowNaf = function (width, k) {
                var wnaf = new Array(k.bitLength() + 1);
                var pow2wB = 1 << width;
                var i = 0;
                var length = 0;
                while (k.sign() > 0) {
                    if (!k.isEven()) {
                        var remainder = Neo.BigInteger.remainder(k, pow2wB);
                        if (remainder.testBit(width - 1)) {
                            wnaf[i] = Neo.BigInteger.subtract(remainder, pow2wB).toInt32();
                        }
                        else {
                            wnaf[i] = remainder.toInt32();
                        }
                        k = k.subtract(wnaf[i]);
                        length = i;
                    }
                    else {
                        wnaf[i] = 0;
                    }
                    k = k.rightShift(1);
                    i++;
                }
                wnaf.length = length + 1;
                return wnaf;
            };
            return ECPoint;
        } ());
        Cryptography.ECPoint = ECPoint;
    })(Cryptography = Neo.Cryptography || (Neo.Cryptography = {}));
})(Neo || (Neo = {}));
var Neo;
(function (Neo) {
    var Cryptography;
    (function (Cryptography) {
        var RandomNumberGenerator = (function () {
            function RandomNumberGenerator() {
            }
            RandomNumberGenerator.addEntropy = function (data, strength) {
                if (RandomNumberGenerator._stopped)
                    return;
                for (var i = 0; i < data.length; i++)
                    if (data[i] != null && data[i] != 0) {
                        RandomNumberGenerator._entropy.push(data[i]);
                        RandomNumberGenerator._strength += strength;
                        RandomNumberGenerator._key = null;
                    }
                if (RandomNumberGenerator._strength >= 512)
                    RandomNumberGenerator.stopCollectors();
            };
            RandomNumberGenerator.getRandomValues = function (array) {
                if (RandomNumberGenerator._strength < 256)
                    throw new Error();
                if (RandomNumberGenerator._key == null) {
                    var data = new Float64Array(RandomNumberGenerator._entropy);
                    RandomNumberGenerator._key = new Uint8Array(Cryptography.Sha256.computeHash(data));
                }
                var aes = new Cryptography.Aes(RandomNumberGenerator._key, RandomNumberGenerator.getWeakRandomValues(16));
                var src = new Uint8Array(16);
                var dst = new Uint8Array(array.buffer, array.byteOffset, array.byteLength);
                for (var i = 0; i < dst.length; i += 16) {
                    aes.encryptBlock(RandomNumberGenerator.getWeakRandomValues(16), src);
                    Array.copy(src, 0, dst, i, Math.min(dst.length - i, 16));
                }
                return array;
            };
            RandomNumberGenerator.getWeakRandomValues = function (array) {
                var buffer = typeof array === "number" ? new Uint8Array(array) : array;
                for (var i = 0; i < buffer.length; i++)
                    buffer[i] = Math.random() * 256;
                return buffer;
            };
            RandomNumberGenerator.processDeviceMotionEvent = function (event) {
                RandomNumberGenerator.addEntropy([event.accelerationIncludingGravity.x, event.accelerationIncludingGravity.y, event.accelerationIncludingGravity.z], 1);
                RandomNumberGenerator.processEvent(event);
            };
            RandomNumberGenerator.processEvent = function (event) {
                if (window.performance && window.performance.now)
                    RandomNumberGenerator.addEntropy([window.performance.now()], 20);
                else
                    RandomNumberGenerator.addEntropy([event.timeStamp], 2);
            };
            RandomNumberGenerator.processMouseEvent = function (event) {
                RandomNumberGenerator.addEntropy([event.clientX, event.clientY, event.offsetX, event.offsetY, event.screenX, event.screenY], 4);
                RandomNumberGenerator.processEvent(event);
            };
            RandomNumberGenerator.processTouchEvent = function (event) {
                var touches = event.changedTouches || event.touches;
                for (var i = 0; i < touches.length; i++)
                    RandomNumberGenerator.addEntropy([touches[i].clientX, touches[i].clientY, touches[i]["radiusX"], touches[i]["radiusY"], touches[i]["force"]], 1);
                RandomNumberGenerator.processEvent(event);
            };
            RandomNumberGenerator.startCollectors = function () {
                if (RandomNumberGenerator._started)
                    return;
                window.addEventListener("load", RandomNumberGenerator.processEvent, false);
                window.addEventListener("mousemove", RandomNumberGenerator.processMouseEvent, false);
                window.addEventListener("keypress", RandomNumberGenerator.processEvent, false);
                window.addEventListener("devicemotion", RandomNumberGenerator.processDeviceMotionEvent, false);
                window.addEventListener("touchmove", RandomNumberGenerator.processTouchEvent, false);
                RandomNumberGenerator._started = true;
            };
            RandomNumberGenerator.stopCollectors = function () {
                if (RandomNumberGenerator._stopped)
                    return;
                window.removeEventListener("load", RandomNumberGenerator.processEvent, false);
                window.removeEventListener("mousemove", RandomNumberGenerator.processMouseEvent, false);
                window.removeEventListener("keypress", RandomNumberGenerator.processEvent, false);
                window.removeEventListener("devicemotion", RandomNumberGenerator.processDeviceMotionEvent, false);
                window.removeEventListener("touchmove", RandomNumberGenerator.processTouchEvent, false);
                RandomNumberGenerator._stopped = true;
            };
            RandomNumberGenerator._entropy = [];
            RandomNumberGenerator._strength = 0;
            RandomNumberGenerator._started = false;
            RandomNumberGenerator._stopped = false;
            return RandomNumberGenerator;
        } ());
        Cryptography.RandomNumberGenerator = RandomNumberGenerator;
    })(Cryptography = Neo.Cryptography || (Neo.Cryptography = {}));
})(Neo || (Neo = {}));
var Neo;
(function (Neo) {
    var Cryptography;
    (function (Cryptography) {
        String.prototype.base58Decode = function () {
            return Cryptography.Base58.decode(this);
        };
        String.prototype.base64UrlDecode = function () {
            var str = window.atob(this.replace(/-/g, '+').replace(/_/g, '/'));
            var arr = new Uint8Array(str.length);
            for (var i = 0; i < str.length; i++)
                arr[i] = str.charCodeAt(i);
            return arr;
        };
        String.prototype.toAesKey = function () {
            var utf8 = unescape(encodeURIComponent(this));
            var codes = new Uint8Array(utf8.length);
            for (var i = 0; i < codes.length; i++)
                codes[i] = utf8.charCodeAt(i);
            return window.crypto.subtle.digest({ name: "SHA-256" }, codes).then(function (result) {
                return window.crypto.subtle.digest({ name: "SHA-256" }, result);
            });
        };
        Uint8Array.prototype.base58Encode = function () {
            return Cryptography.Base58.encode(this);
        };
        Uint8Array.prototype.base64UrlEncode = function () {
            var str = String.fromCharCode.apply(null, this);
            str = window.btoa(str);
            return str.replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '');
        };
        var getAlgorithmName = function (algorithm) { return typeof algorithm === "string" ? algorithm : algorithm.name; };
        var w = window;
        if (window.crypto == null)
            window.crypto = { subtle: null, getRandomValues: null };
        if (window.crypto.getRandomValues == null) {
            if (w.msCrypto) {
                w.crypto.getRandomValues = function (array) { return w.msCrypto.getRandomValues(array); };
            }
            else {
                Cryptography.RandomNumberGenerator.startCollectors();
                window.crypto.getRandomValues = Cryptography.RandomNumberGenerator.getRandomValues;
            }
        }
        w.crypto.subtle = window.crypto.subtle || w.crypto.webkitSubtle;
        if (window.crypto.subtle == null && w.msCrypto) {
            window.crypto.subtle = {
                decrypt: function (a, b, c) { return new NeoPromise(function (resolve, reject) { var op = w.msCrypto.subtle.decrypt(a, b, c); op.oncomplete = function () { return resolve(op.result); }; op.onerror = function (e) { return reject(e); }; }); },
                deriveBits: function (a, b, c) { return new NeoPromise(function (resolve, reject) { var op = w.msCrypto.subtle.deriveBits(a, b, c); op.oncomplete = function () { return resolve(op.result); }; op.onerror = function (e) { return reject(e); }; }); },
                deriveKey: function (a, b, c, d, e) { return new NeoPromise(function (resolve, reject) { var op = w.msCrypto.subtle.deriveKey(a, b, c, d, e); op.oncomplete = function () { return resolve(op.result); }; op.onerror = function (e) { return reject(e); }; }); },
                digest: function (a, b) { return new NeoPromise(function (resolve, reject) { var op = w.msCrypto.subtle.digest(a, b); op.oncomplete = function () { return resolve(op.result); }; op.onerror = function (e) { return reject(e); }; }); },
                encrypt: function (a, b, c) { return new NeoPromise(function (resolve, reject) { var op = w.msCrypto.subtle.encrypt(a, b, c); op.oncomplete = function () { return resolve(op.result); }; op.onerror = function (e) { return reject(e); }; }); },
                exportKey: function (a, b) { return new NeoPromise(function (resolve, reject) { var op = w.msCrypto.subtle.exportKey(a, b); op.oncomplete = function () { return resolve(op.result); }; op.onerror = function (e) { return reject(e); }; }); },
                generateKey: function (a, b, c) { return new NeoPromise(function (resolve, reject) { var op = w.msCrypto.subtle.generateKey(a, b, c); op.oncomplete = function () { return resolve(op.result); }; op.onerror = function (e) { return reject(e); }; }); },
                importKey: function (a, b, c, d, e) { return new NeoPromise(function (resolve, reject) { var op = w.msCrypto.subtle.importKey(a, b, c, d, e); op.oncomplete = function () { return resolve(op.result); }; op.onerror = function (e) { return reject(e); }; }); },
                sign: function (a, b, c) { return new NeoPromise(function (resolve, reject) { var op = w.msCrypto.subtle.sign(a, b, c); op.oncomplete = function () { return resolve(op.result); }; op.onerror = function (e) { return reject(e); }; }); },
                unwrapKey: function (a, b, c, d, e, f, g) { return new NeoPromise(function (resolve, reject) { var op = w.msCrypto.subtle.unwrapKey(a, b, c, d, e, f, g); op.oncomplete = function () { return resolve(op.result); }; op.onerror = function (e) { return reject(e); }; }); },
                verify: function (a, b, c, d) { return new NeoPromise(function (resolve, reject) { var op = w.msCrypto.subtle.verify(a, b, c, d); op.oncomplete = function () { return resolve(op.result); }; op.onerror = function (e) { return reject(e); }; }); },
                wrapKey: function (a, b, c, d) { return new NeoPromise(function (resolve, reject) { var op = w.msCrypto.subtle.wrapKey(a, b, c, d); op.oncomplete = function () { return resolve(op.result); }; op.onerror = function (e) { return reject(e); }; }); },
            };
        }
        if (window.crypto.subtle == null) {
            window.crypto.subtle = {
                decrypt: function (algorithm, key, data) {
                    return new NeoPromise(function (resolve, reject) {
                        if (typeof algorithm === "string" || algorithm.name != "AES-CBC" || !algorithm.iv || algorithm.iv.byteLength != 16 || data.byteLength % 16 != 0) {
                            reject(new RangeError());
                            return;
                        }
                        try {
                            var aes = new Cryptography.Aes(key.export(), algorithm.iv);
                            resolve(aes.decrypt(data));
                        }
                        catch (e) {
                            reject(e);
                        }
                    });
                },
                deriveBits: null,
                deriveKey: null,
                digest: function (algorithm, data) {
                    return new NeoPromise(function (resolve, reject) {
                        if (getAlgorithmName(algorithm) != "SHA-256") {
                            reject(new RangeError());
                            return;
                        }
                        try {
                            resolve(Cryptography.Sha256.computeHash(data));
                        }
                        catch (e) {
                            reject(e);
                        }
                    });
                },
                encrypt: function (algorithm, key, data) {
                    return new NeoPromise(function (resolve, reject) {
                        if (typeof algorithm === "string" || algorithm.name != "AES-CBC" || !algorithm.iv || algorithm.iv.byteLength != 16) {
                            reject(new RangeError());
                            return;
                        }
                        try {
                            var aes = new Cryptography.Aes(key.export(), algorithm.iv);
                            resolve(aes.encrypt(data));
                        }
                        catch (e) {
                            reject(e);
                        }
                    });
                },
                exportKey: function (format, key) {
                    return new NeoPromise(function (resolve, reject) {
                        if (format != "jwk" || !(key instanceof Cryptography.AesCryptoKey)) {
                            reject(new RangeError());
                            return;
                        }
                        try {
                            var k = key;
                            resolve({
                                alg: "A256CBC",
                                ext: true,
                                k: k.export().base64UrlEncode(),
                                key_ops: k.usages,
                                kty: "oct"
                            });
                        }
                        catch (e) {
                            reject(e);
                        }
                    });
                },
                generateKey: function (algorithm, extractable, keyUsages) {
                    return new NeoPromise(function (resolve, reject) {
                        if (typeof algorithm === "string" || algorithm.name != "AES-CBC" || (algorithm.length != 128 && algorithm.length != 192 && algorithm.length != 256)) {
                            reject(new RangeError());
                            return;
                        }
                        try {
                            resolve(Cryptography.AesCryptoKey.create(algorithm.length));
                        }
                        catch (e) {
                            reject(e);
                        }
                    });
                },
                importKey: function (format, keyData, algorithm, extractable, keyUsages) {
                    return new NeoPromise(function (resolve, reject) {
                        if ((format != "raw" && format != "jwk") || getAlgorithmName(algorithm) != "AES-CBC") {
                            reject(new RangeError());
                            return;
                        }
                        try {
                            if (format == "jwk")
                                keyData = keyData.k.base64UrlDecode();
                            resolve(Cryptography.AesCryptoKey.import(keyData));
                        }
                        catch (e) {
                            reject(e);
                        }
                    });
                },
                sign: null,
                unwrapKey: null,
                verify: null,
                wrapKey: null,
            };
        }
        function hook_ripemd160() {
            var digest_old = window.crypto.subtle.digest;
            window.crypto.subtle.digest = function (algorithm, data) {
                if (getAlgorithmName(algorithm) != "RIPEMD-160")
                    return digest_old.call(window.crypto.subtle, algorithm, data);
                return new NeoPromise(function (resolve, reject) {
                    try {
                        resolve(Cryptography.RIPEMD160.computeHash(data));
                    }
                    catch (e) {
                        reject(e);
                    }
                });
            };
        }
        hook_ripemd160();
        function hook_ecdsa() {
            var exportKey_old = window.crypto.subtle.exportKey;
            window.crypto.subtle.exportKey = function (format, key) {
                if (key.algorithm.name != "ECDSA")
                    return exportKey_old.call(window.crypto.subtle, format, key);
                return new NeoPromise(function (resolve, reject) {
                    var k = key;
                    if (format != "jwk" || k.algorithm.namedCurve != "P-256")
                        reject(new RangeError());
                    else
                        try {
                            if (k.type == "private")
                                resolve({
                                    crv: k.algorithm.namedCurve,
                                    d: k.privateKey.base64UrlEncode(),
                                    ext: true,
                                    key_ops: k.usages,
                                    kty: "EC",
                                    x: k.publicKey.x.value.toUint8Array(false, 32).base64UrlEncode(),
                                    y: k.publicKey.y.value.toUint8Array(false, 32).base64UrlEncode()
                                });
                            else
                                resolve({
                                    crv: k.algorithm.namedCurve,
                                    ext: true,
                                    key_ops: k.usages,
                                    kty: "EC",
                                    x: k.publicKey.x.value.toUint8Array(false, 32).base64UrlEncode(),
                                    y: k.publicKey.y.value.toUint8Array(false, 32).base64UrlEncode()
                                });
                        }
                        catch (e) {
                            reject(e);
                        }
                });
            };
            var generateKey_old = window.crypto.subtle.generateKey;
            window.crypto.subtle.generateKey = function (algorithm, extractable, keyUsages) {
                if (getAlgorithmName(algorithm) != "ECDSA")
                    return generateKey_old.call(window.crypto.subtle, algorithm, extractable, keyUsages);
                return new NeoPromise(function (resolve, reject) {
                    if (algorithm.namedCurve != "P-256")
                        reject(new RangeError());
                    else
                        try {
                            resolve(Cryptography.ECDsa.generateKey(Cryptography.ECCurve.secp256r1));
                        }
                        catch (e) {
                            reject(e);
                        }
                });
            };
            var importKey_old = window.crypto.subtle.importKey;
            window.crypto.subtle.importKey = function (format, keyData, algorithm, extractable, keyUsages) {
                if (getAlgorithmName(algorithm) != "ECDSA")
                    return importKey_old.call(window.crypto.subtle, format, keyData, algorithm, extractable, keyUsages);
                return new NeoPromise(function (resolve, reject) {
                    if (format != "jwk" || algorithm.namedCurve != "P-256")
                        reject(new RangeError());
                    else
                        try {
                            var k = keyData;
                            var x = k.x.base64UrlDecode();
                            var y = k.y.base64UrlDecode();
                            var arr = new Uint8Array(65);
                            arr[0] = 0x04;
                            Array.copy(x, 0, arr, 1, 32);
                            Array.copy(y, 0, arr, 33, 32);
                            var pubkey = Cryptography.ECPoint.decodePoint(arr, Cryptography.ECCurve.secp256r1);
                            if (k.d)
                                resolve(new Cryptography.ECDsaCryptoKey(pubkey, k.d.base64UrlDecode()));
                            else
                                resolve(new Cryptography.ECDsaCryptoKey(pubkey));
                        }
                        catch (e) {
                            reject(e);
                        }
                });
            };
            var sign_old = window.crypto.subtle.sign;
            window.crypto.subtle.sign = function (algorithm, key, data) {
                if (getAlgorithmName(algorithm) != "ECDSA")
                    return sign_old.call(window.crypto.subtle, algorithm, key, data);
                return new NeoPromise(function (resolve, reject) {
                    if (algorithm.hash.name != "SHA-256" || key.algorithm.name != "ECDSA")
                        reject(new RangeError());
                    else
                        try {
                            var ecdsa = new Cryptography.ECDsa(key);
                            resolve(ecdsa.sign(data));
                        }
                        catch (e) {
                            reject(e);
                        }
                });
            };
            var verify_old = window.crypto.subtle.verify;
            window.crypto.subtle.verify = function (algorithm, key, signature, data) {
                if (getAlgorithmName(algorithm) != "ECDSA")
                    return verify_old.call(window.crypto.subtle, algorithm, key, signature, data);
                return new NeoPromise(function (resolve, reject) {
                    if (algorithm.hash.name != "SHA-256" || key.algorithm.name != "ECDSA")
                        reject(new RangeError());
                    else
                        try {
                            var ecdsa = new Cryptography.ECDsa(key);
                            resolve(ecdsa.verify(data, signature));
                        }
                        catch (e) {
                            reject(e);
                        }
                });
            };
        }
        try {
            window.crypto.subtle.generateKey({ name: "ECDSA", namedCurve: "P-256" }, false, ["sign", "verify"]).catch(hook_ecdsa);
        }
        catch (ex) {
            hook_ecdsa();
        }
    })(Cryptography = Neo.Cryptography || (Neo.Cryptography = {}));
})(Neo || (Neo = {}));
var Neo;
(function (Neo) {
    var Cryptography;
    (function (Cryptography) {
        var RIPEMD160 = (function () {
            function RIPEMD160() {
            }
            RIPEMD160.bytesToWords = function (bytes) {
                var words = [];
                for (var i = 0, b = 0; i < bytes.length; i++ , b += 8) {
                    words[b >>> 5] |= bytes[i] << (24 - b % 32);
                }
                return words;
            };
            RIPEMD160.wordsToBytes = function (words) {
                var bytes = [];
                for (var b = 0; b < words.length * 32; b += 8) {
                    bytes.push((words[b >>> 5] >>> (24 - b % 32)) & 0xFF);
                }
                return bytes;
            };
            RIPEMD160.processBlock = function (H, M, offset) {
                for (var i = 0; i < 16; i++) {
                    var offset_i = offset + i;
                    var M_offset_i = M[offset_i];
                    M[offset_i] = ((((M_offset_i << 8) | (M_offset_i >>> 24)) & 0x00ff00ff) |
                        (((M_offset_i << 24) | (M_offset_i >>> 8)) & 0xff00ff00));
                }
                var al, bl, cl, dl, el;
                var ar, br, cr, dr, er;
                ar = al = H[0];
                br = bl = H[1];
                cr = cl = H[2];
                dr = dl = H[3];
                er = el = H[4];
                var t;
                for (var i = 0; i < 80; i += 1) {
                    t = (al + M[offset + RIPEMD160.zl[i]]) | 0;
                    if (i < 16) {
                        t += RIPEMD160.f1(bl, cl, dl) + RIPEMD160.hl[0];
                    }
                    else if (i < 32) {
                        t += RIPEMD160.f2(bl, cl, dl) + RIPEMD160.hl[1];
                    }
                    else if (i < 48) {
                        t += RIPEMD160.f3(bl, cl, dl) + RIPEMD160.hl[2];
                    }
                    else if (i < 64) {
                        t += RIPEMD160.f4(bl, cl, dl) + RIPEMD160.hl[3];
                    }
                    else {
                        t += RIPEMD160.f5(bl, cl, dl) + RIPEMD160.hl[4];
                    }
                    t = t | 0;
                    t = RIPEMD160.rotl(t, RIPEMD160.sl[i]);
                    t = (t + el) | 0;
                    al = el;
                    el = dl;
                    dl = RIPEMD160.rotl(cl, 10);
                    cl = bl;
                    bl = t;
                    t = (ar + M[offset + RIPEMD160.zr[i]]) | 0;
                    if (i < 16) {
                        t += RIPEMD160.f5(br, cr, dr) + RIPEMD160.hr[0];
                    }
                    else if (i < 32) {
                        t += RIPEMD160.f4(br, cr, dr) + RIPEMD160.hr[1];
                    }
                    else if (i < 48) {
                        t += RIPEMD160.f3(br, cr, dr) + RIPEMD160.hr[2];
                    }
                    else if (i < 64) {
                        t += RIPEMD160.f2(br, cr, dr) + RIPEMD160.hr[3];
                    }
                    else {
                        t += RIPEMD160.f1(br, cr, dr) + RIPEMD160.hr[4];
                    }
                    t = t | 0;
                    t = RIPEMD160.rotl(t, RIPEMD160.sr[i]);
                    t = (t + er) | 0;
                    ar = er;
                    er = dr;
                    dr = RIPEMD160.rotl(cr, 10);
                    cr = br;
                    br = t;
                }
                t = (H[1] + cl + dr) | 0;
                H[1] = (H[2] + dl + er) | 0;
                H[2] = (H[3] + el + ar) | 0;
                H[3] = (H[4] + al + br) | 0;
                H[4] = (H[0] + bl + cr) | 0;
                H[0] = t;
            };
            RIPEMD160.f1 = function (x, y, z) { return ((x) ^ (y) ^ (z)); };
            RIPEMD160.f2 = function (x, y, z) { return (((x) & (y)) | ((~x) & (z))); };
            RIPEMD160.f3 = function (x, y, z) { return (((x) | (~(y))) ^ (z)); };
            RIPEMD160.f4 = function (x, y, z) { return (((x) & (z)) | ((y) & (~(z)))); };
            RIPEMD160.f5 = function (x, y, z) { return ((x) ^ ((y) | (~(z)))); };
            RIPEMD160.rotl = function (x, n) { return (x << n) | (x >>> (32 - n)); };
            RIPEMD160.computeHash = function (data) {
                var H = [0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0];
                var m = RIPEMD160.bytesToWords(Uint8Array.fromArrayBuffer(data));
                var nBitsLeft = data.byteLength * 8;
                var nBitsTotal = data.byteLength * 8;
                m[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
                m[(((nBitsLeft + 64) >>> 9) << 4) + 14] = ((((nBitsTotal << 8) | (nBitsTotal >>> 24)) & 0x00ff00ff) |
                    (((nBitsTotal << 24) | (nBitsTotal >>> 8)) & 0xff00ff00));
                for (var i = 0; i < m.length; i += 16) {
                    RIPEMD160.processBlock(H, m, i);
                }
                for (var i = 0; i < 5; i++) {
                    var H_i = H[i];
                    H[i] = (((H_i << 8) | (H_i >>> 24)) & 0x00ff00ff) |
                        (((H_i << 24) | (H_i >>> 8)) & 0xff00ff00);
                }
                var digestbytes = RIPEMD160.wordsToBytes(H);
                return new Uint8Array(digestbytes).buffer;
            };
            RIPEMD160.zl = [
                0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
                7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
                3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,
                1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,
                4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13
            ];
            RIPEMD160.zr = [
                5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,
                6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,
                15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,
                8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,
                12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11
            ];
            RIPEMD160.sl = [
                11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,
                7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,
                11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,
                11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,
                9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6
            ];
            RIPEMD160.sr = [
                8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,
                9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,
                9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,
                15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,
                8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11
            ];
            RIPEMD160.hl = [0x00000000, 0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xA953FD4E];
            RIPEMD160.hr = [0x50A28BE6, 0x5C4DD124, 0x6D703EF3, 0x7A6D76E9, 0x00000000];
            return RIPEMD160;
        } ());
        Cryptography.RIPEMD160 = RIPEMD160;
    })(Cryptography = Neo.Cryptography || (Neo.Cryptography = {}));
})(Neo || (Neo = {}));
var Neo;
(function (Neo) {
    var Cryptography;
    (function (Cryptography) {
        var Sha256 = (function () {
            function Sha256() {
            }
            Sha256.computeHash = function (data) {
                var H = new Uint32Array([
                    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
                ]);
                var l = data.byteLength / 4 + 2;
                var N = Math.ceil(l / 16);
                var M = new Array(N);
                var view = Uint8Array.fromArrayBuffer(data);
                for (var i = 0; i < N; i++) {
                    M[i] = new Uint32Array(16);
                    for (var j = 0; j < 16; j++) {
                        M[i][j] = (view[i * 64 + j * 4] << 24) | (view[i * 64 + j * 4 + 1] << 16) |
                            (view[i * 64 + j * 4 + 2] << 8) | (view[i * 64 + j * 4 + 3]);
                    }
                }
                M[Math.floor(data.byteLength / 4 / 16)][Math.floor(data.byteLength / 4) % 16] |= 0x80 << ((3 - data.byteLength % 4) * 8);
                M[N - 1][14] = (data.byteLength * 8) / Math.pow(2, 32);
                M[N - 1][15] = (data.byteLength * 8) & 0xffffffff;
                var W = new Uint32Array(64);
                var a, b, c, d, e, f, g, h;
                for (var i = 0; i < N; i++) {
                    for (var t = 0; t < 16; t++)
                        W[t] = M[i][t];
                    for (var t = 16; t < 64; t++)
                        W[t] = (Sha256.σ1(W[t - 2]) + W[t - 7] + Sha256.σ0(W[t - 15]) + W[t - 16]) & 0xffffffff;
                    a = H[0];
                    b = H[1];
                    c = H[2];
                    d = H[3];
                    e = H[4];
                    f = H[5];
                    g = H[6];
                    h = H[7];
                    for (var t = 0; t < 64; t++) {
                        var T1 = h + Sha256.Σ1(e) + Sha256.Ch(e, f, g) + Sha256.K[t] + W[t];
                        var T2 = Sha256.Σ0(a) + Sha256.Maj(a, b, c);
                        h = g;
                        g = f;
                        f = e;
                        e = (d + T1) & 0xffffffff;
                        d = c;
                        c = b;
                        b = a;
                        a = (T1 + T2) & 0xffffffff;
                    }
                    H[0] = (H[0] + a) & 0xffffffff;
                    H[1] = (H[1] + b) & 0xffffffff;
                    H[2] = (H[2] + c) & 0xffffffff;
                    H[3] = (H[3] + d) & 0xffffffff;
                    H[4] = (H[4] + e) & 0xffffffff;
                    H[5] = (H[5] + f) & 0xffffffff;
                    H[6] = (H[6] + g) & 0xffffffff;
                    H[7] = (H[7] + h) & 0xffffffff;
                }
                var result = new Uint8Array(32);
                for (var i = 0; i < H.length; i++) {
                    result[i * 4 + 0] = (H[i] >>> (3 * 8)) & 0xff;
                    result[i * 4 + 1] = (H[i] >>> (2 * 8)) & 0xff;
                    result[i * 4 + 2] = (H[i] >>> (1 * 8)) & 0xff;
                    result[i * 4 + 3] = (H[i] >>> (0 * 8)) & 0xff;
                }
                return result.buffer;
            };
            Sha256.ROTR = function (n, x) { return (x >>> n) | (x << (32 - n)); };
            Sha256.Σ0 = function (x) { return Sha256.ROTR(2, x) ^ Sha256.ROTR(13, x) ^ Sha256.ROTR(22, x); };
            Sha256.Σ1 = function (x) { return Sha256.ROTR(6, x) ^ Sha256.ROTR(11, x) ^ Sha256.ROTR(25, x); };
            Sha256.σ0 = function (x) { return Sha256.ROTR(7, x) ^ Sha256.ROTR(18, x) ^ (x >>> 3); };
            Sha256.σ1 = function (x) { return Sha256.ROTR(17, x) ^ Sha256.ROTR(19, x) ^ (x >>> 10); };
            Sha256.Ch = function (x, y, z) { return (x & y) ^ (~x & z); };
            Sha256.Maj = function (x, y, z) { return (x & y) ^ (x & z) ^ (y & z); };
            Sha256.K = [
                0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
                0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
                0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
                0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
                0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
                0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
                0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
                0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
            ];
            return Sha256;
        } ());
        Cryptography.Sha256 = Sha256;
    })(Cryptography = Neo.Cryptography || (Neo.Cryptography = {}));
})(Neo || (Neo = {}));
var Neo;
(function (Neo) {
    var IO;
    (function (IO) {
        var BinaryReader = (function () {
            function BinaryReader(input) {
                this.input = input;
                this._buffer = new ArrayBuffer(8);
            }
            BinaryReader.prototype.canRead = function () {
                return this.input.length() - this.input.position();
            };
            BinaryReader.prototype.close = function () {
            };
            BinaryReader.prototype.fillBuffer = function (buffer, count) {
                var i = 0;
                while (count > 0) {
                    var actual_count = this.input.read(buffer, 0, count);
                    if (actual_count == 0)
                        throw new Error("EOF");
                    i += actual_count;
                    count -= actual_count;
                }
            };
            BinaryReader.prototype.read = function (buffer, index, count) {
                return this.input.read(buffer, index, count);
            };
            BinaryReader.prototype.readBoolean = function () {
                return this.readByte() != 0;
            };
            BinaryReader.prototype.readByte = function () {
                this.fillBuffer(this._buffer, 1);
                if (this.array_uint8 == null)
                    this.array_uint8 = new Uint8Array(this._buffer, 0, 1);
                return this.array_uint8[0];
            };
            BinaryReader.prototype.readBytes = function (count) {
                var buffer = new ArrayBuffer(count);
                this.fillBuffer(buffer, count);
                return buffer;
            };
            BinaryReader.prototype.readDouble = function () {
                this.fillBuffer(this._buffer, 8);
                if (this.array_float64 == null)
                    this.array_float64 = new Float64Array(this._buffer, 0, 1);
                return this.array_float64[0];
            };
            BinaryReader.prototype.readFixed8 = function () {
                return new Neo.Fixed8(this.readUint64());
            };
            BinaryReader.prototype.readInt16 = function () {
                this.fillBuffer(this._buffer, 2);
                if (this.array_int16 == null)
                    this.array_int16 = new Int16Array(this._buffer, 0, 1);
                return this.array_int16[0];
            };
            BinaryReader.prototype.readInt32 = function () {
                this.fillBuffer(this._buffer, 4);
                if (this.array_int32 == null)
                    this.array_int32 = new Int32Array(this._buffer, 0, 1);
                return this.array_int32[0];
            };
            BinaryReader.prototype.readSByte = function () {
                this.fillBuffer(this._buffer, 1);
                if (this.array_int8 == null)
                    this.array_int8 = new Int8Array(this._buffer, 0, 1);
                return this.array_int8[0];
            };
            BinaryReader.prototype.readSerializable = function (T) {
                var obj = new T();
                obj.deserialize(this);
                return obj;
            };
            BinaryReader.prototype.readSerializableArray = function (T) {
                var array = new Array(this.readVarInt(0x10000000));
                for (var i = 0; i < array.length; i++)
                    array[i] = this.readSerializable(T);
                return array;
            };
            BinaryReader.prototype.readSingle = function () {
                this.fillBuffer(this._buffer, 4);
                if (this.array_float32 == null)
                    this.array_float32 = new Float32Array(this._buffer, 0, 1);
                return this.array_float32[0];
            };
            BinaryReader.prototype.readUint16 = function () {
                this.fillBuffer(this._buffer, 2);
                if (this.array_uint16 == null)
                    this.array_uint16 = new Uint16Array(this._buffer, 0, 1);
                return this.array_uint16[0];
            };
            BinaryReader.prototype.readUint160 = function () {
                return new Neo.Uint160(this.readBytes(20));
            };
            BinaryReader.prototype.readUint256 = function () {
                return new Neo.Uint256(this.readBytes(32));
            };
            BinaryReader.prototype.readUint32 = function () {
                this.fillBuffer(this._buffer, 4);
                if (this.array_uint32 == null)
                    this.array_uint32 = new Uint32Array(this._buffer, 0, 1);
                return this.array_uint32[0];
            };
            BinaryReader.prototype.readUint64 = function () {
                this.fillBuffer(this._buffer, 8);
                if (this.array_uint32 == null)
                    this.array_uint32 = new Uint32Array(this._buffer, 0, 2);
                return new Neo.Uint64(this.array_uint32[0], this.array_uint32[1]);
            };
            BinaryReader.prototype.readVarBytes = function (max) {
                if (max === void 0) { max = 0X7fffffc7; }
                return this.readBytes(this.readVarInt(max));
            };
            BinaryReader.prototype.readVarInt = function (max) {
                if (max === void 0) { max = 9007199254740991; }
                var fb = this.readByte();
                var value;
                if (fb == 0xfd)
                    value = this.readUint16();
                else if (fb == 0xfe)
                    value = this.readUint32();
                else if (fb == 0xff)
                    value = this.readUint64().toNumber();
                else
                    value = fb;
                if (value > max)
                    throw new RangeError();
                return value;
            };
            BinaryReader.prototype.readVarString = function () {
                return decodeURIComponent(escape(String.fromCharCode.apply(null, new Uint8Array(this.readVarBytes()))));
            };
            return BinaryReader;
        } ());
        IO.BinaryReader = BinaryReader;
    })(IO = Neo.IO || (Neo.IO = {}));
})(Neo || (Neo = {}));
var Neo;
(function (Neo) {
    var IO;
    (function (IO) {
        var BinaryWriter = (function () {
            function BinaryWriter(output) {
                this.output = output;
                this._buffer = new ArrayBuffer(8);
            }
            BinaryWriter.prototype.close = function () {
            };
            BinaryWriter.prototype.seek = function (offset, origin) {
                return this.output.seek(offset, origin);
            };
            BinaryWriter.prototype.write = function (buffer, index, count) {
                if (index === void 0) { index = 0; }
                if (count === void 0) { count = buffer.byteLength - index; }
                this.output.write(buffer, index, count);
            };
            BinaryWriter.prototype.writeBoolean = function (value) {
                this.writeByte(value ? 0xff : 0);
            };
            BinaryWriter.prototype.writeByte = function (value) {
                if (this.array_uint8 == null)
                    this.array_uint8 = new Uint8Array(this._buffer, 0, 1);
                this.array_uint8[0] = value;
                this.output.write(this._buffer, 0, 1);
            };
            BinaryWriter.prototype.writeDouble = function (value) {
                if (this.array_float64 == null)
                    this.array_float64 = new Float64Array(this._buffer, 0, 1);
                this.array_float64[0] = value;
                this.output.write(this._buffer, 0, 8);
            };
            BinaryWriter.prototype.writeInt16 = function (value) {
                if (this.array_int16 == null)
                    this.array_int16 = new Int16Array(this._buffer, 0, 1);
                this.array_int16[0] = value;
                this.output.write(this._buffer, 0, 2);
            };
            BinaryWriter.prototype.writeInt32 = function (value) {
                if (this.array_int32 == null)
                    this.array_int32 = new Int32Array(this._buffer, 0, 1);
                this.array_int32[0] = value;
                this.output.write(this._buffer, 0, 4);
            };
            BinaryWriter.prototype.writeSByte = function (value) {
                if (this.array_int8 == null)
                    this.array_int8 = new Int8Array(this._buffer, 0, 1);
                this.array_int8[0] = value;
                this.output.write(this._buffer, 0, 1);
            };
            BinaryWriter.prototype.writeSerializableArray = function (array) {
                this.writeVarInt(array.length);
                for (var i = 0; i < array.length; i++)
                    array[i].serialize(this);
            };
            BinaryWriter.prototype.writeSingle = function (value) {
                if (this.array_float32 == null)
                    this.array_float32 = new Float32Array(this._buffer, 0, 1);
                this.array_float32[0] = value;
                this.output.write(this._buffer, 0, 4);
            };
            BinaryWriter.prototype.writeUint16 = function (value) {
                if (this.array_uint16 == null)
                    this.array_uint16 = new Uint16Array(this._buffer, 0, 1);
                this.array_uint16[0] = value;
                this.output.write(this._buffer, 0, 2);
            };
            BinaryWriter.prototype.writeUint32 = function (value) {
                if (this.array_uint32 == null)
                    this.array_uint32 = new Uint32Array(this._buffer, 0, 1);
                this.array_uint32[0] = value;
                this.output.write(this._buffer, 0, 4);
            };
            BinaryWriter.prototype.writeUint64 = function (value) {
                this.writeUintVariable(value);
            };
            BinaryWriter.prototype.writeUintVariable = function (value) {
                this.write(value.bits.buffer);
            };
            BinaryWriter.prototype.writeVarBytes = function (value) {
                this.writeVarInt(value.byteLength);
                this.output.write(value, 0, value.byteLength);
            };
            BinaryWriter.prototype.writeVarInt = function (value) {
                if (value < 0)
                    throw new RangeError();
                if (value < 0xfd) {
                    this.writeByte(value);
                }
                else if (value <= 0xffff) {
                    this.writeByte(0xfd);
                    this.writeUint16(value);
                }
                else if (value <= 0xFFFFFFFF) {
                    this.writeByte(0xfe);
                    this.writeUint32(value);
                }
                else {
                    this.writeByte(0xff);
                    this.writeUint32(value);
                    this.writeUint32(value / Math.pow(2, 32));
                }
            };
            BinaryWriter.prototype.writeVarString = function (value) {
                value = unescape(encodeURIComponent(value));
                var codes = new Uint8Array(value.length);
                for (var i = 0; i < codes.length; i++)
                    codes[i] = value.charCodeAt(i);
                this.writeVarBytes(codes.buffer);
            };
            return BinaryWriter;
        } ());
        IO.BinaryWriter = BinaryWriter;
    })(IO = Neo.IO || (Neo.IO = {}));
})(Neo || (Neo = {}));
Uint8Array.prototype.asSerializable = function (T) {
    var ms = new Neo.IO.MemoryStream(this.buffer, false);
    var reader = new Neo.IO.BinaryReader(ms);
    return reader.readSerializable(T);
};
Uint8Array.fromSerializable = function (obj) {
    var ms = new Neo.IO.MemoryStream();
    var writer = new Neo.IO.BinaryWriter(ms);
    obj.serialize(writer);
    return new Uint8Array(ms.toArray());
};
var Neo;
(function (Neo) {
    var IO;
    (function (IO) {
        var SeekOrigin;
        (function (SeekOrigin) {
            SeekOrigin[SeekOrigin["Begin"] = 0] = "Begin";
            SeekOrigin[SeekOrigin["Current"] = 1] = "Current";
            SeekOrigin[SeekOrigin["End"] = 2] = "End";
        })(SeekOrigin = IO.SeekOrigin || (IO.SeekOrigin = {}));
        var Stream = (function () {
            function Stream() {
                this._array = new Uint8Array(1);
            }
            Stream.prototype.close = function () { };
            Stream.prototype.readByte = function () {
                if (this.read(this._array.buffer, 0, 1) == 0)
                    return -1;
                return this._array[0];
            };
            Stream.prototype.writeByte = function (value) {
                if (value < 0 || value > 255)
                    throw new RangeError();
                this._array[0] = value;
                this.write(this._array.buffer, 0, 1);
            };
            return Stream;
        } ());
        IO.Stream = Stream;
    })(IO = Neo.IO || (Neo.IO = {}));
})(Neo || (Neo = {}));
var Neo;
(function (Neo) {
    var IO;
    (function (IO) {
        var BufferSize = 1024;
        var MemoryStream = (function (_super) {
            __extends(MemoryStream, _super);
            function MemoryStream() {
                var _this = _super.call(this) || this;
                _this._buffers = new Array();
                _this._origin = 0;
                _this._position = 0;
                if (arguments.length == 0) {
                    _this._length = 0;
                    _this._capacity = 0;
                    _this._expandable = true;
                    _this._writable = true;
                }
                else if (arguments.length == 1 && typeof arguments[0] === "number") {
                    _this._length = 0;
                    _this._capacity = arguments[0];
                    _this._expandable = true;
                    _this._writable = true;
                    _this._buffers.push(new ArrayBuffer(_this._capacity));
                }
                else {
                    var buffer = arguments[0];
                    _this._buffers.push(buffer);
                    _this._expandable = false;
                    if (arguments.length == 1) {
                        _this._writable = false;
                        _this._length = buffer.byteLength;
                    }
                    else if (typeof arguments[1] === "boolean") {
                        _this._writable = arguments[1];
                        _this._length = buffer.byteLength;
                    }
                    else {
                        _this._origin = arguments[1];
                        _this._length = arguments[2];
                        _this._writable = arguments.length == 4 ? arguments[3] : false;
                        if (_this._origin < 0 || _this._origin + _this._length > buffer.byteLength)
                            throw new RangeError();
                    }
                    _this._capacity = _this._length;
                }
                return _this;
            }
            MemoryStream.prototype.canRead = function () {
                return true;
            };
            MemoryStream.prototype.canSeek = function () {
                return true;
            };
            MemoryStream.prototype.canWrite = function () {
                return this._writable;
            };
            MemoryStream.prototype.capacity = function () {
                return this._capacity;
            };
            MemoryStream.prototype.findBuffer = function (position) {
                var iBuff, pBuff;
                var firstSize = this._buffers[0] == null ? BufferSize : this._buffers[0].byteLength;
                if (position < firstSize) {
                    iBuff = 0;
                    pBuff = position;
                }
                else {
                    iBuff = Math.floor((position - firstSize) / BufferSize) + 1;
                    pBuff = (position - firstSize) % BufferSize;
                }
                return { iBuff: iBuff, pBuff: pBuff };
            };
            MemoryStream.prototype.length = function () {
                return this._length;
            };
            MemoryStream.prototype.position = function () {
                return this._position;
            };
            MemoryStream.prototype.read = function (buffer, offset, count) {
                if (this._position + count > this._length)
                    count = this._length - this._position;
                this.readInternal(new Uint8Array(buffer, offset, count), this._position);
                this._position += count;
                return count;
            };
            MemoryStream.prototype.readInternal = function (dst, srcPos) {
                if (this._expandable) {
                    var i = 0, count = dst.length;
                    var d = this.findBuffer(srcPos);
                    while (count > 0) {
                        var actual_count = void 0;
                        if (this._buffers[d.iBuff] == null) {
                            actual_count = Math.min(count, BufferSize - d.pBuff);
                            dst.fill(0, i, i + actual_count);
                        }
                        else {
                            actual_count = Math.min(count, this._buffers[d.iBuff].byteLength - d.pBuff);
                            var src = new Uint8Array(this._buffers[d.iBuff]);
                            Array.copy(src, d.pBuff, dst, i, actual_count);
                        }
                        i += actual_count;
                        count -= actual_count;
                        d.iBuff++;
                        d.pBuff = 0;
                    }
                }
                else {
                    var src = new Uint8Array(this._buffers[0], this._origin, this._length);
                    Array.copy(src, srcPos, dst, 0, dst.length);
                }
            };
            MemoryStream.prototype.seek = function (offset, origin) {
                switch (origin) {
                    case IO.SeekOrigin.Begin:
                        break;
                    case IO.SeekOrigin.Current:
                        offset += this._position;
                        break;
                    case IO.SeekOrigin.End:
                        offset += this._length;
                        break;
                    default:
                        throw new RangeError();
                }
                if (offset < 0 || offset > this._length)
                    throw new RangeError();
                this._position = offset;
                return offset;
            };
            MemoryStream.prototype.setLength = function (value) {
                if (value < 0 || (value != this._length && !this._writable) || (value > this._capacity && !this._expandable))
                    throw new RangeError();
                this._length = value;
                if (this._position > this._length)
                    this._position = this._length;
                if (this._capacity < this._length)
                    this._capacity = this._length;
            };
            MemoryStream.prototype.toArray = function () {
                if (this._buffers.length == 1 && this._origin == 0 && this._length == this._buffers[0].byteLength)
                    return this._buffers[0];
                var bw = new Uint8Array(this._length);
                this.readInternal(bw, 0);
                return bw.buffer;
            };
            MemoryStream.prototype.write = function (buffer, offset, count) {
                if (!this._writable || (!this._expandable && this._capacity - this._position < count))
                    throw new Error();
                if (this._expandable) {
                    var src = new Uint8Array(buffer);
                    var d = this.findBuffer(this._position);
                    while (count > 0) {
                        if (this._buffers[d.iBuff] == null)
                            this._buffers[d.iBuff] = new ArrayBuffer(BufferSize);
                        var actual_count = Math.min(count, this._buffers[d.iBuff].byteLength - d.pBuff);
                        var dst = new Uint8Array(this._buffers[d.iBuff]);
                        Array.copy(src, offset, dst, d.pBuff, actual_count);
                        this._position += actual_count;
                        offset += actual_count;
                        count -= actual_count;
                        d.iBuff++;
                        d.pBuff = 0;
                    }
                }
                else {
                    var src = new Uint8Array(buffer, offset, count);
                    var dst = new Uint8Array(this._buffers[0], this._origin, this._capacity);
                    Array.copy(src, 0, dst, this._position, count);
                    this._position += count;
                }
                if (this._length < this._position)
                    this._length = this._position;
                if (this._capacity < this._length)
                    this._capacity = this._length;
            };
            return MemoryStream;
        } (IO.Stream));
        IO.MemoryStream = MemoryStream;
    })(IO = Neo.IO || (Neo.IO = {}));
})(Neo || (Neo = {}));
var ThinNeo;
(function (ThinNeo) {
    var Compiler;
    (function (Compiler) {
        var Avm2Asm = (function () {
            function Avm2Asm() {
            }
            Avm2Asm.Trans = function (script) {
                var breader = new Compiler.ByteReader(script);
                var arr = new Array();
                while (breader.End == false) {
                    var o = new Compiler.Op();
                    o.addr = breader.addr;
                    o.code = breader.ReadOP();
                    try {
                        if (o.code >= ThinNeo.OpCode.PUSHBYTES1 && o.code <= ThinNeo.OpCode.PUSHBYTES75) {
                            o.paramType = Compiler.ParamType.ByteArray;
                            var _count = o.code;
                            o.paramData = breader.ReadBytes(_count);
                        }
                        else {
                            switch (o.code) {
                                case ThinNeo.OpCode.PUSH0:
                                case ThinNeo.OpCode.PUSHM1:
                                case ThinNeo.OpCode.PUSH1:
                                case ThinNeo.OpCode.PUSH2:
                                case ThinNeo.OpCode.PUSH3:
                                case ThinNeo.OpCode.PUSH4:
                                case ThinNeo.OpCode.PUSH5:
                                case ThinNeo.OpCode.PUSH6:
                                case ThinNeo.OpCode.PUSH7:
                                case ThinNeo.OpCode.PUSH8:
                                case ThinNeo.OpCode.PUSH9:
                                case ThinNeo.OpCode.PUSH10:
                                case ThinNeo.OpCode.PUSH11:
                                case ThinNeo.OpCode.PUSH12:
                                case ThinNeo.OpCode.PUSH13:
                                case ThinNeo.OpCode.PUSH14:
                                case ThinNeo.OpCode.PUSH15:
                                case ThinNeo.OpCode.PUSH16:
                                    o.paramType = Compiler.ParamType.None;
                                    break;
                                case ThinNeo.OpCode.PUSHDATA1:
                                    {
                                        o.paramType = Compiler.ParamType.ByteArray;
                                        var _count = breader.ReadByte();
                                        o.paramData = breader.ReadBytes(_count);
                                    }
                                    break;
                                case ThinNeo.OpCode.PUSHDATA2:
                                    {
                                        o.paramType = Compiler.ParamType.ByteArray;
                                        var _count = breader.ReadUInt16();
                                        o.paramData = breader.ReadBytes(_count);
                                    }
                                    break;
                                case ThinNeo.OpCode.PUSHDATA4:
                                    {
                                        o.paramType = Compiler.ParamType.ByteArray;
                                        var _count = breader.ReadInt32();
                                        o.paramData = breader.ReadBytes(_count);
                                    }
                                    break;
                                case ThinNeo.OpCode.NOP:
                                    o.paramType = Compiler.ParamType.None;
                                    break;
                                case ThinNeo.OpCode.JMP:
                                case ThinNeo.OpCode.JMPIF:
                                case ThinNeo.OpCode.JMPIFNOT:
                                    o.paramType = Compiler.ParamType.Addr;
                                    o.paramData = breader.ReadBytes(2);
                                    break;
                                case ThinNeo.OpCode.CALL:
                                    o.paramType = Compiler.ParamType.Addr;
                                    o.paramData = breader.ReadBytes(2);
                                    break;
                                case ThinNeo.OpCode.RET:
                                    o.paramType = Compiler.ParamType.None;
                                    break;
                                case ThinNeo.OpCode.APPCALL:
                                case ThinNeo.OpCode.TAILCALL:
                                    o.paramType = Compiler.ParamType.ByteArray;
                                    o.paramData = breader.ReadBytes(20);
                                    break;
                                case ThinNeo.OpCode.SYSCALL:
                                    o.paramType = Compiler.ParamType.String;
                                    o.paramData = breader.ReadVarBytes();
                                    break;
                                case ThinNeo.OpCode.DUPFROMALTSTACK:
                                case ThinNeo.OpCode.TOALTSTACK:
                                case ThinNeo.OpCode.FROMALTSTACK:
                                case ThinNeo.OpCode.XDROP:
                                case ThinNeo.OpCode.XSWAP:
                                case ThinNeo.OpCode.XTUCK:
                                case ThinNeo.OpCode.DEPTH:
                                case ThinNeo.OpCode.DROP:
                                case ThinNeo.OpCode.DUP:
                                case ThinNeo.OpCode.NIP:
                                case ThinNeo.OpCode.OVER:
                                case ThinNeo.OpCode.PICK:
                                case ThinNeo.OpCode.ROLL:
                                case ThinNeo.OpCode.ROT:
                                case ThinNeo.OpCode.SWAP:
                                case ThinNeo.OpCode.TUCK:
                                    o.paramType = Compiler.ParamType.None;
                                    break;
                                case ThinNeo.OpCode.CAT:
                                case ThinNeo.OpCode.SUBSTR:
                                case ThinNeo.OpCode.LEFT:
                                case ThinNeo.OpCode.RIGHT:
                                case ThinNeo.OpCode.SIZE:
                                    o.paramType = Compiler.ParamType.None;
                                    break;
                                case ThinNeo.OpCode.INVERT:
                                case ThinNeo.OpCode.AND:
                                case ThinNeo.OpCode.OR:
                                case ThinNeo.OpCode.XOR:
                                case ThinNeo.OpCode.EQUAL:
                                    o.paramType = Compiler.ParamType.None;
                                    break;
                                case ThinNeo.OpCode.INC:
                                case ThinNeo.OpCode.DEC:
                                case ThinNeo.OpCode.SIGN:
                                case ThinNeo.OpCode.NEGATE:
                                case ThinNeo.OpCode.ABS:
                                case ThinNeo.OpCode.NOT:
                                case ThinNeo.OpCode.NZ:
                                case ThinNeo.OpCode.ADD:
                                case ThinNeo.OpCode.SUB:
                                case ThinNeo.OpCode.MUL:
                                case ThinNeo.OpCode.DIV:
                                case ThinNeo.OpCode.MOD:
                                case ThinNeo.OpCode.SHL:
                                case ThinNeo.OpCode.SHR:
                                case ThinNeo.OpCode.BOOLAND:
                                case ThinNeo.OpCode.BOOLOR:
                                case ThinNeo.OpCode.NUMEQUAL:
                                case ThinNeo.OpCode.NUMNOTEQUAL:
                                case ThinNeo.OpCode.LT:
                                case ThinNeo.OpCode.GT:
                                case ThinNeo.OpCode.LTE:
                                case ThinNeo.OpCode.GTE:
                                case ThinNeo.OpCode.MIN:
                                case ThinNeo.OpCode.MAX:
                                case ThinNeo.OpCode.WITHIN:
                                    o.paramType = Compiler.ParamType.None;
                                    break;
                                case ThinNeo.OpCode.SHA1:
                                case ThinNeo.OpCode.SHA256:
                                case ThinNeo.OpCode.HASH160:
                                case ThinNeo.OpCode.HASH256:
                                case ThinNeo.OpCode.CSHARPSTRHASH32:
                                case ThinNeo.OpCode.JAVAHASH32:
                                case ThinNeo.OpCode.CHECKSIG:
                                case ThinNeo.OpCode.CHECKMULTISIG:
                                    o.paramType = Compiler.ParamType.None;
                                    break;
                                case ThinNeo.OpCode.ARRAYSIZE:
                                case ThinNeo.OpCode.PACK:
                                case ThinNeo.OpCode.UNPACK:
                                case ThinNeo.OpCode.PICKITEM:
                                case ThinNeo.OpCode.SETITEM:
                                case ThinNeo.OpCode.NEWARRAY:
                                case ThinNeo.OpCode.NEWSTRUCT:
                                    o.paramType = Compiler.ParamType.None;
                                    break;
                                case ThinNeo.OpCode.THROW:
                                case ThinNeo.OpCode.THROWIFNOT:
                                    o.paramType = Compiler.ParamType.None;
                                    break;
                                default:
                                    throw new Error("you fogot a type:" + o.code);
                            }
                        }
                    }
                    catch (_a) {
                        o.error = true;
                    }
                    arr.push(o);
                    if (o.error)
                        break;
                }
                return arr;
            };
            return Avm2Asm;
        } ());
        Compiler.Avm2Asm = Avm2Asm;
    })(Compiler = ThinNeo.Compiler || (ThinNeo.Compiler = {}));
})(ThinNeo || (ThinNeo = {}));
var ThinNeo;
(function (ThinNeo) {
    var Compiler;
    (function (Compiler) {
        var ByteReader = (function () {
            function ByteReader(data) {
                this.addr = 0;
                this.data = data;
            }
            ByteReader.prototype.ReadOP = function () {
                var op = this.data[this.addr];
                this.addr++;
                return op;
            };
            ByteReader.prototype.ReadBytes = function (count) {
                var _data = new Uint8Array(count);
                for (var i = 0; i < count; i++)
                    _data[i] = this.data[this.addr + i];
                this.addr += count;
                return _data;
            };
            ByteReader.prototype.ReadByte = function () {
                var b = this.data[this.addr];
                this.addr++;
                return b;
            };
            ByteReader.prototype.ReadUInt16 = function () {
                var d = new DataView(this.data.buffer);
                var u16 = d.getUint16(this.addr, true);
                this.addr += 2;
                return u16;
            };
            ByteReader.prototype.ReadInt16 = function () {
                var d = new DataView(this.data.buffer);
                var u16 = d.getInt16(this.addr, true);
                this.addr += 2;
                return u16;
            };
            ByteReader.prototype.ReadUInt32 = function () {
                var d = new DataView(this.data.buffer);
                var u16 = d.getUint32(this.addr, true);
                this.addr += 4;
                return u16;
            };
            ByteReader.prototype.ReadInt32 = function () {
                var d = new DataView(this.data.buffer);
                var u16 = d.getInt32(this.addr, true);
                this.addr += 4;
                return u16;
            };
            ByteReader.prototype.ReadUInt64 = function () {
                var u1 = this.ReadUInt32();
                var u2 = this.ReadUInt32();
                return u2 * 0x100000000 + u1;
            };
            ByteReader.prototype.ReadVarBytes = function () {
                var count = this.ReadVarInt();
                return this.ReadBytes(count);
            };
            ByteReader.prototype.ReadVarInt = function () {
                var fb = this.ReadByte();
                var value;
                if (fb == 0xFD)
                    value = this.ReadUInt16();
                else if (fb == 0xFE)
                    value = this.ReadUInt32();
                else if (fb == 0xFF)
                    value = this.ReadUInt64();
                else
                    value = fb;
                return value;
            };
            Object.defineProperty(ByteReader.prototype, "End", {
                get: function () {
                    return this.addr >= this.data.length;
                },
                enumerable: true,
                configurable: true
            });
            return ByteReader;
        } ());
        Compiler.ByteReader = ByteReader;
    })(Compiler = ThinNeo.Compiler || (ThinNeo.Compiler = {}));
})(ThinNeo || (ThinNeo = {}));
var ThinNeo;
(function (ThinNeo) {
    var Compiler;
    (function (Compiler) {
        var ParamType;
        (function (ParamType) {
            ParamType[ParamType["None"] = 0] = "None";
            ParamType[ParamType["ByteArray"] = 1] = "ByteArray";
            ParamType[ParamType["String"] = 2] = "String";
            ParamType[ParamType["Addr"] = 3] = "Addr";
        })(ParamType = Compiler.ParamType || (Compiler.ParamType = {}));
        var Op = (function () {
            function Op() {
            }
            Op.prototype.toString = function () {
                var name = this.getCodeName();
                if (this.paramType == ParamType.None) {
                }
                else if (this.paramType == ParamType.ByteArray) {
                    name += "[" + this.AsHexString() + "]";
                }
                else if (this.paramType == ParamType.String) {
                    name += "[" + this.AsString() + "]";
                }
                else if (this.paramType == ParamType.Addr) {
                    name += "[" + this.AsAddr() + "]";
                }
                return this.addr.toString(16) + ":" + name;
            };
            Op.prototype.AsHexString = function () {
                var str = "0x";
                for (var i = 0; i < this.paramData.length; i++) {
                    var s = this.paramData[i].toString(16);
                    if (s.length % 2 == 1)
                        s = "0" + s;
                    str += s;
                }
                return str;
            };
            Op.prototype.AsString = function () {
                var str = "";
                for (var i = 0; i < this.paramData.length; i++) {
                    str += this.paramData[i].toLocaleString();
                }
                return str;
            };
            Op.prototype.AsAddr = function () {
                var dview = new DataView(this.paramData.buffer);
                return dview.getInt16(0, true);
            };
            Op.prototype.getCodeName = function () {
                var name = "";
                if (this.error)
                    name = "[E]";
                if (this.code == ThinNeo.OpCode.PUSHT)
                    return "PUSH1(true)";
                if (this.code == ThinNeo.OpCode.PUSHF)
                    return "PUSH0(false)";
                if (this.code > ThinNeo.OpCode.PUSHBYTES1 && this.code < ThinNeo.OpCode.PUSHBYTES75)
                    return name + "PUSHBYTES" + (this.code - ThinNeo.OpCode.PUSHBYTES1 + 1);
                else
                    return name + ThinNeo.OpCode[this.code].toString();
            };
            return Op;
        } ());
        Compiler.Op = Op;
    })(Compiler = ThinNeo.Compiler || (ThinNeo.Compiler = {}));
})(ThinNeo || (ThinNeo = {}));
var Neo;
(function (Neo) {
    var IO;
    (function (IO) {
        var Caching;
        (function (Caching) {
            var TrackableCollection = (function () {
                function TrackableCollection(items) {
                    this._map = new NeoMap();
                    if (items != null) {
                        for (var i = 0; i < items.length; i++) {
                            this._map.set(items[i].key, items[i]);
                            items[i].trackState = Caching.TrackState.None;
                        }
                    }
                }
                TrackableCollection.prototype.add = function (item) {
                    this._map.set(item.key, item);
                    item.trackState = Caching.TrackState.Added;
                };
                TrackableCollection.prototype.clear = function () {
                    this._map.forEach(function (value, key, map) {
                        if (value.trackState == Caching.TrackState.Added)
                            map.delete(key);
                        else
                            value.trackState = Caching.TrackState.Deleted;
                    });
                };
                TrackableCollection.prototype.commit = function () {
                    this._map.forEach(function (value, key, map) {
                        if (value.trackState == Caching.TrackState.Deleted)
                            map.delete(key);
                        else
                            value.trackState = Caching.TrackState.None;
                    });
                };
                TrackableCollection.prototype.forEach = function (callback) {
                    var _this = this;
                    this._map.forEach(function (value, key) {
                        callback(value, key, _this);
                    });
                };
                TrackableCollection.prototype.get = function (key) {
                    return this._map.get(key);
                };
                TrackableCollection.prototype.getChangeSet = function () {
                    var array = new Array();
                    this._map.forEach(function (value) {
                        if (value.trackState != Caching.TrackState.None)
                            array.push(value);
                    });
                    return array;
                };
                TrackableCollection.prototype.has = function (key) {
                    return this._map.has(key);
                };
                TrackableCollection.prototype.remove = function (key) {
                    var item = this._map.get(key);
                    if (item.trackState == Caching.TrackState.Added)
                        this._map.delete(key);
                    else
                        item.trackState = Caching.TrackState.Deleted;
                };
                return TrackableCollection;
            } ());
            Caching.TrackableCollection = TrackableCollection;
        })(Caching = IO.Caching || (IO.Caching = {}));
    })(IO = Neo.IO || (Neo.IO = {}));
})(Neo || (Neo = {}));
var Neo;
(function (Neo) {
    var IO;
    (function (IO) {
        var Caching;
        (function (Caching) {
            var TrackState;
            (function (TrackState) {
                TrackState[TrackState["None"] = 0] = "None";
                TrackState[TrackState["Added"] = 1] = "Added";
                TrackState[TrackState["Changed"] = 2] = "Changed";
                TrackState[TrackState["Deleted"] = 3] = "Deleted";
            })(TrackState = Caching.TrackState || (Caching.TrackState = {}));
        })(Caching = IO.Caching || (IO.Caching = {}));
    })(IO = Neo.IO || (Neo.IO = {}));
})(Neo || (Neo = {}));
(function (root, factory) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory();
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define([], factory);
	}
	else {
		// Global (browser)
		root.CryptoJS = factory();
	}
}(this, function () {

	/**
	 * CryptoJS core components.
	 */
	var CryptoJS = CryptoJS || (function (Math, undefined) {
	    /*
	     * Local polyfil of Object.create
	     */
	    var create = Object.create || (function () {
	        function F() {};

	        return function (obj) {
	            var subtype;

	            F.prototype = obj;

	            subtype = new F();

	            F.prototype = null;

	            return subtype;
	        };
	    }())

	    /**
	     * CryptoJS namespace.
	     */
	    var C = {};

	    /**
	     * Library namespace.
	     */
	    var C_lib = C.lib = {};

	    /**
	     * Base object for prototypal inheritance.
	     */
	    var Base = C_lib.Base = (function () {


	        return {
	            /**
	             * Creates a new object that inherits from this object.
	             *
	             * @param {Object} overrides Properties to copy into the new object.
	             *
	             * @return {Object} The new object.
	             *
	             * @static
	             *
	             * @example
	             *
	             *     var MyType = CryptoJS.lib.Base.extend({
	             *         field: 'value',
	             *
	             *         method: function () {
	             *         }
	             *     });
	             */
	            extend: function (overrides) {
	                // Spawn
	                var subtype = create(this);

	                // Augment
	                if (overrides) {
	                    subtype.mixIn(overrides);
	                }

	                // Create default initializer
	                if (!subtype.hasOwnProperty('init') || this.init === subtype.init) {
	                    subtype.init = function () {
	                        subtype.$super.init.apply(this, arguments);
	                    };
	                }

	                // Initializer's prototype is the subtype object
	                subtype.init.prototype = subtype;

	                // Reference supertype
	                subtype.$super = this;

	                return subtype;
	            },

	            /**
	             * Extends this object and runs the init method.
	             * Arguments to create() will be passed to init().
	             *
	             * @return {Object} The new object.
	             *
	             * @static
	             *
	             * @example
	             *
	             *     var instance = MyType.create();
	             */
	            create: function () {
	                var instance = this.extend();
	                instance.init.apply(instance, arguments);

	                return instance;
	            },

	            /**
	             * Initializes a newly created object.
	             * Override this method to add some logic when your objects are created.
	             *
	             * @example
	             *
	             *     var MyType = CryptoJS.lib.Base.extend({
	             *         init: function () {
	             *             // ...
	             *         }
	             *     });
	             */
	            init: function () {
	            },

	            /**
	             * Copies properties into this object.
	             *
	             * @param {Object} properties The properties to mix in.
	             *
	             * @example
	             *
	             *     MyType.mixIn({
	             *         field: 'value'
	             *     });
	             */
	            mixIn: function (properties) {
	                for (var propertyName in properties) {
	                    if (properties.hasOwnProperty(propertyName)) {
	                        this[propertyName] = properties[propertyName];
	                    }
	                }

	                // IE won't copy toString using the loop above
	                if (properties.hasOwnProperty('toString')) {
	                    this.toString = properties.toString;
	                }
	            },

	            /**
	             * Creates a copy of this object.
	             *
	             * @return {Object} The clone.
	             *
	             * @example
	             *
	             *     var clone = instance.clone();
	             */
	            clone: function () {
	                return this.init.prototype.extend(this);
	            }
	        };
	    }());

	    /**
	     * An array of 32-bit words.
	     *
	     * @property {Array} words The array of 32-bit words.
	     * @property {number} sigBytes The number of significant bytes in this word array.
	     */
	    var WordArray = C_lib.WordArray = Base.extend({
	        /**
	         * Initializes a newly created word array.
	         *
	         * @param {Array} words (Optional) An array of 32-bit words.
	         * @param {number} sigBytes (Optional) The number of significant bytes in the words.
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.lib.WordArray.create();
	         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
	         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
	         */
	        init: function (words, sigBytes) {
	            words = this.words = words || [];

	            if (sigBytes != undefined) {
	                this.sigBytes = sigBytes;
	            } else {
	                this.sigBytes = words.length * 4;
	            }
	        },

	        /**
	         * Converts this word array to a string.
	         *
	         * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
	         *
	         * @return {string} The stringified word array.
	         *
	         * @example
	         *
	         *     var string = wordArray + '';
	         *     var string = wordArray.toString();
	         *     var string = wordArray.toString(CryptoJS.enc.Utf8);
	         */
	        toString: function (encoder) {
	            return (encoder || Hex).stringify(this);
	        },

	        /**
	         * Concatenates a word array to this word array.
	         *
	         * @param {WordArray} wordArray The word array to append.
	         *
	         * @return {WordArray} This word array.
	         *
	         * @example
	         *
	         *     wordArray1.concat(wordArray2);
	         */
	        concat: function (wordArray) {
	            // Shortcuts
	            var thisWords = this.words;
	            var thatWords = wordArray.words;
	            var thisSigBytes = this.sigBytes;
	            var thatSigBytes = wordArray.sigBytes;

	            // Clamp excess bits
	            this.clamp();

	            // Concat
	            if (thisSigBytes % 4) {
	                // Copy one byte at a time
	                for (var i = 0; i < thatSigBytes; i++) {
	                    var thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                    thisWords[(thisSigBytes + i) >>> 2] |= thatByte << (24 - ((thisSigBytes + i) % 4) * 8);
	                }
	            } else {
	                // Copy one word at a time
	                for (var i = 0; i < thatSigBytes; i += 4) {
	                    thisWords[(thisSigBytes + i) >>> 2] = thatWords[i >>> 2];
	                }
	            }
	            this.sigBytes += thatSigBytes;

	            // Chainable
	            return this;
	        },

	        /**
	         * Removes insignificant bits.
	         *
	         * @example
	         *
	         *     wordArray.clamp();
	         */
	        clamp: function () {
	            // Shortcuts
	            var words = this.words;
	            var sigBytes = this.sigBytes;

	            // Clamp
	            words[sigBytes >>> 2] &= 0xffffffff << (32 - (sigBytes % 4) * 8);
	            words.length = Math.ceil(sigBytes / 4);
	        },

	        /**
	         * Creates a copy of this word array.
	         *
	         * @return {WordArray} The clone.
	         *
	         * @example
	         *
	         *     var clone = wordArray.clone();
	         */
	        clone: function () {
	            var clone = Base.clone.call(this);
	            clone.words = this.words.slice(0);

	            return clone;
	        },

	        /**
	         * Creates a word array filled with random bytes.
	         *
	         * @param {number} nBytes The number of random bytes to generate.
	         *
	         * @return {WordArray} The random word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.lib.WordArray.random(16);
	         */
	        random: function (nBytes) {
	            var words = [];

	            var r = (function (m_w) {
	                var m_w = m_w;
	                var m_z = 0x3ade68b1;
	                var mask = 0xffffffff;

	                return function () {
	                    m_z = (0x9069 * (m_z & 0xFFFF) + (m_z >> 0x10)) & mask;
	                    m_w = (0x4650 * (m_w & 0xFFFF) + (m_w >> 0x10)) & mask;
	                    var result = ((m_z << 0x10) + m_w) & mask;
	                    result /= 0x100000000;
	                    result += 0.5;
	                    return result * (Math.random() > .5 ? 1 : -1);
	                }
	            });

	            for (var i = 0, rcache; i < nBytes; i += 4) {
	                var _r = r((rcache || Math.random()) * 0x100000000);

	                rcache = _r() * 0x3ade67b7;
	                words.push((_r() * 0x100000000) | 0);
	            }

	            return new WordArray.init(words, nBytes);
	        }
	    });

	    /**
	     * Encoder namespace.
	     */
	    var C_enc = C.enc = {};

	    /**
	     * Hex encoding strategy.
	     */
	    var Hex = C_enc.Hex = {
	        /**
	         * Converts a word array to a hex string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The hex string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var hexChars = [];
	            for (var i = 0; i < sigBytes; i++) {
	                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                hexChars.push((bite >>> 4).toString(16));
	                hexChars.push((bite & 0x0f).toString(16));
	            }

	            return hexChars.join('');
	        },

	        /**
	         * Converts a hex string to a word array.
	         *
	         * @param {string} hexStr The hex string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
	         */
	        parse: function (hexStr) {
	            // Shortcut
	            var hexStrLength = hexStr.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < hexStrLength; i += 2) {
	                words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);
	            }

	            return new WordArray.init(words, hexStrLength / 2);
	        }
	    };

	    /**
	     * Latin1 encoding strategy.
	     */
	    var Latin1 = C_enc.Latin1 = {
	        /**
	         * Converts a word array to a Latin1 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The Latin1 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var latin1Chars = [];
	            for (var i = 0; i < sigBytes; i++) {
	                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                latin1Chars.push(String.fromCharCode(bite));
	            }

	            return latin1Chars.join('');
	        },

	        /**
	         * Converts a Latin1 string to a word array.
	         *
	         * @param {string} latin1Str The Latin1 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
	         */
	        parse: function (latin1Str) {
	            // Shortcut
	            var latin1StrLength = latin1Str.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < latin1StrLength; i++) {
	                words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);
	            }

	            return new WordArray.init(words, latin1StrLength);
	        }
	    };

	    /**
	     * UTF-8 encoding strategy.
	     */
	    var Utf8 = C_enc.Utf8 = {
	        /**
	         * Converts a word array to a UTF-8 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The UTF-8 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            try {
	                return decodeURIComponent(escape(Latin1.stringify(wordArray)));
	            } catch (e) {
	                throw new Error('Malformed UTF-8 data');
	            }
	        },

	        /**
	         * Converts a UTF-8 string to a word array.
	         *
	         * @param {string} utf8Str The UTF-8 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
	         */
	        parse: function (utf8Str) {
	            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
	        }
	    };

	    /**
	     * Abstract buffered block algorithm template.
	     *
	     * The property blockSize must be implemented in a concrete subtype.
	     *
	     * @property {number} _minBufferSize The number of blocks that should be kept unprocessed in the buffer. Default: 0
	     */
	    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
	        /**
	         * Resets this block algorithm's data buffer to its initial state.
	         *
	         * @example
	         *
	         *     bufferedBlockAlgorithm.reset();
	         */
	        reset: function () {
	            // Initial values
	            this._data = new WordArray.init();
	            this._nDataBytes = 0;
	        },

	        /**
	         * Adds new data to this block algorithm's buffer.
	         *
	         * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
	         *
	         * @example
	         *
	         *     bufferedBlockAlgorithm._append('data');
	         *     bufferedBlockAlgorithm._append(wordArray);
	         */
	        _append: function (data) {
	            // Convert string to WordArray, else assume WordArray already
	            if (typeof data == 'string') {
	                data = Utf8.parse(data);
	            }

	            // Append
	            this._data.concat(data);
	            this._nDataBytes += data.sigBytes;
	        },

	        /**
	         * Processes available data blocks.
	         *
	         * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
	         *
	         * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
	         *
	         * @return {WordArray} The processed data.
	         *
	         * @example
	         *
	         *     var processedData = bufferedBlockAlgorithm._process();
	         *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
	         */
	        _process: function (doFlush) {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;
	            var dataSigBytes = data.sigBytes;
	            var blockSize = this.blockSize;
	            var blockSizeBytes = blockSize * 4;

	            // Count blocks ready
	            var nBlocksReady = dataSigBytes / blockSizeBytes;
	            if (doFlush) {
	                // Round up to include partial blocks
	                nBlocksReady = Math.ceil(nBlocksReady);
	            } else {
	                // Round down to include only full blocks,
	                // less the number of blocks that must remain in the buffer
	                nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);
	            }

	            // Count words ready
	            var nWordsReady = nBlocksReady * blockSize;

	            // Count bytes ready
	            var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);

	            // Process blocks
	            if (nWordsReady) {
	                for (var offset = 0; offset < nWordsReady; offset += blockSize) {
	                    // Perform concrete-algorithm logic
	                    this._doProcessBlock(dataWords, offset);
	                }

	                // Remove processed words
	                var processedWords = dataWords.splice(0, nWordsReady);
	                data.sigBytes -= nBytesReady;
	            }

	            // Return processed words
	            return new WordArray.init(processedWords, nBytesReady);
	        },

	        /**
	         * Creates a copy of this object.
	         *
	         * @return {Object} The clone.
	         *
	         * @example
	         *
	         *     var clone = bufferedBlockAlgorithm.clone();
	         */
	        clone: function () {
	            var clone = Base.clone.call(this);
	            clone._data = this._data.clone();

	            return clone;
	        },

	        _minBufferSize: 0
	    });

	    /**
	     * Abstract hasher template.
	     *
	     * @property {number} blockSize The number of 32-bit words this hasher operates on. Default: 16 (512 bits)
	     */
	    var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({
	        /**
	         * Configuration options.
	         */
	        cfg: Base.extend(),

	        /**
	         * Initializes a newly created hasher.
	         *
	         * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
	         *
	         * @example
	         *
	         *     var hasher = CryptoJS.algo.SHA256.create();
	         */
	        init: function (cfg) {
	            // Apply config defaults
	            this.cfg = this.cfg.extend(cfg);

	            // Set initial values
	            this.reset();
	        },

	        /**
	         * Resets this hasher to its initial state.
	         *
	         * @example
	         *
	         *     hasher.reset();
	         */
	        reset: function () {
	            // Reset data buffer
	            BufferedBlockAlgorithm.reset.call(this);

	            // Perform concrete-hasher logic
	            this._doReset();
	        },

	        /**
	         * Updates this hasher with a message.
	         *
	         * @param {WordArray|string} messageUpdate The message to append.
	         *
	         * @return {Hasher} This hasher.
	         *
	         * @example
	         *
	         *     hasher.update('message');
	         *     hasher.update(wordArray);
	         */
	        update: function (messageUpdate) {
	            // Append
	            this._append(messageUpdate);

	            // Update the hash
	            this._process();

	            // Chainable
	            return this;
	        },

	        /**
	         * Finalizes the hash computation.
	         * Note that the finalize operation is effectively a destructive, read-once operation.
	         *
	         * @param {WordArray|string} messageUpdate (Optional) A final message update.
	         *
	         * @return {WordArray} The hash.
	         *
	         * @example
	         *
	         *     var hash = hasher.finalize();
	         *     var hash = hasher.finalize('message');
	         *     var hash = hasher.finalize(wordArray);
	         */
	        finalize: function (messageUpdate) {
	            // Final message update
	            if (messageUpdate) {
	                this._append(messageUpdate);
	            }

	            // Perform concrete-hasher logic
	            var hash = this._doFinalize();

	            return hash;
	        },

	        blockSize: 512/32,

	        /**
	         * Creates a shortcut function to a hasher's object interface.
	         *
	         * @param {Hasher} hasher The hasher to create a helper for.
	         *
	         * @return {Function} The shortcut function.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
	         */
	        _createHelper: function (hasher) {
	            return function (message, cfg) {
	                return new hasher.init(cfg).finalize(message);
	            };
	        },

	        /**
	         * Creates a shortcut function to the HMAC's object interface.
	         *
	         * @param {Hasher} hasher The hasher to use in this HMAC helper.
	         *
	         * @return {Function} The shortcut function.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
	         */
	        _createHmacHelper: function (hasher) {
	            return function (message, key) {
	                return new C_algo.HMAC.init(hasher, key).finalize(message);
	            };
	        }
	    });

	    /**
	     * Algorithm namespace.
	     */
	    var C_algo = C.algo = {};

	    return C;
	}(Math));


	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var C_enc = C.enc;

	    /**
	     * Base64 encoding strategy.
	     */
	    var Base64 = C_enc.Base64 = {
	        /**
	         * Converts a word array to a Base64 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The Base64 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var base64String = CryptoJS.enc.Base64.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;
	            var map = this._map;

	            // Clamp excess bits
	            wordArray.clamp();

	            // Convert
	            var base64Chars = [];
	            for (var i = 0; i < sigBytes; i += 3) {
	                var byte1 = (words[i >>> 2]       >>> (24 - (i % 4) * 8))       & 0xff;
	                var byte2 = (words[(i + 1) >>> 2] >>> (24 - ((i + 1) % 4) * 8)) & 0xff;
	                var byte3 = (words[(i + 2) >>> 2] >>> (24 - ((i + 2) % 4) * 8)) & 0xff;

	                var triplet = (byte1 << 16) | (byte2 << 8) | byte3;

	                for (var j = 0; (j < 4) && (i + j * 0.75 < sigBytes); j++) {
	                    base64Chars.push(map.charAt((triplet >>> (6 * (3 - j))) & 0x3f));
	                }
	            }

	            // Add padding
	            var paddingChar = map.charAt(64);
	            if (paddingChar) {
	                while (base64Chars.length % 4) {
	                    base64Chars.push(paddingChar);
	                }
	            }

	            return base64Chars.join('');
	        },

	        /**
	         * Converts a Base64 string to a word array.
	         *
	         * @param {string} base64Str The Base64 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Base64.parse(base64String);
	         */
	        parse: function (base64Str) {
	            // Shortcuts
	            var base64StrLength = base64Str.length;
	            var map = this._map;
	            var reverseMap = this._reverseMap;

	            if (!reverseMap) {
	                    reverseMap = this._reverseMap = [];
	                    for (var j = 0; j < map.length; j++) {
	                        reverseMap[map.charCodeAt(j)] = j;
	                    }
	            }

	            // Ignore padding
	            var paddingChar = map.charAt(64);
	            if (paddingChar) {
	                var paddingIndex = base64Str.indexOf(paddingChar);
	                if (paddingIndex !== -1) {
	                    base64StrLength = paddingIndex;
	                }
	            }

	            // Convert
	            return parseLoop(base64Str, base64StrLength, reverseMap);

	        },

	        _map: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='
	    };

	    function parseLoop(base64Str, base64StrLength, reverseMap) {
	      var words = [];
	      var nBytes = 0;
	      for (var i = 0; i < base64StrLength; i++) {
	          if (i % 4) {
	              var bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << ((i % 4) * 2);
	              var bits2 = reverseMap[base64Str.charCodeAt(i)] >>> (6 - (i % 4) * 2);
	              words[nBytes >>> 2] |= (bits1 | bits2) << (24 - (nBytes % 4) * 8);
	              nBytes++;
	          }
	      }
	      return WordArray.create(words, nBytes);
	    }
	}());


	(function (Math) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_algo = C.algo;

	    // Constants table
	    var T = [];

	    // Compute constants
	    (function () {
	        for (var i = 0; i < 64; i++) {
	            T[i] = (Math.abs(Math.sin(i + 1)) * 0x100000000) | 0;
	        }
	    }());

	    /**
	     * MD5 hash algorithm.
	     */
	    var MD5 = C_algo.MD5 = Hasher.extend({
	        _doReset: function () {
	            this._hash = new WordArray.init([
	                0x67452301, 0xefcdab89,
	                0x98badcfe, 0x10325476
	            ]);
	        },

	        _doProcessBlock: function (M, offset) {
	            // Swap endian
	            for (var i = 0; i < 16; i++) {
	                // Shortcuts
	                var offset_i = offset + i;
	                var M_offset_i = M[offset_i];

	                M[offset_i] = (
	                    (((M_offset_i << 8)  | (M_offset_i >>> 24)) & 0x00ff00ff) |
	                    (((M_offset_i << 24) | (M_offset_i >>> 8))  & 0xff00ff00)
	                );
	            }

	            // Shortcuts
	            var H = this._hash.words;

	            var M_offset_0  = M[offset + 0];
	            var M_offset_1  = M[offset + 1];
	            var M_offset_2  = M[offset + 2];
	            var M_offset_3  = M[offset + 3];
	            var M_offset_4  = M[offset + 4];
	            var M_offset_5  = M[offset + 5];
	            var M_offset_6  = M[offset + 6];
	            var M_offset_7  = M[offset + 7];
	            var M_offset_8  = M[offset + 8];
	            var M_offset_9  = M[offset + 9];
	            var M_offset_10 = M[offset + 10];
	            var M_offset_11 = M[offset + 11];
	            var M_offset_12 = M[offset + 12];
	            var M_offset_13 = M[offset + 13];
	            var M_offset_14 = M[offset + 14];
	            var M_offset_15 = M[offset + 15];

	            // Working varialbes
	            var a = H[0];
	            var b = H[1];
	            var c = H[2];
	            var d = H[3];

	            // Computation
	            a = FF(a, b, c, d, M_offset_0,  7,  T[0]);
	            d = FF(d, a, b, c, M_offset_1,  12, T[1]);
	            c = FF(c, d, a, b, M_offset_2,  17, T[2]);
	            b = FF(b, c, d, a, M_offset_3,  22, T[3]);
	            a = FF(a, b, c, d, M_offset_4,  7,  T[4]);
	            d = FF(d, a, b, c, M_offset_5,  12, T[5]);
	            c = FF(c, d, a, b, M_offset_6,  17, T[6]);
	            b = FF(b, c, d, a, M_offset_7,  22, T[7]);
	            a = FF(a, b, c, d, M_offset_8,  7,  T[8]);
	            d = FF(d, a, b, c, M_offset_9,  12, T[9]);
	            c = FF(c, d, a, b, M_offset_10, 17, T[10]);
	            b = FF(b, c, d, a, M_offset_11, 22, T[11]);
	            a = FF(a, b, c, d, M_offset_12, 7,  T[12]);
	            d = FF(d, a, b, c, M_offset_13, 12, T[13]);
	            c = FF(c, d, a, b, M_offset_14, 17, T[14]);
	            b = FF(b, c, d, a, M_offset_15, 22, T[15]);

	            a = GG(a, b, c, d, M_offset_1,  5,  T[16]);
	            d = GG(d, a, b, c, M_offset_6,  9,  T[17]);
	            c = GG(c, d, a, b, M_offset_11, 14, T[18]);
	            b = GG(b, c, d, a, M_offset_0,  20, T[19]);
	            a = GG(a, b, c, d, M_offset_5,  5,  T[20]);
	            d = GG(d, a, b, c, M_offset_10, 9,  T[21]);
	            c = GG(c, d, a, b, M_offset_15, 14, T[22]);
	            b = GG(b, c, d, a, M_offset_4,  20, T[23]);
	            a = GG(a, b, c, d, M_offset_9,  5,  T[24]);
	            d = GG(d, a, b, c, M_offset_14, 9,  T[25]);
	            c = GG(c, d, a, b, M_offset_3,  14, T[26]);
	            b = GG(b, c, d, a, M_offset_8,  20, T[27]);
	            a = GG(a, b, c, d, M_offset_13, 5,  T[28]);
	            d = GG(d, a, b, c, M_offset_2,  9,  T[29]);
	            c = GG(c, d, a, b, M_offset_7,  14, T[30]);
	            b = GG(b, c, d, a, M_offset_12, 20, T[31]);

	            a = HH(a, b, c, d, M_offset_5,  4,  T[32]);
	            d = HH(d, a, b, c, M_offset_8,  11, T[33]);
	            c = HH(c, d, a, b, M_offset_11, 16, T[34]);
	            b = HH(b, c, d, a, M_offset_14, 23, T[35]);
	            a = HH(a, b, c, d, M_offset_1,  4,  T[36]);
	            d = HH(d, a, b, c, M_offset_4,  11, T[37]);
	            c = HH(c, d, a, b, M_offset_7,  16, T[38]);
	            b = HH(b, c, d, a, M_offset_10, 23, T[39]);
	            a = HH(a, b, c, d, M_offset_13, 4,  T[40]);
	            d = HH(d, a, b, c, M_offset_0,  11, T[41]);
	            c = HH(c, d, a, b, M_offset_3,  16, T[42]);
	            b = HH(b, c, d, a, M_offset_6,  23, T[43]);
	            a = HH(a, b, c, d, M_offset_9,  4,  T[44]);
	            d = HH(d, a, b, c, M_offset_12, 11, T[45]);
	            c = HH(c, d, a, b, M_offset_15, 16, T[46]);
	            b = HH(b, c, d, a, M_offset_2,  23, T[47]);

	            a = II(a, b, c, d, M_offset_0,  6,  T[48]);
	            d = II(d, a, b, c, M_offset_7,  10, T[49]);
	            c = II(c, d, a, b, M_offset_14, 15, T[50]);
	            b = II(b, c, d, a, M_offset_5,  21, T[51]);
	            a = II(a, b, c, d, M_offset_12, 6,  T[52]);
	            d = II(d, a, b, c, M_offset_3,  10, T[53]);
	            c = II(c, d, a, b, M_offset_10, 15, T[54]);
	            b = II(b, c, d, a, M_offset_1,  21, T[55]);
	            a = II(a, b, c, d, M_offset_8,  6,  T[56]);
	            d = II(d, a, b, c, M_offset_15, 10, T[57]);
	            c = II(c, d, a, b, M_offset_6,  15, T[58]);
	            b = II(b, c, d, a, M_offset_13, 21, T[59]);
	            a = II(a, b, c, d, M_offset_4,  6,  T[60]);
	            d = II(d, a, b, c, M_offset_11, 10, T[61]);
	            c = II(c, d, a, b, M_offset_2,  15, T[62]);
	            b = II(b, c, d, a, M_offset_9,  21, T[63]);

	            // Intermediate hash value
	            H[0] = (H[0] + a) | 0;
	            H[1] = (H[1] + b) | 0;
	            H[2] = (H[2] + c) | 0;
	            H[3] = (H[3] + d) | 0;
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;

	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);

	            var nBitsTotalH = Math.floor(nBitsTotal / 0x100000000);
	            var nBitsTotalL = nBitsTotal;
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = (
	                (((nBitsTotalH << 8)  | (nBitsTotalH >>> 24)) & 0x00ff00ff) |
	                (((nBitsTotalH << 24) | (nBitsTotalH >>> 8))  & 0xff00ff00)
	            );
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (
	                (((nBitsTotalL << 8)  | (nBitsTotalL >>> 24)) & 0x00ff00ff) |
	                (((nBitsTotalL << 24) | (nBitsTotalL >>> 8))  & 0xff00ff00)
	            );

	            data.sigBytes = (dataWords.length + 1) * 4;

	            // Hash final blocks
	            this._process();

	            // Shortcuts
	            var hash = this._hash;
	            var H = hash.words;

	            // Swap endian
	            for (var i = 0; i < 4; i++) {
	                // Shortcut
	                var H_i = H[i];

	                H[i] = (((H_i << 8)  | (H_i >>> 24)) & 0x00ff00ff) |
	                       (((H_i << 24) | (H_i >>> 8))  & 0xff00ff00);
	            }

	            // Return final computed hash
	            return hash;
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);
	            clone._hash = this._hash.clone();

	            return clone;
	        }
	    });

	    function FF(a, b, c, d, x, s, t) {
	        var n = a + ((b & c) | (~b & d)) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    function GG(a, b, c, d, x, s, t) {
	        var n = a + ((b & d) | (c & ~d)) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    function HH(a, b, c, d, x, s, t) {
	        var n = a + (b ^ c ^ d) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    function II(a, b, c, d, x, s, t) {
	        var n = a + (c ^ (b | ~d)) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.MD5('message');
	     *     var hash = CryptoJS.MD5(wordArray);
	     */
	    C.MD5 = Hasher._createHelper(MD5);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacMD5(message, key);
	     */
	    C.HmacMD5 = Hasher._createHmacHelper(MD5);
	}(Math));


	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_algo = C.algo;

	    // Reusable object
	    var W = [];

	    /**
	     * SHA-1 hash algorithm.
	     */
	    var SHA1 = C_algo.SHA1 = Hasher.extend({
	        _doReset: function () {
	            this._hash = new WordArray.init([
	                0x67452301, 0xefcdab89,
	                0x98badcfe, 0x10325476,
	                0xc3d2e1f0
	            ]);
	        },

	        _doProcessBlock: function (M, offset) {
	            // Shortcut
	            var H = this._hash.words;

	            // Working variables
	            var a = H[0];
	            var b = H[1];
	            var c = H[2];
	            var d = H[3];
	            var e = H[4];

	            // Computation
	            for (var i = 0; i < 80; i++) {
	                if (i < 16) {
	                    W[i] = M[offset + i] | 0;
	                } else {
	                    var n = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];
	                    W[i] = (n << 1) | (n >>> 31);
	                }

	                var t = ((a << 5) | (a >>> 27)) + e + W[i];
	                if (i < 20) {
	                    t += ((b & c) | (~b & d)) + 0x5a827999;
	                } else if (i < 40) {
	                    t += (b ^ c ^ d) + 0x6ed9eba1;
	                } else if (i < 60) {
	                    t += ((b & c) | (b & d) | (c & d)) - 0x70e44324;
	                } else /* if (i < 80) */ {
	                    t += (b ^ c ^ d) - 0x359d3e2a;
	                }

	                e = d;
	                d = c;
	                c = (b << 30) | (b >>> 2);
	                b = a;
	                a = t;
	            }

	            // Intermediate hash value
	            H[0] = (H[0] + a) | 0;
	            H[1] = (H[1] + b) | 0;
	            H[2] = (H[2] + c) | 0;
	            H[3] = (H[3] + d) | 0;
	            H[4] = (H[4] + e) | 0;
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;

	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;
	            data.sigBytes = dataWords.length * 4;

	            // Hash final blocks
	            this._process();

	            // Return final computed hash
	            return this._hash;
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);
	            clone._hash = this._hash.clone();

	            return clone;
	        }
	    });

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA1('message');
	     *     var hash = CryptoJS.SHA1(wordArray);
	     */
	    C.SHA1 = Hasher._createHelper(SHA1);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA1(message, key);
	     */
	    C.HmacSHA1 = Hasher._createHmacHelper(SHA1);
	}());


	(function (Math) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_algo = C.algo;

	    // Initialization and round constants tables
	    var H = [];
	    var K = [];

	    // Compute constants
	    (function () {
	        function isPrime(n) {
	            var sqrtN = Math.sqrt(n);
	            for (var factor = 2; factor <= sqrtN; factor++) {
	                if (!(n % factor)) {
	                    return false;
	                }
	            }

	            return true;
	        }

	        function getFractionalBits(n) {
	            return ((n - (n | 0)) * 0x100000000) | 0;
	        }

	        var n = 2;
	        var nPrime = 0;
	        while (nPrime < 64) {
	            if (isPrime(n)) {
	                if (nPrime < 8) {
	                    H[nPrime] = getFractionalBits(Math.pow(n, 1 / 2));
	                }
	                K[nPrime] = getFractionalBits(Math.pow(n, 1 / 3));

	                nPrime++;
	            }

	            n++;
	        }
	    }());

	    // Reusable object
	    var W = [];

	    /**
	     * SHA-256 hash algorithm.
	     */
	    var SHA256 = C_algo.SHA256 = Hasher.extend({
	        _doReset: function () {
	            this._hash = new WordArray.init(H.slice(0));
	        },

	        _doProcessBlock: function (M, offset) {
	            // Shortcut
	            var H = this._hash.words;

	            // Working variables
	            var a = H[0];
	            var b = H[1];
	            var c = H[2];
	            var d = H[3];
	            var e = H[4];
	            var f = H[5];
	            var g = H[6];
	            var h = H[7];

	            // Computation
	            for (var i = 0; i < 64; i++) {
	                if (i < 16) {
	                    W[i] = M[offset + i] | 0;
	                } else {
	                    var gamma0x = W[i - 15];
	                    var gamma0  = ((gamma0x << 25) | (gamma0x >>> 7))  ^
	                                  ((gamma0x << 14) | (gamma0x >>> 18)) ^
	                                   (gamma0x >>> 3);

	                    var gamma1x = W[i - 2];
	                    var gamma1  = ((gamma1x << 15) | (gamma1x >>> 17)) ^
	                                  ((gamma1x << 13) | (gamma1x >>> 19)) ^
	                                   (gamma1x >>> 10);

	                    W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];
	                }

	                var ch  = (e & f) ^ (~e & g);
	                var maj = (a & b) ^ (a & c) ^ (b & c);

	                var sigma0 = ((a << 30) | (a >>> 2)) ^ ((a << 19) | (a >>> 13)) ^ ((a << 10) | (a >>> 22));
	                var sigma1 = ((e << 26) | (e >>> 6)) ^ ((e << 21) | (e >>> 11)) ^ ((e << 7)  | (e >>> 25));

	                var t1 = h + sigma1 + ch + K[i] + W[i];
	                var t2 = sigma0 + maj;

	                h = g;
	                g = f;
	                f = e;
	                e = (d + t1) | 0;
	                d = c;
	                c = b;
	                b = a;
	                a = (t1 + t2) | 0;
	            }

	            // Intermediate hash value
	            H[0] = (H[0] + a) | 0;
	            H[1] = (H[1] + b) | 0;
	            H[2] = (H[2] + c) | 0;
	            H[3] = (H[3] + d) | 0;
	            H[4] = (H[4] + e) | 0;
	            H[5] = (H[5] + f) | 0;
	            H[6] = (H[6] + g) | 0;
	            H[7] = (H[7] + h) | 0;
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;

	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;
	            data.sigBytes = dataWords.length * 4;

	            // Hash final blocks
	            this._process();

	            // Return final computed hash
	            return this._hash;
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);
	            clone._hash = this._hash.clone();

	            return clone;
	        }
	    });

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA256('message');
	     *     var hash = CryptoJS.SHA256(wordArray);
	     */
	    C.SHA256 = Hasher._createHelper(SHA256);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA256(message, key);
	     */
	    C.HmacSHA256 = Hasher._createHmacHelper(SHA256);
	}(Math));


	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var C_enc = C.enc;

	    /**
	     * UTF-16 BE encoding strategy.
	     */
	    var Utf16BE = C_enc.Utf16 = C_enc.Utf16BE = {
	        /**
	         * Converts a word array to a UTF-16 BE string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The UTF-16 BE string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var utf16String = CryptoJS.enc.Utf16.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var utf16Chars = [];
	            for (var i = 0; i < sigBytes; i += 2) {
	                var codePoint = (words[i >>> 2] >>> (16 - (i % 4) * 8)) & 0xffff;
	                utf16Chars.push(String.fromCharCode(codePoint));
	            }

	            return utf16Chars.join('');
	        },

	        /**
	         * Converts a UTF-16 BE string to a word array.
	         *
	         * @param {string} utf16Str The UTF-16 BE string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Utf16.parse(utf16String);
	         */
	        parse: function (utf16Str) {
	            // Shortcut
	            var utf16StrLength = utf16Str.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < utf16StrLength; i++) {
	                words[i >>> 1] |= utf16Str.charCodeAt(i) << (16 - (i % 2) * 16);
	            }

	            return WordArray.create(words, utf16StrLength * 2);
	        }
	    };

	    /**
	     * UTF-16 LE encoding strategy.
	     */
	    C_enc.Utf16LE = {
	        /**
	         * Converts a word array to a UTF-16 LE string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The UTF-16 LE string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var utf16Str = CryptoJS.enc.Utf16LE.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var utf16Chars = [];
	            for (var i = 0; i < sigBytes; i += 2) {
	                var codePoint = swapEndian((words[i >>> 2] >>> (16 - (i % 4) * 8)) & 0xffff);
	                utf16Chars.push(String.fromCharCode(codePoint));
	            }

	            return utf16Chars.join('');
	        },

	        /**
	         * Converts a UTF-16 LE string to a word array.
	         *
	         * @param {string} utf16Str The UTF-16 LE string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Utf16LE.parse(utf16Str);
	         */
	        parse: function (utf16Str) {
	            // Shortcut
	            var utf16StrLength = utf16Str.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < utf16StrLength; i++) {
	                words[i >>> 1] |= swapEndian(utf16Str.charCodeAt(i) << (16 - (i % 2) * 16));
	            }

	            return WordArray.create(words, utf16StrLength * 2);
	        }
	    };

	    function swapEndian(word) {
	        return ((word << 8) & 0xff00ff00) | ((word >>> 8) & 0x00ff00ff);
	    }
	}());


	(function () {
	    // Check if typed arrays are supported
	    if (typeof ArrayBuffer != 'function') {
	        return;
	    }

	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;

	    // Reference original init
	    var superInit = WordArray.init;

	    // Augment WordArray.init to handle typed arrays
	    var subInit = WordArray.init = function (typedArray) {
	        // Convert buffers to uint8
	        if (typedArray instanceof ArrayBuffer) {
	            typedArray = new Uint8Array(typedArray);
	        }

	        // Convert other array views to uint8
	        if (
	            typedArray instanceof Int8Array ||
	            (typeof Uint8ClampedArray !== "undefined" && typedArray instanceof Uint8ClampedArray) ||
	            typedArray instanceof Int16Array ||
	            typedArray instanceof Uint16Array ||
	            typedArray instanceof Int32Array ||
	            typedArray instanceof Uint32Array ||
	            typedArray instanceof Float32Array ||
	            typedArray instanceof Float64Array
	        ) {
	            typedArray = new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);
	        }

	        // Handle Uint8Array
	        if (typedArray instanceof Uint8Array) {
	            // Shortcut
	            var typedArrayByteLength = typedArray.byteLength;

	            // Extract bytes
	            var words = [];
	            for (var i = 0; i < typedArrayByteLength; i++) {
	                words[i >>> 2] |= typedArray[i] << (24 - (i % 4) * 8);
	            }

	            // Initialize this word array
	            superInit.call(this, words, typedArrayByteLength);
	        } else {
	            // Else call normal init
	            superInit.apply(this, arguments);
	        }
	    };

	    subInit.prototype = WordArray;
	}());


	/** @preserve
	(c) 2012 by Cédric Mesnil. All rights reserved.

	Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

	    - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
	    - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.

	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*/

	(function (Math) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_algo = C.algo;

	    // Constants table
	    var _zl = WordArray.create([
	        0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
	        7,  4, 13,  1, 10,  6, 15,  3, 12,  0,  9,  5,  2, 14, 11,  8,
	        3, 10, 14,  4,  9, 15,  8,  1,  2,  7,  0,  6, 13, 11,  5, 12,
	        1,  9, 11, 10,  0,  8, 12,  4, 13,  3,  7, 15, 14,  5,  6,  2,
	        4,  0,  5,  9,  7, 12,  2, 10, 14,  1,  3,  8, 11,  6, 15, 13]);
	    var _zr = WordArray.create([
	        5, 14,  7,  0,  9,  2, 11,  4, 13,  6, 15,  8,  1, 10,  3, 12,
	        6, 11,  3,  7,  0, 13,  5, 10, 14, 15,  8, 12,  4,  9,  1,  2,
	        15,  5,  1,  3,  7, 14,  6,  9, 11,  8, 12,  2, 10,  0,  4, 13,
	        8,  6,  4,  1,  3, 11, 15,  0,  5, 12,  2, 13,  9,  7, 10, 14,
	        12, 15, 10,  4,  1,  5,  8,  7,  6,  2, 13, 14,  0,  3,  9, 11]);
	    var _sl = WordArray.create([
	         11, 14, 15, 12,  5,  8,  7,  9, 11, 13, 14, 15,  6,  7,  9,  8,
	        7, 6,   8, 13, 11,  9,  7, 15,  7, 12, 15,  9, 11,  7, 13, 12,
	        11, 13,  6,  7, 14,  9, 13, 15, 14,  8, 13,  6,  5, 12,  7,  5,
	          11, 12, 14, 15, 14, 15,  9,  8,  9, 14,  5,  6,  8,  6,  5, 12,
	        9, 15,  5, 11,  6,  8, 13, 12,  5, 12, 13, 14, 11,  8,  5,  6 ]);
	    var _sr = WordArray.create([
	        8,  9,  9, 11, 13, 15, 15,  5,  7,  7,  8, 11, 14, 14, 12,  6,
	        9, 13, 15,  7, 12,  8,  9, 11,  7,  7, 12,  7,  6, 15, 13, 11,
	        9,  7, 15, 11,  8,  6,  6, 14, 12, 13,  5, 14, 13, 13,  7,  5,
	        15,  5,  8, 11, 14, 14,  6, 14,  6,  9, 12,  9, 12,  5, 15,  8,
	        8,  5, 12,  9, 12,  5, 14,  6,  8, 13,  6,  5, 15, 13, 11, 11 ]);

	    var _hl =  WordArray.create([ 0x00000000, 0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xA953FD4E]);
	    var _hr =  WordArray.create([ 0x50A28BE6, 0x5C4DD124, 0x6D703EF3, 0x7A6D76E9, 0x00000000]);

	    /**
	     * RIPEMD160 hash algorithm.
	     */
	    var RIPEMD160 = C_algo.RIPEMD160 = Hasher.extend({
	        _doReset: function () {
	            this._hash  = WordArray.create([0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0]);
	        },

	        _doProcessBlock: function (M, offset) {

	            // Swap endian
	            for (var i = 0; i < 16; i++) {
	                // Shortcuts
	                var offset_i = offset + i;
	                var M_offset_i = M[offset_i];

	                // Swap
	                M[offset_i] = (
	                    (((M_offset_i << 8)  | (M_offset_i >>> 24)) & 0x00ff00ff) |
	                    (((M_offset_i << 24) | (M_offset_i >>> 8))  & 0xff00ff00)
	                );
	            }
	            // Shortcut
	            var H  = this._hash.words;
	            var hl = _hl.words;
	            var hr = _hr.words;
	            var zl = _zl.words;
	            var zr = _zr.words;
	            var sl = _sl.words;
	            var sr = _sr.words;

	            // Working variables
	            var al, bl, cl, dl, el;
	            var ar, br, cr, dr, er;

	            ar = al = H[0];
	            br = bl = H[1];
	            cr = cl = H[2];
	            dr = dl = H[3];
	            er = el = H[4];
	            // Computation
	            var t;
	            for (var i = 0; i < 80; i += 1) {
	                t = (al +  M[offset+zl[i]])|0;
	                if (i<16){
		            t +=  f1(bl,cl,dl) + hl[0];
	                } else if (i<32) {
		            t +=  f2(bl,cl,dl) + hl[1];
	                } else if (i<48) {
		            t +=  f3(bl,cl,dl) + hl[2];
	                } else if (i<64) {
		            t +=  f4(bl,cl,dl) + hl[3];
	                } else {// if (i<80) {
		            t +=  f5(bl,cl,dl) + hl[4];
	                }
	                t = t|0;
	                t =  rotl(t,sl[i]);
	                t = (t+el)|0;
	                al = el;
	                el = dl;
	                dl = rotl(cl, 10);
	                cl = bl;
	                bl = t;

	                t = (ar + M[offset+zr[i]])|0;
	                if (i<16){
		            t +=  f5(br,cr,dr) + hr[0];
	                } else if (i<32) {
		            t +=  f4(br,cr,dr) + hr[1];
	                } else if (i<48) {
		            t +=  f3(br,cr,dr) + hr[2];
	                } else if (i<64) {
		            t +=  f2(br,cr,dr) + hr[3];
	                } else {// if (i<80) {
		            t +=  f1(br,cr,dr) + hr[4];
	                }
	                t = t|0;
	                t =  rotl(t,sr[i]) ;
	                t = (t+er)|0;
	                ar = er;
	                er = dr;
	                dr = rotl(cr, 10);
	                cr = br;
	                br = t;
	            }
	            // Intermediate hash value
	            t    = (H[1] + cl + dr)|0;
	            H[1] = (H[2] + dl + er)|0;
	            H[2] = (H[3] + el + ar)|0;
	            H[3] = (H[4] + al + br)|0;
	            H[4] = (H[0] + bl + cr)|0;
	            H[0] =  t;
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;

	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (
	                (((nBitsTotal << 8)  | (nBitsTotal >>> 24)) & 0x00ff00ff) |
	                (((nBitsTotal << 24) | (nBitsTotal >>> 8))  & 0xff00ff00)
	            );
	            data.sigBytes = (dataWords.length + 1) * 4;

	            // Hash final blocks
	            this._process();

	            // Shortcuts
	            var hash = this._hash;
	            var H = hash.words;

	            // Swap endian
	            for (var i = 0; i < 5; i++) {
	                // Shortcut
	                var H_i = H[i];

	                // Swap
	                H[i] = (((H_i << 8)  | (H_i >>> 24)) & 0x00ff00ff) |
	                       (((H_i << 24) | (H_i >>> 8))  & 0xff00ff00);
	            }

	            // Return final computed hash
	            return hash;
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);
	            clone._hash = this._hash.clone();

	            return clone;
	        }
	    });


	    function f1(x, y, z) {
	        return ((x) ^ (y) ^ (z));

	    }

	    function f2(x, y, z) {
	        return (((x)&(y)) | ((~x)&(z)));
	    }

	    function f3(x, y, z) {
	        return (((x) | (~(y))) ^ (z));
	    }

	    function f4(x, y, z) {
	        return (((x) & (z)) | ((y)&(~(z))));
	    }

	    function f5(x, y, z) {
	        return ((x) ^ ((y) |(~(z))));

	    }

	    function rotl(x,n) {
	        return (x<<n) | (x>>>(32-n));
	    }


	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.RIPEMD160('message');
	     *     var hash = CryptoJS.RIPEMD160(wordArray);
	     */
	    C.RIPEMD160 = Hasher._createHelper(RIPEMD160);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacRIPEMD160(message, key);
	     */
	    C.HmacRIPEMD160 = Hasher._createHmacHelper(RIPEMD160);
	}(Math));


	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Base = C_lib.Base;
	    var C_enc = C.enc;
	    var Utf8 = C_enc.Utf8;
	    var C_algo = C.algo;

	    /**
	     * HMAC algorithm.
	     */
	    var HMAC = C_algo.HMAC = Base.extend({
	        /**
	         * Initializes a newly created HMAC.
	         *
	         * @param {Hasher} hasher The hash algorithm to use.
	         * @param {WordArray|string} key The secret key.
	         *
	         * @example
	         *
	         *     var hmacHasher = CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA256, key);
	         */
	        init: function (hasher, key) {
	            // Init hasher
	            hasher = this._hasher = new hasher.init();

	            // Convert string to WordArray, else assume WordArray already
	            if (typeof key == 'string') {
	                key = Utf8.parse(key);
	            }

	            // Shortcuts
	            var hasherBlockSize = hasher.blockSize;
	            var hasherBlockSizeBytes = hasherBlockSize * 4;

	            // Allow arbitrary length keys
	            if (key.sigBytes > hasherBlockSizeBytes) {
	                key = hasher.finalize(key);
	            }

	            // Clamp excess bits
	            key.clamp();

	            // Clone key for inner and outer pads
	            var oKey = this._oKey = key.clone();
	            var iKey = this._iKey = key.clone();

	            // Shortcuts
	            var oKeyWords = oKey.words;
	            var iKeyWords = iKey.words;

	            // XOR keys with pad constants
	            for (var i = 0; i < hasherBlockSize; i++) {
	                oKeyWords[i] ^= 0x5c5c5c5c;
	                iKeyWords[i] ^= 0x36363636;
	            }
	            oKey.sigBytes = iKey.sigBytes = hasherBlockSizeBytes;

	            // Set initial values
	            this.reset();
	        },

	        /**
	         * Resets this HMAC to its initial state.
	         *
	         * @example
	         *
	         *     hmacHasher.reset();
	         */
	        reset: function () {
	            // Shortcut
	            var hasher = this._hasher;

	            // Reset
	            hasher.reset();
	            hasher.update(this._iKey);
	        },

	        /**
	         * Updates this HMAC with a message.
	         *
	         * @param {WordArray|string} messageUpdate The message to append.
	         *
	         * @return {HMAC} This HMAC instance.
	         *
	         * @example
	         *
	         *     hmacHasher.update('message');
	         *     hmacHasher.update(wordArray);
	         */
	        update: function (messageUpdate) {
	            this._hasher.update(messageUpdate);

	            // Chainable
	            return this;
	        },

	        /**
	         * Finalizes the HMAC computation.
	         * Note that the finalize operation is effectively a destructive, read-once operation.
	         *
	         * @param {WordArray|string} messageUpdate (Optional) A final message update.
	         *
	         * @return {WordArray} The HMAC.
	         *
	         * @example
	         *
	         *     var hmac = hmacHasher.finalize();
	         *     var hmac = hmacHasher.finalize('message');
	         *     var hmac = hmacHasher.finalize(wordArray);
	         */
	        finalize: function (messageUpdate) {
	            // Shortcut
	            var hasher = this._hasher;

	            // Compute HMAC
	            var innerHash = hasher.finalize(messageUpdate);
	            hasher.reset();
	            var hmac = hasher.finalize(this._oKey.clone().concat(innerHash));

	            return hmac;
	        }
	    });
	}());


	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Base = C_lib.Base;
	    var WordArray = C_lib.WordArray;
	    var C_algo = C.algo;
	    var SHA1 = C_algo.SHA1;
	    var HMAC = C_algo.HMAC;

	    /**
	     * Password-Based Key Derivation Function 2 algorithm.
	     */
	    var PBKDF2 = C_algo.PBKDF2 = Base.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
	         * @property {Hasher} hasher The hasher to use. Default: SHA1
	         * @property {number} iterations The number of iterations to perform. Default: 1
	         */
	        cfg: Base.extend({
	            keySize: 128/32,
	            hasher: SHA1,
	            iterations: 1
	        }),

	        /**
	         * Initializes a newly created key derivation function.
	         *
	         * @param {Object} cfg (Optional) The configuration options to use for the derivation.
	         *
	         * @example
	         *
	         *     var kdf = CryptoJS.algo.PBKDF2.create();
	         *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8 });
	         *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8, iterations: 1000 });
	         */
	        init: function (cfg) {
	            this.cfg = this.cfg.extend(cfg);
	        },

	        /**
	         * Computes the Password-Based Key Derivation Function 2.
	         *
	         * @param {WordArray|string} password The password.
	         * @param {WordArray|string} salt A salt.
	         *
	         * @return {WordArray} The derived key.
	         *
	         * @example
	         *
	         *     var key = kdf.compute(password, salt);
	         */
	        compute: function (password, salt) {
	            // Shortcut
	            var cfg = this.cfg;

	            // Init HMAC
	            var hmac = HMAC.create(cfg.hasher, password);

	            // Initial values
	            var derivedKey = WordArray.create();
	            var blockIndex = WordArray.create([0x00000001]);

	            // Shortcuts
	            var derivedKeyWords = derivedKey.words;
	            var blockIndexWords = blockIndex.words;
	            var keySize = cfg.keySize;
	            var iterations = cfg.iterations;

	            // Generate key
	            while (derivedKeyWords.length < keySize) {
	                var block = hmac.update(salt).finalize(blockIndex);
	                hmac.reset();

	                // Shortcuts
	                var blockWords = block.words;
	                var blockWordsLength = blockWords.length;

	                // Iterations
	                var intermediate = block;
	                for (var i = 1; i < iterations; i++) {
	                    intermediate = hmac.finalize(intermediate);
	                    hmac.reset();

	                    // Shortcut
	                    var intermediateWords = intermediate.words;

	                    // XOR intermediate with block
	                    for (var j = 0; j < blockWordsLength; j++) {
	                        blockWords[j] ^= intermediateWords[j];
	                    }
	                }

	                derivedKey.concat(block);
	                blockIndexWords[0]++;
	            }
	            derivedKey.sigBytes = keySize * 4;

	            return derivedKey;
	        }
	    });

	    /**
	     * Computes the Password-Based Key Derivation Function 2.
	     *
	     * @param {WordArray|string} password The password.
	     * @param {WordArray|string} salt A salt.
	     * @param {Object} cfg (Optional) The configuration options to use for this computation.
	     *
	     * @return {WordArray} The derived key.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var key = CryptoJS.PBKDF2(password, salt);
	     *     var key = CryptoJS.PBKDF2(password, salt, { keySize: 8 });
	     *     var key = CryptoJS.PBKDF2(password, salt, { keySize: 8, iterations: 1000 });
	     */
	    C.PBKDF2 = function (password, salt, cfg) {
	        return PBKDF2.create(cfg).compute(password, salt);
	    };
	}());


	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Base = C_lib.Base;
	    var WordArray = C_lib.WordArray;
	    var C_algo = C.algo;
	    var MD5 = C_algo.MD5;

	    /**
	     * This key derivation function is meant to conform with EVP_BytesToKey.
	     * www.openssl.org/docs/crypto/EVP_BytesToKey.html
	     */
	    var EvpKDF = C_algo.EvpKDF = Base.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
	         * @property {Hasher} hasher The hash algorithm to use. Default: MD5
	         * @property {number} iterations The number of iterations to perform. Default: 1
	         */
	        cfg: Base.extend({
	            keySize: 128/32,
	            hasher: MD5,
	            iterations: 1
	        }),

	        /**
	         * Initializes a newly created key derivation function.
	         *
	         * @param {Object} cfg (Optional) The configuration options to use for the derivation.
	         *
	         * @example
	         *
	         *     var kdf = CryptoJS.algo.EvpKDF.create();
	         *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8 });
	         *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8, iterations: 1000 });
	         */
	        init: function (cfg) {
	            this.cfg = this.cfg.extend(cfg);
	        },

	        /**
	         * Derives a key from a password.
	         *
	         * @param {WordArray|string} password The password.
	         * @param {WordArray|string} salt A salt.
	         *
	         * @return {WordArray} The derived key.
	         *
	         * @example
	         *
	         *     var key = kdf.compute(password, salt);
	         */
	        compute: function (password, salt) {
	            // Shortcut
	            var cfg = this.cfg;

	            // Init hasher
	            var hasher = cfg.hasher.create();

	            // Initial values
	            var derivedKey = WordArray.create();

	            // Shortcuts
	            var derivedKeyWords = derivedKey.words;
	            var keySize = cfg.keySize;
	            var iterations = cfg.iterations;

	            // Generate key
	            while (derivedKeyWords.length < keySize) {
	                if (block) {
	                    hasher.update(block);
	                }
	                var block = hasher.update(password).finalize(salt);
	                hasher.reset();

	                // Iterations
	                for (var i = 1; i < iterations; i++) {
	                    block = hasher.finalize(block);
	                    hasher.reset();
	                }

	                derivedKey.concat(block);
	            }
	            derivedKey.sigBytes = keySize * 4;

	            return derivedKey;
	        }
	    });

	    /**
	     * Derives a key from a password.
	     *
	     * @param {WordArray|string} password The password.
	     * @param {WordArray|string} salt A salt.
	     * @param {Object} cfg (Optional) The configuration options to use for this computation.
	     *
	     * @return {WordArray} The derived key.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var key = CryptoJS.EvpKDF(password, salt);
	     *     var key = CryptoJS.EvpKDF(password, salt, { keySize: 8 });
	     *     var key = CryptoJS.EvpKDF(password, salt, { keySize: 8, iterations: 1000 });
	     */
	    C.EvpKDF = function (password, salt, cfg) {
	        return EvpKDF.create(cfg).compute(password, salt);
	    };
	}());


	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var C_algo = C.algo;
	    var SHA256 = C_algo.SHA256;

	    /**
	     * SHA-224 hash algorithm.
	     */
	    var SHA224 = C_algo.SHA224 = SHA256.extend({
	        _doReset: function () {
	            this._hash = new WordArray.init([
	                0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939,
	                0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4
	            ]);
	        },

	        _doFinalize: function () {
	            var hash = SHA256._doFinalize.call(this);

	            hash.sigBytes -= 4;

	            return hash;
	        }
	    });

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA224('message');
	     *     var hash = CryptoJS.SHA224(wordArray);
	     */
	    C.SHA224 = SHA256._createHelper(SHA224);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA224(message, key);
	     */
	    C.HmacSHA224 = SHA256._createHmacHelper(SHA224);
	}());


	(function (undefined) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Base = C_lib.Base;
	    var X32WordArray = C_lib.WordArray;

	    /**
	     * x64 namespace.
	     */
	    var C_x64 = C.x64 = {};

	    /**
	     * A 64-bit word.
	     */
	    var X64Word = C_x64.Word = Base.extend({
	        /**
	         * Initializes a newly created 64-bit word.
	         *
	         * @param {number} high The high 32 bits.
	         * @param {number} low The low 32 bits.
	         *
	         * @example
	         *
	         *     var x64Word = CryptoJS.x64.Word.create(0x00010203, 0x04050607);
	         */
	        init: function (high, low) {
	            this.high = high;
	            this.low = low;
	        }

	        /**
	         * Bitwise NOTs this word.
	         *
	         * @return {X64Word} A new x64-Word object after negating.
	         *
	         * @example
	         *
	         *     var negated = x64Word.not();
	         */
	        // not: function () {
	            // var high = ~this.high;
	            // var low = ~this.low;

	            // return X64Word.create(high, low);
	        // },

	        /**
	         * Bitwise ANDs this word with the passed word.
	         *
	         * @param {X64Word} word The x64-Word to AND with this word.
	         *
	         * @return {X64Word} A new x64-Word object after ANDing.
	         *
	         * @example
	         *
	         *     var anded = x64Word.and(anotherX64Word);
	         */
	        // and: function (word) {
	            // var high = this.high & word.high;
	            // var low = this.low & word.low;

	            // return X64Word.create(high, low);
	        // },

	        /**
	         * Bitwise ORs this word with the passed word.
	         *
	         * @param {X64Word} word The x64-Word to OR with this word.
	         *
	         * @return {X64Word} A new x64-Word object after ORing.
	         *
	         * @example
	         *
	         *     var ored = x64Word.or(anotherX64Word);
	         */
	        // or: function (word) {
	            // var high = this.high | word.high;
	            // var low = this.low | word.low;

	            // return X64Word.create(high, low);
	        // },

	        /**
	         * Bitwise XORs this word with the passed word.
	         *
	         * @param {X64Word} word The x64-Word to XOR with this word.
	         *
	         * @return {X64Word} A new x64-Word object after XORing.
	         *
	         * @example
	         *
	         *     var xored = x64Word.xor(anotherX64Word);
	         */
	        // xor: function (word) {
	            // var high = this.high ^ word.high;
	            // var low = this.low ^ word.low;

	            // return X64Word.create(high, low);
	        // },

	        /**
	         * Shifts this word n bits to the left.
	         *
	         * @param {number} n The number of bits to shift.
	         *
	         * @return {X64Word} A new x64-Word object after shifting.
	         *
	         * @example
	         *
	         *     var shifted = x64Word.shiftL(25);
	         */
	        // shiftL: function (n) {
	            // if (n < 32) {
	                // var high = (this.high << n) | (this.low >>> (32 - n));
	                // var low = this.low << n;
	            // } else {
	                // var high = this.low << (n - 32);
	                // var low = 0;
	            // }

	            // return X64Word.create(high, low);
	        // },

	        /**
	         * Shifts this word n bits to the right.
	         *
	         * @param {number} n The number of bits to shift.
	         *
	         * @return {X64Word} A new x64-Word object after shifting.
	         *
	         * @example
	         *
	         *     var shifted = x64Word.shiftR(7);
	         */
	        // shiftR: function (n) {
	            // if (n < 32) {
	                // var low = (this.low >>> n) | (this.high << (32 - n));
	                // var high = this.high >>> n;
	            // } else {
	                // var low = this.high >>> (n - 32);
	                // var high = 0;
	            // }

	            // return X64Word.create(high, low);
	        // },

	        /**
	         * Rotates this word n bits to the left.
	         *
	         * @param {number} n The number of bits to rotate.
	         *
	         * @return {X64Word} A new x64-Word object after rotating.
	         *
	         * @example
	         *
	         *     var rotated = x64Word.rotL(25);
	         */
	        // rotL: function (n) {
	            // return this.shiftL(n).or(this.shiftR(64 - n));
	        // },

	        /**
	         * Rotates this word n bits to the right.
	         *
	         * @param {number} n The number of bits to rotate.
	         *
	         * @return {X64Word} A new x64-Word object after rotating.
	         *
	         * @example
	         *
	         *     var rotated = x64Word.rotR(7);
	         */
	        // rotR: function (n) {
	            // return this.shiftR(n).or(this.shiftL(64 - n));
	        // },

	        /**
	         * Adds this word with the passed word.
	         *
	         * @param {X64Word} word The x64-Word to add with this word.
	         *
	         * @return {X64Word} A new x64-Word object after adding.
	         *
	         * @example
	         *
	         *     var added = x64Word.add(anotherX64Word);
	         */
	        // add: function (word) {
	            // var low = (this.low + word.low) | 0;
	            // var carry = (low >>> 0) < (this.low >>> 0) ? 1 : 0;
	            // var high = (this.high + word.high + carry) | 0;

	            // return X64Word.create(high, low);
	        // }
	    });

	    /**
	     * An array of 64-bit words.
	     *
	     * @property {Array} words The array of CryptoJS.x64.Word objects.
	     * @property {number} sigBytes The number of significant bytes in this word array.
	     */
	    var X64WordArray = C_x64.WordArray = Base.extend({
	        /**
	         * Initializes a newly created word array.
	         *
	         * @param {Array} words (Optional) An array of CryptoJS.x64.Word objects.
	         * @param {number} sigBytes (Optional) The number of significant bytes in the words.
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.x64.WordArray.create();
	         *
	         *     var wordArray = CryptoJS.x64.WordArray.create([
	         *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),
	         *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)
	         *     ]);
	         *
	         *     var wordArray = CryptoJS.x64.WordArray.create([
	         *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),
	         *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)
	         *     ], 10);
	         */
	        init: function (words, sigBytes) {
	            words = this.words = words || [];

	            if (sigBytes != undefined) {
	                this.sigBytes = sigBytes;
	            } else {
	                this.sigBytes = words.length * 8;
	            }
	        },

	        /**
	         * Converts this 64-bit word array to a 32-bit word array.
	         *
	         * @return {CryptoJS.lib.WordArray} This word array's data as a 32-bit word array.
	         *
	         * @example
	         *
	         *     var x32WordArray = x64WordArray.toX32();
	         */
	        toX32: function () {
	            // Shortcuts
	            var x64Words = this.words;
	            var x64WordsLength = x64Words.length;

	            // Convert
	            var x32Words = [];
	            for (var i = 0; i < x64WordsLength; i++) {
	                var x64Word = x64Words[i];
	                x32Words.push(x64Word.high);
	                x32Words.push(x64Word.low);
	            }

	            return X32WordArray.create(x32Words, this.sigBytes);
	        },

	        /**
	         * Creates a copy of this word array.
	         *
	         * @return {X64WordArray} The clone.
	         *
	         * @example
	         *
	         *     var clone = x64WordArray.clone();
	         */
	        clone: function () {
	            var clone = Base.clone.call(this);

	            // Clone "words" array
	            var words = clone.words = this.words.slice(0);

	            // Clone each X64Word object
	            var wordsLength = words.length;
	            for (var i = 0; i < wordsLength; i++) {
	                words[i] = words[i].clone();
	            }

	            return clone;
	        }
	    });
	}());


	(function (Math) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_x64 = C.x64;
	    var X64Word = C_x64.Word;
	    var C_algo = C.algo;

	    // Constants tables
	    var RHO_OFFSETS = [];
	    var PI_INDEXES  = [];
	    var ROUND_CONSTANTS = [];

	    // Compute Constants
	    (function () {
	        // Compute rho offset constants
	        var x = 1, y = 0;
	        for (var t = 0; t < 24; t++) {
	            RHO_OFFSETS[x + 5 * y] = ((t + 1) * (t + 2) / 2) % 64;

	            var newX = y % 5;
	            var newY = (2 * x + 3 * y) % 5;
	            x = newX;
	            y = newY;
	        }

	        // Compute pi index constants
	        for (var x = 0; x < 5; x++) {
	            for (var y = 0; y < 5; y++) {
	                PI_INDEXES[x + 5 * y] = y + ((2 * x + 3 * y) % 5) * 5;
	            }
	        }

	        // Compute round constants
	        var LFSR = 0x01;
	        for (var i = 0; i < 24; i++) {
	            var roundConstantMsw = 0;
	            var roundConstantLsw = 0;

	            for (var j = 0; j < 7; j++) {
	                if (LFSR & 0x01) {
	                    var bitPosition = (1 << j) - 1;
	                    if (bitPosition < 32) {
	                        roundConstantLsw ^= 1 << bitPosition;
	                    } else /* if (bitPosition >= 32) */ {
	                        roundConstantMsw ^= 1 << (bitPosition - 32);
	                    }
	                }

	                // Compute next LFSR
	                if (LFSR & 0x80) {
	                    // Primitive polynomial over GF(2): x^8 + x^6 + x^5 + x^4 + 1
	                    LFSR = (LFSR << 1) ^ 0x71;
	                } else {
	                    LFSR <<= 1;
	                }
	            }

	            ROUND_CONSTANTS[i] = X64Word.create(roundConstantMsw, roundConstantLsw);
	        }
	    }());

	    // Reusable objects for temporary values
	    var T = [];
	    (function () {
	        for (var i = 0; i < 25; i++) {
	            T[i] = X64Word.create();
	        }
	    }());

	    /**
	     * SHA-3 hash algorithm.
	     */
	    var SHA3 = C_algo.SHA3 = Hasher.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {number} outputLength
	         *   The desired number of bits in the output hash.
	         *   Only values permitted are: 224, 256, 384, 512.
	         *   Default: 512
	         */
	        cfg: Hasher.cfg.extend({
	            outputLength: 512
	        }),

	        _doReset: function () {
	            var state = this._state = []
	            for (var i = 0; i < 25; i++) {
	                state[i] = new X64Word.init();
	            }

	            this.blockSize = (1600 - 2 * this.cfg.outputLength) / 32;
	        },

	        _doProcessBlock: function (M, offset) {
	            // Shortcuts
	            var state = this._state;
	            var nBlockSizeLanes = this.blockSize / 2;

	            // Absorb
	            for (var i = 0; i < nBlockSizeLanes; i++) {
	                // Shortcuts
	                var M2i  = M[offset + 2 * i];
	                var M2i1 = M[offset + 2 * i + 1];

	                // Swap endian
	                M2i = (
	                    (((M2i << 8)  | (M2i >>> 24)) & 0x00ff00ff) |
	                    (((M2i << 24) | (M2i >>> 8))  & 0xff00ff00)
	                );
	                M2i1 = (
	                    (((M2i1 << 8)  | (M2i1 >>> 24)) & 0x00ff00ff) |
	                    (((M2i1 << 24) | (M2i1 >>> 8))  & 0xff00ff00)
	                );

	                // Absorb message into state
	                var lane = state[i];
	                lane.high ^= M2i1;
	                lane.low  ^= M2i;
	            }

	            // Rounds
	            for (var round = 0; round < 24; round++) {
	                // Theta
	                for (var x = 0; x < 5; x++) {
	                    // Mix column lanes
	                    var tMsw = 0, tLsw = 0;
	                    for (var y = 0; y < 5; y++) {
	                        var lane = state[x + 5 * y];
	                        tMsw ^= lane.high;
	                        tLsw ^= lane.low;
	                    }

	                    // Temporary values
	                    var Tx = T[x];
	                    Tx.high = tMsw;
	                    Tx.low  = tLsw;
	                }
	                for (var x = 0; x < 5; x++) {
	                    // Shortcuts
	                    var Tx4 = T[(x + 4) % 5];
	                    var Tx1 = T[(x + 1) % 5];
	                    var Tx1Msw = Tx1.high;
	                    var Tx1Lsw = Tx1.low;

	                    // Mix surrounding columns
	                    var tMsw = Tx4.high ^ ((Tx1Msw << 1) | (Tx1Lsw >>> 31));
	                    var tLsw = Tx4.low  ^ ((Tx1Lsw << 1) | (Tx1Msw >>> 31));
	                    for (var y = 0; y < 5; y++) {
	                        var lane = state[x + 5 * y];
	                        lane.high ^= tMsw;
	                        lane.low  ^= tLsw;
	                    }
	                }

	                // Rho Pi
	                for (var laneIndex = 1; laneIndex < 25; laneIndex++) {
	                    // Shortcuts
	                    var lane = state[laneIndex];
	                    var laneMsw = lane.high;
	                    var laneLsw = lane.low;
	                    var rhoOffset = RHO_OFFSETS[laneIndex];

	                    // Rotate lanes
	                    if (rhoOffset < 32) {
	                        var tMsw = (laneMsw << rhoOffset) | (laneLsw >>> (32 - rhoOffset));
	                        var tLsw = (laneLsw << rhoOffset) | (laneMsw >>> (32 - rhoOffset));
	                    } else /* if (rhoOffset >= 32) */ {
	                        var tMsw = (laneLsw << (rhoOffset - 32)) | (laneMsw >>> (64 - rhoOffset));
	                        var tLsw = (laneMsw << (rhoOffset - 32)) | (laneLsw >>> (64 - rhoOffset));
	                    }

	                    // Transpose lanes
	                    var TPiLane = T[PI_INDEXES[laneIndex]];
	                    TPiLane.high = tMsw;
	                    TPiLane.low  = tLsw;
	                }

	                // Rho pi at x = y = 0
	                var T0 = T[0];
	                var state0 = state[0];
	                T0.high = state0.high;
	                T0.low  = state0.low;

	                // Chi
	                for (var x = 0; x < 5; x++) {
	                    for (var y = 0; y < 5; y++) {
	                        // Shortcuts
	                        var laneIndex = x + 5 * y;
	                        var lane = state[laneIndex];
	                        var TLane = T[laneIndex];
	                        var Tx1Lane = T[((x + 1) % 5) + 5 * y];
	                        var Tx2Lane = T[((x + 2) % 5) + 5 * y];

	                        // Mix rows
	                        lane.high = TLane.high ^ (~Tx1Lane.high & Tx2Lane.high);
	                        lane.low  = TLane.low  ^ (~Tx1Lane.low  & Tx2Lane.low);
	                    }
	                }

	                // Iota
	                var lane = state[0];
	                var roundConstant = ROUND_CONSTANTS[round];
	                lane.high ^= roundConstant.high;
	                lane.low  ^= roundConstant.low;;
	            }
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;
	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;
	            var blockSizeBits = this.blockSize * 32;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x1 << (24 - nBitsLeft % 32);
	            dataWords[((Math.ceil((nBitsLeft + 1) / blockSizeBits) * blockSizeBits) >>> 5) - 1] |= 0x80;
	            data.sigBytes = dataWords.length * 4;

	            // Hash final blocks
	            this._process();

	            // Shortcuts
	            var state = this._state;
	            var outputLengthBytes = this.cfg.outputLength / 8;
	            var outputLengthLanes = outputLengthBytes / 8;

	            // Squeeze
	            var hashWords = [];
	            for (var i = 0; i < outputLengthLanes; i++) {
	                // Shortcuts
	                var lane = state[i];
	                var laneMsw = lane.high;
	                var laneLsw = lane.low;

	                // Swap endian
	                laneMsw = (
	                    (((laneMsw << 8)  | (laneMsw >>> 24)) & 0x00ff00ff) |
	                    (((laneMsw << 24) | (laneMsw >>> 8))  & 0xff00ff00)
	                );
	                laneLsw = (
	                    (((laneLsw << 8)  | (laneLsw >>> 24)) & 0x00ff00ff) |
	                    (((laneLsw << 24) | (laneLsw >>> 8))  & 0xff00ff00)
	                );

	                // Squeeze state to retrieve hash
	                hashWords.push(laneLsw);
	                hashWords.push(laneMsw);
	            }

	            // Return final computed hash
	            return new WordArray.init(hashWords, outputLengthBytes);
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);

	            var state = clone._state = this._state.slice(0);
	            for (var i = 0; i < 25; i++) {
	                state[i] = state[i].clone();
	            }

	            return clone;
	        }
	    });

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA3('message');
	     *     var hash = CryptoJS.SHA3(wordArray);
	     */
	    C.SHA3 = Hasher._createHelper(SHA3);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA3(message, key);
	     */
	    C.HmacSHA3 = Hasher._createHmacHelper(SHA3);
	}(Math));


	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Hasher = C_lib.Hasher;
	    var C_x64 = C.x64;
	    var X64Word = C_x64.Word;
	    var X64WordArray = C_x64.WordArray;
	    var C_algo = C.algo;

	    function X64Word_create() {
	        return X64Word.create.apply(X64Word, arguments);
	    }

	    // Constants
	    var K = [
	        X64Word_create(0x428a2f98, 0xd728ae22), X64Word_create(0x71374491, 0x23ef65cd),
	        X64Word_create(0xb5c0fbcf, 0xec4d3b2f), X64Word_create(0xe9b5dba5, 0x8189dbbc),
	        X64Word_create(0x3956c25b, 0xf348b538), X64Word_create(0x59f111f1, 0xb605d019),
	        X64Word_create(0x923f82a4, 0xaf194f9b), X64Word_create(0xab1c5ed5, 0xda6d8118),
	        X64Word_create(0xd807aa98, 0xa3030242), X64Word_create(0x12835b01, 0x45706fbe),
	        X64Word_create(0x243185be, 0x4ee4b28c), X64Word_create(0x550c7dc3, 0xd5ffb4e2),
	        X64Word_create(0x72be5d74, 0xf27b896f), X64Word_create(0x80deb1fe, 0x3b1696b1),
	        X64Word_create(0x9bdc06a7, 0x25c71235), X64Word_create(0xc19bf174, 0xcf692694),
	        X64Word_create(0xe49b69c1, 0x9ef14ad2), X64Word_create(0xefbe4786, 0x384f25e3),
	        X64Word_create(0x0fc19dc6, 0x8b8cd5b5), X64Word_create(0x240ca1cc, 0x77ac9c65),
	        X64Word_create(0x2de92c6f, 0x592b0275), X64Word_create(0x4a7484aa, 0x6ea6e483),
	        X64Word_create(0x5cb0a9dc, 0xbd41fbd4), X64Word_create(0x76f988da, 0x831153b5),
	        X64Word_create(0x983e5152, 0xee66dfab), X64Word_create(0xa831c66d, 0x2db43210),
	        X64Word_create(0xb00327c8, 0x98fb213f), X64Word_create(0xbf597fc7, 0xbeef0ee4),
	        X64Word_create(0xc6e00bf3, 0x3da88fc2), X64Word_create(0xd5a79147, 0x930aa725),
	        X64Word_create(0x06ca6351, 0xe003826f), X64Word_create(0x14292967, 0x0a0e6e70),
	        X64Word_create(0x27b70a85, 0x46d22ffc), X64Word_create(0x2e1b2138, 0x5c26c926),
	        X64Word_create(0x4d2c6dfc, 0x5ac42aed), X64Word_create(0x53380d13, 0x9d95b3df),
	        X64Word_create(0x650a7354, 0x8baf63de), X64Word_create(0x766a0abb, 0x3c77b2a8),
	        X64Word_create(0x81c2c92e, 0x47edaee6), X64Word_create(0x92722c85, 0x1482353b),
	        X64Word_create(0xa2bfe8a1, 0x4cf10364), X64Word_create(0xa81a664b, 0xbc423001),
	        X64Word_create(0xc24b8b70, 0xd0f89791), X64Word_create(0xc76c51a3, 0x0654be30),
	        X64Word_create(0xd192e819, 0xd6ef5218), X64Word_create(0xd6990624, 0x5565a910),
	        X64Word_create(0xf40e3585, 0x5771202a), X64Word_create(0x106aa070, 0x32bbd1b8),
	        X64Word_create(0x19a4c116, 0xb8d2d0c8), X64Word_create(0x1e376c08, 0x5141ab53),
	        X64Word_create(0x2748774c, 0xdf8eeb99), X64Word_create(0x34b0bcb5, 0xe19b48a8),
	        X64Word_create(0x391c0cb3, 0xc5c95a63), X64Word_create(0x4ed8aa4a, 0xe3418acb),
	        X64Word_create(0x5b9cca4f, 0x7763e373), X64Word_create(0x682e6ff3, 0xd6b2b8a3),
	        X64Word_create(0x748f82ee, 0x5defb2fc), X64Word_create(0x78a5636f, 0x43172f60),
	        X64Word_create(0x84c87814, 0xa1f0ab72), X64Word_create(0x8cc70208, 0x1a6439ec),
	        X64Word_create(0x90befffa, 0x23631e28), X64Word_create(0xa4506ceb, 0xde82bde9),
	        X64Word_create(0xbef9a3f7, 0xb2c67915), X64Word_create(0xc67178f2, 0xe372532b),
	        X64Word_create(0xca273ece, 0xea26619c), X64Word_create(0xd186b8c7, 0x21c0c207),
	        X64Word_create(0xeada7dd6, 0xcde0eb1e), X64Word_create(0xf57d4f7f, 0xee6ed178),
	        X64Word_create(0x06f067aa, 0x72176fba), X64Word_create(0x0a637dc5, 0xa2c898a6),
	        X64Word_create(0x113f9804, 0xbef90dae), X64Word_create(0x1b710b35, 0x131c471b),
	        X64Word_create(0x28db77f5, 0x23047d84), X64Word_create(0x32caab7b, 0x40c72493),
	        X64Word_create(0x3c9ebe0a, 0x15c9bebc), X64Word_create(0x431d67c4, 0x9c100d4c),
	        X64Word_create(0x4cc5d4be, 0xcb3e42b6), X64Word_create(0x597f299c, 0xfc657e2a),
	        X64Word_create(0x5fcb6fab, 0x3ad6faec), X64Word_create(0x6c44198c, 0x4a475817)
	    ];

	    // Reusable objects
	    var W = [];
	    (function () {
	        for (var i = 0; i < 80; i++) {
	            W[i] = X64Word_create();
	        }
	    }());

	    /**
	     * SHA-512 hash algorithm.
	     */
	    var SHA512 = C_algo.SHA512 = Hasher.extend({
	        _doReset: function () {
	            this._hash = new X64WordArray.init([
	                new X64Word.init(0x6a09e667, 0xf3bcc908), new X64Word.init(0xbb67ae85, 0x84caa73b),
	                new X64Word.init(0x3c6ef372, 0xfe94f82b), new X64Word.init(0xa54ff53a, 0x5f1d36f1),
	                new X64Word.init(0x510e527f, 0xade682d1), new X64Word.init(0x9b05688c, 0x2b3e6c1f),
	                new X64Word.init(0x1f83d9ab, 0xfb41bd6b), new X64Word.init(0x5be0cd19, 0x137e2179)
	            ]);
	        },

	        _doProcessBlock: function (M, offset) {
	            // Shortcuts
	            var H = this._hash.words;

	            var H0 = H[0];
	            var H1 = H[1];
	            var H2 = H[2];
	            var H3 = H[3];
	            var H4 = H[4];
	            var H5 = H[5];
	            var H6 = H[6];
	            var H7 = H[7];

	            var H0h = H0.high;
	            var H0l = H0.low;
	            var H1h = H1.high;
	            var H1l = H1.low;
	            var H2h = H2.high;
	            var H2l = H2.low;
	            var H3h = H3.high;
	            var H3l = H3.low;
	            var H4h = H4.high;
	            var H4l = H4.low;
	            var H5h = H5.high;
	            var H5l = H5.low;
	            var H6h = H6.high;
	            var H6l = H6.low;
	            var H7h = H7.high;
	            var H7l = H7.low;

	            // Working variables
	            var ah = H0h;
	            var al = H0l;
	            var bh = H1h;
	            var bl = H1l;
	            var ch = H2h;
	            var cl = H2l;
	            var dh = H3h;
	            var dl = H3l;
	            var eh = H4h;
	            var el = H4l;
	            var fh = H5h;
	            var fl = H5l;
	            var gh = H6h;
	            var gl = H6l;
	            var hh = H7h;
	            var hl = H7l;

	            // Rounds
	            for (var i = 0; i < 80; i++) {
	                // Shortcut
	                var Wi = W[i];

	                // Extend message
	                if (i < 16) {
	                    var Wih = Wi.high = M[offset + i * 2]     | 0;
	                    var Wil = Wi.low  = M[offset + i * 2 + 1] | 0;
	                } else {
	                    // Gamma0
	                    var gamma0x  = W[i - 15];
	                    var gamma0xh = gamma0x.high;
	                    var gamma0xl = gamma0x.low;
	                    var gamma0h  = ((gamma0xh >>> 1) | (gamma0xl << 31)) ^ ((gamma0xh >>> 8) | (gamma0xl << 24)) ^ (gamma0xh >>> 7);
	                    var gamma0l  = ((gamma0xl >>> 1) | (gamma0xh << 31)) ^ ((gamma0xl >>> 8) | (gamma0xh << 24)) ^ ((gamma0xl >>> 7) | (gamma0xh << 25));

	                    // Gamma1
	                    var gamma1x  = W[i - 2];
	                    var gamma1xh = gamma1x.high;
	                    var gamma1xl = gamma1x.low;
	                    var gamma1h  = ((gamma1xh >>> 19) | (gamma1xl << 13)) ^ ((gamma1xh << 3) | (gamma1xl >>> 29)) ^ (gamma1xh >>> 6);
	                    var gamma1l  = ((gamma1xl >>> 19) | (gamma1xh << 13)) ^ ((gamma1xl << 3) | (gamma1xh >>> 29)) ^ ((gamma1xl >>> 6) | (gamma1xh << 26));

	                    // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]
	                    var Wi7  = W[i - 7];
	                    var Wi7h = Wi7.high;
	                    var Wi7l = Wi7.low;

	                    var Wi16  = W[i - 16];
	                    var Wi16h = Wi16.high;
	                    var Wi16l = Wi16.low;

	                    var Wil = gamma0l + Wi7l;
	                    var Wih = gamma0h + Wi7h + ((Wil >>> 0) < (gamma0l >>> 0) ? 1 : 0);
	                    var Wil = Wil + gamma1l;
	                    var Wih = Wih + gamma1h + ((Wil >>> 0) < (gamma1l >>> 0) ? 1 : 0);
	                    var Wil = Wil + Wi16l;
	                    var Wih = Wih + Wi16h + ((Wil >>> 0) < (Wi16l >>> 0) ? 1 : 0);

	                    Wi.high = Wih;
	                    Wi.low  = Wil;
	                }

	                var chh  = (eh & fh) ^ (~eh & gh);
	                var chl  = (el & fl) ^ (~el & gl);
	                var majh = (ah & bh) ^ (ah & ch) ^ (bh & ch);
	                var majl = (al & bl) ^ (al & cl) ^ (bl & cl);

	                var sigma0h = ((ah >>> 28) | (al << 4))  ^ ((ah << 30)  | (al >>> 2)) ^ ((ah << 25) | (al >>> 7));
	                var sigma0l = ((al >>> 28) | (ah << 4))  ^ ((al << 30)  | (ah >>> 2)) ^ ((al << 25) | (ah >>> 7));
	                var sigma1h = ((eh >>> 14) | (el << 18)) ^ ((eh >>> 18) | (el << 14)) ^ ((eh << 23) | (el >>> 9));
	                var sigma1l = ((el >>> 14) | (eh << 18)) ^ ((el >>> 18) | (eh << 14)) ^ ((el << 23) | (eh >>> 9));

	                // t1 = h + sigma1 + ch + K[i] + W[i]
	                var Ki  = K[i];
	                var Kih = Ki.high;
	                var Kil = Ki.low;

	                var t1l = hl + sigma1l;
	                var t1h = hh + sigma1h + ((t1l >>> 0) < (hl >>> 0) ? 1 : 0);
	                var t1l = t1l + chl;
	                var t1h = t1h + chh + ((t1l >>> 0) < (chl >>> 0) ? 1 : 0);
	                var t1l = t1l + Kil;
	                var t1h = t1h + Kih + ((t1l >>> 0) < (Kil >>> 0) ? 1 : 0);
	                var t1l = t1l + Wil;
	                var t1h = t1h + Wih + ((t1l >>> 0) < (Wil >>> 0) ? 1 : 0);

	                // t2 = sigma0 + maj
	                var t2l = sigma0l + majl;
	                var t2h = sigma0h + majh + ((t2l >>> 0) < (sigma0l >>> 0) ? 1 : 0);

	                // Update working variables
	                hh = gh;
	                hl = gl;
	                gh = fh;
	                gl = fl;
	                fh = eh;
	                fl = el;
	                el = (dl + t1l) | 0;
	                eh = (dh + t1h + ((el >>> 0) < (dl >>> 0) ? 1 : 0)) | 0;
	                dh = ch;
	                dl = cl;
	                ch = bh;
	                cl = bl;
	                bh = ah;
	                bl = al;
	                al = (t1l + t2l) | 0;
	                ah = (t1h + t2h + ((al >>> 0) < (t1l >>> 0) ? 1 : 0)) | 0;
	            }

	            // Intermediate hash value
	            H0l = H0.low  = (H0l + al);
	            H0.high = (H0h + ah + ((H0l >>> 0) < (al >>> 0) ? 1 : 0));
	            H1l = H1.low  = (H1l + bl);
	            H1.high = (H1h + bh + ((H1l >>> 0) < (bl >>> 0) ? 1 : 0));
	            H2l = H2.low  = (H2l + cl);
	            H2.high = (H2h + ch + ((H2l >>> 0) < (cl >>> 0) ? 1 : 0));
	            H3l = H3.low  = (H3l + dl);
	            H3.high = (H3h + dh + ((H3l >>> 0) < (dl >>> 0) ? 1 : 0));
	            H4l = H4.low  = (H4l + el);
	            H4.high = (H4h + eh + ((H4l >>> 0) < (el >>> 0) ? 1 : 0));
	            H5l = H5.low  = (H5l + fl);
	            H5.high = (H5h + fh + ((H5l >>> 0) < (fl >>> 0) ? 1 : 0));
	            H6l = H6.low  = (H6l + gl);
	            H6.high = (H6h + gh + ((H6l >>> 0) < (gl >>> 0) ? 1 : 0));
	            H7l = H7.low  = (H7l + hl);
	            H7.high = (H7h + hh + ((H7l >>> 0) < (hl >>> 0) ? 1 : 0));
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;

	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
	            dataWords[(((nBitsLeft + 128) >>> 10) << 5) + 30] = Math.floor(nBitsTotal / 0x100000000);
	            dataWords[(((nBitsLeft + 128) >>> 10) << 5) + 31] = nBitsTotal;
	            data.sigBytes = dataWords.length * 4;

	            // Hash final blocks
	            this._process();

	            // Convert hash to 32-bit word array before returning
	            var hash = this._hash.toX32();

	            // Return final computed hash
	            return hash;
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);
	            clone._hash = this._hash.clone();

	            return clone;
	        },

	        blockSize: 1024/32
	    });

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA512('message');
	     *     var hash = CryptoJS.SHA512(wordArray);
	     */
	    C.SHA512 = Hasher._createHelper(SHA512);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA512(message, key);
	     */
	    C.HmacSHA512 = Hasher._createHmacHelper(SHA512);
	}());


	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_x64 = C.x64;
	    var X64Word = C_x64.Word;
	    var X64WordArray = C_x64.WordArray;
	    var C_algo = C.algo;
	    var SHA512 = C_algo.SHA512;

	    /**
	     * SHA-384 hash algorithm.
	     */
	    var SHA384 = C_algo.SHA384 = SHA512.extend({
	        _doReset: function () {
	            this._hash = new X64WordArray.init([
	                new X64Word.init(0xcbbb9d5d, 0xc1059ed8), new X64Word.init(0x629a292a, 0x367cd507),
	                new X64Word.init(0x9159015a, 0x3070dd17), new X64Word.init(0x152fecd8, 0xf70e5939),
	                new X64Word.init(0x67332667, 0xffc00b31), new X64Word.init(0x8eb44a87, 0x68581511),
	                new X64Word.init(0xdb0c2e0d, 0x64f98fa7), new X64Word.init(0x47b5481d, 0xbefa4fa4)
	            ]);
	        },

	        _doFinalize: function () {
	            var hash = SHA512._doFinalize.call(this);

	            hash.sigBytes -= 16;

	            return hash;
	        }
	    });

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA384('message');
	     *     var hash = CryptoJS.SHA384(wordArray);
	     */
	    C.SHA384 = SHA512._createHelper(SHA384);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA384(message, key);
	     */
	    C.HmacSHA384 = SHA512._createHmacHelper(SHA384);
	}());


	/**
	 * Cipher core components.
	 */
	CryptoJS.lib.Cipher || (function (undefined) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Base = C_lib.Base;
	    var WordArray = C_lib.WordArray;
	    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm;
	    var C_enc = C.enc;
	    var Utf8 = C_enc.Utf8;
	    var Base64 = C_enc.Base64;
	    var C_algo = C.algo;
	    var EvpKDF = C_algo.EvpKDF;

	    /**
	     * Abstract base cipher template.
	     *
	     * @property {number} keySize This cipher's key size. Default: 4 (128 bits)
	     * @property {number} ivSize This cipher's IV size. Default: 4 (128 bits)
	     * @property {number} _ENC_XFORM_MODE A constant representing encryption mode.
	     * @property {number} _DEC_XFORM_MODE A constant representing decryption mode.
	     */
	    var Cipher = C_lib.Cipher = BufferedBlockAlgorithm.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {WordArray} iv The IV to use for this operation.
	         */
	        cfg: Base.extend(),

	        /**
	         * Creates this cipher in encryption mode.
	         *
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {Cipher} A cipher instance.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var cipher = CryptoJS.algo.AES.createEncryptor(keyWordArray, { iv: ivWordArray });
	         */
	        createEncryptor: function (key, cfg) {
	            return this.create(this._ENC_XFORM_MODE, key, cfg);
	        },

	        /**
	         * Creates this cipher in decryption mode.
	         *
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {Cipher} A cipher instance.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var cipher = CryptoJS.algo.AES.createDecryptor(keyWordArray, { iv: ivWordArray });
	         */
	        createDecryptor: function (key, cfg) {
	            return this.create(this._DEC_XFORM_MODE, key, cfg);
	        },

	        /**
	         * Initializes a newly created cipher.
	         *
	         * @param {number} xformMode Either the encryption or decryption transormation mode constant.
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @example
	         *
	         *     var cipher = CryptoJS.algo.AES.create(CryptoJS.algo.AES._ENC_XFORM_MODE, keyWordArray, { iv: ivWordArray });
	         */
	        init: function (xformMode, key, cfg) {
	            // Apply config defaults
	            this.cfg = this.cfg.extend(cfg);

	            // Store transform mode and key
	            this._xformMode = xformMode;
	            this._key = key;

	            // Set initial values
	            this.reset();
	        },

	        /**
	         * Resets this cipher to its initial state.
	         *
	         * @example
	         *
	         *     cipher.reset();
	         */
	        reset: function () {
	            // Reset data buffer
	            BufferedBlockAlgorithm.reset.call(this);

	            // Perform concrete-cipher logic
	            this._doReset();
	        },

	        /**
	         * Adds data to be encrypted or decrypted.
	         *
	         * @param {WordArray|string} dataUpdate The data to encrypt or decrypt.
	         *
	         * @return {WordArray} The data after processing.
	         *
	         * @example
	         *
	         *     var encrypted = cipher.process('data');
	         *     var encrypted = cipher.process(wordArray);
	         */
	        process: function (dataUpdate) {
	            // Append
	            this._append(dataUpdate);

	            // Process available blocks
	            return this._process();
	        },

	        /**
	         * Finalizes the encryption or decryption process.
	         * Note that the finalize operation is effectively a destructive, read-once operation.
	         *
	         * @param {WordArray|string} dataUpdate The final data to encrypt or decrypt.
	         *
	         * @return {WordArray} The data after final processing.
	         *
	         * @example
	         *
	         *     var encrypted = cipher.finalize();
	         *     var encrypted = cipher.finalize('data');
	         *     var encrypted = cipher.finalize(wordArray);
	         */
	        finalize: function (dataUpdate) {
	            // Final data update
	            if (dataUpdate) {
	                this._append(dataUpdate);
	            }

	            // Perform concrete-cipher logic
	            var finalProcessedData = this._doFinalize();

	            return finalProcessedData;
	        },

	        keySize: 128/32,

	        ivSize: 128/32,

	        _ENC_XFORM_MODE: 1,

	        _DEC_XFORM_MODE: 2,

	        /**
	         * Creates shortcut functions to a cipher's object interface.
	         *
	         * @param {Cipher} cipher The cipher to create a helper for.
	         *
	         * @return {Object} An object with encrypt and decrypt shortcut functions.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var AES = CryptoJS.lib.Cipher._createHelper(CryptoJS.algo.AES);
	         */
	        _createHelper: (function () {
	            function selectCipherStrategy(key) {
	                if (typeof key == 'string') {
	                    return PasswordBasedCipher;
	                } else {
	                    return SerializableCipher;
	                }
	            }

	            return function (cipher) {
	                return {
	                    encrypt: function (message, key, cfg) {
	                        return selectCipherStrategy(key).encrypt(cipher, message, key, cfg);
	                    },

	                    decrypt: function (ciphertext, key, cfg) {
	                        return selectCipherStrategy(key).decrypt(cipher, ciphertext, key, cfg);
	                    }
	                };
	            };
	        }())
	    });

	    /**
	     * Abstract base stream cipher template.
	     *
	     * @property {number} blockSize The number of 32-bit words this cipher operates on. Default: 1 (32 bits)
	     */
	    var StreamCipher = C_lib.StreamCipher = Cipher.extend({
	        _doFinalize: function () {
	            // Process partial blocks
	            var finalProcessedBlocks = this._process(!!'flush');

	            return finalProcessedBlocks;
	        },

	        blockSize: 1
	    });

	    /**
	     * Mode namespace.
	     */
	    var C_mode = C.mode = {};

	    /**
	     * Abstract base block cipher mode template.
	     */
	    var BlockCipherMode = C_lib.BlockCipherMode = Base.extend({
	        /**
	         * Creates this mode for encryption.
	         *
	         * @param {Cipher} cipher A block cipher instance.
	         * @param {Array} iv The IV words.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var mode = CryptoJS.mode.CBC.createEncryptor(cipher, iv.words);
	         */
	        createEncryptor: function (cipher, iv) {
	            return this.Encryptor.create(cipher, iv);
	        },

	        /**
	         * Creates this mode for decryption.
	         *
	         * @param {Cipher} cipher A block cipher instance.
	         * @param {Array} iv The IV words.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var mode = CryptoJS.mode.CBC.createDecryptor(cipher, iv.words);
	         */
	        createDecryptor: function (cipher, iv) {
	            return this.Decryptor.create(cipher, iv);
	        },

	        /**
	         * Initializes a newly created mode.
	         *
	         * @param {Cipher} cipher A block cipher instance.
	         * @param {Array} iv The IV words.
	         *
	         * @example
	         *
	         *     var mode = CryptoJS.mode.CBC.Encryptor.create(cipher, iv.words);
	         */
	        init: function (cipher, iv) {
	            this._cipher = cipher;
	            this._iv = iv;
	        }
	    });

	    /**
	     * Cipher Block Chaining mode.
	     */
	    var CBC = C_mode.CBC = (function () {
	        /**
	         * Abstract base CBC mode.
	         */
	        var CBC = BlockCipherMode.extend();

	        /**
	         * CBC encryptor.
	         */
	        CBC.Encryptor = CBC.extend({
	            /**
	             * Processes the data block at offset.
	             *
	             * @param {Array} words The data words to operate on.
	             * @param {number} offset The offset where the block starts.
	             *
	             * @example
	             *
	             *     mode.processBlock(data.words, offset);
	             */
	            processBlock: function (words, offset) {
	                // Shortcuts
	                var cipher = this._cipher;
	                var blockSize = cipher.blockSize;

	                // XOR and encrypt
	                xorBlock.call(this, words, offset, blockSize);
	                cipher.encryptBlock(words, offset);

	                // Remember this block to use with next block
	                this._prevBlock = words.slice(offset, offset + blockSize);
	            }
	        });

	        /**
	         * CBC decryptor.
	         */
	        CBC.Decryptor = CBC.extend({
	            /**
	             * Processes the data block at offset.
	             *
	             * @param {Array} words The data words to operate on.
	             * @param {number} offset The offset where the block starts.
	             *
	             * @example
	             *
	             *     mode.processBlock(data.words, offset);
	             */
	            processBlock: function (words, offset) {
	                // Shortcuts
	                var cipher = this._cipher;
	                var blockSize = cipher.blockSize;

	                // Remember this block to use with next block
	                var thisBlock = words.slice(offset, offset + blockSize);

	                // Decrypt and XOR
	                cipher.decryptBlock(words, offset);
	                xorBlock.call(this, words, offset, blockSize);

	                // This block becomes the previous block
	                this._prevBlock = thisBlock;
	            }
	        });

	        function xorBlock(words, offset, blockSize) {
	            // Shortcut
	            var iv = this._iv;

	            // Choose mixing block
	            if (iv) {
	                var block = iv;

	                // Remove IV for subsequent blocks
	                this._iv = undefined;
	            } else {
	                var block = this._prevBlock;
	            }

	            // XOR blocks
	            for (var i = 0; i < blockSize; i++) {
	                words[offset + i] ^= block[i];
	            }
	        }

	        return CBC;
	    }());

	    /**
	     * Padding namespace.
	     */
	    var C_pad = C.pad = {};

	    /**
	     * PKCS #5/7 padding strategy.
	     */
	    var Pkcs7 = C_pad.Pkcs7 = {
	        /**
	         * Pads data using the algorithm defined in PKCS #5/7.
	         *
	         * @param {WordArray} data The data to pad.
	         * @param {number} blockSize The multiple that the data should be padded to.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     CryptoJS.pad.Pkcs7.pad(wordArray, 4);
	         */
	        pad: function (data, blockSize) {
	            // Shortcut
	            var blockSizeBytes = blockSize * 4;

	            // Count padding bytes
	            var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;

	            // Create padding word
	            var paddingWord = (nPaddingBytes << 24) | (nPaddingBytes << 16) | (nPaddingBytes << 8) | nPaddingBytes;

	            // Create padding
	            var paddingWords = [];
	            for (var i = 0; i < nPaddingBytes; i += 4) {
	                paddingWords.push(paddingWord);
	            }
	            var padding = WordArray.create(paddingWords, nPaddingBytes);

	            // Add padding
	            data.concat(padding);
	        },

	        /**
	         * Unpads data that had been padded using the algorithm defined in PKCS #5/7.
	         *
	         * @param {WordArray} data The data to unpad.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     CryptoJS.pad.Pkcs7.unpad(wordArray);
	         */
	        unpad: function (data) {
	            // Get number of padding bytes from last byte
	            var nPaddingBytes = data.words[(data.sigBytes - 1) >>> 2] & 0xff;

	            // Remove padding
	            data.sigBytes -= nPaddingBytes;
	        }
	    };

	    /**
	     * Abstract base block cipher template.
	     *
	     * @property {number} blockSize The number of 32-bit words this cipher operates on. Default: 4 (128 bits)
	     */
	    var BlockCipher = C_lib.BlockCipher = Cipher.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {Mode} mode The block mode to use. Default: CBC
	         * @property {Padding} padding The padding strategy to use. Default: Pkcs7
	         */
	        cfg: Cipher.cfg.extend({
	            mode: CBC,
	            padding: Pkcs7
	        }),

	        reset: function () {
	            // Reset cipher
	            Cipher.reset.call(this);

	            // Shortcuts
	            var cfg = this.cfg;
	            var iv = cfg.iv;
	            var mode = cfg.mode;

	            // Reset block mode
	            if (this._xformMode == this._ENC_XFORM_MODE) {
	                var modeCreator = mode.createEncryptor;
	            } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {
	                var modeCreator = mode.createDecryptor;
	                // Keep at least one block in the buffer for unpadding
	                this._minBufferSize = 1;
	            }

	            if (this._mode && this._mode.__creator == modeCreator) {
	                this._mode.init(this, iv && iv.words);
	            } else {
	                this._mode = modeCreator.call(mode, this, iv && iv.words);
	                this._mode.__creator = modeCreator;
	            }
	        },

	        _doProcessBlock: function (words, offset) {
	            this._mode.processBlock(words, offset);
	        },

	        _doFinalize: function () {
	            // Shortcut
	            var padding = this.cfg.padding;

	            // Finalize
	            if (this._xformMode == this._ENC_XFORM_MODE) {
	                // Pad data
	                padding.pad(this._data, this.blockSize);

	                // Process final blocks
	                var finalProcessedBlocks = this._process(!!'flush');
	            } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {
	                // Process final blocks
	                var finalProcessedBlocks = this._process(!!'flush');

	                // Unpad data
	                padding.unpad(finalProcessedBlocks);
	            }

	            return finalProcessedBlocks;
	        },

	        blockSize: 128/32
	    });

	    /**
	     * A collection of cipher parameters.
	     *
	     * @property {WordArray} ciphertext The raw ciphertext.
	     * @property {WordArray} key The key to this ciphertext.
	     * @property {WordArray} iv The IV used in the ciphering operation.
	     * @property {WordArray} salt The salt used with a key derivation function.
	     * @property {Cipher} algorithm The cipher algorithm.
	     * @property {Mode} mode The block mode used in the ciphering operation.
	     * @property {Padding} padding The padding scheme used in the ciphering operation.
	     * @property {number} blockSize The block size of the cipher.
	     * @property {Format} formatter The default formatting strategy to convert this cipher params object to a string.
	     */
	    var CipherParams = C_lib.CipherParams = Base.extend({
	        /**
	         * Initializes a newly created cipher params object.
	         *
	         * @param {Object} cipherParams An object with any of the possible cipher parameters.
	         *
	         * @example
	         *
	         *     var cipherParams = CryptoJS.lib.CipherParams.create({
	         *         ciphertext: ciphertextWordArray,
	         *         key: keyWordArray,
	         *         iv: ivWordArray,
	         *         salt: saltWordArray,
	         *         algorithm: CryptoJS.algo.AES,
	         *         mode: CryptoJS.mode.CBC,
	         *         padding: CryptoJS.pad.PKCS7,
	         *         blockSize: 4,
	         *         formatter: CryptoJS.format.OpenSSL
	         *     });
	         */
	        init: function (cipherParams) {
	            this.mixIn(cipherParams);
	        },

	        /**
	         * Converts this cipher params object to a string.
	         *
	         * @param {Format} formatter (Optional) The formatting strategy to use.
	         *
	         * @return {string} The stringified cipher params.
	         *
	         * @throws Error If neither the formatter nor the default formatter is set.
	         *
	         * @example
	         *
	         *     var string = cipherParams + '';
	         *     var string = cipherParams.toString();
	         *     var string = cipherParams.toString(CryptoJS.format.OpenSSL);
	         */
	        toString: function (formatter) {
	            return (formatter || this.formatter).stringify(this);
	        }
	    });

	    /**
	     * Format namespace.
	     */
	    var C_format = C.format = {};

	    /**
	     * OpenSSL formatting strategy.
	     */
	    var OpenSSLFormatter = C_format.OpenSSL = {
	        /**
	         * Converts a cipher params object to an OpenSSL-compatible string.
	         *
	         * @param {CipherParams} cipherParams The cipher params object.
	         *
	         * @return {string} The OpenSSL-compatible string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var openSSLString = CryptoJS.format.OpenSSL.stringify(cipherParams);
	         */
	        stringify: function (cipherParams) {
	            // Shortcuts
	            var ciphertext = cipherParams.ciphertext;
	            var salt = cipherParams.salt;

	            // Format
	            if (salt) {
	                var wordArray = WordArray.create([0x53616c74, 0x65645f5f]).concat(salt).concat(ciphertext);
	            } else {
	                var wordArray = ciphertext;
	            }

	            return wordArray.toString(Base64);
	        },

	        /**
	         * Converts an OpenSSL-compatible string to a cipher params object.
	         *
	         * @param {string} openSSLStr The OpenSSL-compatible string.
	         *
	         * @return {CipherParams} The cipher params object.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var cipherParams = CryptoJS.format.OpenSSL.parse(openSSLString);
	         */
	        parse: function (openSSLStr) {
	            // Parse base64
	            var ciphertext = Base64.parse(openSSLStr);

	            // Shortcut
	            var ciphertextWords = ciphertext.words;

	            // Test for salt
	            if (ciphertextWords[0] == 0x53616c74 && ciphertextWords[1] == 0x65645f5f) {
	                // Extract salt
	                var salt = WordArray.create(ciphertextWords.slice(2, 4));

	                // Remove salt from ciphertext
	                ciphertextWords.splice(0, 4);
	                ciphertext.sigBytes -= 16;
	            }

	            return CipherParams.create({ ciphertext: ciphertext, salt: salt });
	        }
	    };

	    /**
	     * A cipher wrapper that returns ciphertext as a serializable cipher params object.
	     */
	    var SerializableCipher = C_lib.SerializableCipher = Base.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {Formatter} format The formatting strategy to convert cipher param objects to and from a string. Default: OpenSSL
	         */
	        cfg: Base.extend({
	            format: OpenSSLFormatter
	        }),

	        /**
	         * Encrypts a message.
	         *
	         * @param {Cipher} cipher The cipher algorithm to use.
	         * @param {WordArray|string} message The message to encrypt.
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {CipherParams} A cipher params object.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key);
	         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv });
	         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv, format: CryptoJS.format.OpenSSL });
	         */
	        encrypt: function (cipher, message, key, cfg) {
	            // Apply config defaults
	            cfg = this.cfg.extend(cfg);

	            // Encrypt
	            var encryptor = cipher.createEncryptor(key, cfg);
	            var ciphertext = encryptor.finalize(message);

	            // Shortcut
	            var cipherCfg = encryptor.cfg;

	            // Create and return serializable cipher params
	            return CipherParams.create({
	                ciphertext: ciphertext,
	                key: key,
	                iv: cipherCfg.iv,
	                algorithm: cipher,
	                mode: cipherCfg.mode,
	                padding: cipherCfg.padding,
	                blockSize: cipher.blockSize,
	                formatter: cfg.format
	            });
	        },

	        /**
	         * Decrypts serialized ciphertext.
	         *
	         * @param {Cipher} cipher The cipher algorithm to use.
	         * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {WordArray} The plaintext.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, key, { iv: iv, format: CryptoJS.format.OpenSSL });
	         *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, key, { iv: iv, format: CryptoJS.format.OpenSSL });
	         */
	        decrypt: function (cipher, ciphertext, key, cfg) {
	            // Apply config defaults
	            cfg = this.cfg.extend(cfg);

	            // Convert string to CipherParams
	            ciphertext = this._parse(ciphertext, cfg.format);

	            // Decrypt
	            var plaintext = cipher.createDecryptor(key, cfg).finalize(ciphertext.ciphertext);

	            return plaintext;
	        },

	        /**
	         * Converts serialized ciphertext to CipherParams,
	         * else assumed CipherParams already and returns ciphertext unchanged.
	         *
	         * @param {CipherParams|string} ciphertext The ciphertext.
	         * @param {Formatter} format The formatting strategy to use to parse serialized ciphertext.
	         *
	         * @return {CipherParams} The unserialized ciphertext.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var ciphertextParams = CryptoJS.lib.SerializableCipher._parse(ciphertextStringOrParams, format);
	         */
	        _parse: function (ciphertext, format) {
	            if (typeof ciphertext == 'string') {
	                return format.parse(ciphertext, this);
	            } else {
	                return ciphertext;
	            }
	        }
	    });

	    /**
	     * Key derivation function namespace.
	     */
	    var C_kdf = C.kdf = {};

	    /**
	     * OpenSSL key derivation function.
	     */
	    var OpenSSLKdf = C_kdf.OpenSSL = {
	        /**
	         * Derives a key and IV from a password.
	         *
	         * @param {string} password The password to derive from.
	         * @param {number} keySize The size in words of the key to generate.
	         * @param {number} ivSize The size in words of the IV to generate.
	         * @param {WordArray|string} salt (Optional) A 64-bit salt to use. If omitted, a salt will be generated randomly.
	         *
	         * @return {CipherParams} A cipher params object with the key, IV, and salt.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32);
	         *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32, 'saltsalt');
	         */
	        execute: function (password, keySize, ivSize, salt) {
	            // Generate random salt
	            if (!salt) {
	                salt = WordArray.random(64/8);
	            }

	            // Derive key and IV
	            var key = EvpKDF.create({ keySize: keySize + ivSize }).compute(password, salt);

	            // Separate key and IV
	            var iv = WordArray.create(key.words.slice(keySize), ivSize * 4);
	            key.sigBytes = keySize * 4;

	            // Return params
	            return CipherParams.create({ key: key, iv: iv, salt: salt });
	        }
	    };

	    /**
	     * A serializable cipher wrapper that derives the key from a password,
	     * and returns ciphertext as a serializable cipher params object.
	     */
	    var PasswordBasedCipher = C_lib.PasswordBasedCipher = SerializableCipher.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {KDF} kdf The key derivation function to use to generate a key and IV from a password. Default: OpenSSL
	         */
	        cfg: SerializableCipher.cfg.extend({
	            kdf: OpenSSLKdf
	        }),

	        /**
	         * Encrypts a message using a password.
	         *
	         * @param {Cipher} cipher The cipher algorithm to use.
	         * @param {WordArray|string} message The message to encrypt.
	         * @param {string} password The password.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {CipherParams} A cipher params object.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password');
	         *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password', { format: CryptoJS.format.OpenSSL });
	         */
	        encrypt: function (cipher, message, password, cfg) {
	            // Apply config defaults
	            cfg = this.cfg.extend(cfg);

	            // Derive key and other params
	            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize);

	            // Add IV to config
	            cfg.iv = derivedParams.iv;

	            // Encrypt
	            var ciphertext = SerializableCipher.encrypt.call(this, cipher, message, derivedParams.key, cfg);

	            // Mix in derived params
	            ciphertext.mixIn(derivedParams);

	            return ciphertext;
	        },

	        /**
	         * Decrypts serialized ciphertext using a password.
	         *
	         * @param {Cipher} cipher The cipher algorithm to use.
	         * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
	         * @param {string} password The password.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {WordArray} The plaintext.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, 'password', { format: CryptoJS.format.OpenSSL });
	         *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, 'password', { format: CryptoJS.format.OpenSSL });
	         */
	        decrypt: function (cipher, ciphertext, password, cfg) {
	            // Apply config defaults
	            cfg = this.cfg.extend(cfg);

	            // Convert string to CipherParams
	            ciphertext = this._parse(ciphertext, cfg.format);

	            // Derive key and other params
	            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, ciphertext.salt);

	            // Add IV to config
	            cfg.iv = derivedParams.iv;

	            // Decrypt
	            var plaintext = SerializableCipher.decrypt.call(this, cipher, ciphertext, derivedParams.key, cfg);

	            return plaintext;
	        }
	    });
	}());


	/**
	 * Cipher Feedback block mode.
	 */
	CryptoJS.mode.CFB = (function () {
	    var CFB = CryptoJS.lib.BlockCipherMode.extend();

	    CFB.Encryptor = CFB.extend({
	        processBlock: function (words, offset) {
	            // Shortcuts
	            var cipher = this._cipher;
	            var blockSize = cipher.blockSize;

	            generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);

	            // Remember this block to use with next block
	            this._prevBlock = words.slice(offset, offset + blockSize);
	        }
	    });

	    CFB.Decryptor = CFB.extend({
	        processBlock: function (words, offset) {
	            // Shortcuts
	            var cipher = this._cipher;
	            var blockSize = cipher.blockSize;

	            // Remember this block to use with next block
	            var thisBlock = words.slice(offset, offset + blockSize);

	            generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);

	            // This block becomes the previous block
	            this._prevBlock = thisBlock;
	        }
	    });

	    function generateKeystreamAndEncrypt(words, offset, blockSize, cipher) {
	        // Shortcut
	        var iv = this._iv;

	        // Generate keystream
	        if (iv) {
	            var keystream = iv.slice(0);

	            // Remove IV for subsequent blocks
	            this._iv = undefined;
	        } else {
	            var keystream = this._prevBlock;
	        }
	        cipher.encryptBlock(keystream, 0);

	        // Encrypt
	        for (var i = 0; i < blockSize; i++) {
	            words[offset + i] ^= keystream[i];
	        }
	    }

	    return CFB;
	}());


	/**
	 * Electronic Codebook block mode.
	 */
	CryptoJS.mode.ECB = (function () {
	    var ECB = CryptoJS.lib.BlockCipherMode.extend();

	    ECB.Encryptor = ECB.extend({
	        processBlock: function (words, offset) {
	            this._cipher.encryptBlock(words, offset);
	        }
	    });

	    ECB.Decryptor = ECB.extend({
	        processBlock: function (words, offset) {
	            this._cipher.decryptBlock(words, offset);
	        }
	    });

	    return ECB;
	}());


	/**
	 * ANSI X.923 padding strategy.
	 */
	CryptoJS.pad.AnsiX923 = {
	    pad: function (data, blockSize) {
	        // Shortcuts
	        var dataSigBytes = data.sigBytes;
	        var blockSizeBytes = blockSize * 4;

	        // Count padding bytes
	        var nPaddingBytes = blockSizeBytes - dataSigBytes % blockSizeBytes;

	        // Compute last byte position
	        var lastBytePos = dataSigBytes + nPaddingBytes - 1;

	        // Pad
	        data.clamp();
	        data.words[lastBytePos >>> 2] |= nPaddingBytes << (24 - (lastBytePos % 4) * 8);
	        data.sigBytes += nPaddingBytes;
	    },

	    unpad: function (data) {
	        // Get number of padding bytes from last byte
	        var nPaddingBytes = data.words[(data.sigBytes - 1) >>> 2] & 0xff;

	        // Remove padding
	        data.sigBytes -= nPaddingBytes;
	    }
	};


	/**
	 * ISO 10126 padding strategy.
	 */
	CryptoJS.pad.Iso10126 = {
	    pad: function (data, blockSize) {
	        // Shortcut
	        var blockSizeBytes = blockSize * 4;

	        // Count padding bytes
	        var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;

	        // Pad
	        data.concat(CryptoJS.lib.WordArray.random(nPaddingBytes - 1)).
	             concat(CryptoJS.lib.WordArray.create([nPaddingBytes << 24], 1));
	    },

	    unpad: function (data) {
	        // Get number of padding bytes from last byte
	        var nPaddingBytes = data.words[(data.sigBytes - 1) >>> 2] & 0xff;

	        // Remove padding
	        data.sigBytes -= nPaddingBytes;
	    }
	};


	/**
	 * ISO/IEC 9797-1 Padding Method 2.
	 */
	CryptoJS.pad.Iso97971 = {
	    pad: function (data, blockSize) {
	        // Add 0x80 byte
	        data.concat(CryptoJS.lib.WordArray.create([0x80000000], 1));

	        // Zero pad the rest
	        CryptoJS.pad.ZeroPadding.pad(data, blockSize);
	    },

	    unpad: function (data) {
	        // Remove zero padding
	        CryptoJS.pad.ZeroPadding.unpad(data);

	        // Remove one more byte -- the 0x80 byte
	        data.sigBytes--;
	    }
	};


	/**
	 * Output Feedback block mode.
	 */
	CryptoJS.mode.OFB = (function () {
	    var OFB = CryptoJS.lib.BlockCipherMode.extend();

	    var Encryptor = OFB.Encryptor = OFB.extend({
	        processBlock: function (words, offset) {
	            // Shortcuts
	            var cipher = this._cipher
	            var blockSize = cipher.blockSize;
	            var iv = this._iv;
	            var keystream = this._keystream;

	            // Generate keystream
	            if (iv) {
	                keystream = this._keystream = iv.slice(0);

	                // Remove IV for subsequent blocks
	                this._iv = undefined;
	            }
	            cipher.encryptBlock(keystream, 0);

	            // Encrypt
	            for (var i = 0; i < blockSize; i++) {
	                words[offset + i] ^= keystream[i];
	            }
	        }
	    });

	    OFB.Decryptor = Encryptor;

	    return OFB;
	}());


	/**
	 * A noop padding strategy.
	 */
	CryptoJS.pad.NoPadding = {
	    pad: function () {
	    },

	    unpad: function () {
	    }
	};


	(function (undefined) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var CipherParams = C_lib.CipherParams;
	    var C_enc = C.enc;
	    var Hex = C_enc.Hex;
	    var C_format = C.format;

	    var HexFormatter = C_format.Hex = {
	        /**
	         * Converts the ciphertext of a cipher params object to a hexadecimally encoded string.
	         *
	         * @param {CipherParams} cipherParams The cipher params object.
	         *
	         * @return {string} The hexadecimally encoded string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var hexString = CryptoJS.format.Hex.stringify(cipherParams);
	         */
	        stringify: function (cipherParams) {
	            return cipherParams.ciphertext.toString(Hex);
	        },

	        /**
	         * Converts a hexadecimally encoded ciphertext string to a cipher params object.
	         *
	         * @param {string} input The hexadecimally encoded string.
	         *
	         * @return {CipherParams} The cipher params object.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var cipherParams = CryptoJS.format.Hex.parse(hexString);
	         */
	        parse: function (input) {
	            var ciphertext = Hex.parse(input);
	            return CipherParams.create({ ciphertext: ciphertext });
	        }
	    };
	}());


	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var BlockCipher = C_lib.BlockCipher;
	    var C_algo = C.algo;

	    // Lookup tables
	    var SBOX = [];
	    var INV_SBOX = [];
	    var SUB_MIX_0 = [];
	    var SUB_MIX_1 = [];
	    var SUB_MIX_2 = [];
	    var SUB_MIX_3 = [];
	    var INV_SUB_MIX_0 = [];
	    var INV_SUB_MIX_1 = [];
	    var INV_SUB_MIX_2 = [];
	    var INV_SUB_MIX_3 = [];

	    // Compute lookup tables
	    (function () {
	        // Compute double table
	        var d = [];
	        for (var i = 0; i < 256; i++) {
	            if (i < 128) {
	                d[i] = i << 1;
	            } else {
	                d[i] = (i << 1) ^ 0x11b;
	            }
	        }

	        // Walk GF(2^8)
	        var x = 0;
	        var xi = 0;
	        for (var i = 0; i < 256; i++) {
	            // Compute sbox
	            var sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4);
	            sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63;
	            SBOX[x] = sx;
	            INV_SBOX[sx] = x;

	            // Compute multiplication
	            var x2 = d[x];
	            var x4 = d[x2];
	            var x8 = d[x4];

	            // Compute sub bytes, mix columns tables
	            var t = (d[sx] * 0x101) ^ (sx * 0x1010100);
	            SUB_MIX_0[x] = (t << 24) | (t >>> 8);
	            SUB_MIX_1[x] = (t << 16) | (t >>> 16);
	            SUB_MIX_2[x] = (t << 8)  | (t >>> 24);
	            SUB_MIX_3[x] = t;

	            // Compute inv sub bytes, inv mix columns tables
	            var t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100);
	            INV_SUB_MIX_0[sx] = (t << 24) | (t >>> 8);
	            INV_SUB_MIX_1[sx] = (t << 16) | (t >>> 16);
	            INV_SUB_MIX_2[sx] = (t << 8)  | (t >>> 24);
	            INV_SUB_MIX_3[sx] = t;

	            // Compute next counter
	            if (!x) {
	                x = xi = 1;
	            } else {
	                x = x2 ^ d[d[d[x8 ^ x2]]];
	                xi ^= d[d[xi]];
	            }
	        }
	    }());

	    // Precomputed Rcon lookup
	    var RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];

	    /**
	     * AES block cipher algorithm.
	     */
	    var AES = C_algo.AES = BlockCipher.extend({
	        _doReset: function () {
	            // Skip reset of nRounds has been set before and key did not change
	            if (this._nRounds && this._keyPriorReset === this._key) {
	                return;
	            }

	            // Shortcuts
	            var key = this._keyPriorReset = this._key;
	            var keyWords = key.words;
	            var keySize = key.sigBytes / 4;

	            // Compute number of rounds
	            var nRounds = this._nRounds = keySize + 6;

	            // Compute number of key schedule rows
	            var ksRows = (nRounds + 1) * 4;

	            // Compute key schedule
	            var keySchedule = this._keySchedule = [];
	            for (var ksRow = 0; ksRow < ksRows; ksRow++) {
	                if (ksRow < keySize) {
	                    keySchedule[ksRow] = keyWords[ksRow];
	                } else {
	                    var t = keySchedule[ksRow - 1];

	                    if (!(ksRow % keySize)) {
	                        // Rot word
	                        t = (t << 8) | (t >>> 24);

	                        // Sub word
	                        t = (SBOX[t >>> 24] << 24) | (SBOX[(t >>> 16) & 0xff] << 16) | (SBOX[(t >>> 8) & 0xff] << 8) | SBOX[t & 0xff];

	                        // Mix Rcon
	                        t ^= RCON[(ksRow / keySize) | 0] << 24;
	                    } else if (keySize > 6 && ksRow % keySize == 4) {
	                        // Sub word
	                        t = (SBOX[t >>> 24] << 24) | (SBOX[(t >>> 16) & 0xff] << 16) | (SBOX[(t >>> 8) & 0xff] << 8) | SBOX[t & 0xff];
	                    }

	                    keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t;
	                }
	            }

	            // Compute inv key schedule
	            var invKeySchedule = this._invKeySchedule = [];
	            for (var invKsRow = 0; invKsRow < ksRows; invKsRow++) {
	                var ksRow = ksRows - invKsRow;

	                if (invKsRow % 4) {
	                    var t = keySchedule[ksRow];
	                } else {
	                    var t = keySchedule[ksRow - 4];
	                }

	                if (invKsRow < 4 || ksRow <= 4) {
	                    invKeySchedule[invKsRow] = t;
	                } else {
	                    invKeySchedule[invKsRow] = INV_SUB_MIX_0[SBOX[t >>> 24]] ^ INV_SUB_MIX_1[SBOX[(t >>> 16) & 0xff]] ^
	                                               INV_SUB_MIX_2[SBOX[(t >>> 8) & 0xff]] ^ INV_SUB_MIX_3[SBOX[t & 0xff]];
	                }
	            }
	        },

	        encryptBlock: function (M, offset) {
	            this._doCryptBlock(M, offset, this._keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX);
	        },

	        decryptBlock: function (M, offset) {
	            // Swap 2nd and 4th rows
	            var t = M[offset + 1];
	            M[offset + 1] = M[offset + 3];
	            M[offset + 3] = t;

	            this._doCryptBlock(M, offset, this._invKeySchedule, INV_SUB_MIX_0, INV_SUB_MIX_1, INV_SUB_MIX_2, INV_SUB_MIX_3, INV_SBOX);

	            // Inv swap 2nd and 4th rows
	            var t = M[offset + 1];
	            M[offset + 1] = M[offset + 3];
	            M[offset + 3] = t;
	        },

	        _doCryptBlock: function (M, offset, keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX) {
	            // Shortcut
	            var nRounds = this._nRounds;

	            // Get input, add round key
	            var s0 = M[offset]     ^ keySchedule[0];
	            var s1 = M[offset + 1] ^ keySchedule[1];
	            var s2 = M[offset + 2] ^ keySchedule[2];
	            var s3 = M[offset + 3] ^ keySchedule[3];

	            // Key schedule row counter
	            var ksRow = 4;

	            // Rounds
	            for (var round = 1; round < nRounds; round++) {
	                // Shift rows, sub bytes, mix columns, add round key
	                var t0 = SUB_MIX_0[s0 >>> 24] ^ SUB_MIX_1[(s1 >>> 16) & 0xff] ^ SUB_MIX_2[(s2 >>> 8) & 0xff] ^ SUB_MIX_3[s3 & 0xff] ^ keySchedule[ksRow++];
	                var t1 = SUB_MIX_0[s1 >>> 24] ^ SUB_MIX_1[(s2 >>> 16) & 0xff] ^ SUB_MIX_2[(s3 >>> 8) & 0xff] ^ SUB_MIX_3[s0 & 0xff] ^ keySchedule[ksRow++];
	                var t2 = SUB_MIX_0[s2 >>> 24] ^ SUB_MIX_1[(s3 >>> 16) & 0xff] ^ SUB_MIX_2[(s0 >>> 8) & 0xff] ^ SUB_MIX_3[s1 & 0xff] ^ keySchedule[ksRow++];
	                var t3 = SUB_MIX_0[s3 >>> 24] ^ SUB_MIX_1[(s0 >>> 16) & 0xff] ^ SUB_MIX_2[(s1 >>> 8) & 0xff] ^ SUB_MIX_3[s2 & 0xff] ^ keySchedule[ksRow++];

	                // Update state
	                s0 = t0;
	                s1 = t1;
	                s2 = t2;
	                s3 = t3;
	            }

	            // Shift rows, sub bytes, add round key
	            var t0 = ((SBOX[s0 >>> 24] << 24) | (SBOX[(s1 >>> 16) & 0xff] << 16) | (SBOX[(s2 >>> 8) & 0xff] << 8) | SBOX[s3 & 0xff]) ^ keySchedule[ksRow++];
	            var t1 = ((SBOX[s1 >>> 24] << 24) | (SBOX[(s2 >>> 16) & 0xff] << 16) | (SBOX[(s3 >>> 8) & 0xff] << 8) | SBOX[s0 & 0xff]) ^ keySchedule[ksRow++];
	            var t2 = ((SBOX[s2 >>> 24] << 24) | (SBOX[(s3 >>> 16) & 0xff] << 16) | (SBOX[(s0 >>> 8) & 0xff] << 8) | SBOX[s1 & 0xff]) ^ keySchedule[ksRow++];
	            var t3 = ((SBOX[s3 >>> 24] << 24) | (SBOX[(s0 >>> 16) & 0xff] << 16) | (SBOX[(s1 >>> 8) & 0xff] << 8) | SBOX[s2 & 0xff]) ^ keySchedule[ksRow++];

	            // Set output
	            M[offset]     = t0;
	            M[offset + 1] = t1;
	            M[offset + 2] = t2;
	            M[offset + 3] = t3;
	        },

	        keySize: 256/32
	    });

	    /**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.AES.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.AES.decrypt(ciphertext, key, cfg);
	     */
	    C.AES = BlockCipher._createHelper(AES);
	}());


	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var BlockCipher = C_lib.BlockCipher;
	    var C_algo = C.algo;

	    // Permuted Choice 1 constants
	    var PC1 = [
	        57, 49, 41, 33, 25, 17, 9,  1,
	        58, 50, 42, 34, 26, 18, 10, 2,
	        59, 51, 43, 35, 27, 19, 11, 3,
	        60, 52, 44, 36, 63, 55, 47, 39,
	        31, 23, 15, 7,  62, 54, 46, 38,
	        30, 22, 14, 6,  61, 53, 45, 37,
	        29, 21, 13, 5,  28, 20, 12, 4
	    ];

	    // Permuted Choice 2 constants
	    var PC2 = [
	        14, 17, 11, 24, 1,  5,
	        3,  28, 15, 6,  21, 10,
	        23, 19, 12, 4,  26, 8,
	        16, 7,  27, 20, 13, 2,
	        41, 52, 31, 37, 47, 55,
	        30, 40, 51, 45, 33, 48,
	        44, 49, 39, 56, 34, 53,
	        46, 42, 50, 36, 29, 32
	    ];

	    // Cumulative bit shift constants
	    var BIT_SHIFTS = [1,  2,  4,  6,  8,  10, 12, 14, 15, 17, 19, 21, 23, 25, 27, 28];

	    // SBOXes and round permutation constants
	    var SBOX_P = [
	        {
	            0x0: 0x808200,
	            0x10000000: 0x8000,
	            0x20000000: 0x808002,
	            0x30000000: 0x2,
	            0x40000000: 0x200,
	            0x50000000: 0x808202,
	            0x60000000: 0x800202,
	            0x70000000: 0x800000,
	            0x80000000: 0x202,
	            0x90000000: 0x800200,
	            0xa0000000: 0x8200,
	            0xb0000000: 0x808000,
	            0xc0000000: 0x8002,
	            0xd0000000: 0x800002,
	            0xe0000000: 0x0,
	            0xf0000000: 0x8202,
	            0x8000000: 0x0,
	            0x18000000: 0x808202,
	            0x28000000: 0x8202,
	            0x38000000: 0x8000,
	            0x48000000: 0x808200,
	            0x58000000: 0x200,
	            0x68000000: 0x808002,
	            0x78000000: 0x2,
	            0x88000000: 0x800200,
	            0x98000000: 0x8200,
	            0xa8000000: 0x808000,
	            0xb8000000: 0x800202,
	            0xc8000000: 0x800002,
	            0xd8000000: 0x8002,
	            0xe8000000: 0x202,
	            0xf8000000: 0x800000,
	            0x1: 0x8000,
	            0x10000001: 0x2,
	            0x20000001: 0x808200,
	            0x30000001: 0x800000,
	            0x40000001: 0x808002,
	            0x50000001: 0x8200,
	            0x60000001: 0x200,
	            0x70000001: 0x800202,
	            0x80000001: 0x808202,
	            0x90000001: 0x808000,
	            0xa0000001: 0x800002,
	            0xb0000001: 0x8202,
	            0xc0000001: 0x202,
	            0xd0000001: 0x800200,
	            0xe0000001: 0x8002,
	            0xf0000001: 0x0,
	            0x8000001: 0x808202,
	            0x18000001: 0x808000,
	            0x28000001: 0x800000,
	            0x38000001: 0x200,
	            0x48000001: 0x8000,
	            0x58000001: 0x800002,
	            0x68000001: 0x2,
	            0x78000001: 0x8202,
	            0x88000001: 0x8002,
	            0x98000001: 0x800202,
	            0xa8000001: 0x202,
	            0xb8000001: 0x808200,
	            0xc8000001: 0x800200,
	            0xd8000001: 0x0,
	            0xe8000001: 0x8200,
	            0xf8000001: 0x808002
	        },
	        {
	            0x0: 0x40084010,
	            0x1000000: 0x4000,
	            0x2000000: 0x80000,
	            0x3000000: 0x40080010,
	            0x4000000: 0x40000010,
	            0x5000000: 0x40084000,
	            0x6000000: 0x40004000,
	            0x7000000: 0x10,
	            0x8000000: 0x84000,
	            0x9000000: 0x40004010,
	            0xa000000: 0x40000000,
	            0xb000000: 0x84010,
	            0xc000000: 0x80010,
	            0xd000000: 0x0,
	            0xe000000: 0x4010,
	            0xf000000: 0x40080000,
	            0x800000: 0x40004000,
	            0x1800000: 0x84010,
	            0x2800000: 0x10,
	            0x3800000: 0x40004010,
	            0x4800000: 0x40084010,
	            0x5800000: 0x40000000,
	            0x6800000: 0x80000,
	            0x7800000: 0x40080010,
	            0x8800000: 0x80010,
	            0x9800000: 0x0,
	            0xa800000: 0x4000,
	            0xb800000: 0x40080000,
	            0xc800000: 0x40000010,
	            0xd800000: 0x84000,
	            0xe800000: 0x40084000,
	            0xf800000: 0x4010,
	            0x10000000: 0x0,
	            0x11000000: 0x40080010,
	            0x12000000: 0x40004010,
	            0x13000000: 0x40084000,
	            0x14000000: 0x40080000,
	            0x15000000: 0x10,
	            0x16000000: 0x84010,
	            0x17000000: 0x4000,
	            0x18000000: 0x4010,
	            0x19000000: 0x80000,
	            0x1a000000: 0x80010,
	            0x1b000000: 0x40000010,
	            0x1c000000: 0x84000,
	            0x1d000000: 0x40004000,
	            0x1e000000: 0x40000000,
	            0x1f000000: 0x40084010,
	            0x10800000: 0x84010,
	            0x11800000: 0x80000,
	            0x12800000: 0x40080000,
	            0x13800000: 0x4000,
	            0x14800000: 0x40004000,
	            0x15800000: 0x40084010,
	            0x16800000: 0x10,
	            0x17800000: 0x40000000,
	            0x18800000: 0x40084000,
	            0x19800000: 0x40000010,
	            0x1a800000: 0x40004010,
	            0x1b800000: 0x80010,
	            0x1c800000: 0x0,
	            0x1d800000: 0x4010,
	            0x1e800000: 0x40080010,
	            0x1f800000: 0x84000
	        },
	        {
	            0x0: 0x104,
	            0x100000: 0x0,
	            0x200000: 0x4000100,
	            0x300000: 0x10104,
	            0x400000: 0x10004,
	            0x500000: 0x4000004,
	            0x600000: 0x4010104,
	            0x700000: 0x4010000,
	            0x800000: 0x4000000,
	            0x900000: 0x4010100,
	            0xa00000: 0x10100,
	            0xb00000: 0x4010004,
	            0xc00000: 0x4000104,
	            0xd00000: 0x10000,
	            0xe00000: 0x4,
	            0xf00000: 0x100,
	            0x80000: 0x4010100,
	            0x180000: 0x4010004,
	            0x280000: 0x0,
	            0x380000: 0x4000100,
	            0x480000: 0x4000004,
	            0x580000: 0x10000,
	            0x680000: 0x10004,
	            0x780000: 0x104,
	            0x880000: 0x4,
	            0x980000: 0x100,
	            0xa80000: 0x4010000,
	            0xb80000: 0x10104,
	            0xc80000: 0x10100,
	            0xd80000: 0x4000104,
	            0xe80000: 0x4010104,
	            0xf80000: 0x4000000,
	            0x1000000: 0x4010100,
	            0x1100000: 0x10004,
	            0x1200000: 0x10000,
	            0x1300000: 0x4000100,
	            0x1400000: 0x100,
	            0x1500000: 0x4010104,
	            0x1600000: 0x4000004,
	            0x1700000: 0x0,
	            0x1800000: 0x4000104,
	            0x1900000: 0x4000000,
	            0x1a00000: 0x4,
	            0x1b00000: 0x10100,
	            0x1c00000: 0x4010000,
	            0x1d00000: 0x104,
	            0x1e00000: 0x10104,
	            0x1f00000: 0x4010004,
	            0x1080000: 0x4000000,
	            0x1180000: 0x104,
	            0x1280000: 0x4010100,
	            0x1380000: 0x0,
	            0x1480000: 0x10004,
	            0x1580000: 0x4000100,
	            0x1680000: 0x100,
	            0x1780000: 0x4010004,
	            0x1880000: 0x10000,
	            0x1980000: 0x4010104,
	            0x1a80000: 0x10104,
	            0x1b80000: 0x4000004,
	            0x1c80000: 0x4000104,
	            0x1d80000: 0x4010000,
	            0x1e80000: 0x4,
	            0x1f80000: 0x10100
	        },
	        {
	            0x0: 0x80401000,
	            0x10000: 0x80001040,
	            0x20000: 0x401040,
	            0x30000: 0x80400000,
	            0x40000: 0x0,
	            0x50000: 0x401000,
	            0x60000: 0x80000040,
	            0x70000: 0x400040,
	            0x80000: 0x80000000,
	            0x90000: 0x400000,
	            0xa0000: 0x40,
	            0xb0000: 0x80001000,
	            0xc0000: 0x80400040,
	            0xd0000: 0x1040,
	            0xe0000: 0x1000,
	            0xf0000: 0x80401040,
	            0x8000: 0x80001040,
	            0x18000: 0x40,
	            0x28000: 0x80400040,
	            0x38000: 0x80001000,
	            0x48000: 0x401000,
	            0x58000: 0x80401040,
	            0x68000: 0x0,
	            0x78000: 0x80400000,
	            0x88000: 0x1000,
	            0x98000: 0x80401000,
	            0xa8000: 0x400000,
	            0xb8000: 0x1040,
	            0xc8000: 0x80000000,
	            0xd8000: 0x400040,
	            0xe8000: 0x401040,
	            0xf8000: 0x80000040,
	            0x100000: 0x400040,
	            0x110000: 0x401000,
	            0x120000: 0x80000040,
	            0x130000: 0x0,
	            0x140000: 0x1040,
	            0x150000: 0x80400040,
	            0x160000: 0x80401000,
	            0x170000: 0x80001040,
	            0x180000: 0x80401040,
	            0x190000: 0x80000000,
	            0x1a0000: 0x80400000,
	            0x1b0000: 0x401040,
	            0x1c0000: 0x80001000,
	            0x1d0000: 0x400000,
	            0x1e0000: 0x40,
	            0x1f0000: 0x1000,
	            0x108000: 0x80400000,
	            0x118000: 0x80401040,
	            0x128000: 0x0,
	            0x138000: 0x401000,
	            0x148000: 0x400040,
	            0x158000: 0x80000000,
	            0x168000: 0x80001040,
	            0x178000: 0x40,
	            0x188000: 0x80000040,
	            0x198000: 0x1000,
	            0x1a8000: 0x80001000,
	            0x1b8000: 0x80400040,
	            0x1c8000: 0x1040,
	            0x1d8000: 0x80401000,
	            0x1e8000: 0x400000,
	            0x1f8000: 0x401040
	        },
	        {
	            0x0: 0x80,
	            0x1000: 0x1040000,
	            0x2000: 0x40000,
	            0x3000: 0x20000000,
	            0x4000: 0x20040080,
	            0x5000: 0x1000080,
	            0x6000: 0x21000080,
	            0x7000: 0x40080,
	            0x8000: 0x1000000,
	            0x9000: 0x20040000,
	            0xa000: 0x20000080,
	            0xb000: 0x21040080,
	            0xc000: 0x21040000,
	            0xd000: 0x0,
	            0xe000: 0x1040080,
	            0xf000: 0x21000000,
	            0x800: 0x1040080,
	            0x1800: 0x21000080,
	            0x2800: 0x80,
	            0x3800: 0x1040000,
	            0x4800: 0x40000,
	            0x5800: 0x20040080,
	            0x6800: 0x21040000,
	            0x7800: 0x20000000,
	            0x8800: 0x20040000,
	            0x9800: 0x0,
	            0xa800: 0x21040080,
	            0xb800: 0x1000080,
	            0xc800: 0x20000080,
	            0xd800: 0x21000000,
	            0xe800: 0x1000000,
	            0xf800: 0x40080,
	            0x10000: 0x40000,
	            0x11000: 0x80,
	            0x12000: 0x20000000,
	            0x13000: 0x21000080,
	            0x14000: 0x1000080,
	            0x15000: 0x21040000,
	            0x16000: 0x20040080,
	            0x17000: 0x1000000,
	            0x18000: 0x21040080,
	            0x19000: 0x21000000,
	            0x1a000: 0x1040000,
	            0x1b000: 0x20040000,
	            0x1c000: 0x40080,
	            0x1d000: 0x20000080,
	            0x1e000: 0x0,
	            0x1f000: 0x1040080,
	            0x10800: 0x21000080,
	            0x11800: 0x1000000,
	            0x12800: 0x1040000,
	            0x13800: 0x20040080,
	            0x14800: 0x20000000,
	            0x15800: 0x1040080,
	            0x16800: 0x80,
	            0x17800: 0x21040000,
	            0x18800: 0x40080,
	            0x19800: 0x21040080,
	            0x1a800: 0x0,
	            0x1b800: 0x21000000,
	            0x1c800: 0x1000080,
	            0x1d800: 0x40000,
	            0x1e800: 0x20040000,
	            0x1f800: 0x20000080
	        },
	        {
	            0x0: 0x10000008,
	            0x100: 0x2000,
	            0x200: 0x10200000,
	            0x300: 0x10202008,
	            0x400: 0x10002000,
	            0x500: 0x200000,
	            0x600: 0x200008,
	            0x700: 0x10000000,
	            0x800: 0x0,
	            0x900: 0x10002008,
	            0xa00: 0x202000,
	            0xb00: 0x8,
	            0xc00: 0x10200008,
	            0xd00: 0x202008,
	            0xe00: 0x2008,
	            0xf00: 0x10202000,
	            0x80: 0x10200000,
	            0x180: 0x10202008,
	            0x280: 0x8,
	            0x380: 0x200000,
	            0x480: 0x202008,
	            0x580: 0x10000008,
	            0x680: 0x10002000,
	            0x780: 0x2008,
	            0x880: 0x200008,
	            0x980: 0x2000,
	            0xa80: 0x10002008,
	            0xb80: 0x10200008,
	            0xc80: 0x0,
	            0xd80: 0x10202000,
	            0xe80: 0x202000,
	            0xf80: 0x10000000,
	            0x1000: 0x10002000,
	            0x1100: 0x10200008,
	            0x1200: 0x10202008,
	            0x1300: 0x2008,
	            0x1400: 0x200000,
	            0x1500: 0x10000000,
	            0x1600: 0x10000008,
	            0x1700: 0x202000,
	            0x1800: 0x202008,
	            0x1900: 0x0,
	            0x1a00: 0x8,
	            0x1b00: 0x10200000,
	            0x1c00: 0x2000,
	            0x1d00: 0x10002008,
	            0x1e00: 0x10202000,
	            0x1f00: 0x200008,
	            0x1080: 0x8,
	            0x1180: 0x202000,
	            0x1280: 0x200000,
	            0x1380: 0x10000008,
	            0x1480: 0x10002000,
	            0x1580: 0x2008,
	            0x1680: 0x10202008,
	            0x1780: 0x10200000,
	            0x1880: 0x10202000,
	            0x1980: 0x10200008,
	            0x1a80: 0x2000,
	            0x1b80: 0x202008,
	            0x1c80: 0x200008,
	            0x1d80: 0x0,
	            0x1e80: 0x10000000,
	            0x1f80: 0x10002008
	        },
	        {
	            0x0: 0x100000,
	            0x10: 0x2000401,
	            0x20: 0x400,
	            0x30: 0x100401,
	            0x40: 0x2100401,
	            0x50: 0x0,
	            0x60: 0x1,
	            0x70: 0x2100001,
	            0x80: 0x2000400,
	            0x90: 0x100001,
	            0xa0: 0x2000001,
	            0xb0: 0x2100400,
	            0xc0: 0x2100000,
	            0xd0: 0x401,
	            0xe0: 0x100400,
	            0xf0: 0x2000000,
	            0x8: 0x2100001,
	            0x18: 0x0,
	            0x28: 0x2000401,
	            0x38: 0x2100400,
	            0x48: 0x100000,
	            0x58: 0x2000001,
	            0x68: 0x2000000,
	            0x78: 0x401,
	            0x88: 0x100401,
	            0x98: 0x2000400,
	            0xa8: 0x2100000,
	            0xb8: 0x100001,
	            0xc8: 0x400,
	            0xd8: 0x2100401,
	            0xe8: 0x1,
	            0xf8: 0x100400,
	            0x100: 0x2000000,
	            0x110: 0x100000,
	            0x120: 0x2000401,
	            0x130: 0x2100001,
	            0x140: 0x100001,
	            0x150: 0x2000400,
	            0x160: 0x2100400,
	            0x170: 0x100401,
	            0x180: 0x401,
	            0x190: 0x2100401,
	            0x1a0: 0x100400,
	            0x1b0: 0x1,
	            0x1c0: 0x0,
	            0x1d0: 0x2100000,
	            0x1e0: 0x2000001,
	            0x1f0: 0x400,
	            0x108: 0x100400,
	            0x118: 0x2000401,
	            0x128: 0x2100001,
	            0x138: 0x1,
	            0x148: 0x2000000,
	            0x158: 0x100000,
	            0x168: 0x401,
	            0x178: 0x2100400,
	            0x188: 0x2000001,
	            0x198: 0x2100000,
	            0x1a8: 0x0,
	            0x1b8: 0x2100401,
	            0x1c8: 0x100401,
	            0x1d8: 0x400,
	            0x1e8: 0x2000400,
	            0x1f8: 0x100001
	        },
	        {
	            0x0: 0x8000820,
	            0x1: 0x20000,
	            0x2: 0x8000000,
	            0x3: 0x20,
	            0x4: 0x20020,
	            0x5: 0x8020820,
	            0x6: 0x8020800,
	            0x7: 0x800,
	            0x8: 0x8020000,
	            0x9: 0x8000800,
	            0xa: 0x20800,
	            0xb: 0x8020020,
	            0xc: 0x820,
	            0xd: 0x0,
	            0xe: 0x8000020,
	            0xf: 0x20820,
	            0x80000000: 0x800,
	            0x80000001: 0x8020820,
	            0x80000002: 0x8000820,
	            0x80000003: 0x8000000,
	            0x80000004: 0x8020000,
	            0x80000005: 0x20800,
	            0x80000006: 0x20820,
	            0x80000007: 0x20,
	            0x80000008: 0x8000020,
	            0x80000009: 0x820,
	            0x8000000a: 0x20020,
	            0x8000000b: 0x8020800,
	            0x8000000c: 0x0,
	            0x8000000d: 0x8020020,
	            0x8000000e: 0x8000800,
	            0x8000000f: 0x20000,
	            0x10: 0x20820,
	            0x11: 0x8020800,
	            0x12: 0x20,
	            0x13: 0x800,
	            0x14: 0x8000800,
	            0x15: 0x8000020,
	            0x16: 0x8020020,
	            0x17: 0x20000,
	            0x18: 0x0,
	            0x19: 0x20020,
	            0x1a: 0x8020000,
	            0x1b: 0x8000820,
	            0x1c: 0x8020820,
	            0x1d: 0x20800,
	            0x1e: 0x820,
	            0x1f: 0x8000000,
	            0x80000010: 0x20000,
	            0x80000011: 0x800,
	            0x80000012: 0x8020020,
	            0x80000013: 0x20820,
	            0x80000014: 0x20,
	            0x80000015: 0x8020000,
	            0x80000016: 0x8000000,
	            0x80000017: 0x8000820,
	            0x80000018: 0x8020820,
	            0x80000019: 0x8000020,
	            0x8000001a: 0x8000800,
	            0x8000001b: 0x0,
	            0x8000001c: 0x20800,
	            0x8000001d: 0x820,
	            0x8000001e: 0x20020,
	            0x8000001f: 0x8020800
	        }
	    ];

	    // Masks that select the SBOX input
	    var SBOX_MASK = [
	        0xf8000001, 0x1f800000, 0x01f80000, 0x001f8000,
	        0x0001f800, 0x00001f80, 0x000001f8, 0x8000001f
	    ];

	    /**
	     * DES block cipher algorithm.
	     */
	    var DES = C_algo.DES = BlockCipher.extend({
	        _doReset: function () {
	            // Shortcuts
	            var key = this._key;
	            var keyWords = key.words;

	            // Select 56 bits according to PC1
	            var keyBits = [];
	            for (var i = 0; i < 56; i++) {
	                var keyBitPos = PC1[i] - 1;
	                keyBits[i] = (keyWords[keyBitPos >>> 5] >>> (31 - keyBitPos % 32)) & 1;
	            }

	            // Assemble 16 subkeys
	            var subKeys = this._subKeys = [];
	            for (var nSubKey = 0; nSubKey < 16; nSubKey++) {
	                // Create subkey
	                var subKey = subKeys[nSubKey] = [];

	                // Shortcut
	                var bitShift = BIT_SHIFTS[nSubKey];

	                // Select 48 bits according to PC2
	                for (var i = 0; i < 24; i++) {
	                    // Select from the left 28 key bits
	                    subKey[(i / 6) | 0] |= keyBits[((PC2[i] - 1) + bitShift) % 28] << (31 - i % 6);

	                    // Select from the right 28 key bits
	                    subKey[4 + ((i / 6) | 0)] |= keyBits[28 + (((PC2[i + 24] - 1) + bitShift) % 28)] << (31 - i % 6);
	                }

	                // Since each subkey is applied to an expanded 32-bit input,
	                // the subkey can be broken into 8 values scaled to 32-bits,
	                // which allows the key to be used without expansion
	                subKey[0] = (subKey[0] << 1) | (subKey[0] >>> 31);
	                for (var i = 1; i < 7; i++) {
	                    subKey[i] = subKey[i] >>> ((i - 1) * 4 + 3);
	                }
	                subKey[7] = (subKey[7] << 5) | (subKey[7] >>> 27);
	            }

	            // Compute inverse subkeys
	            var invSubKeys = this._invSubKeys = [];
	            for (var i = 0; i < 16; i++) {
	                invSubKeys[i] = subKeys[15 - i];
	            }
	        },

	        encryptBlock: function (M, offset) {
	            this._doCryptBlock(M, offset, this._subKeys);
	        },

	        decryptBlock: function (M, offset) {
	            this._doCryptBlock(M, offset, this._invSubKeys);
	        },

	        _doCryptBlock: function (M, offset, subKeys) {
	            // Get input
	            this._lBlock = M[offset];
	            this._rBlock = M[offset + 1];

	            // Initial permutation
	            exchangeLR.call(this, 4,  0x0f0f0f0f);
	            exchangeLR.call(this, 16, 0x0000ffff);
	            exchangeRL.call(this, 2,  0x33333333);
	            exchangeRL.call(this, 8,  0x00ff00ff);
	            exchangeLR.call(this, 1,  0x55555555);

	            // Rounds
	            for (var round = 0; round < 16; round++) {
	                // Shortcuts
	                var subKey = subKeys[round];
	                var lBlock = this._lBlock;
	                var rBlock = this._rBlock;

	                // Feistel function
	                var f = 0;
	                for (var i = 0; i < 8; i++) {
	                    f |= SBOX_P[i][((rBlock ^ subKey[i]) & SBOX_MASK[i]) >>> 0];
	                }
	                this._lBlock = rBlock;
	                this._rBlock = lBlock ^ f;
	            }

	            // Undo swap from last round
	            var t = this._lBlock;
	            this._lBlock = this._rBlock;
	            this._rBlock = t;

	            // Final permutation
	            exchangeLR.call(this, 1,  0x55555555);
	            exchangeRL.call(this, 8,  0x00ff00ff);
	            exchangeRL.call(this, 2,  0x33333333);
	            exchangeLR.call(this, 16, 0x0000ffff);
	            exchangeLR.call(this, 4,  0x0f0f0f0f);

	            // Set output
	            M[offset] = this._lBlock;
	            M[offset + 1] = this._rBlock;
	        },

	        keySize: 64/32,

	        ivSize: 64/32,

	        blockSize: 64/32
	    });

	    // Swap bits across the left and right words
	    function exchangeLR(offset, mask) {
	        var t = ((this._lBlock >>> offset) ^ this._rBlock) & mask;
	        this._rBlock ^= t;
	        this._lBlock ^= t << offset;
	    }

	    function exchangeRL(offset, mask) {
	        var t = ((this._rBlock >>> offset) ^ this._lBlock) & mask;
	        this._lBlock ^= t;
	        this._rBlock ^= t << offset;
	    }

	    /**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.DES.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.DES.decrypt(ciphertext, key, cfg);
	     */
	    C.DES = BlockCipher._createHelper(DES);

	    /**
	     * Triple-DES block cipher algorithm.
	     */
	    var TripleDES = C_algo.TripleDES = BlockCipher.extend({
	        _doReset: function () {
	            // Shortcuts
	            var key = this._key;
	            var keyWords = key.words;

	            // Create DES instances
	            this._des1 = DES.createEncryptor(WordArray.create(keyWords.slice(0, 2)));
	            this._des2 = DES.createEncryptor(WordArray.create(keyWords.slice(2, 4)));
	            this._des3 = DES.createEncryptor(WordArray.create(keyWords.slice(4, 6)));
	        },

	        encryptBlock: function (M, offset) {
	            this._des1.encryptBlock(M, offset);
	            this._des2.decryptBlock(M, offset);
	            this._des3.encryptBlock(M, offset);
	        },

	        decryptBlock: function (M, offset) {
	            this._des3.decryptBlock(M, offset);
	            this._des2.encryptBlock(M, offset);
	            this._des1.decryptBlock(M, offset);
	        },

	        keySize: 192/32,

	        ivSize: 64/32,

	        blockSize: 64/32
	    });

	    /**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.TripleDES.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.TripleDES.decrypt(ciphertext, key, cfg);
	     */
	    C.TripleDES = BlockCipher._createHelper(TripleDES);
	}());


	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var StreamCipher = C_lib.StreamCipher;
	    var C_algo = C.algo;

	    /**
	     * RC4 stream cipher algorithm.
	     */
	    var RC4 = C_algo.RC4 = StreamCipher.extend({
	        _doReset: function () {
	            // Shortcuts
	            var key = this._key;
	            var keyWords = key.words;
	            var keySigBytes = key.sigBytes;

	            // Init sbox
	            var S = this._S = [];
	            for (var i = 0; i < 256; i++) {
	                S[i] = i;
	            }

	            // Key setup
	            for (var i = 0, j = 0; i < 256; i++) {
	                var keyByteIndex = i % keySigBytes;
	                var keyByte = (keyWords[keyByteIndex >>> 2] >>> (24 - (keyByteIndex % 4) * 8)) & 0xff;

	                j = (j + S[i] + keyByte) % 256;

	                // Swap
	                var t = S[i];
	                S[i] = S[j];
	                S[j] = t;
	            }

	            // Counters
	            this._i = this._j = 0;
	        },

	        _doProcessBlock: function (M, offset) {
	            M[offset] ^= generateKeystreamWord.call(this);
	        },

	        keySize: 256/32,

	        ivSize: 0
	    });

	    function generateKeystreamWord() {
	        // Shortcuts
	        var S = this._S;
	        var i = this._i;
	        var j = this._j;

	        // Generate keystream word
	        var keystreamWord = 0;
	        for (var n = 0; n < 4; n++) {
	            i = (i + 1) % 256;
	            j = (j + S[i]) % 256;

	            // Swap
	            var t = S[i];
	            S[i] = S[j];
	            S[j] = t;

	            keystreamWord |= S[(S[i] + S[j]) % 256] << (24 - n * 8);
	        }

	        // Update counters
	        this._i = i;
	        this._j = j;

	        return keystreamWord;
	    }

	    /**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.RC4.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.RC4.decrypt(ciphertext, key, cfg);
	     */
	    C.RC4 = StreamCipher._createHelper(RC4);

	    /**
	     * Modified RC4 stream cipher algorithm.
	     */
	    var RC4Drop = C_algo.RC4Drop = RC4.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {number} drop The number of keystream words to drop. Default 192
	         */
	        cfg: RC4.cfg.extend({
	            drop: 192
	        }),

	        _doReset: function () {
	            RC4._doReset.call(this);

	            // Drop
	            for (var i = this.cfg.drop; i > 0; i--) {
	                generateKeystreamWord.call(this);
	            }
	        }
	    });

	    /**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.RC4Drop.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.RC4Drop.decrypt(ciphertext, key, cfg);
	     */
	    C.RC4Drop = StreamCipher._createHelper(RC4Drop);
	}());


	/** @preserve
	 * Counter block mode compatible with  Dr Brian Gladman fileenc.c
	 * derived from CryptoJS.mode.CTR
	 * Jan Hruby jhruby.web@gmail.com
	 */
	CryptoJS.mode.CTRGladman = (function () {
	    var CTRGladman = CryptoJS.lib.BlockCipherMode.extend();

		function incWord(word)
		{
			if (((word >> 24) & 0xff) === 0xff) { //overflow
			var b1 = (word >> 16)&0xff;
			var b2 = (word >> 8)&0xff;
			var b3 = word & 0xff;

			if (b1 === 0xff) // overflow b1
			{
			b1 = 0;
			if (b2 === 0xff)
			{
				b2 = 0;
				if (b3 === 0xff)
				{
					b3 = 0;
				}
				else
				{
					++b3;
				}
			}
			else
			{
				++b2;
			}
			}
			else
			{
			++b1;
			}

			word = 0;
			word += (b1 << 16);
			word += (b2 << 8);
			word += b3;
			}
			else
			{
			word += (0x01 << 24);
			}
			return word;
		}

		function incCounter(counter)
		{
			if ((counter[0] = incWord(counter[0])) === 0)
			{
				// encr_data in fileenc.c from  Dr Brian Gladman's counts only with DWORD j < 8
				counter[1] = incWord(counter[1]);
			}
			return counter;
		}

	    var Encryptor = CTRGladman.Encryptor = CTRGladman.extend({
	        processBlock: function (words, offset) {
	            // Shortcuts
	            var cipher = this._cipher
	            var blockSize = cipher.blockSize;
	            var iv = this._iv;
	            var counter = this._counter;

	            // Generate keystream
	            if (iv) {
	                counter = this._counter = iv.slice(0);

	                // Remove IV for subsequent blocks
	                this._iv = undefined;
	            }

				incCounter(counter);

				var keystream = counter.slice(0);
	            cipher.encryptBlock(keystream, 0);

	            // Encrypt
	            for (var i = 0; i < blockSize; i++) {
	                words[offset + i] ^= keystream[i];
	            }
	        }
	    });

	    CTRGladman.Decryptor = Encryptor;

	    return CTRGladman;
	}());




	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var StreamCipher = C_lib.StreamCipher;
	    var C_algo = C.algo;

	    // Reusable objects
	    var S  = [];
	    var C_ = [];
	    var G  = [];

	    /**
	     * Rabbit stream cipher algorithm
	     */
	    var Rabbit = C_algo.Rabbit = StreamCipher.extend({
	        _doReset: function () {
	            // Shortcuts
	            var K = this._key.words;
	            var iv = this.cfg.iv;

	            // Swap endian
	            for (var i = 0; i < 4; i++) {
	                K[i] = (((K[i] << 8)  | (K[i] >>> 24)) & 0x00ff00ff) |
	                       (((K[i] << 24) | (K[i] >>> 8))  & 0xff00ff00);
	            }

	            // Generate initial state values
	            var X = this._X = [
	                K[0], (K[3] << 16) | (K[2] >>> 16),
	                K[1], (K[0] << 16) | (K[3] >>> 16),
	                K[2], (K[1] << 16) | (K[0] >>> 16),
	                K[3], (K[2] << 16) | (K[1] >>> 16)
	            ];

	            // Generate initial counter values
	            var C = this._C = [
	                (K[2] << 16) | (K[2] >>> 16), (K[0] & 0xffff0000) | (K[1] & 0x0000ffff),
	                (K[3] << 16) | (K[3] >>> 16), (K[1] & 0xffff0000) | (K[2] & 0x0000ffff),
	                (K[0] << 16) | (K[0] >>> 16), (K[2] & 0xffff0000) | (K[3] & 0x0000ffff),
	                (K[1] << 16) | (K[1] >>> 16), (K[3] & 0xffff0000) | (K[0] & 0x0000ffff)
	            ];

	            // Carry bit
	            this._b = 0;

	            // Iterate the system four times
	            for (var i = 0; i < 4; i++) {
	                nextState.call(this);
	            }

	            // Modify the counters
	            for (var i = 0; i < 8; i++) {
	                C[i] ^= X[(i + 4) & 7];
	            }

	            // IV setup
	            if (iv) {
	                // Shortcuts
	                var IV = iv.words;
	                var IV_0 = IV[0];
	                var IV_1 = IV[1];

	                // Generate four subvectors
	                var i0 = (((IV_0 << 8) | (IV_0 >>> 24)) & 0x00ff00ff) | (((IV_0 << 24) | (IV_0 >>> 8)) & 0xff00ff00);
	                var i2 = (((IV_1 << 8) | (IV_1 >>> 24)) & 0x00ff00ff) | (((IV_1 << 24) | (IV_1 >>> 8)) & 0xff00ff00);
	                var i1 = (i0 >>> 16) | (i2 & 0xffff0000);
	                var i3 = (i2 << 16)  | (i0 & 0x0000ffff);

	                // Modify counter values
	                C[0] ^= i0;
	                C[1] ^= i1;
	                C[2] ^= i2;
	                C[3] ^= i3;
	                C[4] ^= i0;
	                C[5] ^= i1;
	                C[6] ^= i2;
	                C[7] ^= i3;

	                // Iterate the system four times
	                for (var i = 0; i < 4; i++) {
	                    nextState.call(this);
	                }
	            }
	        },

	        _doProcessBlock: function (M, offset) {
	            // Shortcut
	            var X = this._X;

	            // Iterate the system
	            nextState.call(this);

	            // Generate four keystream words
	            S[0] = X[0] ^ (X[5] >>> 16) ^ (X[3] << 16);
	            S[1] = X[2] ^ (X[7] >>> 16) ^ (X[5] << 16);
	            S[2] = X[4] ^ (X[1] >>> 16) ^ (X[7] << 16);
	            S[3] = X[6] ^ (X[3] >>> 16) ^ (X[1] << 16);

	            for (var i = 0; i < 4; i++) {
	                // Swap endian
	                S[i] = (((S[i] << 8)  | (S[i] >>> 24)) & 0x00ff00ff) |
	                       (((S[i] << 24) | (S[i] >>> 8))  & 0xff00ff00);

	                // Encrypt
	                M[offset + i] ^= S[i];
	            }
	        },

	        blockSize: 128/32,

	        ivSize: 64/32
	    });

	    function nextState() {
	        // Shortcuts
	        var X = this._X;
	        var C = this._C;

	        // Save old counter values
	        for (var i = 0; i < 8; i++) {
	            C_[i] = C[i];
	        }

	        // Calculate new counter values
	        C[0] = (C[0] + 0x4d34d34d + this._b) | 0;
	        C[1] = (C[1] + 0xd34d34d3 + ((C[0] >>> 0) < (C_[0] >>> 0) ? 1 : 0)) | 0;
	        C[2] = (C[2] + 0x34d34d34 + ((C[1] >>> 0) < (C_[1] >>> 0) ? 1 : 0)) | 0;
	        C[3] = (C[3] + 0x4d34d34d + ((C[2] >>> 0) < (C_[2] >>> 0) ? 1 : 0)) | 0;
	        C[4] = (C[4] + 0xd34d34d3 + ((C[3] >>> 0) < (C_[3] >>> 0) ? 1 : 0)) | 0;
	        C[5] = (C[5] + 0x34d34d34 + ((C[4] >>> 0) < (C_[4] >>> 0) ? 1 : 0)) | 0;
	        C[6] = (C[6] + 0x4d34d34d + ((C[5] >>> 0) < (C_[5] >>> 0) ? 1 : 0)) | 0;
	        C[7] = (C[7] + 0xd34d34d3 + ((C[6] >>> 0) < (C_[6] >>> 0) ? 1 : 0)) | 0;
	        this._b = (C[7] >>> 0) < (C_[7] >>> 0) ? 1 : 0;

	        // Calculate the g-values
	        for (var i = 0; i < 8; i++) {
	            var gx = X[i] + C[i];

	            // Construct high and low argument for squaring
	            var ga = gx & 0xffff;
	            var gb = gx >>> 16;

	            // Calculate high and low result of squaring
	            var gh = ((((ga * ga) >>> 17) + ga * gb) >>> 15) + gb * gb;
	            var gl = (((gx & 0xffff0000) * gx) | 0) + (((gx & 0x0000ffff) * gx) | 0);

	            // High XOR low
	            G[i] = gh ^ gl;
	        }

	        // Calculate new state values
	        X[0] = (G[0] + ((G[7] << 16) | (G[7] >>> 16)) + ((G[6] << 16) | (G[6] >>> 16))) | 0;
	        X[1] = (G[1] + ((G[0] << 8)  | (G[0] >>> 24)) + G[7]) | 0;
	        X[2] = (G[2] + ((G[1] << 16) | (G[1] >>> 16)) + ((G[0] << 16) | (G[0] >>> 16))) | 0;
	        X[3] = (G[3] + ((G[2] << 8)  | (G[2] >>> 24)) + G[1]) | 0;
	        X[4] = (G[4] + ((G[3] << 16) | (G[3] >>> 16)) + ((G[2] << 16) | (G[2] >>> 16))) | 0;
	        X[5] = (G[5] + ((G[4] << 8)  | (G[4] >>> 24)) + G[3]) | 0;
	        X[6] = (G[6] + ((G[5] << 16) | (G[5] >>> 16)) + ((G[4] << 16) | (G[4] >>> 16))) | 0;
	        X[7] = (G[7] + ((G[6] << 8)  | (G[6] >>> 24)) + G[5]) | 0;
	    }

	    /**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.Rabbit.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.Rabbit.decrypt(ciphertext, key, cfg);
	     */
	    C.Rabbit = StreamCipher._createHelper(Rabbit);
	}());


	/**
	 * Counter block mode.
	 */
	CryptoJS.mode.CTR = (function () {
	    var CTR = CryptoJS.lib.BlockCipherMode.extend();

	    var Encryptor = CTR.Encryptor = CTR.extend({
	        processBlock: function (words, offset) {
	            // Shortcuts
	            var cipher = this._cipher
	            var blockSize = cipher.blockSize;
	            var iv = this._iv;
	            var counter = this._counter;

	            // Generate keystream
	            if (iv) {
	                counter = this._counter = iv.slice(0);

	                // Remove IV for subsequent blocks
	                this._iv = undefined;
	            }
	            var keystream = counter.slice(0);
	            cipher.encryptBlock(keystream, 0);

	            // Increment counter
	            counter[blockSize - 1] = (counter[blockSize - 1] + 1) | 0

	            // Encrypt
	            for (var i = 0; i < blockSize; i++) {
	                words[offset + i] ^= keystream[i];
	            }
	        }
	    });

	    CTR.Decryptor = Encryptor;

	    return CTR;
	}());


	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var StreamCipher = C_lib.StreamCipher;
	    var C_algo = C.algo;

	    // Reusable objects
	    var S  = [];
	    var C_ = [];
	    var G  = [];

	    /**
	     * Rabbit stream cipher algorithm.
	     *
	     * This is a legacy version that neglected to convert the key to little-endian.
	     * This error doesn't affect the cipher's security,
	     * but it does affect its compatibility with other implementations.
	     */
	    var RabbitLegacy = C_algo.RabbitLegacy = StreamCipher.extend({
	        _doReset: function () {
	            // Shortcuts
	            var K = this._key.words;
	            var iv = this.cfg.iv;

	            // Generate initial state values
	            var X = this._X = [
	                K[0], (K[3] << 16) | (K[2] >>> 16),
	                K[1], (K[0] << 16) | (K[3] >>> 16),
	                K[2], (K[1] << 16) | (K[0] >>> 16),
	                K[3], (K[2] << 16) | (K[1] >>> 16)
	            ];

	            // Generate initial counter values
	            var C = this._C = [
	                (K[2] << 16) | (K[2] >>> 16), (K[0] & 0xffff0000) | (K[1] & 0x0000ffff),
	                (K[3] << 16) | (K[3] >>> 16), (K[1] & 0xffff0000) | (K[2] & 0x0000ffff),
	                (K[0] << 16) | (K[0] >>> 16), (K[2] & 0xffff0000) | (K[3] & 0x0000ffff),
	                (K[1] << 16) | (K[1] >>> 16), (K[3] & 0xffff0000) | (K[0] & 0x0000ffff)
	            ];

	            // Carry bit
	            this._b = 0;

	            // Iterate the system four times
	            for (var i = 0; i < 4; i++) {
	                nextState.call(this);
	            }

	            // Modify the counters
	            for (var i = 0; i < 8; i++) {
	                C[i] ^= X[(i + 4) & 7];
	            }

	            // IV setup
	            if (iv) {
	                // Shortcuts
	                var IV = iv.words;
	                var IV_0 = IV[0];
	                var IV_1 = IV[1];

	                // Generate four subvectors
	                var i0 = (((IV_0 << 8) | (IV_0 >>> 24)) & 0x00ff00ff) | (((IV_0 << 24) | (IV_0 >>> 8)) & 0xff00ff00);
	                var i2 = (((IV_1 << 8) | (IV_1 >>> 24)) & 0x00ff00ff) | (((IV_1 << 24) | (IV_1 >>> 8)) & 0xff00ff00);
	                var i1 = (i0 >>> 16) | (i2 & 0xffff0000);
	                var i3 = (i2 << 16)  | (i0 & 0x0000ffff);

	                // Modify counter values
	                C[0] ^= i0;
	                C[1] ^= i1;
	                C[2] ^= i2;
	                C[3] ^= i3;
	                C[4] ^= i0;
	                C[5] ^= i1;
	                C[6] ^= i2;
	                C[7] ^= i3;

	                // Iterate the system four times
	                for (var i = 0; i < 4; i++) {
	                    nextState.call(this);
	                }
	            }
	        },

	        _doProcessBlock: function (M, offset) {
	            // Shortcut
	            var X = this._X;

	            // Iterate the system
	            nextState.call(this);

	            // Generate four keystream words
	            S[0] = X[0] ^ (X[5] >>> 16) ^ (X[3] << 16);
	            S[1] = X[2] ^ (X[7] >>> 16) ^ (X[5] << 16);
	            S[2] = X[4] ^ (X[1] >>> 16) ^ (X[7] << 16);
	            S[3] = X[6] ^ (X[3] >>> 16) ^ (X[1] << 16);

	            for (var i = 0; i < 4; i++) {
	                // Swap endian
	                S[i] = (((S[i] << 8)  | (S[i] >>> 24)) & 0x00ff00ff) |
	                       (((S[i] << 24) | (S[i] >>> 8))  & 0xff00ff00);

	                // Encrypt
	                M[offset + i] ^= S[i];
	            }
	        },

	        blockSize: 128/32,

	        ivSize: 64/32
	    });

	    function nextState() {
	        // Shortcuts
	        var X = this._X;
	        var C = this._C;

	        // Save old counter values
	        for (var i = 0; i < 8; i++) {
	            C_[i] = C[i];
	        }

	        // Calculate new counter values
	        C[0] = (C[0] + 0x4d34d34d + this._b) | 0;
	        C[1] = (C[1] + 0xd34d34d3 + ((C[0] >>> 0) < (C_[0] >>> 0) ? 1 : 0)) | 0;
	        C[2] = (C[2] + 0x34d34d34 + ((C[1] >>> 0) < (C_[1] >>> 0) ? 1 : 0)) | 0;
	        C[3] = (C[3] + 0x4d34d34d + ((C[2] >>> 0) < (C_[2] >>> 0) ? 1 : 0)) | 0;
	        C[4] = (C[4] + 0xd34d34d3 + ((C[3] >>> 0) < (C_[3] >>> 0) ? 1 : 0)) | 0;
	        C[5] = (C[5] + 0x34d34d34 + ((C[4] >>> 0) < (C_[4] >>> 0) ? 1 : 0)) | 0;
	        C[6] = (C[6] + 0x4d34d34d + ((C[5] >>> 0) < (C_[5] >>> 0) ? 1 : 0)) | 0;
	        C[7] = (C[7] + 0xd34d34d3 + ((C[6] >>> 0) < (C_[6] >>> 0) ? 1 : 0)) | 0;
	        this._b = (C[7] >>> 0) < (C_[7] >>> 0) ? 1 : 0;

	        // Calculate the g-values
	        for (var i = 0; i < 8; i++) {
	            var gx = X[i] + C[i];

	            // Construct high and low argument for squaring
	            var ga = gx & 0xffff;
	            var gb = gx >>> 16;

	            // Calculate high and low result of squaring
	            var gh = ((((ga * ga) >>> 17) + ga * gb) >>> 15) + gb * gb;
	            var gl = (((gx & 0xffff0000) * gx) | 0) + (((gx & 0x0000ffff) * gx) | 0);

	            // High XOR low
	            G[i] = gh ^ gl;
	        }

	        // Calculate new state values
	        X[0] = (G[0] + ((G[7] << 16) | (G[7] >>> 16)) + ((G[6] << 16) | (G[6] >>> 16))) | 0;
	        X[1] = (G[1] + ((G[0] << 8)  | (G[0] >>> 24)) + G[7]) | 0;
	        X[2] = (G[2] + ((G[1] << 16) | (G[1] >>> 16)) + ((G[0] << 16) | (G[0] >>> 16))) | 0;
	        X[3] = (G[3] + ((G[2] << 8)  | (G[2] >>> 24)) + G[1]) | 0;
	        X[4] = (G[4] + ((G[3] << 16) | (G[3] >>> 16)) + ((G[2] << 16) | (G[2] >>> 16))) | 0;
	        X[5] = (G[5] + ((G[4] << 8)  | (G[4] >>> 24)) + G[3]) | 0;
	        X[6] = (G[6] + ((G[5] << 16) | (G[5] >>> 16)) + ((G[4] << 16) | (G[4] >>> 16))) | 0;
	        X[7] = (G[7] + ((G[6] << 8)  | (G[6] >>> 24)) + G[5]) | 0;
	    }

	    /**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.RabbitLegacy.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.RabbitLegacy.decrypt(ciphertext, key, cfg);
	     */
	    C.RabbitLegacy = StreamCipher._createHelper(RabbitLegacy);
	}());


	/**
	 * Zero padding strategy.
	 */
	CryptoJS.pad.ZeroPadding = {
	    pad: function (data, blockSize) {
	        // Shortcut
	        var blockSizeBytes = blockSize * 4;

	        // Pad
	        data.clamp();
	        data.sigBytes += blockSizeBytes - ((data.sigBytes % blockSizeBytes) || blockSizeBytes);
	    },

	    unpad: function (data) {
	        // Shortcut
	        var dataWords = data.words;

	        // Unpad
	        var i = data.sigBytes - 1;
	        while (!((dataWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff)) {
	            i--;
	        }
	        data.sigBytes = i + 1;
	    }
	};


	return CryptoJS;

}));!function(){function A(){"use strict";function A(A){return r(self,{},A)}function e(){return 8200}var r=function(A,e,r){"use asm";var n=new A.Int32Array(r),t=A.Math.imul,i=new A.Int8Array(r),a=new A.Uint8Array(r);function o(A,e,r,o,u,c,s){A=A|0;e=e|0;r=r|0;o=o|0;u=u|0;c=c|0;s=s|0;var l=0,w=0,h=0,v=0,d=0,y=0,p=0,g=0,b=0,m=0,M=0,k=0,U=0,L=0,I=0,x=0,E=0,D=0,K=0,R=0,B=0,F=0,O=0,_=0,C=0,H=0,j=0,q=0,G=0,N=0,P=0,S=0;C=e<<7;q=e<<5;N=o+C|0;M=o+(e<<8)|0;if(u|0){A:do if(c>>>0<s>>>0){k=C+-64|0;U=o+k|0;L=A+-1|0;I=q&1073741792;x=N+k|0;if(!I){b=c;while(1){f(o,N,e);f(N,o,e);b=b+2|0;if(b>>>0>=s>>>0)break A}}else g=c;do{_=M+((t(n[U>>2]&L,q)|0)<<2)|0;v=0;do{H=o+(v<<2)|0;n[H>>2]=n[H>>2]^n[_+(v<<2)>>2];v=v+1|0}while((v|0)!=(I|0));f(o,N,e);j=M+((t(n[x>>2]&L,q)|0)<<2)|0;d=0;do{G=N+(d<<2)|0;n[G>>2]=n[G>>2]^n[j+(d<<2)>>2];d=d+1|0}while((d|0)!=(I|0));f(N,o,e);g=g+2|0}while(g>>>0<s>>>0)}while(0);if((s|0)==(A|0)&(q|0)!=0)m=0;else return;do{P=r+(m<<2)|0;S=n[o+(m<<2)>>2]|0;i[P>>0]=S;i[P+1>>0]=S>>>8;i[P+2>>0]=S>>>16;i[P+3>>0]=S>>>24;m=m+1|0}while((m|0)!=(q|0));return}if((c|0)==0&(q|0)!=0){p=0;do{E=r+(p<<2)|0;n[o+(p<<2)>>2]=(a[E+1>>0]|0)<<8|(a[E>>0]|0)|(a[E+2>>0]|0)<<16|(a[E+3>>0]|0)<<24;p=p+1|0}while((p|0)!=(q|0))}D=t(q,c)|0;K=t(q,s)|0;if(D>>>0>=K>>>0)return;R=q&1073741792;if(!R){w=D;do{f(o,N,e);w=w+q+q|0;f(N,o,e)}while(w>>>0<K>>>0);return}else l=D;do{B=M+(l<<2)|0;h=0;do{n[B+(h<<2)>>2]=n[o+(h<<2)>>2];h=h+1|0}while((h|0)!=(R|0));F=l+q|0;f(o,N,e);O=M+(F<<2)|0;y=0;do{n[O+(y<<2)>>2]=n[N+(y<<2)>>2];y=y+1|0}while((y|0)!=(R|0));l=F+q|0;f(N,o,e)}while(l>>>0<K>>>0);return}function f(A,e,r){A=A|0;e=e|0;r=r|0;var t=0,i=0,a=0,o=0,f=0,u=0,c=0,s=0,l=0,w=0,h=0,v=0,d=0,y=0,p=0,g=0,b=0,m=0,M=0,k=0,U=0,L=0,I=0,x=0,E=0,D=0,K=0,R=0,B=0,F=0,O=0,_=0,C=0,H=0,j=0,q=0,G=0,N=0,P=0,S=0,V=0,Z=0,Q=0,T=0,J=0,Y=0,W=0,z=0,X=0,$=0,AA=0,eA=0,rA=0,nA=0,tA=0,iA=0,aA=0,oA=0,fA=0,uA=0,cA=0,sA=0,lA=0,wA=0,hA=0,vA=0,dA=0,yA=0,pA=0,gA=0,bA=0,mA=0,MA=0,kA=0,UA=0,LA=0,IA=0,xA=0,EA=0,DA=0,KA=0,RA=0,BA=0,FA=0,OA=0,_A=0,CA=0,HA=0,jA=0,qA=0,GA=0,NA=0,PA=0,SA=0,VA=0,ZA=0,QA=0,TA=0,JA=0,YA=0,WA=0,zA=0,XA=0,$A=0,Ae=0,ee=0,re=0,ne=0,te=0,ie=0,ae=0,oe=0,fe=0,ue=0,ce=0,se=0,le=0,we=0,he=0,ve=0,de=0,ye=0,pe=0,ge=0,be=0,me=0,Me=0,ke=0,Ue=0,Le=0,Ie=0,xe=0,Ee=0,De=0,Ke=0,Re=0,Be=0,Fe=0,Oe=0,_e=0,Ce=0,He=0,je=0,qe=0,Ge=0,Ne=0,Pe=0,Se=0,Ve=0,Ze=0,Qe=0,Te=0,Je=0,Ye=0,We=0,ze=0,Xe=0,$e=0,Ar=0,er=0,rr=0,nr=0,tr=0,ir=0,ar=0,or=0,fr=0,ur=0,cr=0,sr=0,lr=0,wr=0,hr=0,vr=0,dr=0,yr=0,pr=0,gr=0,br=0,mr=0,Mr=0,kr=0,Ur=0,Lr=0,Ir=0,xr=0,Er=0,Dr=0,Kr=0,Rr=0,Br=0,Fr=0,Or=0,_r=0,Cr=0,Hr=0,jr=0,qr=0,Gr=0,Nr=0,Pr=0,Sr=0,Vr=0,Zr=0,Qr=0,Tr=0,Jr=0,Yr=0,Wr=0,zr=0,Xr=0,$r=0,An=0,en=0,rn=0,nn=0,tn=0,an=0,on=0,fn=0,un=0,cn=0,sn=0,ln=0,wn=0,hn=0,vn=0,dn=0,yn=0,pn=0,gn=0,bn=0,mn=0,Mn=0,kn=0,Un=0,Ln=0,In=0,xn=0,En=0,Dn=0,Kn=0,Rn=0,Bn=0,Fn=0,On=0,_n=0,Cn=0,Hn=0,jn=0,qn=0,Gn=0,Nn=0,Pn=0,Sn=0,Vn=0,Zn=0,Qn=0,Tn=0,Jn=0,Yn=0,Wn=0,zn=0,Xn=0,$n=0,At=0,et=0,rt=0,nt=0,tt=0,it=0,at=0,ot=0,ft=0,ut=0,ct=0,st=0,lt=0,wt=0,ht=0,vt=0,dt=0,yt=0,pt=0,gt=0,bt=0,mt=0,Mt=0,kt=0,Ut=0,Lt=0,It=0,xt=0,Et=0,Dt=0,Kt=0,Rt=0,Bt=0,Ft=0,Ot=0,_t=0,Ct=0,Ht=0,jt=0,qt=0,Gt=0,Nt=0,Pt=0,St=0,Vt=0,Zt=0,Qt=0,Tt=0,Jt=0,Yt=0,Wt=0,zt=0,Xt=0,$t=0,Ai=0,ei=0,ri=0,ni=0,ti=0,ii=0,ai=0,oi=0,fi=0,ui=0,ci=0,si=0,li=0,wi=0,hi=0,vi=0,di=0,yi=0,pi=0,gi=0,bi=0,mi=0,Mi=0,ki=0,Ui=0,Li=0,Ii=0,xi=0,Ei=0,Di=0,Ki=0,Ri=0,Bi=0,Fi=0,Oi=0,_i=0,Ci=0,Hi=0,ji=0,qi=0,Gi=0,Ni=0,Pi=0,Si=0,Vi=0,Zi=0,Qi=0,Ti=0,Ji=0,Yi=0,Wi=0,zi=0,Xi=0,$i=0,Aa=0,ea=0,ra=0,na=0,ta=0,ia=0,aa=0,oa=0,fa=0,ua=0,ca=0,sa=0,la=0,wa=0,ha=0,va=0,da=0,ya=0,pa=0,ga=0,ba=0,ma=0,Ma=0,ka=0,Ua=0,La=0,Ia=0,xa=0,Ea=0,Da=0,Ka=0,Ra=0,Ba=0,Fa=0,Oa=0,_a=0,Ca=0,Ha=0,ja=0,qa=0,Ga=0,Na=0,Pa=0,Sa=0,Va=0,Za=0,Qa=0,Ta=0,Ja=0,Ya=0,Wa=0,za=0,Xa=0,$a=0,Ao=0,eo=0,ro=0,no=0,to=0,io=0,ao=0,oo=0,fo=0,uo=0,co=0,so=0,lo=0,wo=0,ho=0,vo=0,yo=0,po=0,go=0,bo=0,mo=0,Mo=0,ko=0,Uo=0,Lo=0,Io=0,xo=0,Eo=0,Do=0,Ko=0,Ro=0,Bo=0,Fo=0,Oo=0,_o=0,Co=0,Ho=0,jo=0,qo=0,Go=0,No=0,Po=0,So=0,Vo=0,Zo=0,Qo=0,To=0,Jo=0,Yo=0,Wo=0,zo=0,Xo=0,$o=0,Af=0,ef=0,rf=0,nf=0,tf=0,af=0,of=0,ff=0,uf=0,cf=0,sf=0,lf=0,wf=0,hf=0,vf=0,df=0,yf=0,pf=0,gf=0,bf=0,mf=0,Mf=0,kf=0,Uf=0,Lf=0,If=0,xf=0,Ef=0,Df=0,Kf=0,Rf=0,Bf=0,Ff=0,Of=0,_f=0,Cf=0,Hf=0,jf=0,qf=0,Gf=0,Nf=0,Pf=0,Sf=0,Vf=0,Zf=0,Qf=0,Tf=0,Jf=0,Yf=0,Wf=0,zf=0,Xf=0,$f=0,Au=0,eu=0,ru=0,nu=0,tu=0,iu=0,au=0,ou=0,fu=0,uu=0,cu=0,su=0,lu=0,wu=0,hu=0,vu=0,du=0,yu=0,pu=0,gu=0,bu=0,mu=0,Mu=0,ku=0,Uu=0,Lu=0,Iu=0,xu=0,Eu=0,Du=0,Ku=0,Ru=0,Bu=0,Fu=0,Ou=0,_u=0,Cu=0,Hu=0,ju=0,qu=0,Gu=0,Nu=0,Pu=0,Su=0,Vu=0;ct=r<<1;Ba=A+((r<<5)+-16<<2)|0;if(!ct)return;Tt=r<<4;t=n[Ba>>2]|0;i=n[Ba+4>>2]|0;a=n[Ba+8>>2]|0;o=n[Ba+12>>2]|0;f=n[Ba+16>>2]|0;u=n[Ba+20>>2]|0;c=n[Ba+24>>2]|0;s=n[Ba+28>>2]|0;l=n[Ba+32>>2]|0;w=n[Ba+36>>2]|0;h=n[Ba+40>>2]|0;v=n[Ba+44>>2]|0;d=n[Ba+48>>2]|0;y=n[Ba+52>>2]|0;p=n[Ba+56>>2]|0;g=n[Ba+60>>2]|0;b=0;do{Xt=b<<4;ni=A+(Xt<<2)|0;li=n[ni>>2]^t;Li=n[ni+4>>2]^i;ji=n[ni+8>>2]^a;zi=n[ni+12>>2]^o;ca=n[ni+16>>2]^f;ka=n[ni+20>>2]^u;Ha=n[ni+24>>2]^c;Wa=n[ni+28>>2]^s;fo=n[ni+32>>2]^l;mo=n[ni+36>>2]^w;Bo=n[ni+40>>2]^h;Wo=n[ni+44>>2]^v;ff=n[ni+48>>2]^d;gf=n[ni+52>>2]^y;Bf=n[ni+56>>2]^p;Zf=n[ni+60>>2]^g;Wf=ff+li|0;wu=(Wf<<7|Wf>>>25)^ca;pu=wu+li|0;_u=(pu<<9|pu>>>23)^fo;Gu=_u+wu|0;F=(Gu<<13|Gu>>>19)^ff;j=F+_u|0;eA=(j<<18|j>>>14)^li;aA=ka+Li|0;kA=mo^(aA<<7|aA>>>25);EA=kA+ka|0;ZA=gf^(EA<<9|EA>>>23);WA=ZA+kA|0;we=(WA<<13|WA>>>19)^Li;pe=we+ZA|0;_e=(pe<<18|pe>>>14)^ka;Ge=Bo+Ha|0;nr=Bf^(Ge<<7|Ge>>>25);fr=nr+Bo|0;Lr=(fr<<9|fr>>>23)^ji;Kr=Lr+nr|0;Zr=(Kr<<13|Kr>>>19)^Ha;Yr=Zr+Lr|0;en=(Yr<<18|Yr>>>14)^Bo;rn=Zf+Wo|0;nn=(rn<<7|rn>>>25)^zi;tn=nn+Zf|0;an=(tn<<9|tn>>>23)^Wa;on=an+nn|0;fn=(on<<13|on>>>19)^Wo;un=fn+an|0;cn=(un<<18|un>>>14)^Zf;sn=eA+nn|0;ln=(sn<<7|sn>>>25)^we;wn=ln+eA|0;hn=(wn<<9|wn>>>23)^Lr;vn=hn+ln|0;dn=(vn<<13|vn>>>19)^nn;yn=dn+hn|0;pn=(yn<<18|yn>>>14)^eA;gn=_e+wu|0;bn=(gn<<7|gn>>>25)^Zr;mn=bn+_e|0;Mn=(mn<<9|mn>>>23)^an;kn=Mn+bn|0;Un=(kn<<13|kn>>>19)^wu;Ln=Un+Mn|0;In=(Ln<<18|Ln>>>14)^_e;xn=en+kA|0;En=(xn<<7|xn>>>25)^fn;Dn=En+en|0;Kn=(Dn<<9|Dn>>>23)^_u;Rn=Kn+En|0;Bn=(Rn<<13|Rn>>>19)^kA;Fn=Bn+Kn|0;On=(Fn<<18|Fn>>>14)^en;_n=cn+nr|0;Cn=(_n<<7|_n>>>25)^F;Hn=Cn+cn|0;jn=(Hn<<9|Hn>>>23)^ZA;qn=jn+Cn|0;Gn=(qn<<13|qn>>>19)^nr;Nn=Gn+jn|0;Pn=(Nn<<18|Nn>>>14)^cn;Sn=pn+Cn|0;Vn=(Sn<<7|Sn>>>25)^Un;Zn=Vn+pn|0;Qn=(Zn<<9|Zn>>>23)^Kn;Tn=Qn+Vn|0;Jn=(Tn<<13|Tn>>>19)^Cn;Yn=Jn+Qn|0;Wn=(Yn<<18|Yn>>>14)^pn;zn=In+ln|0;Xn=(zn<<7|zn>>>25)^Bn;$n=Xn+In|0;At=($n<<9|$n>>>23)^jn;et=At+Xn|0;rt=(et<<13|et>>>19)^ln;nt=rt+At|0;tt=(nt<<18|nt>>>14)^In;it=On+bn|0;at=(it<<7|it>>>25)^Gn;ot=at+On|0;ft=(ot<<9|ot>>>23)^hn;ut=ft+at|0;st=(ut<<13|ut>>>19)^bn;lt=st+ft|0;wt=(lt<<18|lt>>>14)^On;ht=Pn+En|0;vt=(ht<<7|ht>>>25)^dn;dt=vt+Pn|0;yt=(dt<<9|dt>>>23)^Mn;pt=yt+vt|0;gt=(pt<<13|pt>>>19)^En;bt=gt+yt|0;mt=(bt<<18|bt>>>14)^Pn;Mt=Wn+vt|0;kt=(Mt<<7|Mt>>>25)^rt;Ut=kt+Wn|0;Lt=(Ut<<9|Ut>>>23)^ft;It=Lt+kt|0;xt=(It<<13|It>>>19)^vt;Et=xt+Lt|0;Dt=(Et<<18|Et>>>14)^Wn;Kt=tt+Vn|0;Rt=(Kt<<7|Kt>>>25)^st;Bt=Rt+tt|0;Ft=(Bt<<9|Bt>>>23)^yt;Ot=Ft+Rt|0;_t=(Ot<<13|Ot>>>19)^Vn;Ct=_t+Ft|0;Ht=(Ct<<18|Ct>>>14)^tt;jt=wt+Xn|0;qt=(jt<<7|jt>>>25)^gt;Gt=qt+wt|0;Nt=(Gt<<9|Gt>>>23)^Qn;Pt=Nt+qt|0;St=(Pt<<13|Pt>>>19)^Xn;Vt=St+Nt|0;Zt=(Vt<<18|Vt>>>14)^wt;Qt=mt+at|0;Jt=(Qt<<7|Qt>>>25)^Jn;Yt=Jt+mt|0;Wt=(Yt<<9|Yt>>>23)^At;zt=Wt+Jt|0;$t=(zt<<13|zt>>>19)^at;Ai=$t+Wt|0;ei=(Ai<<18|Ai>>>14)^mt;ri=Dt+Jt|0;ti=(ri<<7|ri>>>25)^_t;ii=ti+Dt|0;ai=(ii<<9|ii>>>23)^Nt;oi=ai+ti|0;fi=(oi<<13|oi>>>19)^Jt;ui=fi+ai|0;ci=(ui<<18|ui>>>14)^Dt;si=Ht+kt|0;wi=(si<<7|si>>>25)^St;hi=wi+Ht|0;vi=(hi<<9|hi>>>23)^Wt;di=vi+wi|0;yi=(di<<13|di>>>19)^kt;pi=yi+vi|0;gi=(pi<<18|pi>>>14)^Ht;bi=Zt+Rt|0;mi=(bi<<7|bi>>>25)^$t;Mi=mi+Zt|0;ki=(Mi<<9|Mi>>>23)^Lt;Ui=ki+mi|0;Ii=(Ui<<13|Ui>>>19)^Rt;xi=Ii+ki|0;Ei=(xi<<18|xi>>>14)^Zt;Di=ei+qt|0;Ki=(Di<<7|Di>>>25)^xt;Ri=Ki+ei|0;Bi=(Ri<<9|Ri>>>23)^Ft;Fi=Bi+Ki|0;Oi=(Fi<<13|Fi>>>19)^qt;_i=Oi+Bi|0;Ci=(_i<<18|_i>>>14)^ei;Hi=ci+Ki|0;qi=(Hi<<7|Hi>>>25)^yi;Gi=qi+ci|0;Ni=(Gi<<9|Gi>>>23)^ki;Pi=Ni+qi|0;Si=(Pi<<13|Pi>>>19)^Ki;Vi=Si+Ni|0;Zi=(Vi<<18|Vi>>>14)^ci;Qi=gi+ti|0;Ti=(Qi<<7|Qi>>>25)^Ii;Ji=Ti+gi|0;Yi=(Ji<<9|Ji>>>23)^Bi;Wi=Yi+Ti|0;Xi=(Wi<<13|Wi>>>19)^ti;$i=Xi+Yi|0;Aa=($i<<18|$i>>>14)^gi;ea=Ei+wi|0;ra=(ea<<7|ea>>>25)^Oi;na=ra+Ei|0;ta=(na<<9|na>>>23)^ai;ia=ta+ra|0;aa=(ia<<13|ia>>>19)^wi;oa=aa+ta|0;fa=(oa<<18|oa>>>14)^Ei;ua=Ci+mi|0;sa=(ua<<7|ua>>>25)^fi;la=sa+Ci|0;wa=(la<<9|la>>>23)^vi;ha=wa+sa|0;va=(ha<<13|ha>>>19)^mi;da=va+wa|0;ya=(da<<18|da>>>14)^Ci;pa=Zi+sa|0;ga=(pa<<7|pa>>>25)^Xi;ba=ga+Zi|0;ma=(ba<<9|ba>>>23)^ta;Ma=ma+ga|0;Ua=(Ma<<13|Ma>>>19)^sa;La=Ua+ma|0;Ia=(La<<18|La>>>14)^Zi;xa=Aa+qi|0;Ea=(xa<<7|xa>>>25)^aa;Da=Ea+Aa|0;Ka=(Da<<9|Da>>>23)^wa;Ra=Ka+Ea|0;Fa=(Ra<<13|Ra>>>19)^qi;Oa=Fa+Ka|0;_a=(Oa<<18|Oa>>>14)^Aa;Ca=fa+Ti|0;ja=(Ca<<7|Ca>>>25)^va;qa=ja+fa|0;Ga=(qa<<9|qa>>>23)^Ni;Na=Ga+ja|0;Pa=(Na<<13|Na>>>19)^Ti;Sa=Pa+Ga|0;Va=(Sa<<18|Sa>>>14)^fa;Za=ya+ra|0;Qa=(Za<<7|Za>>>25)^Si;Ta=Qa+ya|0;Ja=(Ta<<9|Ta>>>23)^Yi;Ya=Ja+Qa|0;za=(Ya<<13|Ya>>>19)^ra;Xa=za+Ja|0;$a=(Xa<<18|Xa>>>14)^ya;Ao=Ia+Qa|0;eo=(Ao<<7|Ao>>>25)^Fa;ro=eo+Ia|0;no=(ro<<9|ro>>>23)^Ga;to=no+eo|0;io=(to<<13|to>>>19)^Qa;ao=io+no|0;oo=_a+ga|0;uo=(oo<<7|oo>>>25)^Pa;co=uo+_a|0;so=(co<<9|co>>>23)^Ja;lo=so+uo|0;wo=(lo<<13|lo>>>19)^ga;ho=wo+so|0;vo=Va+Ea|0;yo=(vo<<7|vo>>>25)^za;po=yo+Va|0;go=(po<<9|po>>>23)^ma;bo=go+yo|0;Mo=(bo<<13|bo>>>19)^Ea;ko=Mo+go|0;Uo=$a+ja|0;Lo=(Uo<<7|Uo>>>25)^Ua;Io=Lo+$a|0;xo=(Io<<9|Io>>>23)^Ka;Eo=xo+Lo|0;Do=(Eo<<13|Eo>>>19)^ja;Ko=Do+xo|0;Ro=((ao<<18|ao>>>14)^Ia)+li|0;Fo=eo+Li|0;Oo=no+ji|0;_o=io+zi|0;Co=wo+ca|0;Ho=((ho<<18|ho>>>14)^_a)+ka|0;jo=uo+Ha|0;qo=so+Wa|0;Go=go+fo|0;No=Mo+mo|0;Po=((ko<<18|ko>>>14)^Va)+Bo|0;So=yo+Wo|0;Vo=Lo+ff|0;Zo=xo+gf|0;Qo=Do+Bf|0;To=((Ko<<18|Ko>>>14)^$a)+Zf|0;Jo=b<<3;Yo=e+(Jo<<2)|0;n[Yo>>2]=Ro;n[Yo+4>>2]=Fo;n[Yo+8>>2]=Oo;n[Yo+12>>2]=_o;n[Yo+16>>2]=Co;n[Yo+20>>2]=Ho;n[Yo+24>>2]=jo;n[Yo+28>>2]=qo;n[Yo+32>>2]=Go;n[Yo+36>>2]=No;n[Yo+40>>2]=Po;n[Yo+44>>2]=So;n[Yo+48>>2]=Vo;n[Yo+52>>2]=Zo;n[Yo+56>>2]=Qo;n[Yo+60>>2]=To;zo=A+((Xt|16)<<2)|0;Xo=Ro^n[zo>>2];$o=Fo^n[zo+4>>2];Af=Oo^n[zo+8>>2];ef=_o^n[zo+12>>2];rf=Co^n[zo+16>>2];nf=Ho^n[zo+20>>2];tf=jo^n[zo+24>>2];af=qo^n[zo+28>>2];of=Go^n[zo+32>>2];uf=No^n[zo+36>>2];cf=Po^n[zo+40>>2];sf=So^n[zo+44>>2];lf=Vo^n[zo+48>>2];wf=Zo^n[zo+52>>2];hf=Qo^n[zo+56>>2];vf=To^n[zo+60>>2];df=Xo+lf|0;yf=(df<<7|df>>>25)^rf;pf=yf+Xo|0;bf=(pf<<9|pf>>>23)^of;mf=bf+yf|0;Mf=(mf<<13|mf>>>19)^lf;kf=Mf+bf|0;Uf=(kf<<18|kf>>>14)^Xo;Lf=nf+$o|0;If=(Lf<<7|Lf>>>25)^uf;xf=If+nf|0;Ef=(xf<<9|xf>>>23)^wf;Df=Ef+If|0;Kf=(Df<<13|Df>>>19)^$o;Rf=Kf+Ef|0;Ff=(Rf<<18|Rf>>>14)^nf;Of=cf+tf|0;_f=(Of<<7|Of>>>25)^hf;Cf=_f+cf|0;Hf=(Cf<<9|Cf>>>23)^Af;jf=Hf+_f|0;qf=(jf<<13|jf>>>19)^tf;Gf=qf+Hf|0;Nf=(Gf<<18|Gf>>>14)^cf;Pf=vf+sf|0;Sf=(Pf<<7|Pf>>>25)^ef;Vf=Sf+vf|0;Qf=(Vf<<9|Vf>>>23)^af;Tf=Qf+Sf|0;Jf=(Tf<<13|Tf>>>19)^sf;Yf=Jf+Qf|0;zf=(Yf<<18|Yf>>>14)^vf;Xf=Uf+Sf|0;$f=(Xf<<7|Xf>>>25)^Kf;Au=$f+Uf|0;eu=(Au<<9|Au>>>23)^Hf;ru=eu+$f|0;nu=(ru<<13|ru>>>19)^Sf;tu=nu+eu|0;iu=(tu<<18|tu>>>14)^Uf;au=Ff+yf|0;ou=(au<<7|au>>>25)^qf;fu=ou+Ff|0;uu=(fu<<9|fu>>>23)^Qf;cu=uu+ou|0;su=(cu<<13|cu>>>19)^yf;lu=su+uu|0;hu=(lu<<18|lu>>>14)^Ff;vu=Nf+If|0;du=(vu<<7|vu>>>25)^Jf;yu=du+Nf|0;gu=(yu<<9|yu>>>23)^bf;bu=gu+du|0;mu=(bu<<13|bu>>>19)^If;Mu=mu+gu|0;ku=(Mu<<18|Mu>>>14)^Nf;Uu=zf+_f|0;Lu=(Uu<<7|Uu>>>25)^Mf;Iu=Lu+zf|0;xu=(Iu<<9|Iu>>>23)^Ef;Eu=xu+Lu|0;Du=(Eu<<13|Eu>>>19)^_f;Ku=Du+xu|0;Ru=(Ku<<18|Ku>>>14)^zf;Bu=iu+Lu|0;Fu=(Bu<<7|Bu>>>25)^su;Ou=Fu+iu|0;Cu=(Ou<<9|Ou>>>23)^gu;Hu=Cu+Fu|0;ju=(Hu<<13|Hu>>>19)^Lu;qu=ju+Cu|0;Nu=(qu<<18|qu>>>14)^iu;Pu=hu+$f|0;Su=(Pu<<7|Pu>>>25)^mu;Vu=Su+hu|0;m=(Vu<<9|Vu>>>23)^xu;M=m+Su|0;k=(M<<13|M>>>19)^$f;U=k+m|0;L=(U<<18|U>>>14)^hu;I=ku+ou|0;x=(I<<7|I>>>25)^Du;E=x+ku|0;D=(E<<9|E>>>23)^eu;K=D+x|0;R=(K<<13|K>>>19)^ou;B=R+D|0;O=(B<<18|B>>>14)^ku;_=Ru+du|0;C=(_<<7|_>>>25)^nu;H=C+Ru|0;q=(H<<9|H>>>23)^uu;G=q+C|0;N=(G<<13|G>>>19)^du;P=N+q|0;S=(P<<18|P>>>14)^Ru;V=Nu+C|0;Z=(V<<7|V>>>25)^k;Q=Z+Nu|0;T=(Q<<9|Q>>>23)^D;J=T+Z|0;Y=(J<<13|J>>>19)^C;W=Y+T|0;z=(W<<18|W>>>14)^Nu;X=L+Fu|0;$=(X<<7|X>>>25)^R;AA=$+L|0;rA=(AA<<9|AA>>>23)^q;nA=rA+$|0;tA=(nA<<13|nA>>>19)^Fu;iA=tA+rA|0;oA=(iA<<18|iA>>>14)^L;fA=O+Su|0;uA=(fA<<7|fA>>>25)^N;cA=uA+O|0;sA=(cA<<9|cA>>>23)^Cu;lA=sA+uA|0;wA=(lA<<13|lA>>>19)^Su;hA=wA+sA|0;vA=(hA<<18|hA>>>14)^O;dA=S+x|0;yA=(dA<<7|dA>>>25)^ju;pA=yA+S|0;gA=(pA<<9|pA>>>23)^m;bA=gA+yA|0;mA=(bA<<13|bA>>>19)^x;MA=mA+gA|0;UA=(MA<<18|MA>>>14)^S;LA=z+yA|0;IA=(LA<<7|LA>>>25)^tA;xA=IA+z|0;DA=(xA<<9|xA>>>23)^sA;KA=DA+IA|0;RA=(KA<<13|KA>>>19)^yA;BA=RA+DA|0;FA=(BA<<18|BA>>>14)^z;OA=oA+Z|0;_A=(OA<<7|OA>>>25)^wA;CA=_A+oA|0;HA=(CA<<9|CA>>>23)^gA;jA=HA+_A|0;qA=(jA<<13|jA>>>19)^Z;GA=qA+HA|0;NA=(GA<<18|GA>>>14)^oA;PA=vA+$|0;SA=(PA<<7|PA>>>25)^mA;VA=SA+vA|0;QA=(VA<<9|VA>>>23)^T;TA=QA+SA|0;JA=(TA<<13|TA>>>19)^$;YA=JA+QA|0;zA=(YA<<18|YA>>>14)^vA;XA=UA+uA|0;$A=(XA<<7|XA>>>25)^Y;Ae=$A+UA|0;ee=(Ae<<9|Ae>>>23)^rA;re=ee+$A|0;ne=(re<<13|re>>>19)^uA;te=ne+ee|0;ie=(te<<18|te>>>14)^UA;ae=FA+$A|0;oe=(ae<<7|ae>>>25)^qA;fe=oe+FA|0;ue=(fe<<9|fe>>>23)^QA;ce=ue+oe|0;se=(ce<<13|ce>>>19)^$A;le=se+ue|0;he=(le<<18|le>>>14)^FA;ve=NA+IA|0;de=(ve<<7|ve>>>25)^JA;ye=de+NA|0;ge=(ye<<9|ye>>>23)^ee;be=ge+de|0;me=(be<<13|be>>>19)^IA;Me=me+ge|0;ke=(Me<<18|Me>>>14)^NA;Ue=zA+_A|0;Le=(Ue<<7|Ue>>>25)^ne;Ie=Le+zA|0;xe=(Ie<<9|Ie>>>23)^DA;Ee=xe+Le|0;De=(Ee<<13|Ee>>>19)^_A;Ke=De+xe|0;Re=(Ke<<18|Ke>>>14)^zA;Be=ie+SA|0;Fe=(Be<<7|Be>>>25)^RA;Oe=Fe+ie|0;Ce=(Oe<<9|Oe>>>23)^HA;He=Ce+Fe|0;je=(He<<13|He>>>19)^SA;qe=je+Ce|0;Ne=(qe<<18|qe>>>14)^ie;Pe=he+Fe|0;Se=(Pe<<7|Pe>>>25)^me;Ve=Se+he|0;Ze=(Ve<<9|Ve>>>23)^xe;Qe=Ze+Se|0;Te=(Qe<<13|Qe>>>19)^Fe;Je=Te+Ze|0;Ye=(Je<<18|Je>>>14)^he;We=ke+oe|0;ze=(We<<7|We>>>25)^De;Xe=ze+ke|0;$e=(Xe<<9|Xe>>>23)^Ce;Ar=$e+ze|0;er=(Ar<<13|Ar>>>19)^oe;rr=er+$e|0;tr=(rr<<18|rr>>>14)^ke;ir=Re+de|0;ar=(ir<<7|ir>>>25)^je;or=ar+Re|0;ur=(or<<9|or>>>23)^ue;cr=ur+ar|0;sr=(cr<<13|cr>>>19)^de;lr=sr+ur|0;wr=(lr<<18|lr>>>14)^Re;hr=Ne+Le|0;vr=(hr<<7|hr>>>25)^se;dr=vr+Ne|0;yr=(dr<<9|dr>>>23)^ge;pr=yr+vr|0;gr=(pr<<13|pr>>>19)^Le;br=gr+yr|0;mr=(br<<18|br>>>14)^Ne;Mr=Ye+vr|0;kr=(Mr<<7|Mr>>>25)^er;Ur=kr+Ye|0;Ir=(Ur<<9|Ur>>>23)^ur;xr=Ir+kr|0;Er=(xr<<13|xr>>>19)^vr;Dr=Er+Ir|0;Rr=tr+Se|0;Br=(Rr<<7|Rr>>>25)^sr;Fr=Br+tr|0;Or=(Fr<<9|Fr>>>23)^yr;_r=Or+Br|0;Cr=(_r<<13|_r>>>19)^Se;Hr=Cr+Or|0;jr=wr+ze|0;qr=(jr<<7|jr>>>25)^gr;Gr=qr+wr|0;Nr=(Gr<<9|Gr>>>23)^Ze;Pr=Nr+qr|0;Sr=(Pr<<13|Pr>>>19)^ze;Vr=Sr+Nr|0;Qr=mr+ar|0;Tr=(Qr<<7|Qr>>>25)^Te;Jr=Tr+mr|0;Wr=(Jr<<9|Jr>>>23)^$e;zr=Wr+Tr|0;Xr=(zr<<13|zr>>>19)^ar;$r=Xr+Wr|0;t=((Dr<<18|Dr>>>14)^Ye)+Xo|0;i=kr+$o|0;a=Ir+Af|0;o=Er+ef|0;f=Cr+rf|0;u=((Hr<<18|Hr>>>14)^tr)+nf|0;c=Br+tf|0;s=Or+af|0;l=Nr+of|0;w=Sr+uf|0;h=((Vr<<18|Vr>>>14)^wr)+cf|0;v=qr+sf|0;d=Tr+lf|0;y=Wr+wf|0;p=Xr+hf|0;g=(($r<<18|$r>>>14)^mr)+vf|0;An=e+(Jo+Tt<<2)|0;n[An>>2]=t;n[An+4>>2]=i;n[An+8>>2]=a;n[An+12>>2]=o;n[An+16>>2]=f;n[An+20>>2]=u;n[An+24>>2]=c;n[An+28>>2]=s;n[An+32>>2]=l;n[An+36>>2]=w;n[An+40>>2]=h;n[An+44>>2]=v;n[An+48>>2]=d;n[An+52>>2]=y;n[An+56>>2]=p;n[An+60>>2]=g;b=b+2|0}while(b>>>0<ct>>>0);return}return{_SMix:o}};return{create:A,getHeap:e}}function e(){"use strict";function A(A){for(var e=new Uint8Array(A),n=atob("mC+KQpFEN3HP+8C1pdu16VvCVjnxEfFZpII/ktVeHKuYqgfYAVuDEr6FMSTDfQxVdF2+cv6x3oCnBtybdPGbwcFpm+SGR77vxp3BD8yhDCRvLOktqoR0StypsFzaiPl2UlE+mG3GMajIJwOwx39Zv/ML4MZHkafVUWPKBmcpKRSFCrcnOCEbLvxtLE0TDThTVHMKZbsKanYuycKBhSxykqHov6JLZhqocItLwqNRbMcZ6JLRJAaZ1oU1DvRwoGoQFsGkGQhsNx5Md0gntbywNLMMHDlKqthOT8qcW/NvLmjugo90b2OleBR4yIQIAseM+v++kOtsUKT3o/m+8nhxxgUAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAACAAAAYAcAAAAEAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAr/////AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAQAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=="),t=8,i=0;i<n.length;i++)e[t+i]=n.charCodeAt(i);return r(self,{},A)}function e(){return 8636}var r=function(A,e,r){"use asm";var n=new A.Int32Array(r),t=new A.Int8Array(r),i=new A.Uint8Array(r);function a(A,e,r,i,a,u){A=A|0;e=e|0;r=r|0;i=i|0;a=a|0;u=u|0;var s=0,l=0,w=0,h=0,v=0,d=0,y=0,p=0,g=0,b=0,m=0;if(e>>>0>64){n[191]=0;n[183]=1779033703;n[184]=-1150833019;n[185]=1013904242;n[186]=-1521486534;n[187]=1359893119;n[188]=-1694144372;n[189]=528734635;n[190]=1541459225;o(732,A,e);c(1816,732);l=1816;w=32}else{l=A;w=e}n[191]=0;n[183]=1779033703;n[184]=-1150833019;n[185]=1013904242;n[186]=-1521486534;n[187]=1359893119;n[188]=-1694144372;n[189]=528734635;n[190]=1541459225;g=1752;m=g+64|0;do{t[g>>0]=54;g=g+1|0}while((g|0)<(m|0));if(!w)h=1;else{t[1752]=t[l>>0]^54;if((w|0)==1)h=0;else{t[1753]=t[l+1>>0]^54;if((w|0)==2)h=0;else{t[1754]=t[l+2>>0]^54;if((w|0)==3)h=0;else{v=3;do{t[1752+v>>0]=t[l+v>>0]^t[1752+v>>0];v=v+1|0}while((v|0)!=(w|0));h=0}}}}o(732,1752,64);n[216]=0;n[208]=1779033703;n[209]=-1150833019;n[210]=1013904242;n[211]=-1521486534;n[212]=1359893119;n[213]=-1694144372;n[214]=528734635;n[215]=1541459225;g=1752;m=g+64|0;do{t[g>>0]=92;g=g+1|0}while((g|0)<(m|0));if(!h){t[1752]=t[l>>0]^92;if((w|0)!=1){t[1753]=t[l+1>>0]^92;if((w|0)!=2){t[1754]=t[l+2>>0]^92;if((w|0)!=3){d=3;do{t[1752+d>>0]=t[l+d>>0]^t[1752+d>>0];d=d+1|0}while((d|0)!=(w|0))}}}}o(832,1752,64);o(732,r,i);if(u|0){s=0;p=0;do{s=s+1|0;t[1687]=s;t[1686]=s>>>8;t[1685]=s>>>16;t[1684]=s>>>24;f(932,732,200)|0;o(932,1684,4);c(1848,932);o(1032,1848,32);c(1688,1032);g=1720;b=1688;m=g+32|0;do{t[g>>0]=t[b>>0]|0;g=g+1|0;b=b+1|0}while((g|0)<(m|0));y=u-p|0;f(a+p|0,1720,(y>>>0>32?32:y)|0)|0;p=s<<5}while(p>>>0<u>>>0)}return}function o(A,e,r){A=A|0;e=e|0;r=r|0;var t=0,i=0,a=0,o=0,c=0,s=0,l=0,w=0,h=0,v=0,d=0,y=0,p=0,g=0,b=0;do if(r|0){p=A+32|0;g=n[p>>2]|0;b=g>>>3&63;n[p>>2]=g+(r<<3);c=64-b|0;s=A+36+b|0;if(c>>>0>r>>>0){f(s|0,e|0,r|0)|0;break}f(s|0,e|0,c|0)|0;l=A+36|0;u(A,l);w=e+c|0;h=r-c|0;if(h>>>0>63){v=b+r+-128|0;d=v&-64;y=d+128-b|0;a=h;o=w;while(1){u(A,o);a=a+-64|0;if(a>>>0<=63)break;else o=o+64|0}t=e+y|0;i=v-d|0}else{t=w;i=h}f(l|0,t|0,i|0)|0}while(0);return}function f(A,e,r){A=A|0;e=e|0;r=r|0;var i=0;i=A|0;if((A&3)==(e&3)){while(A&3){if(!r)return i|0;t[A>>0]=t[e>>0]|0;A=A+1|0;e=e+1|0;r=r-1|0}while((r|0)>=4){n[A>>2]=n[e>>2];A=A+4|0;e=e+4|0;r=r-4|0}}while((r|0)>0){t[A>>0]=t[e>>0]|0;A=A+1|0;e=e+1|0;r=r-1|0}return i|0}function u(A,e){A=A|0;e=e|0;var r=0,t=0,a=0,o=0,f=0,u=0,c=0,s=0,l=0,w=0,h=0,v=0,d=0,y=0,p=0,g=0,b=0;r=0;do{w=e+(r<<2)|0;n[444+(r<<2)>>2]=(i[w+2>>0]|0)<<8|(i[w+3>>0]|0)|(i[w+1>>0]|0)<<16|(i[w>>0]|0)<<24;r=r+1|0}while((r|0)!=16);t=16;h=n[111]|0;do{l=n[444+(t+-2<<2)>>2]|0;b=h;h=n[444+(t+-15<<2)>>2]|0;n[444+(t<<2)>>2]=b+(n[444+(t+-7<<2)>>2]|0)+((l>>>19|l<<13)^l>>>10^(l>>>17|l<<15))+((h>>>18|h<<14)^h>>>3^(h>>>7|h<<25));t=t+1|0}while((t|0)!=64);n[175]=n[A>>2];n[176]=n[A+4>>2];n[177]=n[A+8>>2];n[178]=n[A+12>>2];n[179]=n[A+16>>2];n[180]=n[A+20>>2];n[181]=n[A+24>>2];n[182]=n[A+28>>2];a=0;do{v=700+(((71-a|0)%8|0)<<2)|0;d=n[700+(((68-a|0)%8|0)<<2)>>2]|0;y=n[700+(((70-a|0)%8|0)<<2)>>2]|0;p=(n[444+(a<<2)>>2]|0)+(n[v>>2]|0)+((d>>>6|d<<26)^(d>>>11|d<<21)^(d>>>25|d<<7))+(n[8+(a<<2)>>2]|0)+((y^n[700+(((69-a|0)%8|0)<<2)>>2])&d^y)|0;g=n[700+(((64-a|0)%8|0)<<2)>>2]|0;f=n[700+(((65-a|0)%8|0)<<2)>>2]|0;u=n[700+(((66-a|0)%8|0)<<2)>>2]|0;c=700+(((67-a|0)%8|0)<<2)|0;n[c>>2]=(n[c>>2]|0)+p;n[v>>2]=((g>>>2|g<<30)^(g>>>13|g<<19)^(g>>>22|g<<10))+p+((u|f)&g|u&f);a=a+1|0}while((a|0)!=64);o=0;do{s=A+(o<<2)|0;n[s>>2]=(n[s>>2]|0)+(n[700+(o<<2)>>2]|0);o=o+1|0}while((o|0)!=8);return}function c(A,e){A=A|0;e=e|0;var r=0,i=0,a=0,f=0,u=0;u=n[e+32>>2]|0;t[1139]=u;t[1138]=u>>>8;t[1137]=u>>>16;t[1136]=u>>>24;i=u>>>3&63;n[283]=0;o(e,380,(i>>>0<56?56:120)-i|0);o(e,1132,8);r=0;do{a=A+(r<<2)|0;f=n[e+(r<<2)>>2]|0;t[a+3>>0]=f;t[a+2>>0]=f>>>8;t[a+1>>0]=f>>>16;t[a>>0]=f>>>24;r=r+1|0}while((r|0)!=8);return}return{_PBKDF2_OneIter:a}};return{create:A,getHeap:e}}var r,n=function(){"use strict";function e(){}function r(A,r){u=A,c=r,f=128*r,o=d+f;var n=d+f*(3+A),t=16777216*Math.ceil(n/16777216);if(!s||s.byteLength<t){try{s=new ArrayBuffer(t)}catch(A){return!1}l=new Uint8Array(s),p=y.create(s),e()}return!0}function n(A){var e=new Uint8Array(A);l.set(e,d),h=262144/c,w=0,v=!0}function t(A){h=h*A>>1<<1}function i(){var A,e=h,r=w,n=r+e,i=0;switch(n>=u&&(n=u,e=n-r,i=v?1:2),2!=i&&g(e),0==i&&(A=b()),p._SMix(u,c,d,o,v?0:1,r,n),i){case 0:A=b()-A,w=n,t(100/A);break;case 1:w=0,v=!1,t(.7);break;case 2:var a=s.slice(d,d+f);g({state:"done",step:e,output:a},[a])}}function a(A){var e=A.data;if(e===!0)return void i();switch(e.cmd){case"task":n(e.input),i();break;case"config":var t=r(e.N,e.r);g({state:t?"ready":"fail"});break;case"free":p=l=s=null}}var o,f,u,c,s,l,w,h,v,d=64,y=A(),p=null,g=self.postMessage,b=Date.now;addEventListener("message",a)};!function(r){function t(A,e,r,n,t,i,a){L=128*e,h=r,E=r*A*2,I=n,K=0;var o=O.getHeap();p=o,o+=t,g=o,o+=i,b=o,o+=a,m=o,o+=L*r,o=65536*Math.ceil(o/65536),(!d||d.byteLength<o)&&(d=new ArrayBuffer(o),y=new Uint8Array(d),_=O.create(d)),v||(v=u());for(var f=0;f<I;f++){var c=C[f];c||(c=new Worker(v),c.onmessage=s,c.tag=0,C[f]=c),c.postMessage({cmd:"config",N:A,r:e})}}function i(A,e,r){y.set(A,p),y.set(e,g),M=A.length,k=e.length,U=r,x=!0,D=0,R=0,B=0,_._PBKDF2_OneIter(p,M,g,k,m,L*h);for(var n=0;n<I;n++)l(C[n])}function a(){x=!1}function o(){C.forEach(function(A){A.postMessage({cmd:"free"})})}function f(){C.forEach(function(A){A.terminate()}),C=[],d=y=O=null,URL.revokeObjectURL(v)}function u(){var e="("+n+")();"+A,r=new Blob([e],{type:"text/javascript"});return URL.createObjectURL(r)}function c(){_._PBKDF2_OneIter(p,M,m,L*h,b,U>32?U:32);var A=new Uint8Array(d,b,U);x=!1,w("oncomplete",A)}function s(A){var e=this,r=A.data;if("number"==typeof r){if(!x)return;e.postMessage(!0),D+=r;var n=Date.now();return n-F>50&&w("onprogress",D/E),void(F=n)}switch(r.state){case"done":if(!x)return;var t=new Uint8Array(r.output),i=e.tag;y.set(t,m+L*i),D+=r.step,++B==h?c():R<h&&l(e);break;case"ready":++K==I&&w("onready");break;case"fail":w("onerror","memory alloc fail")}}function l(A){var e=m+R*L,r=d.slice(e,e+L);A.tag=R++,A.postMessage({cmd:"task",input:r},[r])}function w(A,e){var r=window.scrypt;r&&r.__asmjs_cb&&r.__asmjs_cb(A,e)}var h,v,d,y,p,g,b,m,M,k,U,L,I,x,E,D,K,R,B,F,O=e(),_=null,C=[];r.config=t,r.hash=i,r.stop=a,r.free=o,r.unload=f,w("onload",r)}(r||(r={}))}();
var DNeoContract = (function () {
    function DNeoContract() {
    }
    DNeoContract.compile = function (code) {
        return __awaiter(this, void 0, Promise, function* () {
            if (DNeoWallet.isLogin == false)
                return null;
            try {
                var postdata = DNeoTool.makeRpcPostBody("compileContractFile", DNeoWallet.address, code);
                var value = yield fetch(DNeoNet.contract_net, { "method": "post", "body": JSON.stringify(postdata) });
                var json = yield value["json"]();
                var res = json["result"];
                if (res && res[0] && res[0].code == "0000") {
                    var result = yield DNeoContract.getContractCodeByHash(res[0].hash);
                    if (result.res) {
                        return { res: true, info: { hash: res[0].hash, avm: result.info.avm, abi: result.info.abi } };
                    }
                    else {
                        return { res: false };
                    }
                }
                else {
                    return { res: false };
                }
            }
            catch (e) {
                console.log("编译合约出错！");
                return null;
            }
        });
    };
    DNeoContract.getContractCodeByHash = function (hash) {
        return __awaiter(this, void 0, Promise, function* () {
            if (DNeoWallet.isLogin == false)
                return null;
            try {
                var postdata = DNeoTool.makeRpcPostBody("getContractCodeByHash", DNeoWallet.address, hash);
                var result = yield fetch(DNeoNet.contract_net, { "method": "post", "body": JSON.stringify(postdata) });
                var json = yield result["json"]();
                var res = json["result"];
                if (res && res[0]) {
                    return { res: true, info: res[0] };
                }
                else {
                    return { res: false };
                }
            }
            catch (e) {
                console.log("获取编译文件出错！");
                return null;
            }
        });
    };
    DNeoContract.storageContractFile = function (addr, hash, name, ver, author, email, desc, feepay, isstore, iscall, txid) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                var postdata = DNeoTool.makeRpcPostBody("storageContractFile", addr, hash, name, ver, author, email, desc, feepay, isstore, iscall, txid);
                var result = yield fetch(DNeoNet.contract_net, { "method": "post", "body": JSON.stringify(postdata) });
                var json = yield result["json"]();
                if (json["result"]) {
                    var r = json["result"][0];
                    return r;
                }
            }
            catch (e) {
                console.log("保存失败！");
            }
        });
    };
    DNeoContract.getContractDeployInfoByHash = function (hash) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                var postdata = DNeoTool.makeRpcPostBody("getContractDeployInfoByHash", hash);
                var result = yield fetch(DNeoNet.contract_net, { "method": "post", "body": JSON.stringify(postdata) });
                var json = yield result["json"]();
                var r = json["result"] ? json["result"][0] : undefined;
                return r;
            }
            catch (e) {
                console.log("获取合约数据出错！");
                return null;
            }
        });
    };
    DNeoContract.deploy = function (deployData) {
        return __awaiter(this, void 0, Promise, function* () {
            if (DNeoWallet.isLogin == false)
                return null;
            try {
                if (!DNeoNet.isInit) {
                    console.log("网络未初始化！");
                    return null;
                }
                var sb = new ThinNeo.ScriptBuilder();
                sb.EmitPushString(deployData.description);
                sb.EmitPushString(deployData.email);
                sb.EmitPushString(deployData.author);
                sb.EmitPushString(deployData.version);
                sb.EmitPushString(deployData.name);
                sb.EmitPushNumber(deployData.num);
                sb.EmitPushBytes("05".hexToBytes());
                sb.EmitPushBytes("0710".hexToBytes());
                sb.EmitPushBytes(deployData.script);
                sb.EmitSysCall("Neo.Contract.Create");
                var utxos = yield DNeoTool.getutxo(DNeoWallet.address);
                if (!utxos)
                    return null;
                var assets = utxos[DNeoTool.id_GAS];
                var consume = Neo.Fixed8.fromNumber(deployData.amount);
                var newFee = consume.add(Neo.Fixed8.fromNumber(11));
                var tran = new ThinNeo.Transaction();
                tran.witnesses = [];
                tran.inputs = [];
                tran.outputs = [];
                DNeoTool.setScript(tran, sb.ToArray(), consume);
                DNeoTool.creatInuptAndOutup(tran, assets, newFee);
                tran.version = 1;
                var signdata = DNeoTool.signData(tran);
                if (signdata.length > 102400) {
                    throw new Error("TRANSACTION_LARGE");
                }
                var postdata = DNeoTool.makeRpcPostBody("sendrawtransaction", signdata.toHexString());
                var api = DNeoNet.useMainNet ? DNeoNet.api_net.mainNet : DNeoNet.api_net.testNet;
                var result = yield fetch(api, { "method": "post", "body": JSON.stringify(postdata) });
                var json = yield result["json"]();
                return json;
            }
            catch (e) {
                console.log("发布失败！");
                return null;
            }
        });
    };
    DNeoContract.invokescript = function (scripthash, args) {
        return __awaiter(this, void 0, Promise, function* () {
            try {
                if (!DNeoNet.isInit) {
                    console.log("网络未初始化！");
                    return null;
                }
                var script = DNeoContract.paresInvokeJson(scripthash, args);
                var data = DNeoTool.buildInvokeTransData_attributes(script);
                var postdata = DNeoTool.makeRpcPostBody("sendrawtransaction", data.toHexString());
                var api = DNeoNet.useMainNet ? DNeoNet.api_net.mainNet : DNeoNet.api_net.testNet;
                var result = yield fetch(api, { "method": "post", "body": JSON.stringify(postdata) });
                var json = yield result["json"]();
                return json;
            }
            catch (e) {
                console.log("调用方法出错！");
                return null;
            }
        });
    };
    DNeoContract.getinvokescript = function (scripthash, args) {
        return __awaiter(this, void 0, Promise, function* () {
            try {
                if (!DNeoNet.isInit) {
                    console.log("网络未初始化！");
                    return null;
                }
                var asset_hash = scripthash.substr(0, 2) == "0x" ? scripthash.slice(2) : scripthash;
                var script = DNeoContract.paresInvokeJson(scripthash, args);
                var postdata = DNeoTool.makeRpcPostBody("invokescript", script.toHexString());
                var api = DNeoNet.useMainNet ? DNeoNet.api_net.mainNet : DNeoNet.api_net.testNet;
                var result = yield fetch(api, { "method": "post", "body": JSON.stringify(postdata) });
                var json = yield result["json"]();
                return json;
            }
            catch (e) {
                console.log("调用方法出错！");
                return null;
            }
        });
    };
    DNeoContract.paresInvokeJson = function (scripthash, args) {
        var sb = new ThinNeo.ScriptBuilder();
        var random_int;
        try {
            var random_uint8 = Neo.Cryptography.RandomNumberGenerator.getRandomValues(new Uint8Array(32));
            random_int = Neo.BigInteger.fromUint8Array(random_uint8);
        }
        catch (e) {
            var math_rand = parseInt((Math.random() * 10000000).toString());
            random_int = new Neo.BigInteger(math_rand);
        }
        sb.EmitPushNumber(random_int);
        sb.Emit(ThinNeo.OpCode.DROP);
        sb.EmitParamJson(args[1]);
        sb.EmitParamJson(args[0]);
        var appcall = scripthash.hexToBytes().reverse();
        sb.EmitAppCall(appcall);
        return sb.ToArray();
    };
    DNeoContract.withdrawalsToAccount = function (count, assetID, script, args, net_fee) {
        return __awaiter(this, void 0, Promise, function* () {
            if (net_fee === void 0) { net_fee = Neo.Fixed8.Zero; }
            try {
                if (!DNeoNet.isInit) {
                    console.log("网络未初始化！");
                    return null;
                }
                var vscript = script.hexToBytes();
                var scriptHax = ThinNeo.Helper.GetScriptHashFromScript(vscript);
                var scriptAdr = ThinNeo.Helper.GetAddressFromScriptHash(scriptHax);
                var utxos = yield DNeoTool.getutxo(scriptAdr);
                if (!utxos)
                    return null;
                var sendcount = Neo.Fixed8.parse(count + "");
                var tran;
                if (assetID == DNeoTool.id_GAS) {
                    tran = DNeoTool.makeTran(utxos, DNeoWallet.address, assetID, sendcount, net_fee);
                }
                else {
                    tran = DNeoTool.makeTran(utxos, DNeoWallet.address, assetID, sendcount, Neo.Fixed8.Zero);
                    if (net_fee.compareTo(Neo.Fixed8.Zero) > 0) {
                        var user_tran = DNeoTool.makeTran(utxos, scriptAdr, DNeoTool.id_GAS, Neo.Fixed8.Zero, net_fee);
                        for (var i_2 = 0; i_2 < user_tran.inputs.length; i_2++) {
                            tran.inputs.push(user_tran.inputs[i_2]);
                        }
                        for (var i_3 = 0; i_3 < user_tran.outputs.length; i_3++) {
                            tran.outputs.push(user_tran.outputs[i_3]);
                        }
                    }
                }
                if (!tran)
                    return null;
                if (tran.witnesses == null)
                    tran.witnesses = [];
                var sb = new ThinNeo.ScriptBuilder();
                sb.EmitParamJson(JSON.parse(args[1]));
                sb.EmitParamJson(args[0]);
                var iscript = sb.ToArray();
                tran.AddWitnessScript(vscript, iscript);
                var data = tran.GetRawData();
                var scripthash = data.toHexString();
                var postdata = DNeoTool.makeRpcPostBody("sendrawtransaction", scripthash);
                var api = DNeoNet.useMainNet ? DNeoNet.api_net.mainNet : DNeoNet.api_net.testNet;
                var result = yield fetch(api, { "method": "post", "body": JSON.stringify(postdata) });
                var json = yield result["json"]();
                return json;
            }
            catch (e) {
                console.log("提现出错！");
                return null;
            }
        });
    };
    return DNeoContract;
}());
var DNeoWallet = (function () {
    function DNeoWallet() {
    }
    DNeoWallet.create = function (password) {
        return __awaiter(this, void 0, Promise, function* () {
            try {
                var result = new Promise(function (resolve, reject) {
                    var key;
                    try {
                        key = Neo.Cryptography.RandomNumberGenerator.getRandomValues(new Uint8Array(32));
                    }
                    catch (e) {
                        key = Neo.Cryptography.RandomNumberGenerator.getWeakRandomValues(new Uint8Array(32));
                    }
                    var pubkey = ThinNeo.Helper.GetPublicKeyFromPrivateKey(key);
                    var addr = ThinNeo.Helper.GetAddressFromPublicKey(pubkey);
                    DNeoWallet.wallet.scrypt = new ThinNeo.nep6ScryptParameters();
                    DNeoWallet.wallet.scrypt.N = 16384;
                    DNeoWallet.wallet.scrypt.r = 8;
                    DNeoWallet.wallet.scrypt.p = 8;
                    DNeoWallet.wallet.accounts = [];
                    DNeoWallet.wallet.accounts[0] = new ThinNeo.nep6account();
                    DNeoWallet.wallet.accounts[0].address = addr;
                    ThinNeo.Helper.GetNep2FromPrivateKey(key, password, DNeoWallet.wallet.scrypt.N, DNeoWallet.wallet.scrypt.r, DNeoWallet.wallet.scrypt.p, function (info, result) {
                        if (info == "finish") {
                            DNeoWallet.wallet.accounts[0].nep2key = result;
                            DNeoWallet.wallet.accounts[0].contract = new ThinNeo.contract();
                            var pubkey = ThinNeo.Helper.GetPublicKeyFromPrivateKey(key);
                            DNeoWallet.wallet.accounts[0].contract.script = ThinNeo.Helper.GetAddressCheckScriptFromPublicKey(pubkey).toHexString();
                            DNeoWallet.password = password;
                            resolve({ res: true });
                        }
                        else {
                            reject({ res: false });
                        }
                    });
                });
                return result;
            }
            catch (e) {
                console.log("新建失败！");
                return null;
            }
        });
    };
    DNeoWallet.loginWallet = function (password) {
        return __awaiter(this, void 0, Promise, function* () {
            try {
                if (DNeoWallet.wallet.accounts) {
                    for (var keyindex = 0; keyindex < DNeoWallet.wallet.accounts.length; keyindex++) {
                        var account = DNeoWallet.wallet.accounts[keyindex];
                        if (account.nep2key == null) {
                            continue;
                        }
                        var result = yield DNeoWallet.getPriKeyfromAccount(DNeoWallet.wallet.scrypt, password, account);
                        return result;
                    }
                }
            }
            catch (e) {
                console.log("登陆失败！");
                return null;
            }
        });
    };
    DNeoWallet.getPriKeyfromAccount = function (scrypt, password, account) {
        return __awaiter(this, void 0, Promise, function* () {
            try {
                var result = new Promise(function (resolve, reject) {
                    account.getPrivateKey(scrypt, password, function (info, result) {
                        if (info == "finish") {
                            DNeoWallet.prikey = result;
                            DNeoWallet.pubkey = ThinNeo.Helper.GetPublicKeyFromPrivateKey(DNeoWallet.prikey);
                            DNeoWallet.address = ThinNeo.Helper.GetAddressFromPublicKey(DNeoWallet.pubkey);
                            DNeoWallet.password = password;
                            DNeoWallet.loginWif = null;
                            DNeoWallet.isLogin = true;
                            resolve({ res: true });
                        }
                        else {
                            reject({ res: false });
                        }
                    });
                });
                return result;
            }
            catch (e) {
                console.log("获取私钥失败！");
                return null;
            }
        });
    };
    DNeoWallet.wifDecode = function (wif) {
        try {
            DNeoWallet.prikey = ThinNeo.Helper.GetPrivateKeyFromWIF(wif);
            DNeoWallet.pubkey = ThinNeo.Helper.GetPublicKeyFromPrivateKey(DNeoWallet.prikey);
            DNeoWallet.address = ThinNeo.Helper.GetAddressFromPublicKey(DNeoWallet.pubkey);
            DNeoWallet.loginWif = wif;
            DNeoWallet.isLogin = true;
            return true;
        }
        catch (e) {
            console.log("登录失败！");
            return null;
        }
    };
    DNeoWallet.loginout = function () {
        if (DNeoWallet.isLogin == false)
            return;
        DNeoWallet.isLogin = false;
        DNeoWallet.prikey = null;
        DNeoWallet.pubkey = null;
        DNeoWallet.address = null;
        DNeoWallet.wallet = new ThinNeo.nep6wallet();
        DNeoWallet.password = null;
    };
    DNeoWallet.transferToAccount = function (toAddress, count, assetID, fee) {
        return __awaiter(this, void 0, Promise, function* () {
            if (fee === void 0) { fee = "0"; }
            try {
                if (!DNeoNet.isInit) {
                    console.log("网络未初始化！");
                    return null;
                }
                var utxos = yield DNeoTool.getutxo(DNeoWallet.address);
                if (!utxos)
                    return null;
                var sendcount = Neo.Fixed8.parse(count + "");
                var net_fee = Neo.Fixed8.parse(fee + "");
                var tran;
                if (assetID == DNeoTool.id_GAS) {
                    tran = DNeoTool.makeTran(utxos, toAddress, assetID, sendcount, net_fee);
                }
                else {
                    tran = DNeoTool.makeTran(utxos, toAddress, assetID, sendcount, Neo.Fixed8.Zero);
                    if (net_fee.compareTo(Neo.Fixed8.Zero) > 0) {
                        var user_tran = DNeoTool.makeTran(utxos, DNeoWallet.address, DNeoTool.id_GAS, Neo.Fixed8.Zero, net_fee);
                        for (var i_4 = 0; i_4 < user_tran.inputs.length; i_4++) {
                            tran.inputs.push(user_tran.inputs[i_4]);
                        }
                        for (var i_5 = 0; i_5 < user_tran.outputs.length; i_5++) {
                            tran.outputs.push(user_tran.outputs[i_5]);
                        }
                    }
                }
                if (!tran)
                    return null;
                if (tran.witnesses == null)
                    tran.witnesses = [];
                var msg = tran.GetMessage().clone();
                var signdata = ThinNeo.Helper.Sign(msg, DNeoWallet.prikey);
                tran.AddWitness(signdata, DNeoWallet.pubkey, DNeoWallet.address);
                var data = tran.GetRawData();
                var scripthash = data.toHexString();
                var postdata = DNeoTool.makeRpcPostBody("sendrawtransaction", scripthash);
                var api = DNeoNet.useMainNet ? DNeoNet.api_net.mainNet : DNeoNet.api_net.testNet;
                var result = yield fetch(api, { "method": "post", "body": JSON.stringify(postdata) });
                var json = yield result["json"]();
                return json;
            }
            catch (e) {
                console.log("转账出错！");
                return null;
            }
        });
    };
    DNeoWallet.nep5Transfer = function (tatgeraddr, asset, amount) {
        return __awaiter(this, void 0, Promise, function* () {
            try {
                if (!DNeoNet.isInit) {
                    console.log("网络未初始化！");
                    return null;
                }
                var res = yield DNeoWallet.getNep5Decimals(asset);
                var decimals = res["decimals"];
                var numarr = amount.split(".");
                decimals -= (numarr.length == 1 ? 0 : numarr[1].length);
                var v = 1;
                for (var i = 0; i < decimals; i++)
                    v *= 10;
                var bnum = new Neo.BigInteger(amount.replace(".", ""));
                var intv = bnum.multiply(v).toString();
                var sb = new ThinNeo.ScriptBuilder();
                var scriptaddress = asset.hexToBytes().reverse();
                var random_int;
                try {
                    var random_uint8 = Neo.Cryptography.RandomNumberGenerator.getRandomValues(new Uint8Array(32));
                    random_int = Neo.BigInteger.fromUint8Array(random_uint8);
                }
                catch (e) {
                    var math_rand = parseInt((Math.random() * 10000000).toString());
                    random_int = new Neo.BigInteger(math_rand);
                }
                sb.EmitPushNumber(random_int);
                sb.Emit(ThinNeo.OpCode.DROP);
                sb.EmitParamJson(["(address)" + DNeoWallet.address, "(address)" + tatgeraddr, "(integer)" + intv]);
                sb.EmitPushString("transfer");
                sb.EmitAppCall(scriptaddress);
                var data = DNeoTool.buildInvokeTransData_attributes(sb.ToArray());
                var postdata = DNeoTool.makeRpcPostBody("sendrawtransaction", data.toHexString());
                var api = DNeoNet.useMainNet ? DNeoNet.api_net.mainNet : DNeoNet.api_net.testNet;
                var result = yield fetch(api, { "method": "post", "body": JSON.stringify(postdata) });
                var json = yield result["json"]();
                return json;
            }
            catch (e) {
                console.log("nnep5转账出错！");
                return null;
            }
        });
    };
    DNeoWallet.getNep5Decimals = function (assetid) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                if (!DNeoNet.isInit) {
                    console.log("网络未初始化！");
                    return null;
                }
                var decimals = yield DNeoContract.getinvokescript(assetid, ["(str)decimals", []]);
                return decimals;
            }
            catch (e) {
                console.log("获取资产信息出错！");
                return null;
            }
        });
    };
    DNeoWallet.getTestNetGas = function (address) {
        return __awaiter(this, void 0, Promise, function* () {
            if (!DNeoNet.isInit || DNeoNet.useMainNet)
                return;
            try {
                var str = DNeoTool.makeRpcUrl(DNeoNet.contract_net, "claimgas", address, 500);
                var value = yield fetch(str, { "method": "get" });
                var json = yield value["json"]();
                var result = json["result"];
                return result;
            }
            catch (error) {
                console.log("gas领取失败。");
                return null;
            }
        });
    };
    DNeoWallet.isLogin = false;
    DNeoWallet.wallet = new ThinNeo.nep6wallet();
    return DNeoWallet;
}());
var SDKLib = (function () {
    function SDKLib() {
    }
    SDKLib.init = function (blockchainType) {
        SDKLib.blockchainType = blockchainType;
    };
    SDKLib.loginWallet = function (password) {
        if (SDKLib.blockchainType == -1)
            return;
        if (SDKLib.blockchainType == SDKLib.NEO) {
            SDKLib.isLogin = true;
            DNeoWallet.loginWallet(password);
        }
    };
    Object.defineProperty(SDKLib, "walletAddress", {
        get: function () {
            if (SDKLib.isLogin == false)
                return null;
            if (SDKLib.blockchainType == SDKLib.NEO)
                return DNeoWallet.address;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SDKLib, "walletPriKey", {
        get: function () {
            if (SDKLib.isLogin == false)
                return null;
            if (SDKLib.blockchainType == SDKLib.NEO)
                return DNeoWallet.prikey;
        },
        enumerable: true,
        configurable: true
    });
    SDKLib.transfer = function (toAddr, count, args) {
        if (args === void 0) { args = null; }
        if (SDKLib.isLogin == false)
            return null;
        if (SDKLib.blockchainType == SDKLib.NEO) {
            if (args == null)
                return;
            var assetid = args[0] ? args[0] : DNeoTool.id_GAS;
            var fee = args[1] ? args[1] : 0;
            DNeoWallet.transferToAccount(toAddr, count, assetid, fee);
        }
    };
    SDKLib.invokeContract = function () {
        if (SDKLib.isLogin == false)
            return null;
        if (SDKLib.blockchainType == SDKLib.NEO) {
        }
    };
    SDKLib.NEO = 0;
    SDKLib.blockchainType = -1;
    SDKLib.isLogin = false;
    return SDKLib;
}());
var DNeoQuery = (function () {
    function DNeoQuery() {
    }
    DNeoQuery.queryTransaction = function (TxID) {
        return __awaiter(this, void 0, Promise, function* () {
            try {
                if (!DNeoNet.isInit) {
                    console.log("网络未初始化！");
                    return null;
                }
                var net = DNeoNet.useMainNet ? DNeoNet.neoscan_net.mainNet : DNeoNet.neoscan_net.testNet;
                var api = net + "get_transaction/" + TxID;
                var value = yield fetch(api);
                var res = yield value["json"]();
                return res;
            }
            catch (e) {
                console.log("查询交易失败！");
                return null;
            }
        });
    };
    DNeoQuery.queryAddress = function (address, page) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                if (!DNeoNet.isInit) {
                    console.log("网络未初始化！");
                    return null;
                }
                var net = DNeoNet.useMainNet ? DNeoNet.neoscan_net.mainNet : DNeoNet.neoscan_net.testNet;
                var api = net + "get_address_abstracts/" + address + "/" + page;
                var value = yield fetch(api);
                var res = yield value["json"]();
                return res;
            }
            catch (e) {
                console.log("查询地址交易记录失败！");
                return null;
            }
        });
    };
    DNeoQuery.queryWallet = function (address) {
        return __awaiter(this, void 0, Promise, function* () {
            try {
                if (!DNeoNet.isInit) {
                    console.log("网络未初始化！");
                    return null;
                }
                if (!DNeoWallet.isLogin)
                    return;
                var net = DNeoNet.useMainNet ? DNeoNet.neoscan_net.mainNet : DNeoNet.neoscan_net.testNet;
                var api = net + "get_balance/" + address;
                var value = yield fetch(api);
                var res = yield value["json"]();
                return res;
            }
            catch (e) {
                console.log("查询余额失败！");
                return null;
            }
        });
    };
    DNeoQuery.queryUTXO = function (address) {
        return __awaiter(this, void 0, Promise, function* () {
            try {
                if (!DNeoNet.isInit) {
                    console.log("网络未初始化！");
                    return null;
                }
                var net = DNeoNet.useMainNet ? DNeoNet.neoscan_net.mainNet : DNeoNet.neoscan_net.testNet;
                var api = net + "get_last_transactions_by_address/" + address;
                var value = yield fetch(api);
                var res = yield value["json"]();
                return res;
            }
            catch (e) {
                console.log("查询utxo模型失败！");
                return null;
            }
        });
    };
    return DNeoQuery;
}());
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try {
            step(generator.next(value));
        }
        catch (e) {
            reject(e);
        } }
        function rejected(value) { try {
            step(generator.throw(value));
        }
        catch (e) {
            reject(e);
        } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments)).next());
    });
};
var DNeoNet = (function () {
    function DNeoNet() {
    }
    DNeoNet.init = function (useMainNet, nodeType) {
        if (useMainNet === void 0) { useMainNet = false; }
        if (nodeType === void 0) { nodeType = 0; }
        if (DNeoNet.isInit)
            return;
        DNeoNet.isInit = true;
        DNeoNet.useMainNet = useMainNet;
        DNeoNet.selectedNode(nodeType);
    };
    DNeoNet.selectedNode = function (nodeType) {
        DNeoNet.nodeType = nodeType;
        switch (nodeType) {
            case DNeoNet.NODE_TYPE_NEL:
                DNeoNet.api_net = DNeoNet.nel_net;
                break;
            case DNeoNet.NODE_TYPE_CITY5:
                DNeoNet.api_net = DNeoNet.city_net;
                break;
        }
    };
    DNeoNet.NODE_TYPE_NEL = 0;
    DNeoNet.NODE_TYPE_CITY5 = 1;
    DNeoNet.neoscan_net = {
        testNet: "https://neoscan-testnet.io/api/test_net/v1/",
        mainNet: "https://neoscan.io/api/main_net/v1/"
    };
    DNeoNet.nel_net = {
        testNet: "https://api.nel.group/api/testnet",
        mainNet: "https://api.nel.group/api/mainnet"
    };
    DNeoNet.city_net = {
        testNet: "https://test5.cityofzion.io",
        mainNet: "https://seed5.cityofzion.io:443"
    };
    DNeoNet.contract_net = "https://apidebug.nel.group/api/testnet";
    DNeoNet.isInit = false;
    DNeoNet.useMainNet = false;
    return DNeoNet;
}());
var DNeoTool = (function () {
    function DNeoTool() {
    }
    DNeoTool.getutxo = function (address) {
        return __awaiter(this, void 0, Promise, function* () {
            try {
                var res = yield DNeoQuery.queryUTXO(address);
                var txidList = [];
                var utxoList = [];
                for (var i = 0; i < res.length; i++) {
                    var item = res[i];
                    if (item.vin.length > 0) {
                        for (var j = 0; j < item.vin.length; j++) {
                            var vin = item.vin[j];
                            if (!txidList[vin.asset])
                                txidList[vin.asset] = [];
                            if (vin.address_hash == address)
                                txidList[vin.asset].push(vin.txid);
                        }
                    }
                    if (item.vouts.length > 0) {
                        for (var k = 0; k < item.vouts.length; k++) {
                            var vout = item.vouts[k];
                            if (vout.address_hash != address)
                                continue;
                            if (!utxoList[vout.asset])
                                utxoList[vout.asset] = [];
                            var utxo = new UTXO();
                            utxo.addr = vout.address_hash;
                            utxo.asset = vout.asset;
                            utxo.n = vout.n;
                            utxo.txid = vout.txid;
                            utxo.count = Neo.Fixed8.parse(vout.value + "");
                            utxoList[vout.asset].push(utxo);
                        }
                    }
                }
                var utxos = [];
                for (var assetid in utxoList) {
                    if (!utxos[assetid])
                        utxos[assetid] = [];
                    for (var m = 0; m < utxoList[assetid].length; m++) {
                        var value = utxoList[assetid][m];
                        if (txidList[assetid] && txidList[assetid].indexOf(value.txid) != -1)
                            continue;
                        var item = LocalStorage.getJSON(assetid);
                        if (item && item.indexOf(value.txid) != -1)
                            continue;
                        utxos[assetid].push(value);
                    }
                }
                return utxos;
            }
            catch (e) {
                console.log("获取UTXO模型出错！");
                return null;
            }
        });
    };
    DNeoTool.makeTran = function (utxos, targetaddr, assetid, sendcount, net_fee, left_fee, split) {
        if (net_fee === void 0) { net_fee = Neo.Fixed8.Zero; }
        if (left_fee === void 0) { left_fee = 0; }
        if (split === void 0) { split = false; }
        try {
            var split_num = 10;
            var split_min = 1;
            var us = utxos[assetid];
            if (us == undefined) {
                console.log("余额不足");
                return null;
            }
            var tran = new ThinNeo.Transaction();
            tran.type = ThinNeo.TransactionType.ContractTransaction;
            tran.version = 0;
            tran.extdata = null;
            tran.attributes = [];
            tran.inputs = [];
            var scraddr = "";
            utxos[assetid].sort(function (a, b) {
                return a.count.compareTo(b.count);
            });
            var count = Neo.Fixed8.Zero;
            var clonearr = [].concat(us);
            var sendcounts = sendcount.add(net_fee);
            for (var i = 0; i < us.length; i++) {
                var input = new ThinNeo.TransactionInput();
                input.hash = us[i].txid.hexToBytes().reverse();
                input.index = us[i].n;
                input["_addr"] = us[i].addr;
                tran.inputs.push(input);
                count = count.add(us[i].count);
                scraddr = us[i].addr;
                clonearr.shift();
                var item = LocalStorage.getJSON(assetid);
                if (!item)
                    item = [];
                item.push(us[i].txid);
                LocalStorage.setJSON(assetid, item);
                if (split) {
                    if (us.length >= split_num) {
                        if (count.compareTo(sendcount) > 0) {
                            break;
                        }
                    }
                }
                else {
                    if (count.compareTo(sendcount) > 0) {
                        break;
                    }
                }
                if (us.length >= split_num && count.compareTo(sendcounts) > 0) {
                    break;
                }
            }
            if (count.compareTo(sendcounts) >= 0) {
                tran.outputs = [];
                if (sendcount.compareTo(Neo.Fixed8.Zero) > 0) {
                    var output = new ThinNeo.TransactionOutput();
                    output.assetId = assetid.hexToBytes().reverse();
                    output.value = sendcount;
                    output.toAddress = ThinNeo.Helper.GetPublicKeyScriptHash_FromAddress(targetaddr);
                    tran.outputs.push(output);
                }
                if (left_fee == 0) {
                    var change = count.subtract(sendcounts);
                    if (change.compareTo(Neo.Fixed8.Zero) > 0) {
                        if (split && change.compareTo(Neo.Fixed8.fromNumber(split_min)) > 0 && us.length < split_num) {
                            var change_num = change.getData().toNumber() / 100000000;
                            var change_int = Math["trunc"](change_num);
                            var change_1 = change_int / split_num;
                            for (var i_1 = 0; i_1 < split_num; i_1++) {
                                var outputchange = new ThinNeo.TransactionOutput();
                                outputchange.toAddress = ThinNeo.Helper.GetPublicKeyScriptHash_FromAddress(scraddr);
                                outputchange.value = Neo.Fixed8.fromNumber(change_1);
                                outputchange.assetId = assetid.hexToBytes().reverse();
                                tran.outputs.push(outputchange);
                            }
                            var litt = change.subtract(Neo.Fixed8.fromNumber(change_int));
                            if (litt.compareTo(Neo.Fixed8.Zero) > 0) {
                                var outputchange = new ThinNeo.TransactionOutput();
                                outputchange.toAddress = ThinNeo.Helper.GetPublicKeyScriptHash_FromAddress(scraddr);
                                outputchange.value = litt;
                                outputchange.assetId = assetid.hexToBytes().reverse();
                                tran.outputs.push(outputchange);
                            }
                        }
                        else {
                            var outputchange = new ThinNeo.TransactionOutput();
                            outputchange.toAddress = ThinNeo.Helper.GetPublicKeyScriptHash_FromAddress(scraddr);
                            outputchange.value = change;
                            outputchange.assetId = assetid.hexToBytes().reverse();
                            tran.outputs.push(outputchange);
                        }
                    }
                }
            }
            else {
                console.log("余额不足！");
                return null;
            }
            return tran;
        }
        catch (e) {
            console.log("获取utxo模型出错！");
            return null;
        }
    };
    DNeoTool.setScript = function (tran, script, gas) {
        try {
            tran.type = ThinNeo.TransactionType.InvocationTransaction;
            tran.extdata = new ThinNeo.InvokeTransData();
            tran.extdata.script = script;
            if (gas) {
                tran.extdata.gas = gas;
            }
            tran.attributes = new Array(1);
            tran.attributes[0] = new ThinNeo.Attribute();
            tran.attributes[0].usage = ThinNeo.TransactionAttributeUsage.Script;
            tran.attributes[0].data = ThinNeo.Helper.GetPublicKeyScriptHash_FromAddress(DNeoWallet.address);
        }
        catch (e) {
            console.log("交易写入脚本出错！");
        }
    };
    DNeoTool.creatInuptAndOutup = function (tran, utxos, sendcount, target) {
        try {
            var count = Neo.Fixed8.Zero;
            var scraddr = "";
            var assetId = utxos[0].asset.hexToBytes().reverse();
            for (var i in utxos) {
                var utxo = utxos[i];
                var input = new ThinNeo.TransactionInput();
                input.hash = utxo.txid.hexToBytes().reverse();
                input.index = utxo.n;
                input["_addr"] = utxo.addr;
                count = count.add(utxo.count);
                scraddr = utxo.addr;
                tran.inputs.push(input);
                var item = LocalStorage.getJSON(DNeoTool.id_GAS);
                if (!item)
                    item = [];
                item.push(utxo.txid);
                LocalStorage.setJSON(DNeoTool.id_GAS, item);
                if (count.compareTo(sendcount) > 0) {
                    break;
                }
            }
            if (count.compareTo(sendcount) >= 0) {
                if (target) {
                    if (sendcount.compareTo(Neo.Fixed8.Zero) > 0) {
                        var output = new ThinNeo.TransactionOutput();
                        output.assetId = assetId;
                        output.value = sendcount;
                        output.toAddress = ThinNeo.Helper.GetPublicKeyScriptHash_FromAddress(target);
                        tran.outputs.push(output);
                    }
                }
                var change = count.subtract(sendcount);
                if (change.compareTo(Neo.Fixed8.Zero) > 0) {
                    var outputchange = new ThinNeo.TransactionOutput();
                    outputchange.toAddress = ThinNeo.Helper.GetPublicKeyScriptHash_FromAddress(scraddr);
                    outputchange.value = change;
                    outputchange.assetId = assetId;
                    tran.outputs.push(outputchange);
                }
            }
            else {
                console.log("余额不足！");
            }
        }
        catch (e) {
            console.log("获取utxo模型出错！");
        }
    };
    DNeoTool.buildInvokeTransData_attributes = function (script) {
        try {
            var tran = new ThinNeo.Transaction();
            tran.inputs = [];
            tran.outputs = [];
            tran.type = ThinNeo.TransactionType.InvocationTransaction;
            tran.extdata = new ThinNeo.InvokeTransData();
            tran.extdata.script = script;
            tran.attributes = new Array(1);
            tran.attributes[0] = new ThinNeo.Attribute();
            tran.attributes[0].usage = ThinNeo.TransactionAttributeUsage.Script;
            tran.attributes[0].data = ThinNeo.Helper.GetPublicKeyScriptHash_FromAddress(DNeoWallet.address);
            if (tran.witnesses == null)
                tran.witnesses = [];
            var data = DNeoTool.signData(tran);
            return data;
        }
        catch (error) {
            console.log("签名出错！");
            return null;
        }
    };
    DNeoTool.signData = function (tran) {
        try {
            var msg = tran.GetMessage().clone();
            var addr = DNeoWallet.address;
            var pubkey = DNeoWallet.pubkey.clone();
            var prekey = DNeoWallet.prikey.clone();
            var signdata = ThinNeo.Helper.Sign(msg, prekey);
            tran.AddWitness(signdata, pubkey, addr);
            var data = tran.GetRawData();
            return data;
        }
        catch (error) {
            console.log("签名出错！");
            return null;
        }
    };
    DNeoTool.makeRpcPostBody = function (method) {
        var _params = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            _params[_i - 1] = arguments[_i];
        }
        var body = {};
        body["jsonrpc"] = "2.0";
        body["id"] = 1;
        body["method"] = method;
        var params = [];
        for (var i = 0; i < _params.length; i++) {
            params.push(_params[i]);
        }
        body["params"] = params;
        return body;
    };
    DNeoTool.makeRpcUrl = function (url, method) {
        var _params = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            _params[_i - 2] = arguments[_i];
        }
        var urlout = url + "?jsonrpc=2.0&id=1&method=" + method + "&params=[";
        for (var i = 0; i < _params.length; i++) {
            urlout += JSON.stringify(_params[i]);
            if (i != _params.length - 1)
                urlout += ",";
        }
        urlout += "]";
        return urlout;
    };
    DNeoTool.verifyAddr = function (addr) {
        var verify = /^[a-zA-Z0-9]{34,34}$/;
        var res = verify.test(addr) ? this.verifyPublicKey(addr) : false;
        return res;
    };
    DNeoTool.verifyPublicKey = function (publicKey) {
        var array = Neo.Cryptography.Base58.decode(publicKey);
        var check = array.subarray(21, 21 + 4);
        var checkdata = array.subarray(0, 21);
        var hashd = Neo.Cryptography.Sha256.computeHash(checkdata);
        hashd = Neo.Cryptography.Sha256.computeHash(hashd);
        var hashd = hashd.slice(0, 4);
        var checked = new Uint8Array(hashd);
        var error = false;
        for (var i = 0; i < 4; i++) {
            if (checked[i] != check[i]) {
                error = true;
                break;
            }
        }
        return !error;
    };
    DNeoTool.hexToString = function (hex) {
        var trimhex = hex.trim();
        var rawStr = trimhex.substr(0, 2).toLowerCase() === "0x" ? trimhex.substr(2) : trimhex;
        var len = rawStr.length;
        if (len % 2 !== 0) {
            alert("Illegal Format ASCII Code!");
            return "";
        }
        var cuChar;
        var result = [];
        for (var i = 0; i < len; i = i + 2) {
            cuChar = parseInt(rawStr.substr(i, 2), 16);
            result.push(String.fromCharCode(cuChar));
        }
        return result.join("");
    };
    DNeoTool.stringToHex = function (str) {
        if (str === "")
            return "";
        var hexChar = [];
        for (var i = 0; i < str.length; i++) {
            hexChar.push((str.charCodeAt(i)).toString(16));
        }
        return hexChar.join("");
    };
    DNeoTool.hexToNumber = function (hex) {
        var num = hex.hexToBytes();
        var str = new Neo.BigInteger(num);
        return str.toString();
    };
    DNeoTool.numberToHex = function (str) {
        var num = new Neo.BigInteger(str);
        var text = num.toUint8Array().toHexString();
        return text;
    };
    DNeoTool.toScriptHash = function (address) {
        return __awaiter(this, void 0, Promise, function* () {
            if (address.length != 34) {
                alert("Illegal Format Address!");
                return;
            }
            var data = address.base58Decode();
            if (data.length != 25)
                throw new RangeError();
            if (data[0] != 0x17)
                throw new RangeError();
            return window.crypto.subtle.digest({ name: "SHA-256" }, new Uint8Array(data.buffer, 0, data.length - 4)).then(function (result) {
                return window.crypto.subtle.digest({ name: "SHA-256" }, result);
            }).then(function (result) {
                var array = new Uint8Array(result);
                for (var i = 0; i < 4; i++)
                    if (array[i] != data[data.length - 4 + i])
                        throw new RangeError();
                array = new Uint8Array(20);
                Array.copy(data, 1, array, 0, 20);
                var val = new Neo.Uint160(array.buffer);
                var xScriptHash = "0x" + val.toString();
                var scriptHash = DNeoTool.endianChange(xScriptHash);
                return scriptHash;
            });
        });
    };
    DNeoTool.toAddress = function (scriptHash) {
        return __awaiter(this, void 0, Promise, function* () {
            if (scriptHash.substr(0, 2) == "0x")
                scriptHash = scriptHash.slice(2);
            if (scriptHash.length != 40) {
                alert("Illegal Format Script Hash!");
                return;
            }
            var xScriptHash = DNeoTool.endianChange(scriptHash);
            if (xScriptHash.substr(0, 2) == "0x")
                xScriptHash = xScriptHash.slice(2);
            var hash160 = Neo.Uint160.parse(xScriptHash);
            var data = new Uint8Array(25);
            data[0] = 0x17;
            Array.copy(new Uint8Array(hash160.bits.buffer), 0, data, 1, 20);
            return window.crypto.subtle.digest({ name: "SHA-256" }, new Uint8Array(data.buffer, 0, 21)).then(function (result) {
                return window.crypto.subtle.digest({ name: "SHA-256" }, result);
            }).then(function (result) {
                Array.copy(new Uint8Array(result), 0, data, 21, 4);
                return data.base58Encode();
            });
        });
    };
    DNeoTool.endianChange = function (inSmall) {
        var result = [], num;
        if (inSmall.indexOf("0x") == 0) {
            inSmall = inSmall.slice(2);
        }
        else if (inSmall) {
            result = ['0x'];
        }
        var smaArray = inSmall.hexToBytes().reverse();
        for (var i = 0; i < smaArray.length; i++) {
            num = smaArray[i];
            if (num < 16) {
                num = smaArray[i].toString(16);
                num = "0" + num;
            }
            else {
                num = smaArray[i].toString(16);
            }
            result.push(num);
        }
        return result.join("");
    };
    DNeoTool.id_GAS = "602c79718b16e442de58778e148d0b1084e3b2dffd5de6b7b16cee7969282de7";
    DNeoTool.id_NEO = "c56f33fc6ecfcd0c225c4ab356fee59390af8560be0e930faebe74a6daff7c9b";
    return DNeoTool;
}());
var UTXO = (function () {
    function UTXO() {
    }
    return UTXO;
}());
var AvatarAction = (function () {
    function AvatarAction() {
        this.frameImageInfo = [];
    }
    AvatarAction.prototype.getFrameLength = function (ori, useMapping) {
        if (useMapping === void 0) { useMapping = true; }
        var assetOri = useMapping ? GameUtils.getAssetOri(ori, this.oriMode) : ori;
        var frameImageInfo = this.frameImageInfo[assetOri];
        return frameImageInfo && frameImageInfo.length ? frameImageInfo.length : 0;
    };
    AvatarAction.prototype.getFrameImage = function (ori, frame, useMapping) {
        if (useMapping === void 0) { useMapping = true; }
        var assetOri = useMapping ? GameUtils.getAssetOri(ori, this.oriMode) : ori;
        var arr = this.frameImageInfo[assetOri];
        if (!arr)
            return null;
        return arr[frame];
    };
    AvatarAction.prototype.hasOri = function (ori) {
        var frameImageInfo = this.frameImageInfo[ori];
        return frameImageInfo ? true : false;
    };
    return AvatarAction;
}());
var AvatarFrameImage = (function () {
    function AvatarFrameImage() {
    }
    Object.defineProperty(AvatarFrameImage.prototype, "positiveRect", {
        get: function () {
            if (!this._positiveRect)
                this._positiveRect = new Rectangle(-this.rect.x, -this.rect.y, this.rect.width, this.rect.height);
            return this._positiveRect;
        },
        enumerable: true,
        configurable: true
    });
    return AvatarFrameImage;
}());
var AvatarRefObj = (function () {
    function AvatarRefObj() {
    }
    return AvatarRefObj;
}());
var CommandExecuteGame;
(function (CommandExecuteGame) {
    function command_1000(triggerLineID, isAllowCancle, isignore) {
        if (!GameCommand.isNeedPlayerInput) {
            BlockChainManager.openNeoLoginView(isAllowCancle, isignore);
        }
        return GameCommand.COMMAND_STATE_NEED_INPUT;
    }
    CommandExecuteGame.command_1000 = command_1000;
    function command_1001(triggerLineID, name, toAddress, assetType, value, isAllowInput, isAllowCancle) {
        if (!GameCommand.isNeedPlayerInput) {
            BlockChainManager.openNeoTransferView(name, toAddress, assetType, value, isAllowInput, isAllowCancle);
        }
        return GameCommand.COMMAND_STATE_NEED_INPUT;
    }
    CommandExecuteGame.command_1001 = command_1001;
    function command_1002(triggerLineID, name, contract, operation, params, isAllowCancle) {
        if (!GameCommand.isNeedPlayerInput) {
            BlockChainManager.openNeoInvokeView(name, contract, operation, params, isAllowCancle);
        }
        return GameCommand.COMMAND_STATE_NEED_INPUT;
    }
    CommandExecuteGame.command_1002 = command_1002;
})(CommandExecuteGame || (CommandExecuteGame = {}));
var CommandExecuteGame;
(function (CommandExecuteGame) {
    function command_11(triggerLineID, dialogID, head, name, speed, comicMode, msg) {
        if (!GameCommand.isNeedPlayerInput) {
            GameDialog.showDialog(dialogID, head, name, speed, comicMode, msg);
        }
        return GameCommand.COMMAND_STATE_NEED_INPUT;
    }
    CommandExecuteGame.command_11 = command_11;
})(CommandExecuteGame || (CommandExecuteGame = {}));
var CommandExecuteGame;
(function (CommandExecuteGame) {
    function command_12(triggerLineID, dialogID, head, name, speed, comicMode, msg) {
        return GameCommand.COMMAND_STATE_NEED_INPUT;
    }
    CommandExecuteGame.command_12 = command_12;
})(CommandExecuteGame || (CommandExecuteGame = {}));
var CommandExecuteGame;
(function (CommandExecuteGame) {
    function command_17(triggerLineID, delay, unit) {
        if (unit == 1) {
            setTimeout(GameCommand.start, delay, [triggerLineID]);
        }
        else {
            setFrameout(GameCommand.start, delay, [triggerLineID]);
        }
        return GameCommand.COMMAND_STATE_STOP;
    }
    CommandExecuteGame.command_17 = command_17;
})(CommandExecuteGame || (CommandExecuteGame = {}));
var CommandExecuteGame;
(function (CommandExecuteGame) {
    function command_37(triggerLineID, imageInfos) {
        var funcMapping = [
            GameImage.showImage,
            GameImage.moveImage,
            GameImage.autoRotation,
            GameImage.changeTonal,
            GameImage.deleteImage,
            GameImage.showAnimation,
            GameImage.moveAnimation,
            null,
            GameImage.delay
        ];
        for (var i = 0; i < imageInfos.length; i++) {
            var imageInfo = imageInfos[i];
            var type = imageInfo.shift();
            funcMapping[type].apply(GameImage, imageInfo);
        }
        return GameCommand.COMMAND_STATE_CONTINUE;
    }
    CommandExecuteGame.command_37 = command_37;
})(CommandExecuteGame || (CommandExecuteGame = {}));
var CommandExecuteGame;
(function (CommandExecuteGame) {
    function command_3(triggerLineID, dialogID, selContents) {
        if (!GameCommand.isNeedPlayerInput || triggerLineID == GameCommand.inputTriggerLine) {
            GameDialog.showOption(dialogID, selContents);
        }
        return GameCommand.COMMAND_STATE_NEED_INPUT;
    }
    CommandExecuteGame.command_3 = command_3;
})(CommandExecuteGame || (CommandExecuteGame = {}));
var AssetManager = (function () {
    function AssetManager() {
    }
    AssetManager.preLoadSceneAsset = function (id, complete, syncCallbackWhenAssetExist, autoDispose) {
        if (complete === void 0) { complete = null; }
        if (syncCallbackWhenAssetExist === void 0) { syncCallbackWhenAssetExist = false; }
        if (autoDispose === void 0) { autoDispose = true; }
        if (id == 0) {
            complete && (syncCallbackWhenAssetExist ? complete.run() : complete.delayRun(0));
            return;
        }
        AssetManager.loadJson("asset/json/scene/data/scene" + id + ".json", Callback.New(function (jsonObj) {
            if (!jsonObj) {
                complete && (syncCallbackWhenAssetExist ? complete.run() : complete.delayRun(0));
                return;
            }
            var loadCount = 1;
            function onLoadOne() {
                loadCount--;
                if (loadCount == 0) {
                    if (autoDispose)
                        setTimeout(function (id) { AssetManager.disposeScene(id); }, AssetManager.disposeInterval, id);
                    complete && (syncCallbackWhenAssetExist ? complete.run() : complete.delayRun(0));
                }
            }
            var onLoadOneCB = Callback.New(onLoadOne, this);
            var imgUrls = [];
            for (var i = 0; i < jsonObj.LayerDatas.length; i++) {
                var layerData = jsonObj.LayerDatas[i];
                if (layerData.img) {
                    imgUrls.push(layerData.img);
                }
                if (layerData.drawMode && layerData.tileData) {
                    for (var id in layerData.tileData) {
                        var tileData = Game.data.tileList.data[id];
                        if (tileData && tileData.url)
                            imgUrls.push(tileData.url);
                    }
                }
            }
            loadCount += 1;
            AssetManager.loadImages(imgUrls, onLoadOneCB, syncCallbackWhenAssetExist);
            if (jsonObj.bgm) {
                loadCount++;
                AssetManager.loadAudio(jsonObj.bgm, onLoadOneCB, syncCallbackWhenAssetExist);
            }
            if (jsonObj.bgs) {
                loadCount++;
                AssetManager.loadAudio(jsonObj.bgs, onLoadOneCB, syncCallbackWhenAssetExist);
            }
            for (var s in jsonObj.preLoadAssets) {
                var preLoadAssetInfo = jsonObj.preLoadAssets[s];
                var valueStr = preLoadAssetInfo.value;
                var valueInt = preLoadAssetInfo.value;
                loadCount++;
                switch (preLoadAssetInfo.type) {
                    case 0:
                        AssetManager.loadImage(valueStr, onLoadOneCB, syncCallbackWhenAssetExist);
                        break;
                    case 1:
                        AssetManager.loadAudio(valueStr, onLoadOneCB, syncCallbackWhenAssetExist);
                        break;
                    case 2:
                        AssetManager.loadText(valueStr, onLoadOneCB, syncCallbackWhenAssetExist);
                        break;
                    case 3:
                        AssetManager.loadJson(valueStr, onLoadOneCB, syncCallbackWhenAssetExist);
                        break;
                    case 4:
                        AssetManager.preLoadAvatarAsset(valueInt, onLoadOneCB, syncCallbackWhenAssetExist);
                        break;
                    case 5:
                        AssetManager.preLoadUIAsset(valueInt, onLoadOneCB, syncCallbackWhenAssetExist);
                        break;
                    case 6:
                        AssetManager.preLoadAnimationAsset(valueInt, onLoadOneCB, syncCallbackWhenAssetExist);
                        break;
                }
            }
            onLoadOneCB.run();
        }, this));
    };
    AssetManager.preLoadSceneObjectAsset = function (so, complete, syncCallbackWhenAssetExist, autoDispose) {
        if (complete === void 0) { complete = null; }
        if (syncCallbackWhenAssetExist === void 0) { syncCallbackWhenAssetExist = false; }
        if (autoDispose === void 0) { autoDispose = true; }
        var modelData = Common.sceneObjectModelList.data[so.modelID];
        if (!modelData) {
            complete && (syncCallbackWhenAssetExist ? complete.run() : complete.delayRun(0));
            return;
        }
        var loadCount = 0;
        function onLoadOne() {
            loadCount--;
            if (loadCount == 0) {
                if (autoDispose)
                    setTimeout(function (so) { AssetManager.disposeSceneObject(so); }, AssetManager.disposeInterval, so);
                loadCount = -1;
                complete && (syncCallbackWhenAssetExist ? complete.run() : complete.delayRun(0));
            }
        }
        var onLoadOneCB = Callback.New(onLoadOne, this);
        var loads = [];
        for (var i in modelData.preLayer) {
            var preLayer = modelData.preLayer[i];
            var displayInfo = so.displayList[preLayer.varName];
            switch (preLayer.type) {
                case 1:
                    loadCount++;
                    loads.push(Callback.New(this.preLoadAvatarAsset, this, [displayInfo.id, onLoadOneCB, syncCallbackWhenAssetExist, autoDispose]));
                    break;
                case 2:
                    loadCount++;
                    loads.push(Callback.New(this.preLoadUIAsset, this, [preLayer.id, onLoadOneCB, syncCallbackWhenAssetExist, autoDispose]));
                    break;
                case 3:
                    if (displayInfo) {
                        loadCount++;
                        loads.push(Callback.New(this.preLoadUIAsset, this, [displayInfo.id, onLoadOneCB, syncCallbackWhenAssetExist, autoDispose]));
                    }
                    break;
                case 4:
                    loadCount++;
                    loads.push(Callback.New(this.preLoadAnimationAsset, this, [preLayer.id, onLoadOneCB, syncCallbackWhenAssetExist, autoDispose]));
                    break;
                case 5:
                    if (displayInfo) {
                        loadCount++;
                        loads.push(Callback.New(this.preLoadAnimationAsset, this, [displayInfo.id, onLoadOneCB, syncCallbackWhenAssetExist, autoDispose]));
                    }
                    break;
            }
        }
        for (var i in loads) {
            loads[i].run();
        }
        if (loadCount == 0) {
            complete && (syncCallbackWhenAssetExist ? complete.run() : complete.delayRun(0));
        }
    };
    AssetManager.preLoadAvatarAsset = function (id, complete, syncCallbackWhenAssetExist, autoDispose) {
        var _this = this;
        if (complete === void 0) { complete = null; }
        if (syncCallbackWhenAssetExist === void 0) { syncCallbackWhenAssetExist = false; }
        if (autoDispose === void 0) { autoDispose = true; }
        if (id < 0) {
            complete && (syncCallbackWhenAssetExist ? complete.run() : complete.delayRun(0));
            return;
        }
        AssetManager.loadJson("asset/json/avatar/data/avatar" + id + ".json", Callback.New(function (avatarData) {
            if (!avatarData) {
                complete && (syncCallbackWhenAssetExist ? complete.run() : complete.delayRun(0));
                return;
            }
            var loadCount = avatarData.parts.length;
            var onLoaded = Callback.New(function () {
                loadCount--;
                if (loadCount == 0) {
                    if (autoDispose)
                        setTimeout(function (id) { AssetManager.disposeAvatarAsset(id); }, AssetManager.disposeInterval, id);
                    complete && (syncCallbackWhenAssetExist ? complete.run() : complete.delayRun(0));
                }
            }, _this);
            AssetManager.loadImages(avatarData.picUrls, onLoaded, syncCallbackWhenAssetExist);
            for (var i = 0; i < avatarData.parts.length; i++) {
                var avatarPartID = avatarData.parts[i].id;
                if (avatarPartID == 0)
                    continue;
                AssetManager.preLoadAvatarAsset(avatarPartID, onLoaded, syncCallbackWhenAssetExist, false);
            }
        }, this), syncCallbackWhenAssetExist);
    };
    AssetManager.preLoadUIAsset = function (id, complete, syncCallbackWhenAssetExist, autoDispose) {
        if (complete === void 0) { complete = null; }
        if (syncCallbackWhenAssetExist === void 0) { syncCallbackWhenAssetExist = false; }
        if (autoDispose === void 0) { autoDispose = true; }
        if (id == 0) {
            complete && (syncCallbackWhenAssetExist ? complete.run() : complete.delayRun(0));
            return;
        }
        AssetManager.loadJson("asset/json/ui/data/ui" + id + ".json", Callback.New(function (uiDisData) {
            if (!uiDisData || !uiDisData.root) {
                complete && (syncCallbackWhenAssetExist ? complete.run() : complete.delayRun(0));
                return;
            }
            var root = new UIComponent.UIRoot(true, id);
            var uiArr = AssetManager.preUIs[id];
            if (!uiArr)
                uiArr = AssetManager.preUIs[id] = [];
            uiArr.push(root);
            root.once(EventObject.LOADED, complete.caller, function () {
                complete.run();
                if (autoDispose)
                    setTimeout(function (id) { AssetManager.disposeUIAsset(id); }, AssetManager.disposeInterval, id);
            });
            var ui = GameUI.parse(uiDisData, false, null, id, root, syncCallbackWhenAssetExist);
        }, this), syncCallbackWhenAssetExist);
    };
    AssetManager.preLoadAnimationAsset = function (id, complete, syncCallbackWhenAssetExist, autoDispose) {
        var _this = this;
        if (complete === void 0) { complete = null; }
        if (syncCallbackWhenAssetExist === void 0) { syncCallbackWhenAssetExist = false; }
        if (autoDispose === void 0) { autoDispose = true; }
        if (id == 0) {
            complete && (syncCallbackWhenAssetExist ? complete.run() : complete.delayRun(0));
            return;
        }
        AssetManager.loadJson("asset/json/animation/data/ani" + id + ".json", Callback.New(function (aniData) {
            if (!aniData) {
                complete && (syncCallbackWhenAssetExist ? complete.run() : complete.delayRun(0));
                return;
            }
            var loadCount = 1;
            var onLoaded = Callback.New(function () {
                loadCount--;
                if (loadCount == 0) {
                    if (autoDispose)
                        setTimeout(function (id) { AssetManager.disposeAnimationAsset(id); }, AssetManager.disposeInterval, id);
                    complete && (syncCallbackWhenAssetExist ? complete.run() : complete.delayRun(0));
                }
            }, _this);
            if (aniData.isParticle && aniData.particleData) {
                AssetManager.loadTexture(aniData.particleData.textureName, onLoaded, syncCallbackWhenAssetExist);
            }
            else {
                for (var index = 0; index < aniData.layers.length; index++) {
                    var layerInfo = aniData.layers[index];
                    if (layerInfo.type == AnimationItemType.Animation) {
                        var nodes = ArrayUtils.getTreeNodeArray(layerInfo);
                        for (var s in nodes) {
                            var childLayerInfo = nodes[s];
                            if (childLayerInfo.type == AnimationItemType.Animation) {
                                loadCount++;
                                AssetManager.preLoadAnimationAsset(childLayerInfo.animationId, onLoaded, syncCallbackWhenAssetExist, false);
                            }
                        }
                    }
                }
                var picUrls = aniData.imageSources ? aniData.imageSources.reduce(function (pv, v) { if (v && pv.indexOf(v.url) == -1)
                    pv.push(v.url); return pv; }, []) : [];
                AssetManager.loadImages(picUrls, onLoaded, syncCallbackWhenAssetExist);
            }
        }, this), syncCallbackWhenAssetExist);
    };
    AssetManager.batchPreLoadAsset = function (onFin, onProgress, images, scenes, avatars, animations, uis, jsons, syncCallbackWhenAssetExist, autoDispose) {
        if (onProgress === void 0) { onProgress = null; }
        if (images === void 0) { images = []; }
        if (scenes === void 0) { scenes = []; }
        if (avatars === void 0) { avatars = []; }
        if (animations === void 0) { animations = []; }
        if (uis === void 0) { uis = []; }
        if (jsons === void 0) { jsons = []; }
        if (syncCallbackWhenAssetExist === void 0) { syncCallbackWhenAssetExist = false; }
        if (autoDispose === void 0) { autoDispose = true; }
        var loadCount = images.length + scenes.length + avatars.length + animations.length + uis.length + jsons.length;
        if (loadCount == 0) {
            onFin && (syncCallbackWhenAssetExist ? onFin.run() : onFin.delayRun(0));
            return;
        }
        var loadCountR = loadCount;
        function onLoaded() {
            loadCount--;
            onProgress && onProgress.runWith([loadCountR - loadCount, loadCountR]);
            if (loadCount == 0) {
                onFin && (syncCallbackWhenAssetExist ? onFin.run() : onFin.delayRun(0));
            }
        }
        var onLoadedCB = Callback.New(onLoaded, this);
        for (var i = 0; i < images.length; i++) {
            var url = images[i];
            this.loadImage(url, onLoadedCB, syncCallbackWhenAssetExist, true);
            if (autoDispose)
                setTimeout(function (id) { AssetManager.disposeImage(url); }, AssetManager.disposeInterval, url);
        }
        for (var i = 0; i < scenes.length; i++) {
            this.preLoadSceneAsset(scenes[i], onLoadedCB, syncCallbackWhenAssetExist, autoDispose);
        }
        for (var i = 0; i < avatars.length; i++) {
            this.preLoadAvatarAsset(avatars[i], onLoadedCB, syncCallbackWhenAssetExist, autoDispose);
        }
        for (var i = 0; i < animations.length; i++) {
            this.preLoadAnimationAsset(animations[i], onLoadedCB, syncCallbackWhenAssetExist, autoDispose);
        }
        for (var i = 0; i < uis.length; i++) {
            this.preLoadUIAsset(uis[i], onLoadedCB, syncCallbackWhenAssetExist, autoDispose);
        }
        for (var i = 0; i < jsons.length; i++) {
            var url = jsons[i];
            this.loadJson(url, onLoadedCB, syncCallbackWhenAssetExist, true);
            if (autoDispose)
                setTimeout(function (id) { AssetManager.disposeJson(url); }, AssetManager.disposeInterval, url);
        }
    };
    AssetManager.disposeScene = function (id) {
        if (!id || id <= 0 || Config.EDIT_MODE)
            return;
        var dataURL = "asset/json/scene/data/scene" + id + ".json";
        AssetManager.loadJson(dataURL, Callback.New(function (jsonObj) {
            if (!jsonObj)
                return;
            AssetManager.disposeJson(dataURL);
            var imgUrls = [];
            for (var i = 0; i < jsonObj.LayerDatas.length; i++) {
                var layerData = jsonObj.LayerDatas[i];
                if (layerData.img) {
                    imgUrls.push(layerData.img);
                }
                if (this.drawMode && layerData.tileData) {
                    for (var id in layerData.tileData) {
                        var tileData = Game.data.tileList.data[id];
                        if (tileData && tileData.url)
                            imgUrls.push(tileData.url);
                    }
                }
            }
            AssetManager.disposeImages(imgUrls);
            if (jsonObj.bgm) {
                AssetManager.disposeAudio(jsonObj.bgm);
            }
            if (jsonObj.bgs) {
                AssetManager.disposeAudio(jsonObj.bgs);
            }
            for (var s in jsonObj.preLoadAssets) {
                var preLoadAssetInfo = jsonObj.preLoadAssets[s];
                var valueStr = preLoadAssetInfo.value;
                var valueInt = preLoadAssetInfo.value;
                switch (preLoadAssetInfo.type) {
                    case 0:
                        AssetManager.disposeImage(valueStr);
                        break;
                    case 1:
                        AssetManager.disposeAudio(valueStr);
                        break;
                    case 2:
                        AssetManager.disposeText(valueStr);
                        break;
                    case 3:
                        AssetManager.disposeJson(valueStr);
                        break;
                    case 4:
                        AssetManager.disposeAvatarAsset(valueInt);
                        break;
                    case 5:
                        AssetManager.disposeUIAsset(valueInt);
                        break;
                    case 6:
                        AssetManager.disposeAnimationAsset(valueInt);
                        break;
                }
            }
        }, this));
    };
    AssetManager.disposeSceneObject = function (so) {
        if (Config.EDIT_MODE)
            return;
        var modelData = Common.sceneObjectModelList.data[so.modelID];
        if (!modelData) {
            return;
        }
        var loads = [];
        for (var i in modelData.preLayer) {
            var preLayer = modelData.preLayer[i];
            var displayInfo = so.displayList[preLayer.varName];
            if (!displayInfo) {
                continue;
            }
            ;
            switch (preLayer.type) {
                case 1:
                    this.disposeAvatarAsset(displayInfo.id);
                    break;
                case 2:
                    this.disposeUIAsset(preLayer.id);
                    break;
                case 3:
                    if (displayInfo) {
                        this.disposeUIAsset(displayInfo.id);
                    }
                    break;
                case 4:
                    this.disposeAnimationAsset(preLayer.id);
                    break;
                case 5:
                    if (displayInfo) {
                        this.disposeAnimationAsset(displayInfo.id);
                    }
                    break;
            }
        }
    };
    AssetManager.disposeAvatarAsset = function (id) {
        if (!id || id < 0 || Config.EDIT_MODE)
            return;
        var dataURL = "asset/json/avatar/data/avatar" + id + ".json";
        AssetManager.loadJson(dataURL, Callback.New(function (avatarData) {
            if (!avatarData) {
                return;
            }
            AssetManager.disposeJson(dataURL);
            AssetManager.disposeImages(avatarData.picUrls);
            for (var i = 0; i < avatarData.parts.length; i++) {
                var avatarPartID = avatarData.parts[i].id;
                if (avatarPartID == 0)
                    continue;
                AssetManager.disposeAvatarAsset(avatarPartID);
            }
        }, this), true, false);
    };
    AssetManager.disposeUIAsset = function (id) {
        if (!id || id <= 0 || Config.EDIT_MODE)
            return;
        var uiArr = AssetManager.preUIs[id];
        if (!uiArr || uiArr.length == 0)
            return;
        var ui = uiArr.shift();
        ui.dispose();
    };
    AssetManager.disposeAnimationAsset = function (id) {
        if (!id || id <= 0 || Config.EDIT_MODE)
            return;
        var dataURL = "asset/json/animation/data/ani" + id + ".json";
        AssetManager.loadJson(dataURL, Callback.New(function (aniData) {
            if (!aniData || !aniData.imageSources) {
                return;
            }
            AssetManager.disposeJson(dataURL);
            if (aniData.isParticle && aniData.particleData) {
                AssetManager.disposeImage(aniData.particleData.textureName);
            }
            else {
                for (var index = 0; index < aniData.layers.length; index++) {
                    var layerInfo = aniData.layers[index];
                    if (layerInfo.type == AnimationItemType.Animation) {
                        var nodes = ArrayUtils.getTreeNodeArray(layerInfo);
                        for (var s in nodes) {
                            var childLayerInfo = nodes[s];
                            if (childLayerInfo.type == AnimationItemType.Animation) {
                                AssetManager.disposeAnimationAsset(childLayerInfo.animationId);
                            }
                        }
                    }
                }
                var picUrls = aniData.imageSources.reduce(function (pv, v) { if (v && pv.indexOf(v.url) == -1)
                    pv.push(v.url); return pv; }, []);
                AssetManager.disposeImages(picUrls);
            }
        }, this), true, false);
    };
    AssetManager.loadImage = function (url, complete, syncCallbackWhenAssetExist, useRef) {
        if (complete === void 0) { complete = null; }
        if (syncCallbackWhenAssetExist === void 0) { syncCallbackWhenAssetExist = false; }
        if (useRef === void 0) { useRef = true; }
        this.loadAsset(url, Loader.IMAGE, complete, syncCallbackWhenAssetExist, useRef);
    };
    AssetManager.loadTexture = function (url, complete, syncCallbackWhenAssetExist, useRef) {
        if (complete === void 0) { complete = null; }
        if (syncCallbackWhenAssetExist === void 0) { syncCallbackWhenAssetExist = false; }
        if (useRef === void 0) { useRef = true; }
        this.loadAsset(url, Loader.IMAGE, complete, syncCallbackWhenAssetExist, useRef, true);
    };
    AssetManager.loadImages = function (urls, complete, syncCallbackWhenAssetExist, useRef) {
        if (complete === void 0) { complete = null; }
        if (syncCallbackWhenAssetExist === void 0) { syncCallbackWhenAssetExist = false; }
        if (useRef === void 0) { useRef = true; }
        this.batchLoadAsset(urls, Loader.IMAGE, complete, syncCallbackWhenAssetExist, useRef);
    };
    AssetManager.loadTextures = function (urls, complete, syncCallbackWhenAssetExist, useRef) {
        if (complete === void 0) { complete = null; }
        if (syncCallbackWhenAssetExist === void 0) { syncCallbackWhenAssetExist = false; }
        if (useRef === void 0) { useRef = true; }
        this.batchLoadAsset(urls, Loader.IMAGE, complete, syncCallbackWhenAssetExist, useRef, true);
    };
    AssetManager.loadAudio = function (url, complete, syncCallbackWhenAssetExist, useRef) {
        if (complete === void 0) { complete = null; }
        if (syncCallbackWhenAssetExist === void 0) { syncCallbackWhenAssetExist = false; }
        if (useRef === void 0) { useRef = true; }
        this.loadAsset(url, Loader.SOUND, complete, syncCallbackWhenAssetExist, useRef);
    };
    AssetManager.loadAudios = function (urls, complete, syncCallbackWhenAssetExist, useRef) {
        if (complete === void 0) { complete = null; }
        if (syncCallbackWhenAssetExist === void 0) { syncCallbackWhenAssetExist = false; }
        if (useRef === void 0) { useRef = true; }
        this.batchLoadAsset(urls, Loader.IMAGE, complete, syncCallbackWhenAssetExist, useRef);
    };
    AssetManager.loadJson = function (url, complete, syncCallbackWhenAssetExist, useRef) {
        if (syncCallbackWhenAssetExist === void 0) { syncCallbackWhenAssetExist = false; }
        if (useRef === void 0) { useRef = true; }
        if (!url) {
            complete && (syncCallbackWhenAssetExist ? complete.runWith([]) : complete.delayRun(1, null, []));
            return;
        }
        if (useRef)
            AssetManager.addRef(url);
        var asset = loader.getRes(url);
        if (asset) {
            complete && (syncCallbackWhenAssetExist ? complete.runWith([asset]) : complete.delayRun(1, null, [asset]));
            return;
        }
        FileUtils.loadJsonFile(url, complete);
    };
    AssetManager.loadJsons = function (urls, complete, syncCallbackWhenAssetExist, useRef) {
        if (syncCallbackWhenAssetExist === void 0) { syncCallbackWhenAssetExist = false; }
        if (useRef === void 0) { useRef = true; }
        this.batchLoadAsset(urls, Loader.JSON, complete, syncCallbackWhenAssetExist, useRef);
    };
    AssetManager.loadText = function (url, complete, syncCallbackWhenAssetExist, useRef) {
        if (syncCallbackWhenAssetExist === void 0) { syncCallbackWhenAssetExist = false; }
        if (useRef === void 0) { useRef = true; }
        this.loadAsset(url, Loader.TEXT, complete, syncCallbackWhenAssetExist, useRef);
    };
    AssetManager.loadTexts = function (urls, complete, syncCallbackWhenAssetExist, useRef) {
        if (syncCallbackWhenAssetExist === void 0) { syncCallbackWhenAssetExist = false; }
        if (useRef === void 0) { useRef = true; }
        this.batchLoadAsset(urls, Loader.TEXT, complete, syncCallbackWhenAssetExist, useRef);
    };
    AssetManager.loadAsset = function (url, type, complete, syncCallbackWhenAssetExist, useRef, isTexture) {
        if (complete === void 0) { complete = null; }
        if (syncCallbackWhenAssetExist === void 0) { syncCallbackWhenAssetExist = false; }
        if (useRef === void 0) { useRef = true; }
        if (isTexture === void 0) { isTexture = false; }
        if (!url) {
            complete && (syncCallbackWhenAssetExist ? complete.runWith([]) : complete.delayRun(1));
            return;
        }
        if (useRef)
            AssetManager.addRef(url);
        var asset = loader.getRes(url);
        if (asset) {
            if (type == Loader.IMAGE) {
                if (isTexture)
                    (asset.bitmap).enableMerageInAtlas = false;
                else
                    (asset.bitmap).enableMerageInAtlas = true;
            }
            complete && (syncCallbackWhenAssetExist ? complete.runWith([asset]) : complete.delayRun(1, null, [asset]));
            return;
        }
        loader.load(url, Handler.create(this, function (asset) {
            if (type == Loader.IMAGE && isTexture)
                (asset.bitmap).enableMerageInAtlas = false;
            complete && complete.runWith([asset]);
        }), null, type);
    };
    AssetManager.batchLoadAsset = function (urls, type, complete, syncCallbackWhenAssetExist, useRef, isTexture) {
        if (complete === void 0) { complete = null; }
        if (syncCallbackWhenAssetExist === void 0) { syncCallbackWhenAssetExist = false; }
        if (useRef === void 0) { useRef = true; }
        if (isTexture === void 0) { isTexture = false; }
        var loadUrls = [];
        for (var i in urls) {
            if (urls[i])
                loadUrls.push(urls[i]);
        }
        if (loadUrls.length == 0) {
            complete && (syncCallbackWhenAssetExist ? complete.run() : complete.delayRun(1));
            return;
        }
        var allExist = true;
        for (var i in loadUrls) {
            var url = loadUrls[i];
            var asset = loader.getRes(url);
            if (!asset)
                allExist = false;
            if (asset && type == Loader.IMAGE) {
                if (isTexture)
                    (asset.bitmap).enableMerageInAtlas = false;
                else
                    (asset.bitmap).enableMerageInAtlas = true;
            }
            if (useRef)
                AssetManager.addRef(url);
        }
        if (allExist) {
            complete && (syncCallbackWhenAssetExist ? complete.run() : complete.delayRun(1));
        }
        else {
            loader.load(loadUrls, Handler.create(this, function () {
                if (type == Loader.IMAGE && isTexture) {
                    for (var i in loadUrls) {
                        var url = loadUrls[i];
                        var asset = loader.getRes(url);
                        if (!asset)
                            continue;
                        (asset.bitmap).enableMerageInAtlas = false;
                    }
                }
                complete && complete.run();
            }), null, type);
        }
    };
    AssetManager.getImage = function (url) {
        var tex = loader.getRes(url);
        return tex;
    };
    AssetManager.getJson = function (url) {
        return loader.getRes(url);
    };
    AssetManager.getText = function (url) {
        return loader.getRes(url);
    };
    AssetManager.disposeImage = function (url) {
        if (Config.EDIT_MODE)
            return;
        Callback.New(function (url) {
            var ref = AssetManager.subRef(url);
            if (ref == 0) {
                AssetManager.imageAssets[url] = null;
                var t = loader.getRes(url);
                loader.clearRes(url, true);
                if (t && t.destroy)
                    t.destroy(true);
            }
        }, this, [url]).delayRun(AssetManager.disposeInterval);
    };
    AssetManager.disposeImages = function (urls) {
        if (Config.EDIT_MODE)
            return;
        Callback.New(function (urls) {
            for (var i in urls) {
                AssetManager.disposeImage(urls[i]);
            }
        }, this, [urls]).delayRun(AssetManager.disposeInterval);
    };
    AssetManager.disposeAudio = function (url) {
        if (Config.EDIT_MODE)
            return;
        Callback.New(function (url) {
            var ref = AssetManager.subRef(url);
            if (ref == 0) {
                var s = loader.getRes(url);
                loader.clearRes(url, true);
                if (s && s.dispose)
                    s.dispose();
            }
        }, this, [url]).delayRun(AssetManager.disposeInterval);
    };
    AssetManager.disposeJson = function (url) {
        if (Config.EDIT_MODE || !url)
            return;
        Callback.New(function (url) {
            var ref = AssetManager.subRef(url);
            if (ref == 0) {
                loader.clearRes(url, true);
            }
        }, this, [url]).delayRun(AssetManager.disposeInterval);
    };
    AssetManager.disposeText = function (url) {
        if (Config.EDIT_MODE || !url)
            return;
        Callback.New(function (url) {
            var ref = AssetManager.subRef(url);
            if (ref == 0) {
                loader.clearRes(url, true);
            }
        }, this, [url]).delayRun(AssetManager.disposeInterval);
    };
    AssetManager.getClipImage = function (url, x, y, rect) {
        var tex = loader.getRes(url);
        if (!tex)
            return null;
        var imageAssetClips = AssetManager.imageAssets[url];
        if (!imageAssetClips)
            imageAssetClips = AssetManager.imageAssets[url] = {};
        var key = x + "_" + y + "_" + rect.width + "_" + rect.height + "_" + rect.x + "_" + rect.y;
        var g = imageAssetClips[key];
        if (!g) {
            g = imageAssetClips[key] = new Graphics();
            g.fillTexture(tex, x, y, rect.width, rect.height, null, new Point(rect.x, rect.y));
        }
        return g;
    };
    AssetManager.drawToTexture = function (source, textureWidth, textureHeight, offsetX, offsetY, mipmap, minFifter, magFifter) {
        if (offsetX === void 0) { offsetX = 0; }
        if (offsetY === void 0) { offsetY = 0; }
        if (mipmap === void 0) { mipmap = false; }
        if (minFifter === void 0) { minFifter = 0x2600; }
        if (magFifter === void 0) { magFifter = 0x2600; }
        var helpSprite;
        if (source instanceof Graphics) {
            helpSprite = new Sprite();
            helpSprite.graphics = source;
            helpSprite.blendMode = "light";
        }
        else {
            helpSprite = source;
        }
        var oldRect = helpSprite.scrollRect;
        helpSprite.scrollRect = new Rectangle(-offsetX, -offsetY, textureWidth, textureHeight);
        var t = _drawToTexture(helpSprite, textureWidth, textureHeight, 0, 0, mipmap, minFifter, magFifter);
        helpSprite.scrollRect = oldRect;
        var texture = new Texture(t.bitmap);
        return texture;
        function _drawToTexture(sprite, textureWidth, textureHeight, offsetX, offsetY, mipmap, minFifter, magFifter) {
            var _renderType = 640;
            offsetX -= sprite.x;
            offsetY -= sprite.y;
            sprite.scaleY *= -1;
            var renderTarget = RenderTarget2D.create(textureWidth, textureHeight, 0x1908, 0x1401, 0, mipmap, false, minFifter, magFifter);
            renderTarget.start();
            renderTarget.clear(0.0, 0.0, 0.0, 0.0);
            Render.context.clear();
            RenderSprite.renders[_renderType]._fun(sprite, Render.context, offsetX, RenderState2D.height + offsetY);
            Render.context.flush();
            renderTarget.end();
            sprite.scaleY *= -1;
            return renderTarget;
        }
    };
    AssetManager.drawToAtlasSprite = function (source, width, height, mipmap, minFifter, magFifter, offsetX, offsetY) {
        if (mipmap === void 0) { mipmap = false; }
        if (minFifter === void 0) { minFifter = -1; }
        if (magFifter === void 0) { magFifter = -1; }
        if (offsetX === void 0) { offsetX = 0; }
        if (offsetY === void 0) { offsetY = 0; }
        var root = new Sprite();
        var splitW = Math.ceil(width / Config.TILE_SPLIT_SIZE);
        var splitH = Math.ceil(height / Config.TILE_SPLIT_SIZE);
        for (var xGrid = 0; xGrid < splitW; xGrid++) {
            for (var yGrid = 0; yGrid < splitH; yGrid++) {
                var dx = -Config.TILE_SPLIT_SIZE * xGrid;
                var dy = -Config.TILE_SPLIT_SIZE * yGrid;
                var tex = AssetManager.drawToTexture(source, Config.TILE_SPLIT_SIZE, Config.TILE_SPLIT_SIZE, dx + offsetX, dy + offsetY, mipmap, minFifter, magFifter);
                var splitSp = new Sprite();
                splitSp.texture = tex;
                splitSp.x = -dx;
                splitSp.y = -dy;
                root.addChild(splitSp);
            }
        }
        return root;
    };
    AssetManager.bigTextureToAtlasSprite = function (texture, xLoop, yLoop, mapWidth, mapHeight) {
        if (xLoop === void 0) { xLoop = false; }
        if (yLoop === void 0) { yLoop = false; }
        if (mapWidth === void 0) { mapWidth = 0; }
        if (mapHeight === void 0) { mapHeight = 0; }
        var drawArea = [];
        if (xLoop) {
            drawArea.push([1, 0], [-1, 0]);
        }
        if (yLoop) {
            drawArea.push([0, 1], [0, -1]);
        }
        if (xLoop && yLoop) {
            drawArea.push([-1, -1], [1, -1], [1, 1], [-1, 1]);
        }
        var img = texture.bitmap["_image"];
        if (!img) {
            return new Sprite();
        }
        var maxW = Config.TILE_SPLIT_SIZE;
        var maxH = Config.TILE_SPLIT_SIZE;
        var root = new Sprite();
        var splitW = Math.ceil(img.width / maxW);
        var splitH = Math.ceil(img.height / maxW);
        for (var xGrid = 0; xGrid < splitW; xGrid++) {
            for (var yGrid = 0; yGrid < splitH; yGrid++) {
                var dx = maxW * xGrid;
                var dy = maxW * yGrid;
                var canvas = document.createElement("canvas");
                canvas.width = maxW;
                canvas.height = maxW;
                var canvas2d = document.createElement("canvas");
                canvas2d.width = maxW;
                canvas2d.height = maxW;
                var ctx = canvas2d.getContext("2d");
                ctx.drawImage(img, dx, dy, maxW, maxW, 0, 0, maxW, maxH);
                var wgImage = new WebGLImage(canvas2d, new Date().getTime() + Math.random().toString());
                var newTexture = new Texture(wgImage);
                var splitSp = new Sprite();
                splitSp.texture = newTexture;
                splitSp.x = dx;
                splitSp.y = dy;
                for (var s in drawArea) {
                    var loopSp = new Sprite();
                    loopSp.name = "loop";
                    loopSp.texture = newTexture;
                    root.addChild(loopSp);
                    loopSp.x = drawArea[s][0] * mapWidth + splitSp.x;
                    loopSp.y = drawArea[s][1] * mapHeight + splitSp.y;
                }
                root.addChild(splitSp);
            }
        }
        return root;
    };
    AssetManager.disposeAtlasSprite = function (root) {
        if (!root)
            return;
        for (var i = 0; i < root.numChildren; i++) {
            var sp = root.getChildAt(i);
            sp.texture.destroy(true);
            sp.texture = null;
        }
        root.removeChildren();
    };
    AssetManager.subRef = function (url) {
        var ref = AssetManager.assetCountMap[url];
        if (ref == null)
            return 0;
        ref--;
        if (ref == 0) {
            delete AssetManager.assetCountMap[url];
        }
        else {
            AssetManager.assetCountMap[url] = ref;
        }
        return ref;
    };
    AssetManager.addRef = function (url) {
        var ref = AssetManager.assetCountMap[url];
        if (ref == null) {
            AssetManager.assetCountMap[url] = ref = 0;
        }
        AssetManager.assetCountMap[url] = ++ref;
    };
    AssetManager.assetCountMap = {};
    AssetManager.imageAssets = {};
    AssetManager.disposeInterval = 3000;
    AssetManager.preUIs = [];
    return AssetManager;
}());
var BlockChainManager = (function () {
    function BlockChainManager() {
    }
    BlockChainManager.openNeoLoginView = function (isAllowCancle, isignore, loginCallBack) {
        if (DNeoWallet.isLogin && isignore) {
            Callback.New(function () {
                GameCommand.inputMessageAndContinueExecute([""]);
            }, this).delayRun(0);
            return;
        }
        if (!BlockChainManager.neoLoginUI) {
            BlockChainManager.neoLoginUI = new NeoLogin();
        }
        BlockChainManager.neoLoginUI.x = 0.5 * (stage.width - BlockChainManager.neoLoginUI.width);
        BlockChainManager.neoLoginUI.y = 0.5 * (stage.height - BlockChainManager.neoLoginUI.height);
        BlockChainManager.neoLoginUI.init(isAllowCancle, loginCallBack);
        Game.layer.uiLayer.addChild(BlockChainManager.neoLoginUI);
    };
    BlockChainManager.openNeoTransferView = function (name, toAddress, assetType, value, isAllowInput, isAllowCancle) {
        if (!BlockChainManager.neoTransferUI) {
            BlockChainManager.neoTransferUI = new NeoTransfer();
        }
        BlockChainManager.neoTransferUI.x = 0.5 * (stage.width - BlockChainManager.neoTransferUI.width);
        BlockChainManager.neoTransferUI.y = 0.5 * (stage.height - BlockChainManager.neoTransferUI.height);
        BlockChainManager.neoTransferUI.init(name, toAddress, assetType, value, isAllowInput, isAllowCancle);
        Game.layer.uiLayer.addChild(BlockChainManager.neoTransferUI);
    };
    BlockChainManager.openNeoInvokeView = function (name, contract, operation, params, isAllowCancle) {
        if (!BlockChainManager.neoInvokeUI) {
            BlockChainManager.neoInvokeUI = new NeoInvoke();
        }
        BlockChainManager.neoInvokeUI.x = 0.5 * (stage.width - BlockChainManager.neoInvokeUI.width);
        BlockChainManager.neoInvokeUI.y = 0.5 * (stage.height - BlockChainManager.neoInvokeUI.height);
        BlockChainManager.neoInvokeUI.init(name, contract, operation, params, isAllowCancle);
        Game.layer.uiLayer.addChild(BlockChainManager.neoInvokeUI);
    };
    return BlockChainManager;
}());





var ClientScene = (function (_super) {
    __extends(ClientScene, _super);
    function ClientScene() {
        _super.call(this);
        this.players = [];
        this.settingLayers = [];
        this.layers = [];
        this.shakeX = 0;
        this.shakeY = 0;
        if (typeof GameSprite == "undefined")
            return;
        this.displayObject = new GameSprite();
        this.camera = new Rectangle(0, 0, Config.WINDOW_WIDTH, Config.WINDOW_HEIGHT);
    }
    ClientScene.createScene = function (sceneID, onBaseDataLoaded, onLoaded, syncCallbackWhenAssetExist) {
        if (onBaseDataLoaded === void 0) { onBaseDataLoaded = null; }
        if (onLoaded === void 0) { onLoaded = null; }
        if (syncCallbackWhenAssetExist === void 0) { syncCallbackWhenAssetExist = false; }
        AssetManager.loadJson("asset/json/scene/data/scene" + sceneID + ".json", Callback.New(function (mapData) {
            if (!mapData) {
                throw ("error:场景不存在");
            }
            var cls = mapData.clientInstanceClassName;
            var classImpl = globalThis[cls];
            var scene = (classImpl && classImpl.prototype instanceof ClientScene) ? new classImpl : new ClientScene();
            scene.isSetScene = true;
            scene.id = sceneID;
            Scene.parse(mapData, scene, Common.gameData);
            scene.install(Callback.New(function () {
                scene.event(EventObject.LOADED, [scene]);
                onLoaded && onLoaded.runWith([scene]);
            }, scene));
            scene.event(ClientScene.EVENT_BASE_DATA_LOADED, [scene]);
            onBaseDataLoaded && onBaseDataLoaded.runWith([scene]);
        }, this), syncCallbackWhenAssetExist);
    };
    ClientScene.prototype.dispose = function (autoStopAudio) {
        if (autoStopAudio === void 0) { autoStopAudio = true; }
        if (!this.isDisposed) {
            this.isDisposed = true;
            this.stopRender();
            if (autoStopAudio) {
                if (this.bgm && GameAudio.lastBgmURL == this.bgm) {
                    GameAudio.playBGM(this.bgm, 0, 9999, true, Config.SCENE_BGM_TWEEN);
                }
                if (this.bgs && GameAudio.lastBgsURL == this.bgs) {
                    GameAudio.playBGS(this.bgs, 0, 9999, true, Config.SCENE_BGM_TWEEN);
                }
            }
            this.displayObject.removeSelf();
            for (var i in this.layers) {
                this.layers[i].dispose();
            }
            for (var i in this.sceneObjects) {
                var so = this.sceneObjects[i];
                if (so)
                    so.dispose();
            }
            this.displayObject.destroy(true);
            this.sceneObjects.length = 0;
        }
    };
    ClientScene.prototype.install = function (onFin) {
        this.settingLayers.length = 0;
        var oldLayers = this.layers.concat();
        for (var i = 0; i < oldLayers.length; i++) {
            oldLayers[i].dispose();
        }
        this.layers.length = this.settingLayers.length = 0;
        for (var i = 0; i < this.LayerDatas.length; i++) {
            var layerData = this.LayerDatas[i];
            var layer = new ClientSceneLayer(this);
            new SyncTask(ClientScene.LOAD_LAYERS, function () { });
            layer.install(layerData, Callback.New(SyncTask.taskOver, SyncTask, [ClientScene.LOAD_LAYERS]));
            this.addLayer(layer);
            this.settingLayers.push(layer);
            if (layerData.p)
                this.sceneObjectLayer = layer;
        }
        var sceneObjectLayerIndex = this.layers.indexOf(this.sceneObjectLayer);
        this.sceneObjectLowLayer = new ClientSceneLayer(this);
        this.addLayerAt(this.sceneObjectLowLayer, sceneObjectLayerIndex);
        this.animationLowLayer = new ClientSceneLayer(this);
        this.addLayerAt(this.animationLowLayer, sceneObjectLayerIndex);
        this.shadowLayer = new ClientSceneLayer(this);
        this.addLayerAt(this.shadowLayer, sceneObjectLayerIndex);
        var layerArr = ["sceneObjectHighLayer", "animationHighLayer", "fogLayer", "weaterLayer"];
        for (var s in layerArr) {
            layer = this[layerArr[s]] = new ClientSceneLayer(this);
            this.addLayer(layer);
        }
        this.sceneObjectLowLayer.isChangeChildZOrder = true;
        this.sceneObjectLayer.isChangeChildZOrder = true;
        this.sceneObjectHighLayer.isChangeChildZOrder = true;
        if (Config.DEBUG_OBSTACLE) {
            this.debugLayer = new ClientSceneLayer(this);
            this.addLayer(this.debugLayer);
            this.debugLayer.alpha = 0.7;
        }
        new SyncTask(ClientScene.LOAD_LAYERS, function () {
            onFin.run();
            SyncTask.taskOver(ClientScene.LOAD_LAYERS);
        });
    };
    ClientScene.prototype.refreshSceneSystemLayers = function () {
        this.layers.length = 0;
        this.displayObject.removeChildren();
        for (var i = 0; i < this.settingLayers.length; i++) {
            var layer = this.settingLayers[i];
            this.addLayer(layer);
        }
        var sceneObjectLayerIndex = this.layers.indexOf(this.sceneObjectLayer);
        this.addLayerAt(this.sceneObjectLowLayer, sceneObjectLayerIndex);
        this.addLayerAt(this.animationLowLayer, sceneObjectLayerIndex);
        this.addLayerAt(this.shadowLayer, sceneObjectLayerIndex);
        var layerArr = ["sceneObjectHighLayer", "animationHighLayer", "fogLayer", "weaterLayer"];
        for (var s in layerArr) {
            layer = this[layerArr[s]];
            this.addLayer(layer);
        }
        if (Config.DEBUG_OBSTACLE) {
            this.addLayer(this.debugLayer);
        }
    };
    ClientScene.prototype.addLayer = function (layer) {
        this.displayObject.addChild(layer);
        this.layers.push(layer);
    };
    ClientScene.prototype.addLayerAt = function (layer, index) {
        this.displayObject.addChildAt(layer, index);
        this.layers.splice(index, 0, layer);
    };
    ClientScene.prototype.removeLayer = function (layer) {
        this.displayObject.removeChild(layer);
        this.layers.splice(this.layers.indexOf(layer), 1);
    };
    ClientScene.prototype.removeLayerAt = function (index) {
        this.displayObject.removeChildAt(index);
        this.layers.splice(index, 1);
    };
    ClientScene.prototype.setLayerIndex = function (layer, index) {
        this.displayObject.setChildIndex(layer, index);
        ArrayUtils.adjustment(this.layers, layer, index);
    };
    ClientScene.prototype.getLayer = function (index) {
        return this.layers[index];
    };
    ClientScene.prototype.getLayerByPreset = function (id) {
        return ArrayUtils.get(this.settingLayers, id - 1);
    };
    ClientScene.prototype.addSceneObject = function (soData, isSoc, useModelClass) {
        if (isSoc === void 0) { isSoc = false; }
        if (useModelClass === void 0) { useModelClass = false; }
        var soc;
        if (isSoc) {
            soc = soData;
        }
        else {
            if (useModelClass) {
                var modelData = Common.sceneObjectModelList.data[soData.modelID];
                if (modelData) {
                    var cls;
                    if (modelData.clientInstanceClassName && window[modelData.clientInstanceClassName]) {
                        cls = window[modelData.clientInstanceClassName];
                    }
                    else {
                        cls = SceneObjectModelData.sceneObjectClass[soData.modelID];
                    }
                    soc = new cls(soData, this);
                }
                else {
                    soc = new ClientSceneObject(soData, this);
                }
            }
            else {
                soc = new ClientSceneObject(soData, this);
            }
        }
        this.sceneObjects[soData.index] = soc;
        soc.inScene = true;
        if (soc.onTop == 0) {
            this.sceneObjectLowLayer.addChild(soc.root);
        }
        else if (soc.onTop == 1) {
            this.sceneObjectLayer.addChild(soc.root);
        }
        else {
            this.sceneObjectHighLayer.addChild(soc.root);
        }
        this.shadowLayer.addChild(soc.shadow);
        soc.refreshCoordinate();
        return soc;
    };
    ClientScene.prototype.removeSceneObject = function (so) {
        var soc = this.sceneObjects[so.index];
        this.sceneObjects[so.index] = null;
        if (soc) {
            soc.root.parent.removeChild(soc.root);
            this.shadowLayer.removeChild(soc.shadow);
            this.updateDynamicObsAndBridge(soc, false);
            soc.inScene = false;
        }
        return soc;
    };
    ClientScene.prototype.addPlayer = function (player) {
        if (this.players.indexOf(player) == -1)
            this.players.push(player);
    };
    ClientScene.prototype.removePlayer = function (player) {
        ArrayUtils.remove(this.players, player);
    };
    Object.defineProperty(ClientScene.prototype, "localX", {
        get: function () {
            if (!this.displayObject.scrollRect)
                return 0;
            return this.displayObject.mouseX - (this.displayObject.scrollRect.x / this.displayObject.scaleX) + this.displayObject.scrollRect.x;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClientScene.prototype, "localY", {
        get: function () {
            if (!this.displayObject.scrollRect)
                return 0;
            return this.displayObject.mouseY - (this.displayObject.scrollRect.y / this.displayObject.scaleY) + this.displayObject.scrollRect.y;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ClientScene.prototype, "globalPos", {
        get: function () {
            return this.getGlobalPos(this.localX, this.localY);
        },
        enumerable: true,
        configurable: true
    });
    ClientScene.prototype.getGlobalPos = function (localX, localY) {
        var sceneP = new Point(localX, localY);
        var globalP = this.displayObject.localToGlobal(sceneP);
        return globalP;
    };
    ClientScene.prototype.setCameraSceneObject = function (sceneObject) {
        this.cameraObject = sceneObject;
        this.updateCamera();
    };
    ClientScene.prototype.setCameraPos = function (x, y, w, h) {
        if (w === void 0) { w = null; }
        if (h === void 0) { h = null; }
        this.camera.x = x;
        this.camera.y = y;
        this.setCameraSize(w, h);
        this.updateCamera();
    };
    ClientScene.prototype.setCameraScale = function (scaleX, scaleY) {
        this.displayObject.scaleX = scaleX;
        this.displayObject.scaleY = scaleY;
        this.updateCamera();
    };
    ClientScene.prototype.setCameraSize = function (w, h) {
        if (w)
            this.camera.width = w;
        if (h)
            this.camera.height = h;
        this.updateCamera();
    };
    ClientScene.prototype.getCamera = function () {
        return this.camera;
    };
    ClientScene.prototype.setViewPort = function (rect, isLimit) {
        if (isLimit === void 0) { isLimit = true; }
        if (this.displayObject.scaleX != 1 || this.displayObject.scaleY != 1) {
            rect = rect.clone();
            var sw = (1 / this.displayObject.scaleX) * rect.width - rect.width;
            var sh = (1 / this.displayObject.scaleY) * rect.height - rect.height;
            this["__sw"] = sw;
            this["__sh"] = sh;
            rect.x -= sw * 0.5;
            rect.y -= sh * 0.5;
            rect.width += sw;
            rect.height += sh;
        }
        if (isLimit && !this.editorMode) {
            if (rect.x > this.width - rect.width)
                rect.x = this.width - rect.width;
            if (rect.y > this.height - rect.height)
                rect.y = this.height - rect.height;
            if (rect.x < 0)
                rect.x = 0;
            if (rect.y < 0)
                rect.y = 0;
        }
        if (this.shakeX != 0 || this.shakeY != 0) {
            rect = rect.clone();
            rect.x += this.shakeX;
            rect.y += this.shakeY;
        }
        this.displayObject.scrollRect = rect;
        var len = this.displayObject.numChildren;
        for (var i = 0; i < len; i++) {
            var layer = this.displayObject.getChildAt(i);
            layer.setViewPort(rect);
        }
    };
    ClientScene.prototype.startRender = function () {
        this.stopRender();
        os.add_ENTERFRAME(this.onRender, this);
    };
    ClientScene.prototype.stopRender = function (zFrame) {
        if (zFrame === void 0) { zFrame = false; }
        os.remove_ENTERFRAME(this.onRender, this);
        if (zFrame) {
            for (var i = 0; i < this.layers.length; i++) {
                var layer = this.layers[i];
                layer.onRender(zFrame);
            }
        }
    };
    ClientScene.prototype.updateCamera = function () {
        if (this.cameraObject) {
            this.camera.x = this.cameraObject.x - this.camera.width * 0.5;
            this.camera.y = this.cameraObject.y - this.camera.height * 0.5;
        }
        this.setViewPort(this.camera);
    };
    ClientScene.prototype.onRender = function () {
        var now = new Date().getTime();
        this.updateCamera();
        for (var i = 0; i < this.layers.length; i++) {
            var layer = this.layers[i];
            layer.onRender();
        }
        for (var s in this.sceneObjects) {
            var soc = this.sceneObjects[s];
            if (!soc)
                continue;
            soc.update(now);
        }
        if (Config.DEBUG_OBSTACLE) {
            this.debugLayer.graphics.clear();
            for (var x = 0; x < this.gridWidth; x++) {
                for (var y = 0; y < this.gridHeight; y++) {
                    var gridStatus = this["gridDynamicObsStatus"](new Point(x, y));
                    if (gridStatus == 2 && this.obstacleData[x] && this.obstacleData[x][y]) {
                        this.debugLayer.graphics.drawRect(x * Config.SCENE_GRID_SIZE, y * Config.SCENE_GRID_SIZE, Config.SCENE_GRID_SIZE, Config.SCENE_GRID_SIZE, "#FF00FF");
                    }
                    if (gridStatus == 2) {
                        this.debugLayer.graphics.drawRect(x * Config.SCENE_GRID_SIZE, y * Config.SCENE_GRID_SIZE, Config.SCENE_GRID_SIZE, Config.SCENE_GRID_SIZE, "#FF6600");
                    }
                    else if (this.obstacleData[x] && this.obstacleData[x][y]) {
                        this.debugLayer.graphics.drawRect(x * Config.SCENE_GRID_SIZE, y * Config.SCENE_GRID_SIZE, Config.SCENE_GRID_SIZE, Config.SCENE_GRID_SIZE, "#FF0000");
                    }
                }
            }
        }
    };
    ClientScene.prototype.hasListener = function (type) { return this.displayObject.hasListener.apply(this.displayObject, arguments); };
    ;
    ClientScene.prototype.event = function (type, data) { return this.displayObject.event.apply(this.displayObject, arguments); };
    ;
    ClientScene.prototype.on = function (type, caller, listener, args) { return this.displayObject.on.apply(this.displayObject, arguments); };
    ;
    ClientScene.prototype.once = function (type, caller, listener, args) { return this.displayObject.once.apply(this.displayObject, arguments); };
    ;
    ClientScene.prototype.off = function (type, caller, listener, onceOnly) { return this.displayObject.off.apply(this.displayObject, arguments); };
    ;
    ClientScene.prototype.offAll = function (type) { return this.displayObject.offAll.apply(this, arguments); };
    ;
    ClientScene.EVENT_BASE_DATA_LOADED = "ClientScene_EVENT_FIRST_LOADED";
    ClientScene.LOAD_LAYERS = "ClientScene_LOAD_LAYERS";
    return ClientScene;
}(Scene));
ObjectUtils.reDefineGetSet("ClientScene.prototype", {
    id: function (v) {
        if (!this.isSetScene) {
            this.isSetScene = true;
            if (!Config.EDIT_MODE) {
                AssetManager.loadJson("asset/json/scene/data/scene" + this.id + ".json", Callback.New(function (mapData) {
                    var _this = this;
                    Scene.parse(mapData, this, Common.gameData);
                    this.install(Callback.New(function () {
                        _this.event(EventObject.LOADED, [_this]);
                    }, this));
                    this.event(ClientScene.EVENT_BASE_DATA_LOADED, [this]);
                }, this));
            }
            else {
            }
        }
    }
});





var ClientSceneObject = (function (_super) {
    __extends(ClientSceneObject, _super);
    function ClientSceneObject(soData, scene) {
        if (scene === void 0) { scene = null; }
        _super.call(this);
        this.posGrid = new Point(-1, -1);
        this.posHelper = new Point();
        this.tempPosHelper = new Point();
        this._animationMap = {};
        this.scene = scene;
        if (!soData)
            return;
        this.init();
        if (soData)
            ObjectUtils.clone(soData, this);
        this.install();
    }
    ClientSceneObject.prototype.init = function () {
        this.root = new GameSprite();
        this.root.name = "__SOC";
        this.root["__SOC"] = this;
        var layerNames = {
            animationLowLayer: GameSprite,
            customLayer: GameSprite,
            animationHighLayer: GameSprite,
            customHighLayer: GameSprite,
            systemUILayer: Sprite
        };
        for (var i in layerNames) {
            var layer = this[i] = new layerNames[i]();
            this.root.addChild(layer);
        }
        this.avatarContainer = new GameSprite();
        this.avatar = new Avatar();
        this.avatarContainer.addChild(this.avatar);
        this.shadow = new Sprite();
    };
    ClientSceneObject.prototype.install = function () {
        this.refreshShadow();
        this.refreshCustomDisplayList();
    };
    ClientSceneObject.prototype.stopRender = function () {
        this.avatar.stop(this.avatarFrame);
        for (var i in this._animationMap) {
            var ani = this._animationMap[i];
            ani.stop(ani.currentFrame);
        }
        var customDisplayLayers = this.getCustomDisplayLayers();
        for (var i in customDisplayLayers) {
            var sp = customDisplayLayers[i];
            if (sp instanceof Animation) {
                sp.stop(sp.currentFrame);
            }
        }
    };
    ClientSceneObject.prototype.recoveryRender = function () {
        if (this.autoPlayEnable)
            this.avatar.gotoAndPlay(this.avatarFrame);
        for (var i in this._animationMap) {
            var ani = this._animationMap[i];
            ani.gotoAndPlay(ani.currentFrame);
        }
        var customDisplayLayers = this.getCustomDisplayLayers();
        for (var i in customDisplayLayers) {
            var sp = customDisplayLayers[i];
            if (sp instanceof Animation) {
                sp.gotoAndPlay(sp.currentFrame);
            }
        }
    };
    ClientSceneObject.prototype.refreshCustomDisplayList = function () {
        this.clearCustomDisplayList();
        var modelData = Game.data.sceneObjectModelList.data[this.modelID];
        if (!modelData) {
            this.customLayer.addChild(this.avatarContainer);
        }
        else {
            var layer = this.customLayer;
            for (var i in modelData.preLayer) {
                var preLayer = modelData.preLayer[i];
                if (preLayer.type != 1 && (preLayer.inEditorShowMode == 1 && Config.EDIT_MODE) || (preLayer.inEditorShowMode == 2 && !Config.EDIT_MODE))
                    continue;
                var newLayer;
                switch (preLayer.type) {
                    case 1:
                        newLayer = this.avatar;
                        layer.addChild(this.avatarContainer);
                        layer = this.customHighLayer;
                        break;
                    case 2:
                        newLayer = GameUI.load(preLayer.id, true);
                        if (newLayer)
                            layer.addChild(newLayer);
                        break;
                    case 3:
                        if (this.displayList[preLayer.varName]) {
                            newLayer = GameUI.load(this.displayList[preLayer.varName].id, true);
                            if (newLayer)
                                layer.addChild(newLayer);
                        }
                        break;
                    case 4:
                        var animation = newLayer = new Animation();
                        if (Config.EDIT_MODE)
                            animation.silentMode = true;
                        animation.sceneObject = this;
                        animation.id = preLayer.id;
                        layer.addChild(animation);
                        animation.loop = true;
                        animation.showHitEffect = true;
                        animation.gotoAndPlay();
                        break;
                    case 5:
                        if (this.displayList[preLayer.varName]) {
                            var animation = newLayer = new Animation();
                            if (Config.EDIT_MODE)
                                animation.silentMode = true;
                            animation.sceneObject = this;
                            animation.id = this.displayList[preLayer.varName].id;
                            layer.addChild(animation);
                            animation.loop = true;
                            animation.showHitEffect = true;
                            animation.gotoAndPlay();
                        }
                        break;
                }
                if (!Config.EDIT_MODE && typeof this[preLayer.varName] == "undefined") {
                    this[preLayer.varName] = newLayer;
                }
            }
        }
    };
    ClientSceneObject.prototype.clearCustomDisplayList = function () {
        var displays = [];
        for (var i = 0; i < this.customLayer.numChildren; i++) {
            displays.push(this.customLayer.getChildAt(i));
        }
        for (var i = 0; i < this.customHighLayer.numChildren; i++) {
            displays.push(this.customHighLayer.getChildAt(i));
        }
        for (var i = 0; i < displays.length; i++) {
            var display = displays[i];
            if (display == this.avatarContainer)
                continue;
            display.dispose && display.dispose();
        }
        this.customLayer.removeChildren();
        this.customHighLayer.removeChildren();
    };
    ClientSceneObject.prototype.getCustomDisplayLayers = function () {
        var displays = [];
        for (var i = 0; i < this.customLayer.numChildren; i++) {
            displays.push(this.customLayer.getChildAt(i));
        }
        for (var i = 0; i < this.customHighLayer.numChildren; i++) {
            displays.push(this.customHighLayer.getChildAt(i));
        }
        return displays;
    };
    ClientSceneObject.prototype.dispose = function () {
        if (!this.isDisposed) {
            this.isDisposed = true;
            EventUtils.clear(this);
            this.clearCustomDisplayList();
            for (var i in this._animationMap) {
                var ani = this._animationMap[i];
                if (ani)
                    ani.dispose();
            }
            AssetManager.disposeSceneObject(this);
            this.avatar && this.avatar.dispose();
        }
    };
    ClientSceneObject.prototype.refreshShadow = function (scalePer) {
        if (scalePer === void 0) { scalePer = 1.0; }
        this.shadow.graphics.clear();
        if (this.shadowEnable) {
            this.shadow.graphics.drawCircle(0, 0, this.shadowWidth * scalePer, this.shadowWidth * scalePer, "#000000", 0);
            this.shadow.scaleY = this.shadowHeight / this.shadowWidth * this.avatar.scaleY;
            this.shadow.scaleX = this.avatar.scaleX;
            this.shadow.alpha = this.shadowAlpha;
        }
    };
    ClientSceneObject.prototype.updateShadow = function () {
        this.shadow.x = this.root.x;
        this.shadow.y = this.root.y;
    };
    Object.defineProperty(ClientSceneObject.prototype, "actionIndex", {
        get: function () {
            return this.avatar ? this.avatar.actionIndex : 0;
        },
        set: function (v) {
            this.avatar.actionIndex = v;
            this["_avatarAct"] = this.avatar.actionID;
        },
        enumerable: true,
        configurable: true
    });
    ClientSceneObject.prototype.update = function (_nowTime) {
    };
    ClientSceneObject.prototype.refreshCoordinate = function () {
        this.updateShadow();
    };
    ClientSceneObject.prototype.playAnimation = function (aniID, loop, isHit) {
        var animation = this._animationMap[aniID];
        if (!animation) {
            animation = this._animationMap[aniID] = new Animation();
            animation.sceneObject = this;
            animation.id = aniID;
        }
        animation.addToGameSprite(this.avatarContainer, this.animationLowLayer, this.animationHighLayer);
        this.animationLowLayer.addChild(animation);
        animation.loop = loop;
        animation.showHitEffect = isHit;
        animation.once(Animation.PLAY_COMPLETED, this, this.stopAnimation, [aniID]);
        animation.gotoAndPlay();
    };
    ClientSceneObject.prototype.stopAnimation = function (aniID) {
        var animation = this._animationMap[aniID];
        if (animation) {
            animation.stop(animation.currentFrame);
            animation.dispose();
            this._animationMap[aniID] = null;
        }
    };
    ClientSceneObject.prototype.stopAllAnimation = function () {
        var _this = this;
        Object.keys(this._animationMap).forEach(function (v) {
            _this.stopAnimation(Number(v));
        });
    };
    ClientSceneObject.prototype.hasListener = function (type) { return this.root.hasListener.apply(this.root, arguments); };
    ;
    ClientSceneObject.prototype.event = function (type, data) { return this.root.event.apply(this.root, arguments); };
    ;
    ClientSceneObject.prototype.on = function (type, caller, listener, args) { return this.root.on.apply(this.root, arguments); };
    ;
    ClientSceneObject.prototype.once = function (type, caller, listener, args) { return this.root.once.apply(this.root, arguments); };
    ;
    ClientSceneObject.prototype.off = function (type, caller, listener, onceOnly) { return this.root.off.apply(this.root, arguments); };
    ;
    ClientSceneObject.prototype.offAll = function (type) { return this.root.offAll.apply(this, arguments); };
    ;
    return ClientSceneObject;
}(SceneObject));
ObjectUtils.reDefineGetSet("ClientSceneObject.prototype", {
    isBorn: function (v) {
        if (this.root && Config.EDIT_MODE) {
            if (v) {
                var bornSign = new MyGameCreatorEditorUI.Editor.model.SceneObjectBornSignUI();
                this.root.addChild(bornSign);
            }
        }
    },
    x: function (v) { if (this.root) {
        this.root.x = v;
        this.refreshCoordinate();
    } },
    y: function (v) { if (this.root) {
        this.root.y = v;
        this.refreshCoordinate();
    } },
    avatarID: function (v) {
        if (this.avatar) {
            if (v == this.avatar.id)
                return;
            this.avatar.id = v;
        }
    },
    shadowWidth: function (v) {
        if (this.avatar) {
            Callback.CallLater(this.refreshShadow, this);
        }
    },
    shadowHeight: function (v) {
        if (this.avatar) {
            Callback.CallLater(this.refreshShadow, this);
        }
    },
    shadowAlpha: function (v) {
        if (this.avatar) {
            Callback.CallLater(this.refreshShadow, this);
        }
    },
    shadowEnable: function (v) {
        if (this.avatar) {
            Callback.CallLater(this.refreshShadow, this);
        }
    },
    avatarOri: function (v) { if (this.avatar && this.avatar.orientation != v)
        this.avatar.orientation = v; },
    avatarAct: function (v) { if (this.avatar && this.avatar.actionID != v) {
        this.avatar.actionID = v;
    } },
    avatarPlayInterval: function (v) { if (this.avatar)
        this.avatar.setPlayInterval(v); },
    avatarFrame: function (v) { if (this.avatar) {
        this.avatar.setCurrentFrame(v, true);
    } },
    avatarAlpha: function (v) { if (this.avatar) {
        this.avatar.alpha = v;
    } },
    avatarHue: function (v) { if (this.avatar) {
        this.avatar.gameFilters = v == 0 ? null : [new HueFilter(v)];
    } },
    onTop: function (v) {
        if (!this.root)
            return;
        if (this.root.parent != this.scene.sceneObjectHighLayer && v == 2) {
            this.scene.sceneObjectHighLayer.addChild(this.root);
        }
        else if (this.root.parent != this.scene.sceneObjectLayer && v == 1) {
            this.scene.sceneObjectLayer.addChild(this.root);
        }
        else if (this.root.parent != this.scene.sceneObjectLowLayer && v == 0) {
            this.scene.sceneObjectLowLayer.addChild(this.root);
        }
    },
    autoPlayEnable: function (v) {
        if (!this.root)
            return;
        if (v) {
            this.avatar.play();
        }
        else {
            this.avatar.stop(this.avatarFrame);
        }
    },
    scale: function (v) {
        if (!this.root)
            return;
        this.avatar.scaleX = this.avatar.scaleY = v;
        this.refreshShadow();
    },
    fixedOrientation: function (v) {
        if (!this.root)
            return;
        this.avatar.fixedOrientation = v;
    },
    selectEnabled: function (v) {
        if (!this.root)
            return;
        if (!v) {
            if (typeof Controller != "undefined")
                Controller.unselectOneSceneObject(this);
        }
        else {
            if (typeof Controller != "undefined")
                Controller.updateSelectSceneObject();
        }
    }
});
var GameAudio = (function () {
    function GameAudio() {
    }
    GameAudio.playBGM = function (url, volume, loop, isGradient, gradientTime, pitch) {
        if (volume === void 0) { volume = 1; }
        if (loop === void 0) { loop = 9999; }
        if (isGradient === void 0) { isGradient = false; }
        if (gradientTime === void 0) { gradientTime = 1000; }
        if (pitch === void 0) { pitch = 1; }
        var urlInfo = GameAudio.getAudioURL(url);
        url = urlInfo.url;
        if (urlInfo.volume != null)
            volume = urlInfo.volume;
        if (urlInfo.pitch != null)
            pitch = urlInfo.pitch;
        GameAudio.clearBgmTween();
        if (GameAudio.lastBgmURL != url || pitch != GameAudio.lastBGMPitch) {
            if (GameAudio.lastBgmSoundChannel)
                GameAudio.lastBgmSoundChannel.stop();
            GameAudio.lastBgmSoundChannel = SoundManager.playSound(url, loop, pitch, Handler.create(this, function (url) {
                if (url == GameAudio.lastBgmURL) {
                    GameAudio.lastBgmURL = GameAudio.lastBgmSoundChannel = null;
                }
            }, [url]));
            if (isGradient)
                GameAudio.lastBgmSoundChannel.volume = 0;
        }
        GameAudio.lastBgmURL = url;
        GameAudio.lastBGMPitch = pitch;
        GameAudio.lastBgmSoundChannel["_selfVolume"] = volume;
        if (isGradient) {
            GameAudio.lastBgmTween = Tween.to(GameAudio.lastBgmSoundChannel, { volume: volume * GameAudio._bgmVolume }, gradientTime, null, Handler.create(this, function () {
                GameAudio.lastBgmTween = null;
            }));
            GameAudio.lastBgmTween["gradientTime"] = gradientTime;
        }
        else {
            GameAudio.lastBgmSoundChannel.volume = volume * GameAudio._bgmVolume;
        }
    };
    GameAudio.stopBGM = function (isGradient, gradientTime) {
        if (isGradient === void 0) { isGradient = false; }
        if (gradientTime === void 0) { gradientTime = 1000; }
        GameAudio.clearBgmTween();
        if (GameAudio.lastBgmSoundChannel) {
            if (isGradient) {
                GameAudio.lastBgmTween = Tween.to(GameAudio.lastBgmSoundChannel, { volume: 0 }, gradientTime);
            }
            else {
                SoundManager.stopSound(GameAudio.lastBgmSoundChannel.url);
            }
            GameAudio.lastBgmURL = null;
            GameAudio.lastBgmSoundChannel = null;
        }
    };
    GameAudio.playBGS = function (url, volume, loop, isGradient, gradientTime, pitch) {
        if (volume === void 0) { volume = 1; }
        if (loop === void 0) { loop = 9999; }
        if (isGradient === void 0) { isGradient = false; }
        if (gradientTime === void 0) { gradientTime = 1000; }
        if (pitch === void 0) { pitch = 1; }
        var urlInfo = GameAudio.getAudioURL(url);
        url = urlInfo.url;
        if (urlInfo.volume != null)
            volume = urlInfo.volume;
        if (urlInfo.pitch != null)
            pitch = urlInfo.pitch;
        GameAudio.clearBgsTween();
        if (GameAudio.lastBgsURL != url || pitch != GameAudio.lastBGSPitch) {
            if (GameAudio.lastBgsSoundChannel)
                GameAudio.lastBgsSoundChannel.stop();
            GameAudio.lastBgsSoundChannel = SoundManager.playSound(url, loop, pitch, Handler.create(this, function (url) {
                if (url == GameAudio.lastBgsURL) {
                    GameAudio.lastBgsURL = GameAudio.lastBgsSoundChannel = null;
                }
            }, [url]));
            if (isGradient)
                GameAudio.lastBgsSoundChannel.volume = 0;
        }
        GameAudio.lastBgsURL = url;
        GameAudio.lastBGSPitch = pitch;
        GameAudio.lastBgsSoundChannel["_selfVolume"] = volume;
        if (isGradient) {
            GameAudio.lastBgsTween = Tween.to(GameAudio.lastBgsSoundChannel, { volume: volume * GameAudio._bgsVolume }, gradientTime, null, Handler.create(this, function () {
                GameAudio.lastBgsTween = null;
            }));
            GameAudio.lastBgsTween["gradientTime"] = gradientTime;
        }
        else {
            GameAudio.lastBgsSoundChannel.volume = volume * GameAudio._bgsVolume;
        }
    };
    GameAudio.stopBGS = function (isGradient, gradientTime) {
        if (isGradient === void 0) { isGradient = false; }
        if (gradientTime === void 0) { gradientTime = 1000; }
        GameAudio.clearBgsTween();
        if (GameAudio.lastBgsSoundChannel) {
            if (isGradient) {
                GameAudio.lastBgsTween = Tween.to(GameAudio.lastBgsSoundChannel, { volume: 0 }, gradientTime);
            }
            else {
                SoundManager.stopSound(GameAudio.lastBgsSoundChannel.url);
            }
            GameAudio.lastBgsURL = null;
            GameAudio.lastBgsSoundChannel = null;
        }
    };
    GameAudio.playSE = function (url, volume, pitch, soc) {
        if (volume === void 0) { volume = 1; }
        if (pitch === void 0) { pitch = 1; }
        if (soc === void 0) { soc = null; }
        var urlInfo = GameAudio.getAudioURL(url);
        url = urlInfo.url;
        if (urlInfo.volume != null)
            volume = urlInfo.volume;
        if (urlInfo.pitch != null)
            pitch = urlInfo.pitch;
        var channel = SoundManager.playSound(url, 1, pitch);
        if (!channel) {
            trace("无法获取音源");
            return null;
        }
        channel["_selfVolume"] = volume;
        GameAudio.seArr.push(channel);
        channel.completeHandler = Handler.create(this, function (s) {
            var idx = GameAudio.seArr.indexOf(s);
            if (idx != -1)
                GameAudio.seArr.splice(idx, 1);
        }, [channel]);
        if (!soc) {
            channel.volume = volume * GameAudio._seVolume;
        }
        else {
            var camera = soc.scene.getCamera();
            var cameraCenter = new Point(camera.x + camera.width / 2, camera.y + camera.height / 2);
            var dis = cameraCenter.distance(soc.x, soc.y);
            var disPer = Math.max(1 - dis / (Config.WINDOW_WIDTH * 0.5), 0);
            channel.volume = volume * disPer * GameAudio._seVolume;
        }
        return channel;
    };
    GameAudio.stopSE = function (channels) {
        if (channels === void 0) { channels = null; }
        var seArr = channels ? channels instanceof Array ? channels : [channels] : GameAudio.seArr;
        for (var i = 0; i < seArr.length; i++) {
            var c = seArr[i];
            c.stop();
            if (channels && channels != GameAudio.seArr) {
                var idx = GameAudio.seArr.indexOf(c);
                if (idx != -1) {
                    GameAudio.seArr.splice(idx, 1);
                }
            }
        }
        seArr.length = 0;
    };
    GameAudio.clearBgmTween = function () {
        if (GameAudio.lastBgmTween) {
            Tween.clearAll(GameAudio.lastBgmSoundChannel);
            GameAudio.lastBgmTween = null;
        }
    };
    GameAudio.clearBgsTween = function () {
        if (GameAudio.lastBgsTween) {
            Tween.clearAll(GameAudio.lastBgsSoundChannel);
            GameAudio.lastBgsTween = null;
        }
    };
    Object.defineProperty(GameAudio, "bgmVolume", {
        get: function () {
            return this._bgmVolume;
        },
        set: function (v) {
            this._bgmVolume = v;
            if (this.lastBgmSoundChannel) {
                if (GameAudio.lastBgmTween) {
                    var lastProgress = GameAudio.lastBgmTween.progress;
                    var gradientTime = GameAudio.lastBgmTween["gradientTime"] * (1 - GameAudio.lastBgmTween.progress);
                    this.lastBgmSoundChannel.volume = 0;
                    this.clearBgmTween();
                    GameAudio.lastBgmTween = Tween.to(GameAudio.lastBgmSoundChannel, { volume: this.lastBgmSoundChannel["_selfVolume"] * v }, gradientTime, null, Handler.create(this, function () {
                        GameAudio.lastBgmTween = null;
                    }));
                    GameAudio.lastBgmTween.progress = lastProgress;
                    this.lastBgmSoundChannel.volume = (this.lastBgmSoundChannel["_selfVolume"] * v) * lastProgress;
                }
                else {
                    this.lastBgmSoundChannel.volume = this.lastBgmSoundChannel["_selfVolume"] * v;
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GameAudio, "bgsVolume", {
        get: function () {
            return this._bgsVolume;
        },
        set: function (v) {
            this._bgsVolume = v;
            if (this.lastBgsSoundChannel) {
                if (GameAudio.lastBgsTween) {
                    var lastProgress = GameAudio.lastBgsTween.progress;
                    var gradientTime = GameAudio.lastBgsTween["gradientTime"] * (1 - GameAudio.lastBgsTween.progress);
                    this.lastBgsSoundChannel.volume = 0;
                    this.clearBgsTween();
                    GameAudio.lastBgsTween = Tween.to(GameAudio.lastBgsSoundChannel, { volume: this.lastBgsSoundChannel["_selfVolume"] * v }, gradientTime, null, Handler.create(this, function () {
                        GameAudio.lastBgsTween = null;
                    }));
                    GameAudio.lastBgsTween.progress = lastProgress;
                    this.lastBgsSoundChannel.volume = (this.lastBgsSoundChannel["_selfVolume"] * v) * lastProgress;
                }
                else {
                    this.lastBgsSoundChannel.volume = this.lastBgsSoundChannel["_selfVolume"] * v;
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GameAudio, "seVolume", {
        get: function () {
            return this._seVolume;
        },
        set: function (v) {
            this._seVolume = v;
            for (var i = 0; i < GameAudio.seArr.length; i++) {
                var c = GameAudio.seArr[i];
                c.volume = c["_selfVolume"] * v;
            }
        },
        enumerable: true,
        configurable: true
    });
    GameAudio.prototype.setBlurStopMusic = function (isStop) {
        SoundManager.autoStopMusic = isStop;
    };
    GameAudio.getAudioURL = function (url) {
        if (!url)
            url = "";
        var arr = url.split(",");
        url = arr[0];
        var volume = arr[1] != null ? MathUtils.float(arr[1]) : null;
        var pitch = arr[2] != null ? MathUtils.float(arr[2]) : null;
        return { url: url, volume: volume, pitch: pitch };
    };
    GameAudio._bgmVolume = 1;
    GameAudio._bgsVolume = 1;
    GameAudio._seVolume = 1;
    GameAudio.seArr = [];
    return GameAudio;
}());





var GameDialog = (function (_super) {
    __extends(GameDialog, _super);
    function GameDialog(dialogID, dialogList) {
        _super.call(this);
        this.dialogBox = new UIImage();
        this.headBox = new UIImage();
        this.optionBox = new Sprite();
        this.optionText = new Sprite();
        this.nameText = new TextField();
        this.dialogText = new Sprite();
        this.playTextLabels = [];
        this.id = dialogID;
        this.dialogList = dialogList;
        this.addChild(this.dialogBox);
        this.addChild(this.headBox);
        this.addChild(this.dialogText);
        this.addChild(this.optionBox);
        this.addChild(this.optionText);
        this.addChild(this.nameText);
        var dialogData = this.dialogData = this.dialogList.data[dialogID];
        ObjectUtils.clone(dialogData.dialogBox, this.dialogBox);
        ObjectUtils.clone(dialogData.headBox, this.headBox);
        ObjectUtils.clone(dialogData.nameBox, this.nameText);
        this.optionBox.x = this.dialogData.optionBox.x;
        this.optionBox.y = this.dialogData.optionBox.y;
        this.optionText.x = this.dialogData.option.x;
        this.optionText.y = this.dialogData.option.y;
        this.dialogText.x = dialogData.dialog.x;
        this.dialogText.y = dialogData.dialog.y;
        this.dialogText.width = dialogData.dialog.width;
        this.dialogText.height = dialogData.dialog.height;
        this.size(Config.WINDOW_WIDTH, Config.WINDOW_HEIGHT);
        this.add_CLICK(this.onClick, this);
    }
    GameDialog.showDialog = function (dialogID, head, name, speed, comicMode, msg) {
        var dialog = GameDialog.getDialog(dialogID);
        if (GameDialog.lastDialog) {
            GameDialog.lastDialog.stop();
        }
        GameDialog.lastDialog = dialog;
        dialog.setContent(head, name, speed, comicMode, msg);
        Game.layer.uiLayer.addChild(dialog);
        GameDialog.optionMode = false;
        GameDialog.isCloseDialog = false;
    };
    GameDialog.showOption = function (dialogID, options, isShowOptionWithLastDialog) {
        if (isShowOptionWithLastDialog === void 0) { isShowOptionWithLastDialog = false; }
        var dialog = GameDialog.getDialog(dialogID);
        if (!isShowOptionWithLastDialog && GameDialog.lastDialog &&
            GameDialog.lastDialog == dialog && !GameDialog.isCloseDialog) {
            GameDialog.showOptionWithLastDialog = options;
            if (!dialog.playing && dialog.hasSkip) {
                GameDialog.showOption(dialog.id, options, true);
            }
            return;
        }
        GameDialog.optionMode = true;
        dialog.clearDelayStop();
        if (!isShowOptionWithLastDialog) {
            dialog.dialogText.removeChildren();
            dialog.nameText.text = "";
            dialog.headBox.skin = "";
        }
        GameDialog.showOptionWithLastDialog = null;
        dialog.setOption(options);
        Game.layer.uiLayer.addChild(dialog);
    };
    GameDialog.getDialog = function (dialogID) {
        if (dialogID == 0) {
            if (GameDialog.lastDialog)
                dialogID = GameDialog.lastDialog.id;
            else
                dialogID = 1;
        }
        var dialogData = Game.data.dialogList.data[dialogID];
        if (!dialogData) {
            dialogID = 1;
            dialogData = Game.data.dialogList.data[dialogID];
        }
        if (!dialogData) {
            throw ("找不到对话框模板" + dialogID);
        }
        var dialog = GameDialog.dialogCache[dialogID];
        if (!dialog) {
            dialog = GameDialog.dialogCache[dialogID] = new GameDialog(dialogID, Game.data.dialogList);
        }
        return dialog;
    };
    GameDialog.handleText = function (text, defaultColor) {
        var re = /\[p[0-9]{1,3}\]/g;
        var arr = text.match(re);
        for (var c in arr) {
            var i = arr[c];
            var colorKey = i.substr(2, i.length - 3);
            var waitF = parseInt(colorKey);
            var waitT = "";
            for (var s = 0; s < waitF; s++) {
                waitT += GameDialog.KEY_SYMBOL_DELAY;
            }
            text = text.replace(i, waitT);
        }
        text = text.replace(/\[\.=\]/g, GameDialog.KEY_SYMBOL_WAIT_PLAYER_CLICK);
        text = text.replace(/\[\.s\]/g, GameDialog.KEY_SYMBOL_SKIP);
        return "" + text;
    };
    GameDialog.prototype.setContent = function (head, name, playSpeed, comicMode, msg) {
        this.clearDelayStop();
        this.playSpeed = playSpeed;
        this.playTextIndex = 0;
        this.playTextLabelIndex = 0;
        this.forceShow = false;
        this.hasSkip = false;
        this.playTextLabels.length = 0;
        this.optionClear();
        this.dialogText.removeChildren();
        this.nameText.text = name;
        this.headBox.skin = head;
        var textContent = GameDialog.handleText(msg, this.dialogData.dialog.color);
        var Labels = textContent.match(GameDialog.COLOR_FORMAT);
        if (!Labels)
            return;
        var rowIndex = 0;
        var startX = 0;
        for (var i = 0; i < Labels.length; i++) {
            var unitSpan = Labels[i];
            var color = unitSpan.match(/#[0-9a-zA-Z]{6,6}/g)[0];
            if (color == GameDialog.TRANS_PARENT_COLOR) {
                color = this.dialogData.dialog.color;
            }
            var lines = unitSpan.split("\n");
            for (var s = 0; s < lines.length; s++) {
                if (s > 0) {
                    rowIndex++;
                    startX = 0;
                }
                var text = StringUtils.clearHtmlTag(lines[s]);
                var tf = new TextField();
                tf.text = text;
                tf.fontSize = this.dialogData.dialog.fontSize;
                tf.color = color;
                tf.x = startX;
                tf.y = rowIndex * (tf.fontSize + this.dialogData.dialog.leading);
                startX += tf.textWidth;
                this.dialogText.addChild(tf);
                this.playTextLabels.push(tf);
                tf["playText"] = tf.text;
                tf.text = "";
            }
        }
        switch (playSpeed) {
            case 0:
                this.playTextLoopMod = 10;
                break;
            case 1:
                this.playTextLoopMod = 7;
                break;
            case 2:
                this.playTextLoopMod = 5;
                break;
            case 3:
                this.playTextLoopMod = 3;
                break;
            case 4:
                this.playTextLoopMod = 1;
                break;
        }
        if (playSpeed == 5) {
            this.playText();
        }
        this.playing = this.playSpeed != 5;
        this.playTextLoop = 0;
        os.remove_ENTERFRAME(this.playText, this);
        os.add_ENTERFRAME(this.playText, this);
    };
    GameDialog.prototype.stop = function () {
        os.remove_ENTERFRAME(this.playText, this);
        if (this.parent) {
            this.parent.removeChild(this);
        }
        this.clearDelayStop();
    };
    GameDialog.prototype.clearDelayStop = function () {
        if (this.delayStop) {
            clearInterval(this.delayStop);
            this.delayStop = null;
        }
    };
    GameDialog.prototype.optionClear = function () {
        this.optionBox.removeChildren();
        this.optionText.removeChildren();
    };
    GameDialog.prototype.setOption = function (options) {
        this.optionClear();
        var alignArr = ["left", "center", "right"];
        var column = this.dialogData.optionBox.column;
        for (var i = 0; i < options.length; i++) {
            var opBtn = new UIComponent.UIButton();
            opBtn.width = this.dialogData.optionBox.width;
            opBtn.height = this.dialogData.optionBox.height;
            opBtn.image1 = this.dialogData.optionBox.image1;
            opBtn.image2 = this.dialogData.optionBox.image2;
            opBtn.x = (i % column) * (opBtn.width + this.dialogData.optionBox.columnSpaceing);
            opBtn.y = Math.floor(i / column) * (opBtn.height + this.dialogData.optionBox.rowSpaceing);
            this.optionBox.addChild(opBtn);
            if (this.dialogData.optionBox.overSe) {
                opBtn.add_MOUSEOVER(this.onOptionMouseOver, this);
            }
            var opText = new TextField();
            opText.width = this.dialogData.option.width;
            opText.height = this.dialogData.option.height;
            opText.color = this.dialogData.option.color;
            opText.align = alignArr[this.dialogData.option.align];
            opText.fontSize = this.dialogData.option.fontSize;
            opText.text = options[i];
            opText.x = opBtn.x;
            opText.y = opBtn.y;
            this.optionText.addChild(opText);
        }
    };
    GameDialog.prototype.onOptionMouseOver = function () {
        GameAudio.playSE(this.optionOverSE, this.dialogData.optionBox.overVolume, this.dialogData.optionBox.overPitch);
    };
    GameDialog.prototype.playText = function () {
        if (this.waitPlayerClick)
            return;
        if (this.playSpeed != 5 && this.playTextLoop++ % this.playTextLoopMod != 0)
            return;
        var tf = this.playTextLabels[this.playTextIndex];
        if (!tf) {
            this.playing = false;
            os.remove_ENTERFRAME(this.playText, this);
            return;
        }
        var word = tf["playText"][this.playTextLabelIndex];
        if (!word) {
            this.playTextLabelIndex = 0;
            this.playTextIndex++;
            this.playText();
            return;
        }
        this.playTextLabelIndex++;
        if (word == GameDialog.KEY_SYMBOL_DELAY) {
        }
        else if (word == GameDialog.KEY_SYMBOL_SKIP) {
            this.hasSkip = true;
            if (!this.forceShow && this.playSpeed != 5) {
                this.playing = false;
                this.onClick(null);
            }
            return;
        }
        else if (word == GameDialog.KEY_SYMBOL_WAIT_PLAYER_CLICK) {
            if (this.playSpeed != 5)
                this.waitPlayerClick = true;
        }
        else {
            tf.text += word;
        }
        if (this.playSpeed == 5)
            this.playText();
    };
    GameDialog.prototype.onClick = function (e) {
        if (Config.EDIT_MODE)
            return;
        if (this.playing) {
            if (this.waitPlayerClick) {
                this.waitPlayerClick = false;
                return;
            }
            this.forceShow = true;
            this.playSpeed = 5;
            this.playText();
        }
        else if (GameDialog.showOptionWithLastDialog) {
            GameDialog.showOption(this.id, GameDialog.showOptionWithLastDialog, true);
        }
        else {
            if (GameDialog.optionMode) {
                if (this.optionClickSE)
                    GameAudio.playSE(this.optionClickSE, this.dialogData.optionBox.clickVolume, this.dialogData.optionBox.clikcPitch);
                if (!(e.target instanceof UIComponent.UIButton))
                    return;
                GameCommand.inputMessageAndContinueExecute([this.optionBox.getChildIndex(e.target)]);
            }
            else {
                GameCommand.inputMessageAndContinueExecute();
            }
            GameDialog.isCloseDialog = true;
            this.delayStop = setTimeout(function (_this) {
                _this.stop();
            }, GameDialog.delayCloseTime, this);
        }
    };
    Object.defineProperty(GameDialog.prototype, "optionClickSE", {
        get: function () {
            if (!this.dialogData.optionBox.clickSe)
                this.dialogData.optionBox.clickSe = "";
            return this.dialogData.optionBox.clickSe.split(",")[0];
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GameDialog.prototype, "optionOverSE", {
        get: function () {
            if (!this.dialogData.optionBox.overSe)
                this.dialogData.optionBox.overSe = "";
            return this.dialogData.optionBox.overSe.split(",")[0];
        },
        enumerable: true,
        configurable: true
    });
    GameDialog.TRANS_PARENT_COLOR = "#FfFffF";
    GameDialog.COLOR_FORMAT = /<span style=['"]color:#[0-9a-zA-Z]{6,6}['"]>(.|\n)*?<\/span>/g;
    GameDialog.KEY_SYMBOL_DELAY = String.fromCharCode(1);
    GameDialog.KEY_SYMBOL_WAIT_PLAYER_CLICK = String.fromCharCode(2);
    GameDialog.KEY_SYMBOL_SKIP = String.fromCharCode(3);
    GameDialog.delayCloseTime = 100;
    GameDialog.dialogCache = [];
    return GameDialog;
}(Sprite));





var GameLayer = (function (_super) {
    __extends(GameLayer, _super);
    function GameLayer() {
        _super.call(this);
        this.sceneLayer = new GameSprite();
        this.imageLayer = new GameSprite();
        this.uiLayer = new GameSprite();
        this.graphics.drawRect(0, 0, 1, 1, "#000000");
        this.initLayer();
    }
    GameLayer.prototype.initLayer = function () {
        this.addChild(this.sceneLayer);
        this.addChild(this.imageLayer);
        this.addChild(this.uiLayer);
        stage.addChild(this);
    };
    return GameLayer;
}(Sprite));





var GameSprite = (function (_super) {
    __extends(GameSprite, _super);
    function GameSprite() {
        _super.call(this);
        this._tonalParams = [0, 0, 0, 0, 1, 1, 1];
        this._gameFilters = [];
        this._mouseEventEnabledInEditor = true;
        this._show = true;
        this._showOnEditor = true;
        this._opacity = 1;
        this._opacityPer = 1;
        this._animationTargetEffect = [];
        this._hue = 0;
        this._blur = 0;
    }
    GameSprite.prototype.dispose = function (disposeChild) {
        if (disposeChild === void 0) { disposeChild = false; }
        if (!this.isDisposed) {
            this.removeSelf();
            this.destroy(disposeChild);
            this._tonalParams = this._tonalFilter = this._lastGameFilters = this._gameFilters = this._finalFilters = this.tips = null;
            this.isDisposed = true;
        }
    };
    GameSprite.prototype.addAnimationTargetEffect = function (ani) {
        if (!ani)
            return;
        this._animationTargetEffect.push(ani);
        this.refreshAnimationTargetEffect();
    };
    GameSprite.prototype.removeAnimationTargetEffect = function (ani) {
        ArrayUtils.remove(this._animationTargetEffect, ani);
        this.refreshAnimationTargetEffect();
    };
    GameSprite.prototype.refreshAnimationTargetEffect = function () {
        var target = {
            x: 0,
            y: 0,
            rotation: 0,
            alpha: 1,
            scaleX: 1,
            scaleY: 1,
            hue: 0,
            blur: 0
        };
        var targetTonal = {
            tonal_r: 0,
            tonal_g: 0,
            tonal_b: 0,
            tonal_gray: 0,
            tonal_mr: 1,
            tonal_mg: 1,
            tonal_mb: 1
        };
        for (var i = 0; i < this._animationTargetEffect.length; i++) {
            var t = this._animationTargetEffect[i];
            target.x += t.x;
            target.y += t.y;
            target.rotation += t.rotation;
            target.alpha *= t.alpha;
            target.scaleX *= t.scaleX;
            target.scaleY *= t.scaleY;
            target.hue = t.hue;
            target.blur += t.blur;
            targetTonal.tonal_r += t.tonal_r;
            targetTonal.tonal_g += t.tonal_g;
            targetTonal.tonal_b += t.tonal_b;
            targetTonal.tonal_gray += t.tonal_gray;
            targetTonal.tonal_mr *= t.tonal_mr;
            targetTonal.tonal_mg *= t.tonal_mg;
            targetTonal.tonal_mb *= t.tonal_mb;
        }
        for (var s in target) {
            this[s] = target[s];
        }
        this.setTonal(targetTonal.tonal_r, targetTonal.tonal_g, targetTonal.tonal_b, targetTonal.tonal_gray, targetTonal.tonal_mr, targetTonal.tonal_mb);
    };
    Object.defineProperty(GameSprite.prototype, "gameFilters", {
        get: function () {
            return this._gameFilters;
        },
        set: function (v) {
            var compare = ArrayUtils.compare(v, this._lastGameFilters);
            this.subtractFilter(compare.subtract);
            this.appended(compare.appended);
            this._lastGameFilters = v ? v.concat() : null;
            this._gameFilters = v;
        },
        enumerable: true,
        configurable: true
    });
    GameSprite.prototype.appendGameFilter = function (gameFilter) {
        var gameFilters = this.gameFilters;
        if (!gameFilters)
            gameFilters = [];
        if (gameFilters.indexOf(gameFilter) != -1)
            return;
        gameFilters.push(gameFilter);
        this.gameFilters = gameFilters;
    };
    GameSprite.prototype.subtractGameFilter = function (gameFilter) {
        var gameFilters = this.gameFilters;
        if (!gameFilters)
            return;
        var idx = gameFilters.indexOf(gameFilter);
        if (idx != -1) {
            gameFilters.splice(idx, 1);
            this.gameFilters = gameFilters;
        }
    };
    GameSprite.prototype.setTonal = function (r, g, b, gray, mr, mg, mb) {
        if (mr === void 0) { mr = 1; }
        if (mg === void 0) { mg = 1; }
        if (mb === void 0) { mb = 1; }
        if (this._tonalFilter) {
            this.subtractGameFilter(this._tonalFilter);
            this._tonalFilter = null;
        }
        this._tonalParams[0] = r;
        this._tonalParams[1] = g;
        this._tonalParams[2] = b;
        this._tonalParams[3] = gray;
        this._tonalParams[4] = mr;
        this._tonalParams[5] = mg;
        this._tonalParams[6] = mb;
        if (r == 0 && g == 0 && b == 0 && gray == 0 && mr == 1 && mg == 1 && mb == 1)
            return;
        var rt1 = 1 - (1 - 0.3086) * gray / 100;
        var gt1 = 1 - (1 - 0.6094) * gray / 100;
        var bt1 = 1 - (1 - 0.0820) * gray / 100;
        var rt0 = 0 - (0 - 0.3086) * gray / 100;
        var gt0 = 0 - (0 - 0.6094) * gray / 100;
        var bt0 = 0 - (0 - 0.0820) * gray / 100;
        this._tonalFilter = new ColorFilter([
            rt1 * mr, gt0, bt0, r / 255, 0,
            rt0, gt1 * mg, bt0, g / 255, 0,
            rt0, gt0, bt1 * mb, b / 255, 0,
            0, 0, 0, 1, 0
        ]);
        this.appendGameFilter(this._tonalFilter);
    };
    GameSprite.prototype.getTonal = function () {
        return this._tonalParams.concat();
    };
    GameSprite.prototype.isInherit = function (sp) {
        var p = this.parent;
        while (p) {
            if (p == sp)
                return true;
            p = p.parent;
        }
        return false;
    };
    Object.defineProperty(GameSprite.prototype, "disabled", {
        get: function () {
            return this.mouseEnabled;
        },
        set: function (v) {
            this.mouseEnabled = v;
            this.setTonal(0, 0, 0, 100);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GameSprite.prototype, "tips", {
        get: function () {
            return this._tips ? this._tips : "";
        },
        set: function (v) {
            if (!Config.EDIT_MODE)
                return;
            this._tips = v;
            if (v)
                Tips.reg(this, v, true);
            else
                Tips.cancelReg(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GameSprite.prototype, "show", {
        get: function () {
            return this._show;
        },
        set: function (v) {
            this._show = v;
            this.visible = this._show && this._showOnEditor;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GameSprite.prototype, "showOnEditor", {
        get: function () {
            return this._showOnEditor;
        },
        set: function (v) {
            if (!Config.EDIT_MODE)
                return;
            this._showOnEditor = v;
            this.visible = this._show && this._showOnEditor;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GameSprite.prototype, "opacity", {
        get: function () {
            return this._opacity;
        },
        set: function (v) {
            this._opacity = v;
            this.alpha = this._opacity * this._opacityPer;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GameSprite.prototype, "opacityPer", {
        get: function () {
            return this._opacityPer;
        },
        set: function (v) {
            this._opacityPer = v;
            this.alpha = this._opacity * this._opacityPer;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GameSprite.prototype, "mouseEventEnabled", {
        get: function () {
            return this._mouseEventEnabled;
        },
        set: function (v) {
            this._mouseEventEnabled = v;
            this.mouseEnabled = this._mouseEventEnabled && this._mouseEventEnabledInEditor;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GameSprite.prototype, "mouseEventEnabledInEditor", {
        get: function () {
            return this._mouseEventEnabledInEditor;
        },
        set: function (v) {
            this._mouseEventEnabledInEditor = v;
            this.mouseEnabled = this._mouseEventEnabled && this._mouseEventEnabledInEditor;
        },
        enumerable: true,
        configurable: true
    });
    GameSprite.prototype.addChild = function (node) {
        var node = _super.prototype.addChild.call(this, node);
        if (node instanceof GameSprite)
            node.refreshFilter();
        return node;
    };
    ;
    GameSprite.prototype.addChildren = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i - 0] = arguments[_i];
        }
        _super.prototype.addChildren.apply(this, args);
        for (var i in args) {
            var node = args[i];
            if (node instanceof GameSprite)
                node.refreshFilter();
        }
    };
    ;
    GameSprite.prototype.addChildAt = function (node, index) {
        var node = _super.prototype.addChildAt.call(this, node, index);
        if (node instanceof GameSprite)
            node.refreshFilter();
        return node;
    };
    ;
    GameSprite.prototype.refreshFilter = function () {
        var parentGameFilters = [];
        var sp = this.parent;
        while (sp) {
            if (sp instanceof GameSprite) {
                parentGameFilters = parentGameFilters.concat(sp._gameFilters);
            }
            sp = sp.parent;
        }
        for (var i = 0; i < parentGameFilters.length; i++) {
            if (!parentGameFilters[i]) {
                parentGameFilters.splice(i, 1);
                i--;
            }
        }
        this.appended(parentGameFilters);
    };
    GameSprite.prototype.subtractFilter = function (subtract) {
        if (subtract.length == 0)
            return;
        var finalFilters = this._finalFilters;
        if (finalFilters && finalFilters.length != 0) {
            var len = subtract.length;
            for (var i = 0; i < len; i++) {
                var subFilter = subtract[i];
                var idx = finalFilters.indexOf(subFilter);
                if (idx != -1) {
                    finalFilters.splice(idx, 1);
                }
            }
            if (finalFilters.length == 0)
                finalFilters = null;
            this.filters = this._finalFilters = finalFilters;
        }
        ;
        var numChildren = this.numChildren;
        for (var i = 0; i < numChildren; i++) {
            var child = this.getChildAt(i);
            if (child instanceof GameSprite) {
                child.subtractFilter(subtract);
            }
        }
    };
    GameSprite.prototype.appended = function (appended, childLayer) {
        if (childLayer === void 0) { childLayer = false; }
        if (appended.length == 0)
            return;
        var finalFilters = this._finalFilters;
        if (!childLayer || (this._gameFilters && this._gameFilters.length != 0)) {
            var len = appended.length;
            for (var i = 0; i < len; i++) {
                var appendFilter = appended[i];
                var idx = finalFilters ? finalFilters.indexOf(appendFilter) : -1;
                if (idx == -1) {
                    if (!finalFilters)
                        finalFilters = [];
                    finalFilters.push(appendFilter);
                }
            }
            this.filters = this._finalFilters = finalFilters;
        }
        var numChildren = this.numChildren;
        for (var i = 0; i < numChildren; i++) {
            var child = this.getChildAt(i);
            if (child instanceof GameSprite) {
                child.appended(appended, true);
            }
        }
    };
    Object.defineProperty(GameSprite.prototype, "hue", {
        get: function () {
            return this._hue;
        },
        set: function (v) {
            v || (v = 0);
            this._hue = v;
            if (this._hueFilter)
                this.subtractGameFilter(this._hueFilter);
            this._hueFilter = null;
            if (this._hue) {
                this._hueFilter = new HueFilter(this._hue);
                this.appendGameFilter(this._hueFilter);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GameSprite.prototype, "blur", {
        get: function () {
            return this._blur;
        },
        set: function (v) {
            v || (v = 0);
            this._blur = v;
            if (this._blurFilter)
                this.subtractGameFilter(this._blurFilter);
            this._blurFilter = null;
            if (this._blur) {
                this._blurFilter = new BlurFilter(this._blur);
                this.appendGameFilter(this._blurFilter);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GameSprite.prototype, "tonal_r", {
        get: function () {
            return this._tonalParams[0];
        },
        set: function (v) {
            v || (v = 0);
            this._tonalParams[0] = v;
            this.setTonal(this.tonal_r, this._tonalParams[1], this._tonalParams[2], this._tonalParams[3], this._tonalParams[4], this._tonalParams[5], this._tonalParams[6]);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GameSprite.prototype, "tonal_g", {
        get: function () {
            return this._tonalParams[1];
        },
        set: function (v) {
            v || (v = 0);
            this._tonalParams[1] = v;
            this.setTonal(this.tonal_r, this._tonalParams[1], this._tonalParams[2], this._tonalParams[3], this._tonalParams[4], this._tonalParams[5], this._tonalParams[6]);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GameSprite.prototype, "tonal_b", {
        get: function () {
            return this._tonalParams[2];
        },
        set: function (v) {
            v || (v = 0);
            this._tonalParams[2] = v;
            this.setTonal(this.tonal_r, this._tonalParams[1], this._tonalParams[2], this._tonalParams[3], this._tonalParams[4], this._tonalParams[5], this._tonalParams[6]);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GameSprite.prototype, "tonal_gray", {
        get: function () {
            return this._tonalParams[3];
        },
        set: function (v) {
            v || (v = 0);
            this._tonalParams[3] = v;
            this.setTonal(this.tonal_r, this._tonalParams[1], this._tonalParams[2], this._tonalParams[3], this._tonalParams[4], this._tonalParams[5], this._tonalParams[6]);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GameSprite.prototype, "tonal_mr", {
        get: function () {
            return this._tonalParams[4];
        },
        set: function (v) {
            v || (v = 1);
            this._tonalParams[4] = v;
            this.setTonal(this.tonal_r, this._tonalParams[1], this._tonalParams[2], this._tonalParams[3], this._tonalParams[4], this._tonalParams[5], this._tonalParams[6]);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GameSprite.prototype, "tonal_mb", {
        get: function () {
            return this._tonalParams[6];
        },
        set: function (v) {
            v || (v = 1);
            this._tonalParams[6] = v;
            this.setTonal(this.tonal_r, this._tonalParams[1], this._tonalParams[2], this._tonalParams[3], this._tonalParams[4], this._tonalParams[5], this._tonalParams[6]);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GameSprite.prototype, "tonal_mg", {
        get: function () {
            return this._tonalParams[5];
        },
        set: function (v) {
            v || (v = 1);
            this._tonalParams[5] = v;
            this.setTonal(this.tonal_r, this._tonalParams[1], this._tonalParams[2], this._tonalParams[3], this._tonalParams[4], this._tonalParams[5], this._tonalParams[6]);
        },
        enumerable: true,
        configurable: true
    });
    return GameSprite;
}(Sprite));
Object.defineProperty(GameSprite.prototype, 'width', {
    get: function () {
        if (!this.autoSize)
            return this._width;
        return this.getSelfBounds().width;
    },
    set: function (value) {
        if (this._width !== value) {
            this._width = value;
            this.conchModel && this.conchModel.size(value, this._height);
            this.repaint();
            this.event(EventObject.RESIZE);
        }
    }
});
Object.defineProperty(GameSprite.prototype, 'height', {
    get: function () {
        if (!this.autoSize)
            return this._height;
        return this.getSelfBounds().height;
    },
    set: function (value) {
        if (this._height !== value) {
            this._height = value;
            this.conchModel && this.conchModel.size(this._width, value);
            this.repaint();
            this.event(EventObject.RESIZE);
        }
    }
});
var GameUI = (function () {
    function GameUI() {
    }
    GameUI.load = function (id, copy) {
        if (copy === void 0) { copy = false; }
        var data = Common.uiList.data[id];
        if (!data)
            return null;
        if (Config.EDIT_MODE) {
            if (data) {
                return GameUI.parse(data.uiDisplayData, false, null, id);
            }
            return GameUI.getEmptyRoot(id);
        }
        if (!copy && this.uiDatas[id]) {
            return this.uiDatas[id];
        }
        var instanceClassName = data.uiDisplayData.instanceClassName;
        var classObj = window[instanceClassName];
        if (!classObj)
            classObj = window["GUI_" + id];
        if (!classObj)
            return GameUI.getEmptyRoot(id);
        if (id == 0) {
            return GameUI.getEmptyRoot(id);
        }
        var root = new classObj();
        if (!copy) {
            this.uiDatas[id] = root;
        }
        return root;
    };
    GameUI.get = function (id) {
        return GameUI.uiDatas[id];
    };
    GameUI.dispose = function (id) {
        var ui = GameUI.uiDatas[id];
        if (ui) {
            delete GameUI.uiDatas[id];
            ui.dispose();
        }
    };
    GameUI.show = function (id) {
        var ui = this.load(id);
        Game.layer.uiLayer.addChild(ui);
        return ui;
    };
    GameUI.hide = function (id) {
        var ui = GameUI.uiDatas[id];
        if (ui) {
            Game.layer.uiLayer.removeChild(ui);
        }
    };
    GameUI.hideAll = function () {
        for (var id in GameUI.uiDatas) {
            var ui = GameUI.uiDatas[id];
            ui.removeSelf();
        }
    };
    GameUI.init = function () {
        for (var i in UIComponent) {
            window[i] = UIComponent[i];
        }
    };
    GameUI.getEmptyRoot = function (id) {
        var root = new UIComponent.UIRoot(true, id);
        Callback.New(function () { root.event(EventObject.LOADED); }, this).delayRun(0);
        return root;
    };
    GameUI.parse = function (data, newID, childList, uiID, root, syncLoadedEventWhenAssetExist) {
        if (newID === void 0) { newID = false; }
        if (childList === void 0) { childList = null; }
        if (uiID === void 0) { uiID = null; }
        if (root === void 0) { root = null; }
        if (syncLoadedEventWhenAssetExist === void 0) { syncLoadedEventWhenAssetExist = false; }
        if (!root)
            root = new UIComponent.UIRoot(true, data.id);
        if (!root || !data || !data.root) {
            return null;
        }
        addChild(root, data.root.children);
        function addChild(parent, childDatas) {
            if (!childDatas)
                return;
            for (var i = 0; i < childDatas.length; i++) {
                var childData = childDatas[i];
                var compClass = childData.type;
                if (!compClass)
                    continue;
                var childInstance;
                if (!Config.EDIT_MODE && compClass == "UIGUI") {
                    var data = Game.data.uiList.data[childData.guiID];
                    if (data) {
                        if (childData.instanceClassName && window[childData.instanceClassName]) {
                            childInstance = new window[childData.instanceClassName](false, childData.guiID);
                        }
                        else {
                            childInstance = new window["GUI_" + childData.guiID](false, childData.guiID);
                        }
                    }
                    else {
                        childInstance = new UIComponent.UIRoot(false, childData.guiID);
                    }
                }
                else {
                    childInstance = new UIComponent[childData.type]();
                }
                if (childList)
                    childList.push(childInstance);
                var childrenData = childData.children;
                for (var s in childData) {
                    if (s == "children" || (!Config.EDIT_MODE && GameUI.excludeAttrDataMapping[s]))
                        continue;
                    var attr = childData[s];
                    if (newID && s == "id") {
                        childInstance["__id"] = attr;
                        continue;
                    }
                    if (typeof attr == "boolean" || typeof attr == "number" || typeof attr == "string") {
                        var realAttrName = GameUI.attrDataMapping[s];
                        if (!Config.EDIT_MODE && realAttrName) {
                            childInstance[realAttrName] = attr;
                        }
                        else {
                            childInstance[s] = attr;
                        }
                    }
                    else {
                        try {
                            childInstance[s] = ObjectUtils.depthClone(attr);
                        }
                        catch (e) { }
                    }
                }
                if (!root[childInstance.name]) {
                    root[childInstance.name] = childInstance;
                }
                childInstance.constructorInit(uiID, syncLoadedEventWhenAssetExist);
                parent.addChild(childInstance);
                addChild(childInstance, childrenData);
            }
        }
        root.constructorInit(uiID, syncLoadedEventWhenAssetExist);
        return root;
    };
    GameUI.EVENT_TEST_LOAD_CHILD_UI = "EVENT_TEST_LOAD_CHILD_UI";
    GameUI.uiTaskHead = "kds.ui.active";
    GameUI.uiDatas = {};
    GameUI.attrDataMapping = { "mouseEventEnabledData": "mouseEventEnabled" };
    GameUI.excludeAttrDataMapping = { "showOnEditor": true, "mouseEventEnabledInEditor": true };
    return GameUI;
}());
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator.throw(value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments)).next());
    });
};
var GameFunction = (function () {
    function GameFunction() {
    }
    Object.defineProperty(GameFunction, "scene", {
        get: function () {
            return this._scene ? this._scene : Game.currentScene;
        },
        set: function (scene) {
            this._scene = scene;
        },
        enumerable: true,
        configurable: true
    });
    GameFunction.shake = function (strength, duration) {
        var me = arguments.callee;
        if (this["shakeCB"]) {
            this["shakeCB"].stopDealy(clearFrameout);
        }
        var scene = this.scene;
        ;
        if (duration == 0) {
            scene.shakeX = 0;
            scene.shakeY = 0;
            return;
        }
        ;
        scene.shakeX = strength * (Math.random() < 0.5 ? 1 : -1);
        scene.shakeY = strength * (Math.random() < 0.5 ? 1 : -1);
        this["shakeCB"] = Callback.New(function () {
            me.apply(this, [strength, duration - 1]);
        }, this).delayRun(1, setFrameout);
    };
    GameFunction.tonal = function (r, g, b, gray, t, mr, mg, mb, layer, tCur) {
        if (layer === void 0) { layer = -1; }
        if (tCur === void 0) { tCur = null; }
        var me = arguments.callee;
        if (this["tonalCB"]) {
            this["tonalCB"].stopDealy(clearFrameout);
        }
        if (t < 1)
            t = 1;
        var s, scene = this.scene;
        if (!tCur) {
            tCur = 1;
            s = scene.displayObject.getTonal();
            this["tonalCB_startValue"] = s;
        }
        else {
            s = this["tonalCB_startValue"];
        }
        var per = tCur / t;
        function toValue(from, to, per) {
            return from - (from - to) * per;
        }
        scene.displayObject.setTonal(toValue(s[0], r, per), toValue(s[1], g, per), toValue(s[2], b, per), toValue(s[3], gray, per), toValue(s[4], mr, per), toValue(s[5], mg, per), toValue(s[6], mb, per));
        tCur++;
        if (tCur > t) {
            return;
        }
        ;
        this["tonalCB"] = Callback.New(function () {
            me.apply(this, [r, g, b, gray, t, mr, mg, mb, layer, tCur]);
        }, this).delayRun(1, setFrameout);
    };
    GameFunction.cameraMove = function (type, x, y, soIndex, tween, t, tCur, window_width, window_height) {
        if (tCur === void 0) { tCur = null; }
        if (window_width === void 0) { window_width = null; }
        if (window_height === void 0) { window_height = null; }
        if (!window_width)
            window_width = Config.WINDOW_WIDTH;
        if (!window_height)
            window_height = Config.WINDOW_HEIGHT;
        var me = arguments.callee;
        if (this["cameraMoveCB"]) {
            this["cameraMoveCB"].stopDealy(clearFrameout);
        }
        var scene = this.scene;
        var startRect = scene.getCamera();
        if (tCur == null) {
            this["cameraMove_from"] = new Point(startRect.x, startRect.y);
            tCur = 1;
            scene.setCameraSceneObject(null);
        }
        var fromP = this["cameraMove_from"];
        var toP, soc;
        if (type == 1) {
            if (soIndex >= 0) {
                soc = scene.sceneObjects[soIndex];
                if (soc) {
                    toP = new Point(soc.x - window_width * 0.5, soc.y - window_height * 0.5);
                }
            }
        }
        else {
            toP = new Point(x - window_width * 0.5, y - window_height * 0.5);
        }
        if (!toP) {
            return;
        }
        var curP, per;
        if (tween) {
            per = Ease.strongOut(tCur, 0, 1, t);
        }
        else {
            per = tCur / t;
        }
        curP = Point.interpolate(toP, fromP, per);
        scene.setCameraPos(curP.x, curP.y);
        tCur++;
        if (tCur > t) {
            if (type == 1) {
                scene.setCameraSceneObject(soc);
            }
            return;
        }
        ;
        this["cameraMoveCB"] = Callback.New(function () {
            me.apply(this, [type, x, y, soIndex, tween, t, tCur, window_width, window_height]);
        }, this).delayRun(1, setFrameout);
    };
    GameFunction.fogSet = function (url, sx, sy, dx, dy, alpha, blendMode) {
        var scene = this.scene;
        ;
        if (sx == 0)
            sx = 1;
        if (sy == 0)
            sy = 1;
        scene.fogLayer.scaleX = sx;
        scene.fogLayer.scaleY = sy;
        scene.fogLayer.xLoop = true;
        scene.fogLayer.yLoop = true;
        scene.fogLayer.xMove = dx;
        scene.fogLayer.yMove = dy;
        scene.fogLayer.alpha = alpha;
        scene.fogLayer.blendMode = blendMode == 0 ? null : "lighter";
        if (scene.fogLayer.mapUrl != url)
            scene.fogLayer.setBigImage(url);
    };
    GameFunction.playSE = function (soIndex, url, volume, pitch) {
        if (soIndex == -1) {
            GameAudio.playSE(url, volume, pitch);
            return;
        }
        var soc = this.scene.sceneObjects[soIndex];
        if (!soc)
            return;
        GameAudio.playSE(url, volume, pitch, soc);
    };
    GameFunction.stopSE = function () {
        GameAudio.stopSE();
    };
    GameFunction.playBGM = function (bgmURL, volume, pitch, fadeIn) {
        GameAudio.playBGM(bgmURL, volume, 99999, fadeIn != 0, fadeIn * 1000, pitch);
    };
    GameFunction.playBGS = function (bgsURL, volume, pitch, fadeIn) {
        GameAudio.playBGS(bgsURL, volume, 99999, fadeIn != 0, fadeIn * 1000, pitch);
    };
    GameFunction.stopBGM = function (fadeOut) {
        GameAudio.stopBGM(fadeOut != 0, fadeOut * 1000);
    };
    GameFunction.stopBGS = function (fadeOut) {
        GameAudio.stopBGS(fadeOut != 0, fadeOut * 1000);
    };
    GameFunction.openUI = function (id) {
        GameUI.show(id);
    };
    GameFunction.closeUI = function (id) {
        GameUI.hide(id);
    };
    GameFunction.executeScript = function (code) {
        eval(code);
    };
    return GameFunction;
}());
for (var i in GameFunction) {
    if (i == "scene")
        continue;
    var attr = GameFunction[i];
    if (typeof attr == "function") {
        GameFunction.prototype[i] = attr;
    }
}
var ClientMsgSender = (function () {
    function ClientMsgSender() {
    }
    ClientMsgSender.send = function (msg, threadID) {
        if (threadID === void 0) { threadID = -1; }
        if (threadID == -1)
            threadID = ClientMsgSender.threadID;
        if (threadID == -1)
            return;
        if (ClientMain.conn)
            ClientMain.conn.sendMsg(msg, threadID);
    };
    ClientMsgSender.rpc = function (className, funcName, params, onReturn, threadID) {
        if (params === void 0) { params = []; }
        if (onReturn === void 0) { onReturn = null; }
        if (threadID === void 0) { threadID = -1; }
        if (threadID == -1)
            threadID = ClientMsgSender.threadID;
        if (threadID == -1)
            return;
        var onReturnID;
        if (onReturn) {
            onReturnID = ++ClientMsgSender.onReturnCount;
            ClientMsgSender.onReturns[onReturnID] = onReturn;
            setTimeout(function (onReturnID) {
                delete ClientMsgSender.onReturns[onReturnID];
            }, ClientMsgSender.ONRETURN_OVER_TIME, onReturnID);
        }
        else {
            onReturnID = 0;
        }
        var obj = { c: className, f: funcName, p: params, r: onReturnID };
        if (ClientMain.conn)
            ClientMain.conn.sendMsgObj(obj, threadID);
    };
    ClientMsgSender.rpcReturn = function (success, onReturnID, res, domainName, funcName) {
        var onReturn = ClientMsgSender.onReturns[onReturnID];
        delete ClientMsgSender.onReturns[onReturnID];
        if (!success) {
            trace("error:\u670D\u52A1\u5668\u6CA1\u6709\u627E\u5230\u65B9\u6CD5[" + domainName + "::" + funcName + "]\u6216\u65E0\u6743\u9650\uFF01");
            return;
        }
        onReturn && onReturn.runWith([res]);
    };
    ClientMsgSender.requestTriggerEvent = function (type, mainType, indexType, commandID, inputMessage, onCommandExecuteOver) {
        if (inputMessage === void 0) { inputMessage = null; }
        if (onCommandExecuteOver === void 0) { onCommandExecuteOver = null; }
        var onReturnID;
        if (onCommandExecuteOver) {
            onReturnID = ++ClientMsgSender.onCmdReturnCount;
            ClientMsgSender.onCmdReturns[onReturnID] = onCommandExecuteOver;
            setTimeout(function (onReturnID) {
                delete ClientMsgSender.onCmdReturns[onReturnID];
            }, ClientMsgSender.ON_CMD_RETURN_OVER_TIME, onReturnID);
        }
        else {
            onReturnID = 0;
        }
        ClientMsgSender.rpc("ServerWorld", "triggerEvent", [type, mainType, indexType, [commandID, inputMessage, onReturnID]]);
    };
    ClientMsgSender.cmdReturn = function (onReturnID) {
        var onReturn = ClientMsgSender.onCmdReturns[onReturnID];
        delete ClientMsgSender.onCmdReturns[onReturnID];
        onReturn && onReturn.run();
    };
    ClientMsgSender.requestListenPlayerVariable = function (isListen, type, varID) {
        ClientMsgSender.rpc("ServerWorld", "listenerPlayerVariable", [isListen, type, varID]);
    };
    ClientMsgSender.requestGetWorldVariable = function (type, varID) {
        ClientMsgSender.rpc("ServerWorld", "requestGetWorldVariable", [type, varID]);
    };
    ClientMsgSender.onReturns = {};
    ClientMsgSender.onReturnCount = 0;
    ClientMsgSender.ONRETURN_OVER_TIME = 60000;
    ClientMsgSender.onCmdReturns = {};
    ClientMsgSender.onCmdReturnCount = 0;
    ClientMsgSender.ON_CMD_RETURN_OVER_TIME = 60000;
    return ClientMsgSender;
}());
var NetConn = (function () {
    function NetConn() {
        this.jsonMsgFragment = "";
        this.msgFragment = "";
    }
    NetConn.prototype.connect = function (key, host, port, onConnect, onMsg, onClose) {
        if (onClose === void 0) { onClose = null; }
        this.key = key;
        this.host = host;
        this.port = port;
        this.onConnect = onConnect;
        this.onClose = onClose;
        this.onMsg = onMsg;
        var ws = this.ws = new WebSocket("ws://" + host + ":" + port + "/");
        var _this = this;
        ws.onopen = function () {
            _this.onWSOpen();
        };
        ws.onclose = function () {
            _this.onWSClose();
        };
        ws.onmessage = function (msg) {
            _this.onWSMessage(msg);
        };
    };
    NetConn.prototype.close = function () {
        if (this.ws) {
            this.ws.close();
            this.ws = null;
        }
    };
    NetConn.prototype.onWSOpen = function () {
        this.isConnect = true;
        this.ws.send('0' + this.key);
    };
    NetConn.prototype.onWSClose = function () {
        trace("网络错误");
        this.isConnect = false;
        this.onClose && this.onClose.run();
    };
    NetConn.prototype.onWSMessage = function (msg) {
        var sysMsgID = msg.data.substr(0, 1);
        var msgContent = msg.data.substr(1);
        if (sysMsgID == "0") {
            if (msgContent == "onClientConnected") {
                this.onConnect && this.onConnect.run();
            }
        }
        else if (sysMsgID == "1") {
            var msgType = msgContent.substr(0, 1);
            var msgBody = msgContent.substr(1);
            if (msgType == "0") {
                this.onMsg.runWith([msgType, this.msgFragment + msgBody]);
            }
            else if (msgType == "3") {
                this.msgFragment += msgBody;
            }
            else if (msgType == "1") {
                this.onMsg.runWith([msgType, this.jsonMsgFragment + msgBody]);
                this.jsonMsgFragment = "";
            }
            else if (msgType == "2") {
                this.jsonMsgFragment += msgBody;
            }
        }
    };
    NetConn.prototype.sendMsg = function (msg, passageID) {
        if (passageID === void 0) { passageID = 1; }
        if (this.isConnect) {
            this.ws.send("1" + passageID + ",0" + msg);
        }
    };
    NetConn.prototype.sendMsgObj = function (msgObj, passageID) {
        if (passageID === void 0) { passageID = 1; }
        if (this.isConnect) {
            this.ws.send("1" + passageID + ",1" + JSON.stringify(msgObj));
        }
    };
    return NetConn;
}());
var ClientMain = (function () {
    function ClientMain(is3D) {
        if (is3D === void 0) { is3D = false; }
        this.initTask = "ClientMainInitTask";
        os.init(0, 0, true, is3D);
        Game.layer = new GameLayer();
        stage.alignH = "center";
        stage.alignV = "middle";
        if (Browser.onMobile) {
            stage.screenMode = "horizontal";
        }
        SoundManager.autoStopMusic = false;
        this.init();
    }
    ClientMain.prototype.init = function () {
        this.initFrameout();
        this.initHotKey();
        FileUtils.init();
        GameUI.init();
        GameImage.init();
        GameCommand.init();
        Game.init();
        new SyncTask(this.initTask, this.installDataConfig, [Config.JSON_CONFIG, Config], this);
        new SyncTask(this.initTask, this.loadGameData, [], this);
        new SyncTask(this.initTask, this.installScripts, [], this);
        new SyncTask(this.initTask, this.installGameData, [], this);
        new SyncTask(this.initTask, this.installDataAvatar, [], this);
        new SyncTask(this.initTask, this.initOver, [], this);
    };
    ClientMain.prototype.initFrameout = function () {
        os.add_ENTERFRAME(doFrameout, this);
    };
    ClientMain.prototype.initHotKey = function () {
        stage.add_KEYDOWN(function (e) {
            ClientMain.ctrlKey = e.ctrlKey;
            ClientMain.shiftKey = e.shiftKey;
            ClientMain.altKey = e.shiftKey;
        }, this);
        stage.add_KEYUP(function (e) {
            ClientMain.ctrlKey = e.ctrlKey;
            ClientMain.shiftKey = e.shiftKey;
            ClientMain.altKey = e.shiftKey;
        }, this);
    };
    ClientMain.prototype.installDataConfig = function (url, configObj) {
        FileUtils.loadJsonFile(url, new Callback(function (cfgJson) {
            ObjectUtils.clone(cfgJson, configObj);
            Config.init();
            stage.width = Config.WINDOW_WIDTH;
            stage.height = Config.WINDOW_HEIGHT;
            stage.bgColor = Config.STAGE_BACKGROUND_COLOR;
            stage.scaleMode = "showall";
            SyncTask.taskOver(this.initTask);
        }, this));
    };
    ClientMain.prototype.loadGameData = function () {
        var task = new AsynTask(Callback.New(SyncTask.taskOver, this, [this.initTask]));
        var onloadDataOver = Callback.New(task.complete, task, []);
        task.execute(Game.data.loadDialogList(onloadDataOver));
        task.execute(Game.data.loadTileList(onloadDataOver));
        task.execute(Game.data.loadDataStructureList(onloadDataOver));
        task.execute(Game.data.loadCustomModuleList(onloadDataOver));
        task.execute(Game.data.loadGameAttributeConfig(onloadDataOver));
        task.execute(Game.data.loadSceneObjectModelList(onloadDataOver));
        task.execute(Game.data.loadUIList(onloadDataOver));
        task.execute(Game.data.loadCustomEventType(onloadDataOver));
    };
    ClientMain.prototype.installGameData = function () {
        CustomCompositeSetting.runCode(Game.data);
        SyncTask.taskOver(this.initTask);
    };
    ClientMain.prototype.installScripts = function () {
        var len = GameListData.getLength(Game.data.sceneObjectModelList);
        var soModelBaseCode = "";
        for (var i = 1; i <= len; i++) {
            var soModelData = Game.data.sceneObjectModelList.data[i];
            if (!soModelData)
                continue;
            soModelBaseCode += SceneObjectModelData.getClientJsBaseCode(soModelData) + ";SceneObjectModelData.sceneObjectClass[" + i + "]=ClientSceneObject_" + i + ";";
        }
        for (var typeID = 1; typeID <= 16; typeID++) {
            var len = GameListData.getLength(Game.data.uiList, typeID);
            for (var s = 1; s <= len; s++) {
                var uiData = GameListData.getItem(Game.data.uiList, typeID, s);
                if (!uiData)
                    continue;
                UIDisplayData.init(uiData.uiDisplayData, globalThis);
            }
        }
        Game.data.loadScript(2, Callback.New(function () {
            var jsCode = "";
            for (var i in Game.data.commonScript.bin) {
                jsCode += Game.data.commonScript.bin[i];
            }
            Game.data.loadScript(1, Callback.New(function () {
                for (var i in Game.data.clientScript.bin) {
                    jsCode += Game.data.clientScript.bin[i];
                    var title = Game.data.clientScript.title[i];
                    if (title == SceneObjectModelData.CLIENT_SCENE_OBJECT_CORE_CLASS) {
                        jsCode += soModelBaseCode;
                    }
                }
                globalThis.eval(jsCode);
                SyncTask.taskOver(this.initTask);
            }, this), false);
        }, this), false);
    };
    ClientMain.prototype.installDataAvatar = function () {
        SyncTask.taskOver(this.initTask);
    };
    ClientMain.prototype.initOver = function () {
        EventUtils.happen(ClientWorld, ClientWorld.EVENT_INITED);
    };
    ClientMain.prototype.startLogin = function (onLoginSuccess, onLoginFail) {
        if (onLoginFail === void 0) { onLoginFail = null; }
        trace("网络版");
        ClientMain.conn = new NetConn();
        ClientMain.conn.connect(Game.playerKey, Config.GAME_SERVER_HOST, Config.GAME_SERVER_PORT, null, new Callback(this.onServerMsg, this), onLoginFail);
        var si = setInterval(function () {
            if (ClientMsgSender.threadID != null) {
                onLoginSuccess && onLoginSuccess.run();
                clearInterval(si);
            }
        }, 0);
    };
    ClientMain.prototype.onServerMsg = function (msgType, msgContent) {
        if (msgType == "0") {
            EventUtils.happen(ClientWorld, ClientWorld.EVENT_STRING_MESSAGE, [msgContent]);
        }
        else {
            try {
                var msgObj = JSON.parse(msgContent);
                var domainObj = window[msgObj.c];
                var func = domainObj[msgObj.f];
            }
            catch (e) {
            }
            func.apply(domainObj, msgObj.p);
        }
    };
    return ClientMain;
}());
var __setFrameoutFunc = [];
var __fCount = 0;
var setFrameout = function (func, frame) {
    var arg = [];
    for (var _i = 2; _i < arguments.length; _i++) {
        arg[_i - 2] = arguments[_i];
    }
    var t = new Date().getTime() + "_" + Math.random();
    __setFrameoutFunc.push([func, __fCount, frame, arg, t]);
    return t;
};
var clearFrameout = function (t) {
    var m = ArrayUtils.matchAttributes(__setFrameoutFunc, { 4: t }, true, "==", true);
    if (m.length == 1) {
        __setFrameoutFunc.splice(m[0], 1);
    }
};
var doFrameout = function () {
    __fCount++;
    for (var s = 0; s < __setFrameoutFunc.length; s++) {
        var arr = __setFrameoutFunc[s];
        if (__fCount - arr[1] >= arr[2]) {
            arr[0].apply(this, arr[3]);
            __setFrameoutFunc.splice(s, 1);
            s--;
        }
    }
};
var globalThis = this;





var ClientPlayer = (function (_super) {
    __extends(ClientPlayer, _super);
    function ClientPlayer(isMyPlayer) {
        if (isMyPlayer === void 0) { isMyPlayer = false; }
        _super.call(this);
        if (isMyPlayer)
            this.initMyPlayer();
    }
    ClientPlayer.prototype.initMyPlayer = function () {
        this.variable = new Variable();
        this.event = new EventDispatcher();
        this.requestSyncPlayerVars = [[], [], []];
    };
    ClientPlayer.prototype.addListenerPlayerVariable = function (type, varID, onChange, isOnce) {
        if (isOnce === void 0) { isOnce = false; }
        var rqArr = this.requestSyncPlayerVars[type];
        if (!rqArr[varID]) {
            rqArr[varID] = true;
            ClientMsgSender.requestListenPlayerVariable(true, type, varID);
        }
        else {
            var funcs = [this.variable.getVariable, this.variable.getSwitch, this.variable.getString];
            var value = funcs[type].apply(this.variable, [varID]);
            onChange.runWith([type, varID, value]);
            if (isOnce)
                return;
        }
        var typeEvent = ClientPlayer.getEventType(type, varID);
        this.event[isOnce ? "once" : "on"](typeEvent, onChange.caller, onChange.callbackFunc, onChange.args);
    };
    ClientPlayer.prototype.removeListenerPlayerVariable = function (type, varID, onChange) {
        var typeEvent = ClientPlayer.getEventType(type, varID);
        this.event.off(typeEvent, onChange.caller, onChange.callbackFunc);
        if (!this.event.hasListener(typeEvent)) {
            var rqArr = this.requestSyncPlayerVars[type];
            if (rqArr) {
                delete rqArr[varID];
                ClientMsgSender.requestListenPlayerVariable(false, type, varID);
            }
        }
    };
    ClientPlayer.playerVariableChange = function (type, varID, value) {
        var typeEvent = ClientPlayer.getEventType(type, varID);
        var funcs = [Game.player.variable.setVariable, Game.player.variable.setSwitch, Game.player.variable.setString];
        funcs[type].apply(Game.player.variable, [varID, value]);
        Game.player.event.event(typeEvent, [type, varID, value]);
    };
    ClientPlayer.getEventType = function (type, varID) {
        return "" + ClientPlayer.EVENT_TYPE + type + "_" + varID;
    };
    ClientPlayer.EVENT_TYPE = "VariableSystemEvent";
    return ClientPlayer;
}(Player));
var ClientWorld = (function () {
    function ClientWorld() {
    }
    ClientWorld.init = function () {
        ClientMain.self = new ClientMain();
    };
    ClientWorld.startLogin = function (onLoginSuccess, onLoginFail) {
        if (onLoginFail === void 0) { onLoginFail = null; }
        ClientMain.self.startLogin(onLoginSuccess, onLoginFail);
    };
    ClientWorld.logout = function () {
        ClientMain.conn.close();
    };
    ClientWorld.requestGetVariable = function (type, varID, onResponse) {
        ClientMsgSender.requestGetWorldVariable(type, varID);
        var evType = ClientWorld.getEventType(type, varID);
        EventUtils.addEventListener(ClientWorld, evType, onResponse, true);
    };
    ClientWorld.getEventType = function (type, varID) {
        return "" + ClientWorld.EVENT_GET_WORLD_VAR + type + "_" + varID;
    };
    ClientWorld.reponseGetVariable = function (isSuccess, type, varID, value) {
        var arr = ["variables", "switchs", "strings"];
        ClientWorld.variable[arr[type]][varID] = value;
        var evType = this.getEventType(type, varID);
        EventUtils.happen(ClientWorld, evType, [isSuccess, type, varID, value]);
    };
    ClientWorld.isGame = true;
    ClientWorld.EVENT_INITED = "ClientMain_EVENT_INITED";
    ClientWorld.EVENT_STRING_MESSAGE = "ClientMain_EVENT_STRING_MESSAGE";
    ClientWorld.EVENT_GET_WORLD_VAR = "ClientWorld_EVENT_GET_WORLD_VAR";
    ClientWorld.requestSyncVars = [[], [], []];
    ClientWorld.variable = new Variable();
    return ClientWorld;
}());
var Game = (function () {
    function Game() {
    }
    Game.setPlayerData = function (playerID) {
        Game.player.uid = playerID;
        Game.player.key = Game.playerKey;
    };
    Game.init = function () {
        this.player = new ClientPlayer(true);
    };
    Game.data = new GameData();
    return Game;
}());





var ClientSceneLayer = (function (_super) {
    __extends(ClientSceneLayer, _super);
    function ClientSceneLayer(scene, autoUpdate) {
        if (autoUpdate === void 0) { autoUpdate = true; }
        _super.call(this);
        this.dx = 0;
        this.dy = 0;
        this.xMove = 0;
        this.yMove = 0;
        this.dxMove = 0;
        this.dyMove = 0;
        this.prospectsPerX = 1.0;
        this.prospectsPerY = 1.0;
        this.autoUpdate = true;
        this.tileLayer = new Sprite();
        this.tileData = [];
        this.imgWidth = 0;
        this.imgHeight = 0;
        this.imgBigWidth = 0;
        this.imgBigHeight = 0;
        this.tileSplitMap = [];
        this.needFlushTileSplit = {};
        this.scene = scene;
        this.autoUpdate = autoUpdate;
        this.addChild(this.tileLayer);
    }
    ClientSceneLayer.prototype.install = function (layerData, onFin) {
        var _this = this;
        if (onFin === void 0) { onFin = null; }
        ObjectUtils.clone(layerData, this);
        if (this.drawMode && layerData.tileData) {
            var urls = [];
            if (!Config.EDIT_MODE) {
                for (var id in layerData.tileTexIDs) {
                    if (!layerData.tileTexIDs[id])
                        continue;
                    var tileData = Game.data.tileList.data[id];
                    if (tileData && tileData.url)
                        urls.push(tileData.url);
                }
            }
            else {
                for (var id in Game.data.tileList.data) {
                    var tileData = Game.data.tileList.data[id];
                    if (tileData && tileData.url)
                        urls.push(tileData.url);
                }
            }
            if (urls.length == 0) {
                onFin && onFin.run();
                return;
            }
            AssetManager.loadImages(urls, Callback.New(function () {
                if (_this.isDisposed)
                    return;
                _this.setTilefromJsonData();
                onFin && onFin.run();
            }, this));
            this.tileImageUrls = urls;
        }
        else {
            if (layerData.img) {
                AssetManager.loadImage(layerData.img, Callback.New(function () {
                    if (_this.isDisposed)
                        return;
                    _this.setBigImage(layerData.img);
                    onFin && onFin.run();
                }, this), false, false);
            }
            else {
                onFin && onFin.run();
            }
        }
    };
    ClientSceneLayer.prototype.setTilefromJsonData = function () {
        var wGrid = this.scene.gridWidth;
        var hGrid = this.scene.gridHeight;
        for (var x = 0; x < wGrid; x++) {
            if (!this.tileData[x])
                continue;
            for (var y = 0; y < hGrid; y++) {
                var myTileData = this.tileData[x][y];
                if (myTileData && myTileData.texID) {
                    var tileData = Game.data.tileList.data[myTileData.texID];
                    if (!tileData)
                        continue;
                    var url = Game.data.tileList.data[myTileData.texID].url;
                    var tex = AssetManager.getImage(url);
                    if (!tex)
                        continue;
                    myTileData.tex = tex;
                    this.drawTile(x, y, myTileData);
                }
            }
        }
        this.flushTile();
    };
    ClientSceneLayer.prototype.resizeTileSplit = function (wGrid, hGrid) {
        for (var w = 0; w < this.tileData.length; w++) {
            if (!this.tileData[w])
                continue;
            if (this.tileData[w].length > hGrid) {
                this.tileData[w].splice(hGrid);
            }
        }
        if (this.tileData.length > wGrid)
            this.tileData.splice(wGrid);
        var wSplit = Math.ceil(wGrid / (Config.TILE_SPLIT_SIZE / Config.SCENE_GRID_SIZE));
        var hSplit = Math.ceil(hGrid / (Config.TILE_SPLIT_SIZE / Config.SCENE_GRID_SIZE));
        this.tileLayer.removeChildren();
        var len = this.tileSplitMap.length;
        for (var x = 0; x < len; x++) {
            var tileDataColumn = this.tileSplitMap[x];
            if (!tileDataColumn)
                continue;
            for (var y = 0; y < tileDataColumn.length; y++) {
                if (!tileDataColumn[y])
                    continue;
                if (x >= wSplit || y >= hSplit) {
                    if (tileDataColumn[y].texture)
                        tileDataColumn[y].texture.destroy(true);
                }
            }
            tileDataColumn.length = hSplit;
        }
        this.tileSplitMap.length = wSplit;
        for (var x = 0; x < wSplit; x++) {
            var tileDataColumn = this.tileSplitMap[x];
            if (!tileDataColumn) {
                tileDataColumn = this.tileSplitMap[x] = [];
            }
            for (var y = 0; y < hSplit; y++) {
                var splitData = this.tileSplitMap[x][y];
                if (!splitData) {
                    splitData = this.tileSplitMap[x][y] = {
                        graphics: new Graphics(),
                        graphicsMapping: [],
                        texture: null,
                        sprite: new Sprite()
                    };
                    splitData.sprite.x = x * Config.TILE_SPLIT_SIZE;
                    splitData.sprite.y = y * Config.TILE_SPLIT_SIZE;
                    var localGridSize = Config.TILE_SPLIT_SIZE / Config.SCENE_GRID_SIZE;
                    for (var g = 0; g < localGridSize; g++) {
                        splitData.graphicsMapping[g] = [];
                    }
                }
                this.tileLayer.addChild(splitData.sprite);
            }
        }
        var realSize = Scene.getRealWidth(this.scene);
        this.imgWidth = realSize.width;
        this.imgHeight = realSize.height;
    };
    ClientSceneLayer.prototype.refreshLoopShow = function () {
        if (this.drawMode) {
            this.reloadTile();
        }
        else {
            this.setBigImage(this.mapUrl);
        }
    };
    ClientSceneLayer.prototype.reloadTile = function () {
        this.clearTile(false);
        this.install({ tileData: this.tileData, tileTexIDs: this["tileTexIDs"] });
    };
    ClientSceneLayer.prototype.getTileData = function () {
        var tileData = [];
        var tileTexIDs = {};
        var wGrid = this.scene.gridWidth;
        var hGrid = this.scene.gridHeight;
        for (var x = 0; x < wGrid; x++) {
            if (!this.tileData[x])
                continue;
            if (!tileData[x])
                tileData[x] = [];
            for (var y = 0; y < hGrid; y++) {
                var oneTileData = this.tileData[x][y];
                if (oneTileData) {
                    tileData[x][y] = {
                        texID: oneTileData.texID,
                        x: oneTileData.x,
                        y: oneTileData.y
                    };
                    if (oneTileData.texID && !tileTexIDs[oneTileData.texID]) {
                        tileTexIDs[oneTileData.texID] = true;
                    }
                }
            }
        }
        return [tileData, tileTexIDs];
    };
    ClientSceneLayer.prototype.drawTile = function (xGrid, yGrid, tileData) {
        if (xGrid < 0 || xGrid >= this.scene.gridWidth || yGrid < 0 || yGrid >= this.scene.gridHeight)
            return;
        var splitGridSize = Math.ceil(Config.TILE_SPLIT_SIZE / Config.SCENE_GRID_SIZE);
        var splitX = Math.floor(xGrid / splitGridSize);
        var splitY = Math.floor(yGrid / splitGridSize);
        var splitData = this.tileSplitMap[splitX][splitY];
        var graphics = splitData.graphics;
        var localGridX = xGrid % splitGridSize;
        var localGridY = yGrid % splitGridSize;
        var localX = localGridX * Config.SCENE_GRID_SIZE;
        var localY = localGridY * Config.SCENE_GRID_SIZE;
        var gCmdIndex = splitData.graphicsMapping[localGridX][localGridY];
        if (gCmdIndex == null) {
            if (tileData) {
                var w = Config.SCENE_GRID_SIZE;
                var h = Config.SCENE_GRID_SIZE;
                if (localGridX == splitGridSize - 1)
                    w += 1;
                if (localGridY == splitGridSize - 1)
                    h += 1;
                graphics.fillTexture(tileData.tex, localX, localY, w, h, null, new Point(-tileData.x, -tileData.y));
                gCmdIndex = splitData.graphicsMapping[localGridX][localGridY] = graphics.cmds ? graphics.cmds.length - 1 : 0;
            }
        }
        else {
            var gCmdData = gCmdIndex == 0 && graphics.cmds == null ? graphics["_one"] : graphics.cmds[gCmdIndex];
            if (tileData) {
                if (gCmdData) {
                    gCmdData[0] = tileData.tex;
                    gCmdData[1] = localX;
                    gCmdData[2] = localY;
                    gCmdData[6].x = -tileData.x;
                    gCmdData[6].y = -tileData.y;
                }
            }
            else {
                splitData.graphicsMapping[localGridX][localGridY] = null;
                if (graphics.cmds) {
                    graphics.cmds.splice(gCmdIndex, 1);
                    for (var x = 0; x < splitGridSize; x++) {
                        for (var y = 0; y < splitGridSize; y++) {
                            if (splitData.graphicsMapping[x][y] > gCmdIndex) {
                                splitData.graphicsMapping[x][y]--;
                            }
                        }
                    }
                    if (graphics.cmds.length == 0) {
                        graphics.clear();
                    }
                }
                else {
                    if (gCmdIndex == 0)
                        graphics.clear();
                }
            }
        }
        var tileSplitIndex = splitX + "_" + splitY;
        if (!this.needFlushTileSplit[tileSplitIndex]) {
            this.needFlushTileSplit[tileSplitIndex] = splitData;
        }
        if (!this.tileData[xGrid])
            this.tileData[xGrid] = [];
        this.tileData[xGrid][yGrid] = tileData;
    };
    ClientSceneLayer.prototype.flushTile = function () {
        var realSize = Scene.getRealWidth(this.scene);
        for (var i in this.needFlushTileSplit) {
            var splitData = this.needFlushTileSplit[i];
            if (!splitData.graphics.cmds && !splitData.graphics["_one"]) {
                splitData.graphics.clear();
            }
            if (splitData.texture)
                splitData.texture.destroy(true);
            var texture = AssetManager.drawToTexture(splitData.graphics, Config.TILE_SPLIT_SIZE, Config.TILE_SPLIT_SIZE, 0, 0, false, Config.TILE_LINEAR_MIN ? 0x2601 : 0x2600, Config.TILE_LINEAR_MAG ? 0x2601 : 0x2600);
            var splitSprite = splitData.sprite;
            splitSprite.removeChildren();
            var drawArea = [];
            if (this.xLoop) {
                drawArea.push([1, 0], [-1, 0]);
            }
            if (this.yLoop) {
                drawArea.push([0, 1], [0, -1]);
            }
            if (this.xLoop && this.yLoop) {
                drawArea.push([-1, -1], [1, -1], [1, 1], [-1, 1]);
            }
            for (var s in drawArea) {
                var loopSp = new Sprite();
                loopSp.texture = texture;
                splitSprite.addChild(loopSp);
                loopSp.x = drawArea[s][0] * realSize.width;
                loopSp.y = drawArea[s][1] * realSize.height;
            }
            splitData.sprite.texture = texture;
            splitData.texture = texture;
        }
        this.needFlushTileSplit = [];
    };
    ClientSceneLayer.prototype.clearTile = function (isDispose) {
        if (isDispose === void 0) { isDispose = true; }
        var len = this.tileSplitMap.length;
        var localGridSize = Config.TILE_SPLIT_SIZE / Config.SCENE_GRID_SIZE;
        for (var x = 0; x < len; x++) {
            for (var y = 0; y < this.tileSplitMap[x].length; y++) {
                var tileData = this.tileSplitMap[x][y];
                tileData.graphics.clear();
                for (var g = 0; g < localGridSize; g++) {
                    tileData.graphicsMapping[g] = [];
                }
                if (!tileData || !tileData.texture)
                    continue;
                tileData.texture.destroy(true);
            }
        }
        if (isDispose)
            this.tileSplitMap.length = 0;
    };
    ClientSceneLayer.prototype.setEditorMode = function (bool, forceShow) {
        if (forceShow === void 0) { forceShow = false; }
        if (bool == this.editorMode || !this.drawMode)
            return;
        if (bool) {
            this.lastStates = {
                scaleX: this.scaleX,
                scaleY: this.scaleY,
                rotation: this.rotation,
                opacityPer: this.opacityPer,
                gameFilters: this.gameFilters
            };
            this.scaleX = this.scaleY = 1;
            this.rotation = 0;
            this.opacityPer = 1;
            this.gameFilters = [];
        }
        else {
            if (!this.lastStates)
                return;
            this.scaleX = this.lastStates.scaleX;
            this.scaleY = this.lastStates.scaleY;
            this.rotation = this.lastStates.rotation;
            this.opacityPer = forceShow ? 1 : this.lastStates.opacityPer;
            this.gameFilters = this.lastStates.gameFilters;
            this.dxMove = 0;
            this.dyMove = 0;
        }
        this.editorMode = bool;
        this.onRender(true);
    };
    Object.defineProperty(ClientSceneLayer.prototype, "drawMode", {
        get: function () {
            return this._drawMode;
        },
        set: function (v) {
            if (v) {
                this.setBigTexture(null);
            }
            else {
                this.tileLayer.graphics.clear();
            }
            if (!this._drawMode && v) {
                this.resizeTileSplit(this.scene.gridWidth, this.scene.gridHeight);
            }
            this._drawMode = v;
        },
        enumerable: true,
        configurable: true
    });
    ClientSceneLayer.prototype.setBigImage = function (imgURL) {
        var _this = this;
        AssetManager.disposeImage(this.mapUrl);
        this.mapUrl = imgURL;
        this.graphics.clear();
        if (this.bigImageRoot) {
            this.removeChild(this.bigImageRoot);
            AssetManager.disposeAtlasSprite(this.bigImageRoot);
            this.bigImageRoot = null;
        }
        if (imgURL == null)
            return;
        AssetManager.loadImage(imgURL, Callback.New(function (tex) {
            _this.setBigTexture(tex, false);
        }, this));
    };
    ClientSceneLayer.prototype.setBigTexture = function (t, disposeBitImage) {
        if (disposeBitImage === void 0) { disposeBitImage = true; }
        if (this.isDisposed)
            return;
        if (disposeBitImage && this.mapUrl) {
            AssetManager.disposeImage(this.mapUrl);
            this.mapUrl = null;
        }
        if (!t) {
            this.graphics.clear();
            return;
        }
        this.imgWidth = t.width;
        this.imgHeight = t.height;
        if (t.width > os.MAX_TEXTURE_SIZE || t.height > os.MAX_TEXTURE_SIZE) {
            var bitTextureBox = this.bigImageRoot = AssetManager.bigTextureToAtlasSprite(t, this.xLoop, this.yLoop, this.imgWidth, this.imgHeight);
            this.addChildAt(bitTextureBox, 0);
            return;
        }
        this.imgBigWidth = this.xLoop ? t.width * 50 : 0;
        this.imgBigHeight = this.yLoop ? t.height * 50 : 0;
        var g = new Graphics();
        var loopStr = this.xLoop && this.yLoop ? "repeat" : this.xLoop ? "repeat-x" : this.yLoop ? "repeat-y" : "no-repeat";
        g.fillTexture(t, 0, 0, ClientSceneLayer.prospectSize, ClientSceneLayer.prospectSize, loopStr);
        this.graphics = g;
    };
    ClientSceneLayer.prototype.setViewPort = function (rect) {
        if (!this.autoUpdate)
            return;
        this.viewRect = rect;
        if (this.editorMode) {
            this.x = 0;
            this.y = 0;
            this.tileLayer.x = 0;
            this.tileLayer.y = 0;
            return;
        }
        if ((this.prospectsPerX != 1 || this.prospectsPerY != 1 || this.xMove != 0 || this.yMove != 0) && rect) {
            var dpx = 1 - this.prospectsPerX;
            var dpy = 1 - this.prospectsPerY;
            var globalX = Math.floor(rect.x * dpx);
            var globalY = Math.floor(rect.y * dpy);
            this.x = globalX + this.dx + this.dxMove - this.imgBigWidth;
            this.y = globalY + this.dy + this.dyMove - this.imgBigHeight;
            if (this.drawMode) {
                this.tileLayer.x = this.imgBigWidth;
                this.tileLayer.y = this.imgBigHeight;
            }
        }
        else {
            this.x = this.dx;
            this.y = this.dy;
            if (this.drawMode) {
                this.tileLayer.x = this.tileLayer.y = 0;
            }
        }
        this.x = this.x;
        this.y = this.y;
    };
    ClientSceneLayer.prototype.onRender = function (zFrame) {
        if (zFrame === void 0) { zFrame = false; }
        if (!this.autoUpdate)
            return;
        if (!zFrame) {
            this.dxMove += this.xMove;
            this.dyMove += this.yMove;
            if (this.imgWidth != 0 && this.xLoop) {
                this.dxMove %= this.imgWidth * this.scaleX;
            }
            if (this.imgHeight != 0 && this.yLoop) {
                this.dyMove %= this.imgHeight * this.scaleY;
            }
        }
        else {
            this.dxMove = 0;
            this.dyMove = 0;
        }
        this.setViewPort(this.viewRect);
        this.updateChildZOrder();
    };
    ClientSceneLayer.prototype.updateChildZOrder = function () {
        if (this.isChangeChildZOrder) {
            var len = this.numChildren;
            var mcArray = [];
            for (var i = 0; i < len; i++) {
                mcArray.push(this.getChildAt(i));
            }
            mcArray.sort(function (a, b) {
                return a.y > b.y ? 1 : -1;
            });
            var arrLen = mcArray.length;
            for (var j = 0; j < arrLen; j++) {
                this.setChildIndex(mcArray[j], j);
            }
        }
    };
    ClientSceneLayer.prototype.dispose = function () {
        if (!this.isDisposed) {
            if (this.mapUrl) {
                AssetManager.disposeImage(this.mapUrl);
                this.mapUrl = null;
            }
            if (this.bigImageRoot) {
                AssetManager.disposeAtlasSprite(this.bigImageRoot);
                this.bigImageRoot = null;
            }
            this.clearTile();
            if (this.tileImageUrls)
                AssetManager.disposeImages(this.tileImageUrls);
            this.removeSelf();
        }
        _super.prototype.dispose.call(this);
    };
    ClientSceneLayer.prospectSize = 1000000;
    return ClientSceneLayer;
}(GameSprite));





var Animation = (function (_super) {
    __extends(Animation, _super);
    function Animation() {
        _super.call(this);
        this.autoID = ObjectUtils.getInstanceID();
        this.fps = Config.ANIMATION_FPS ? Config.ANIMATION_FPS : 20;
        this.silentMode = false;
        this._showHitEffect = false;
        this._currentFrame = 0;
        this.loop = false;
        this.imageSources = [null];
        this._totalFrame = 0;
        this._time = 0;
        this._preAnimationlayers = [];
        this._isloading = false;
        this._isloaded = false;
        this.isParticle = false;
        if (Config.EDIT_MODE) {
            this.mouseEnabled = true;
        }
        this.scaleX = 1.0001;
    }
    Object.defineProperty(Animation.prototype, "id", {
        get: function () { return this._id; },
        set: function (v) {
            if (this._id == v)
                return;
            AssetManager.disposeAnimationAsset(this.id);
            this._id = v;
            this._loadIDRD = Math.random();
            this.loadData(v, this._loadIDRD);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Animation.prototype, "showHitEffect", {
        get: function () { return this._showHitEffect; },
        set: function (v) { this._showHitEffect = v; this.onRender(); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Animation.prototype, "currentFrame", {
        get: function () { return this._currentFrame; },
        set: function (v) {
            this._currentFrame = v;
            this._time = v / this.fps * 1000;
            this._preTime = 0;
            this.onRender();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Animation.prototype, "isPlaying", {
        get: function () { return this._isPlaying; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Animation.prototype, "target", {
        get: function () {
            return this._target;
        },
        set: function (value) {
            if (this._target) {
                this._target.removeAnimationTargetEffect(this.animationTargetLayer);
            }
            this._target = value;
            if (this._target)
                this._target.addAnimationTargetEffect(this.animationTargetLayer);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Animation.prototype, "totalFrame", {
        get: function () {
            return this._totalFrame;
        },
        enumerable: true,
        configurable: true
    });
    Animation.prototype.loadData = function (animationID, loadIDRD) {
        var _this = this;
        if (animationID == 0) {
            this.clear();
            Callback.New(this.event, this, [EventObject.LOADED]).delayRun(0);
            return;
        }
        if (Config.EDIT_MODE) {
            var animationData = Common.animationList.data[animationID];
            this.parseData(animationData, loadIDRD);
        }
        else {
            this._isloaded = false;
            this._isloading = true;
            AssetManager.loadJson("asset/json/animation/data/ani" + animationID + ".json", Callback.New(function (animationData) {
                _this.parseData(animationData, loadIDRD);
            }, this), this.syncLoadWhenAssetExist);
        }
    };
    Animation.prototype.clear = function (clearGraphics) {
        if (clearGraphics === void 0) { clearGraphics = true; }
        for (var i = this.numChildren - 1; i >= 0; i--) {
            if (this.getChildAt(i) instanceof AnimationLayer) {
                this.removeChildAt(i);
            }
        }
        if (this.particleAni)
            this.particleAni.removeSelf();
    };
    Animation.prototype.parseData = function (animationData, loadIDRD) {
        if (loadIDRD === void 0) { loadIDRD = null; }
        if (this.isDisposed)
            return;
        this._isloading = true;
        this._isloaded = false;
        if (!animationData) {
            this._isloaded = true;
            return;
        }
        this.clear(false);
        if (animationData.isParticle) {
            this.particleParseData(animationData, loadIDRD);
        }
        else {
            this.sFrameParseData(animationData, loadIDRD);
        }
    };
    Animation.prototype.particleParseData = function (animationData, loadIDRD) {
        this._id = animationData.id;
        this.isParticle = true;
        this.particleData = animationData.particleData;
        if (!this.particleData)
            return;
        var textureName = this.particleData.textureName;
        if (!textureName || textureName.length < 1)
            return;
        var _this = this;
        AssetManager.loadTexture(textureName, Callback.New(function (texture) {
            if (this.isDisposed) {
                return;
            }
            this._isloading = false;
            this._isloaded = true;
            if (!texture)
                return;
            if (!_this.particleAni) {
                var setting = new ParticleSetting();
                ObjectUtils.clone(_this.particleData, setting);
                setting.maxPartices += 1;
                _this.particleAni = new Particle2D(setting);
            }
            if (_this._isPlaying) {
                _this.play(true);
            }
            if (!loadIDRD || loadIDRD == _this._loadIDRD)
                _this.event(EventObject.LOADED);
        }, this), this.syncLoadWhenAssetExist);
    };
    Animation.prototype.refreshParticleSetting = function () {
        if (!this._isPlaying || !this.particleData || !this.particleAni || !this.particleData.textureName)
            return;
        var _this = this;
        AssetManager.loadTexture(this.particleData.textureName, Callback.New(function (texture) {
            if (!texture)
                return;
            var setting = new ParticleSetting();
            ObjectUtils.clone(_this.particleData, setting);
            setting.maxPartices += 1;
            _this.particleAni.setParticleSetting(setting);
        }, this), this.syncLoadWhenAssetExist);
    };
    Animation.prototype.sFrameParseData = function (animationData, loadIDRD) {
        var _this = this;
        this._id = animationData.id;
        if (animationData.fps)
            this.fps = animationData.fps;
        this._totalFrame = animationData.totalFrame;
        this.imageSources = animationData.imageSources;
        this.isParticle = false;
        this._preAnimationlayers.length = 0;
        var picUrls = animationData.imageSources.reduce(function (pv, v) { if (v && pv.indexOf(v.url) == -1)
            pv.push(v.url); return pv; }, []);
        AssetManager.loadImages(picUrls, Callback.New(function () {
            var loadRandName = "loadAnimation" + _this.autoID;
            var layers = animationData.layers;
            for (var index = 0; index < layers.length; index++) {
                var layer = Animation.createAnimationLayer(layers[index]);
                if (layer instanceof AnimationTargetLayer) {
                    _this.animationTargetLayer = layer;
                }
                _this._preAnimationlayers.push(layer);
                layer.animation = _this;
                _this.addChild(layer);
                layer.showFrame(0);
                if (layer instanceof AnimationAnimationLayer) {
                    new SyncTask(loadRandName);
                    layer.once(EventObject.LOADED, _this, SyncTask.taskOver, [loadRandName]);
                }
            }
            new SyncTask(loadRandName, function (loadRandName) {
                _this._isloading = false;
                _this._isloaded = true;
                _this.target = _this.target;
                _this.updateParent();
                if (_this.displayedInStage) {
                    var bounds = _this.getBounds();
                    _this.width = bounds.width;
                    _this.height = bounds.height;
                    _this.onRender();
                }
                SyncTask.clear(loadRandName);
            }, [loadRandName], _this);
            if (!loadIDRD || loadIDRD == _this._loadIDRD)
                _this.event(EventObject.LOADED, [_this.historySelectedIndex, _this.historyFrameIndex]);
        }, this), this.syncLoadWhenAssetExist);
    };
    Animation.prototype.addToGameSprite = function (target, lowLayer, highLayer) {
        this.target = target;
        this._lowLayer = lowLayer;
        this._highLayer = highLayer;
        this.updateParent();
    };
    Animation.prototype.updateParent = function () {
        var _this = this;
        if (this.isDisposed || !this._isloaded)
            return;
        if (this._lowLayer != null || this._highLayer != null) {
            var isLowLayer = true;
            this._preAnimationlayers.forEach(function (element) {
                if (element.type == AnimationItemType.Target) {
                    isLowLayer = false;
                }
                else {
                    if (isLowLayer) {
                        if (_this._lowLayer)
                            _this._lowLayer.addChild(element);
                    }
                    else {
                        if (_this._highLayer)
                            _this._highLayer.addChild(element);
                    }
                }
            });
        }
        else {
            this._preAnimationlayers.forEach(function (v) { return _this.addChild(v); });
        }
    };
    Animation.prototype.removeSelf = function () {
        this.stop();
        this.target = null;
        this._lowLayer = null;
        this._highLayer = null;
        this.updateParent();
        this.particleAni = null;
        this.particleData = null;
        return _super.prototype.removeSelf.call(this);
    };
    Animation.prototype.dispose = function () {
        if (!this.isDisposed) {
            AssetManager.disposeAnimationAsset(this.id);
            this.removeSelf();
        }
        _super.prototype.dispose.call(this, true);
    };
    Animation.prototype.gotoAndPlay = function (frame) {
        if (frame === void 0) { frame = 0; }
        this._currentFrame = frame;
        this._time = frame / this.fps * 1000;
        this._preTime = 0;
        this.play();
    };
    Animation.prototype.play = function (forcePlay) {
        if (forcePlay === void 0) { forcePlay = false; }
        if (!this._isPlaying || forcePlay) {
            this._isPlaying = true;
            this.event(Animation.PLAY_START);
            os.add_ENTERFRAME(this.onEnterFrame, this);
            if (this._currentFrame >= this.totalFrame - 1) {
                this._currentFrame = 0;
                this._time = 0;
                this._preTime = 0;
            }
            if (this.isParticle) {
                os.remove_ENTERFRAME(this.onEnterFrame, this);
                if (!this.particleData || !this.particleData.textureName || !this.particleAni)
                    return;
                if (!this.particleAni.displayedInStage)
                    this.addChild(this.particleAni);
                this.particleAni.emitter.start();
                this.particleAni.play();
            }
        }
    };
    Animation.prototype.stop = function (frame) {
        if (frame === void 0) { frame = 0; }
        if (this._isPlaying) {
            this._isPlaying = false;
            this.event(Animation.PLAY_STOP);
            os.remove_ENTERFRAME(this.onEnterFrame, this);
            if (!this.particleAni)
                return;
            this.particleAni.emitter.stop();
            this.particleAni.stop();
        }
        if (this.displayedInStage) {
            this.currentFrame = frame;
            var animationAudioLayers = Animation.getAllLayers(this).filter(function (v) { return v instanceof AnimationAudioLayer; });
            animationAudioLayers.forEach(function (v) {
                v.stopAudio();
            });
        }
    };
    Animation.prototype.onEnterFrame = function () {
        if (!this.displayedInStage)
            return;
        if (this._totalFrame <= 0)
            return;
        if (this._preTime) {
            this._time += Date.now() - this._preTime;
            var cycle = this.totalFrame / this.fps;
            this._currentFrame = this._time / 1000 * this.fps;
            if (this.loop) {
                if (this._totalFrame < 2)
                    this._currentFrame = 0;
                else
                    this._currentFrame = this._currentFrame % (this._totalFrame - 1);
            }
            else {
                if (this._currentFrame > this._totalFrame - 1) {
                    this.currentFrame = this._totalFrame - 1;
                    this.stop(this.currentFrame);
                    this.event(Animation.PLAY_COMPLETED);
                }
            }
        }
        this.onRender();
        this._preTime = Date.now();
    };
    Animation.prototype.onRender = function () {
        var _this = this;
        if (!this.displayedInStage)
            return;
        Animation.getChildrenLayers(this).forEach(function (layer) {
            layer.showFrame(_this._currentFrame);
        });
        this.event(Animation.RENDER);
    };
    Animation.prototype.updateTotalFrame = function () {
        var totalFrame = Animation.getAllLayers(this).reduce(function (pv, cv) {
            var v = cv.frames.reduce(function (pv1, cv1) {
                return Math.max(pv1, cv1.index + 1);
            }, 0);
            return Math.max(v, pv);
        }, 0);
        return this._totalFrame = totalFrame;
    };
    Animation.prototype.addAnimationLayer = function (layer, toIndex) {
        if (toIndex === void 0) { toIndex = -1; }
        if (toIndex == -1 || toIndex > this.numChildren)
            this.addChild(layer);
        else
            this.addChildAt(layer, toIndex);
        layer.animation = this;
        layer.showFrame(this.currentFrame);
        this.updateTotalFrame();
    };
    Animation.prototype.toAnimationData = function () {
        var animationData = {};
        animationData.id = this.id;
        if (this.isParticle) {
            animationData.totalFrame = 0;
            animationData.imageSources = [null];
            animationData.layers = [];
            if (this.particleData)
                this.particleData.textureName = this.particleData.textureName.replace("?texture", "");
            animationData.particleData = this.particleData;
        }
        else {
            animationData.totalFrame = this.totalFrame;
            animationData.imageSources = this.imageSources;
            animationData.layers = Animation.getChildrenLayers(this).map(function (v) { return v.toAnimationLayerData(); });
            animationData.particleData = null;
        }
        animationData.isParticle = this.isParticle;
        return animationData;
    };
    Animation.getAllLayers = function (sprite) {
        var childrenLayers = Animation.getChildrenLayers(sprite);
        var layers = [];
        childrenLayers.forEach(function (v) {
            layers.push(v);
            layers = layers.concat(Animation.getAllLayers(v));
        });
        return layers;
    };
    Animation.getChildrenLayers = function (sprite) {
        if (!Config.EDIT_MODE && sprite instanceof Animation) {
            if (sprite._preAnimationlayers)
                return sprite._preAnimationlayers;
        }
        var layers = [];
        for (var i = 0; i < sprite.numChildren; i++) {
            var child = sprite.getChildAt(i);
            if (child instanceof AnimationLayer) {
                layers.push(child);
            }
        }
        return layers;
    };
    Animation.createAnimationLayer = function (layerdata) {
        var cls = AnimationLayer.typeClsMap[layerdata.type];
        var layer = new cls();
        layer.setData(layerdata);
        return layer;
    };
    Animation.RENDER = "RENDER";
    Animation.PLAY_START = "playStart";
    Animation.PLAY_STOP = "playStop";
    Animation.PLAY_COMPLETED = "playCompleted";
    return Animation;
}(GameSprite));





var AnimationLayer = (function (_super) {
    __extends(AnimationLayer, _super);
    function AnimationLayer() {
        _super.call(this);
        this.frames = [];
        this._frameIndex = 0;
        if (Config.EDIT_MODE) {
            this.mouseEnabled = true;
        }
    }
    Object.defineProperty(AnimationLayer.prototype, "animation", {
        get: function () {
            if (!this._animation)
                return this.parent ? this.parent.animation : null;
            return this._animation;
        },
        set: function (v) { this._animation = v; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AnimationLayer.prototype, "isHitEffect", {
        get: function () { return this._isHitEffect; },
        set: function (v) { this._isHitEffect = v; this.updateFrame(); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AnimationLayer.prototype, "frameIndex", {
        get: function () {
            return this._frameIndex;
        },
        enumerable: true,
        configurable: true
    });
    AnimationLayer.prototype.setData = function (data) {
        this.name = data.name;
        this.type = data.type;
        this.frames = data.frames;
        this._isHitEffect = data.isHitEffect;
        for (var i = 0; i < data.children.length; i++) {
            var layerdata = data.children[i];
            var cls = AnimationLayer.typeClsMap[layerdata.type];
            var layer = new cls();
            layer.setData(layerdata);
            this.addChild(layer);
        }
    };
    AnimationLayer.prototype.updateFrame = function () {
        this.showFrame(this._frameIndex);
    };
    AnimationLayer.prototype.showFrame = function (frameIndex) {
        var _this = this;
        if (!this.animation)
            return;
        var isShowLayer = !(!this.animation.showHitEffect && this.isHitEffect);
        isShowLayer = isShowLayer && this.showOnEditor;
        if (!isShowLayer) {
            this.visible = false;
            this._frameIndex = frameIndex;
            return;
        }
        this.visible = true;
        var preFrameIndex = this._frameIndex;
        var animationFrame = this.getFrameData(frameIndex);
        this.fromAnimationFrameData(animationFrame);
        Animation.getChildrenLayers(this).forEach(function (layer) {
            layer.showFrame(frameIndex);
        });
        if (!this.animation.isPlaying)
            return;
        if (this instanceof AnimationDisplayLayer) {
            var frames = this.frames;
            var signalNames = frames.filter(function (f) { return f.signalId && ((preFrameIndex < f.index || _this._frameIndex < preFrameIndex) && f.index <= _this._frameIndex); }).map(function (v) { return v.signalId; });
            signalNames.forEach(function (signalID) {
                if (signalID > 0) {
                    var signalName = GameListData.getName(Game.data.animationSignalList, signalID);
                    console.log("\u6B64\u65F6\u9700\u8981\u629B\u51FA\u4FE1\u53F7 " + signalName);
                }
            });
        }
    };
    AnimationLayer.prototype.getCurrentKeyFrame = function () {
        return this.getKeyFrameData(this.frameIndex);
    };
    AnimationLayer.prototype.getKeyFrameData = function (frameIndex) {
        return this.frames.filter(function (f) { return f.index == frameIndex; })[0];
    };
    AnimationLayer.prototype.getFrameData = function (frameIndex) {
        var frames = this.frames;
        var frame;
        if (frames.length == 0) {
            frame = this.toAnimationFrameData();
            frame.index = frameIndex;
            return frame;
        }
        ;
        if (frameIndex < frames[0].index) {
            frame = ObjectUtils.depthClone(frames[0]);
            frame.index = frameIndex;
            return frame;
        }
        if (frameIndex > frames[frames.length - 1].index) {
            frame = ObjectUtils.depthClone(frames[frames.length - 1]);
            frame.index = frameIndex;
            return frame;
        }
        var frame = frames.filter(function (v) { return v.index == frameIndex; })[0];
        if (frame)
            return frame;
        var result = frames.reduce(function (pv, cv, ci) {
            if (!pv) {
                var pf = frames[ci], nf = frames[ci + 1];
                if (pf.index < frameIndex && frameIndex < nf.index)
                    pv = { pf: pf, nf: nf };
            }
            return pv;
        }, null);
        if (result) {
            frame = this.interpolationFrame(result.pf, result.nf, frameIndex);
        }
        return frame;
    };
    AnimationLayer.prototype.remove = function () {
        var parent = this.parent;
        if (parent) {
            parent.removeChild(this);
        }
    };
    AnimationLayer.prototype.isOnKeyFrame = function () {
        var _this = this;
        var framedata = this.frames.filter(function (v) { return v.index == _this._frameIndex; })[0];
        return !!framedata;
    };
    AnimationLayer.prototype.saveCurrentFrameData = function (canNew) {
        var _this = this;
        if (canNew === void 0) { canNew = false; }
        var framedata = this.frames.filter(function (v) { return v.index == _this._frameIndex; })[0];
        if (framedata) {
            this.toAnimationFrameData(framedata);
        }
        else if (canNew) {
            var newFrameData = this.toAnimationFrameData();
            this.frames.push(newFrameData);
            this.frames.sort(function (a, b) { return a.index - b.index; });
            this.animation && this.animation.updateTotalFrame();
        }
    };
    AnimationLayer.prototype.fromAnimationFrameData = function (framedata) {
        this._frameIndex = framedata.index;
    };
    AnimationLayer.prototype.toAnimationFrameData = function (framedata) {
        framedata = framedata || {};
        framedata.index = this._frameIndex;
        return framedata;
    };
    AnimationLayer.prototype.toAnimationLayerData = function () {
        this.saveCurrentFrameData();
        var data = {
            name: this.name,
            type: this.type,
            children: Animation.getChildrenLayers(this).map(function (v) { return v.toAnimationLayerData(); }),
            frames: this.frames,
            isHitEffect: !!this.isHitEffect
        };
        return data;
    };
    AnimationLayer.prototype.interpolationFrame = function (pf, nf, frameIndex) {
        return { index: frameIndex };
    };
    AnimationLayer.typeClsMap = {};
    return AnimationLayer;
}(GameSprite));





var UIComponent;
(function (UIComponent) {
    var UIBase = (function (_super) {
        __extends(UIBase, _super);
        function UIBase() {
            _super.call(this);
            this.condition = [];
            this.hasCommand = [];
            this._needLoad = true;
            this.modifyWidthHeightEnabled = true;
            this.mouseEventEnabledData = true;
            this.id = ObjectUtils.getRandID();
            this.className = "UIBase";
            this.mouseEventEnabled = true;
            if (!Config.EDIT_MODE) {
                this.onConditionCheckCB = new Callback(this.onConditionCheck, this);
                this.add_DISPLAY(this.initCondition, this, [true]);
                this.add_UNDISPLAY(this.initCondition, this, [false]);
            }
        }
        UIBase.prototype.dispose = function (disposeChild) {
            if (disposeChild === void 0) { disposeChild = false; }
            if (!this.isDisposed) {
                this.initCondition(false);
            }
            _super.prototype.dispose.call(this, disposeChild);
        };
        UIBase.prototype.constructorInit = function (uiID, syncLoadedEventWhenAssetExist) {
            if (syncLoadedEventWhenAssetExist === void 0) { syncLoadedEventWhenAssetExist = false; }
            this._syncLoadedEventWhenAssetExist = syncLoadedEventWhenAssetExist;
            this._commondID = uiID + "_" + this.id;
            if (!Config.EDIT_MODE) {
                EventUtils.happen(UIBase, UIBase.EVENT_COMPONENT_CONSTRUCTOR_INIT, [this]);
            }
        };
        UIBase.prototype.loadAssetTest = function () {
        };
        UIBase.prototype.initCondition = function (isListen) {
            if (this.condition.length != 0) {
                for (var i = 0; i < this.condition.length; i++) {
                    var condition = this.condition[i];
                    var type = condition.type == 0 ? 1 : 0;
                    if (isListen) {
                        Game.player.addListenerPlayerVariable(type, condition.varID, this.onConditionCheckCB);
                    }
                    else
                        Game.player.removeListenerPlayerVariable(type, condition.varID, this.onConditionCheckCB);
                }
                if (isListen && this.firstConditionCheckCount == null) {
                    this.firstConditionCheckCount = this.condition.length;
                }
            }
        };
        UIBase.prototype.onConditionCheck = function () {
            var visible = true;
            for (var i = 0; i < this.condition.length; i++) {
                var condition = this.condition[i];
                var bool = true;
                if (condition.type == 0) {
                    bool = Game.player.variable.getSwitch(condition.varID) == 1;
                }
                else {
                    var varValue = Game.player.variable.getVariable(condition.varID);
                    if ((condition.compare == 0 && varValue !== condition.value) ||
                        (condition.compare == 1 && varValue < condition.value) ||
                        (condition.compare == 2 && varValue <= condition.value) ||
                        (condition.compare == 3 && varValue > condition.value) ||
                        (condition.compare == 4 && varValue >= condition.value) ||
                        (condition.compare == 5 && varValue === condition.value)) {
                        bool = false;
                    }
                }
                if (!bool) {
                    visible = false;
                    break;
                }
            }
            if (this.firstConditionCheckCount > 0) {
                this.firstConditionCheckCount--;
            }
            if (this.firstConditionCheckCount == 0) {
                this.visible = visible;
            }
        };
        UIBase.prototype.inEditorInit = function () {
        };
        UIBase.prototype.inEditorInfo = function () {
            return "";
        };
        UIBase.prototype.inEditorCurrentOperactionLayer = function (isInCurrentLayer) {
            this._isInCurrentLayer = isInCurrentLayer;
        };
        UIBase.prototype.inEditorDatabase = function () {
        };
        UIBase.EVENT_COMPONENT_CONSTRUCTOR_INIT = "UIBase_EVENT_COMPONENT_CONSTRUCTOR_INIT";
        return UIBase;
    }(GameSprite));
    UIComponent.UIBase = UIBase;
})(UIComponent || (UIComponent = {}));





var UIComponent;
(function (UIComponent) {
    var UIBitmap = (function (_super) {
        __extends(UIBitmap, _super);
        function UIBitmap() {
            var _this = this;
            _super.call(this);
            this._image = "";
            this._grid9 = "";
            this._uiImage = new UIImage();
            this.addChild(this._uiImage);
            this.className = "UIBitmap";
            this.on(EventObject.RESIZE, this, this.onResize);
            if (!Config.EDIT_MODE) {
                this._onVarChange = Callback.New(function (typeID, varID, value) {
                    _this.onImageChange(value);
                }, this);
                this.add_DISPLAY(this.onAdded, this);
                this.add_UNDISPLAY(this.onRemoved, this);
            }
        }
        UIBitmap.prototype.loadAssetTest = function () {
            var _this = this;
            var varID = GameUtils.getVarID(this.image);
            if (varID != 0) {
                if (!ClientMain.conn || !ClientMain.conn.isConnect) {
                    this.event(GameUI.EVENT_TEST_LOAD_CHILD_UI);
                    return;
                }
                var cb;
                Game.player.addListenerPlayerVariable(2, varID, cb = Callback.New(function (typeID, varID, value) {
                    doLoadAssetTest.apply(_this, [value]);
                    setTimeout(function () {
                        Game.player.removeListenerPlayerVariable(2, varID, cb);
                    }, 5000);
                }, this), true);
                return;
            }
            function doLoadAssetTest(imageURL) {
                AssetManager.loadImages([imageURL], Callback.New(function () {
                    this.event(GameUI.EVENT_TEST_LOAD_CHILD_UI);
                }, this), this._syncLoadedEventWhenAssetExist, false);
            }
            doLoadAssetTest.apply(this, [this.image]);
        };
        UIBitmap.prototype.dispose = function () {
            if (!this.isDisposed) {
                AssetManager.disposeImages([this._uiImage.skin]);
            }
            _super.prototype.dispose.call(this);
        };
        UIBitmap.prototype.inEditorInit = function () {
            this.width = 338;
            this.height = 379;
            this.image = Editor.URL_UNKNOW_IMAGE;
        };
        Object.defineProperty(UIBitmap.prototype, "_source", {
            get: function () {
                var varID = GameUtils.getVarID(this.image);
                if (varID != 0)
                    return null;
                return AssetManager.getImage(this.image);
            },
            enumerable: true,
            configurable: true
        });
        UIBitmap.prototype.onResize = function () {
            this.onImageChange(this._image);
        };
        UIBitmap.prototype.inEditorInfo = function () {
            var varID = GameUtils.getVarID(this.image);
            if (this._source) {
                return "图片原始尺寸：" + this._source.width + "," + this._source.height + " " + this.mouseEnabled;
            }
            return varID != 0 ? "\u5B57\u7B26\u4E32\u53D8\u91CF\u3010" + MathUtils.fixIntDigit(varID.toString()) + "-" + GameListData.getName(Game.data.playerStringNameList, varID) + "\u3011" : "";
        };
        Object.defineProperty(UIBitmap.prototype, "image", {
            get: function () {
                return this._image;
            },
            set: function (v) {
                this._texture = null;
                if (!Config.EDIT_MODE) {
                    var lastVarID = GameUtils.getVarID(this._image);
                    if (lastVarID != 0)
                        Game.player.removeListenerPlayerVariable(2, lastVarID, this._onVarChange);
                }
                var lastImage = v;
                this._image = v;
                if (!Config.EDIT_MODE) {
                    var varID = GameUtils.getVarID(this._image);
                    if (this.displayedInStage && varID != 0)
                        Game.player.addListenerPlayerVariable(2, varID, this._onVarChange);
                }
                this.onImageChange(v);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UIBitmap.prototype, "grid9", {
            get: function () {
                return this._grid9;
            },
            set: function (v) {
                this._grid9 = this._uiImage.sizeGrid = v;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UIBitmap.prototype, "texture", {
            get: function () {
                return this._uiImage.texture;
            },
            set: function (v) {
                this._uiImage.texture = this._texture = v;
            },
            enumerable: true,
            configurable: true
        });
        UIBitmap.prototype.onAdded = function (e) {
            var varID = GameUtils.getVarID(this.image);
            if (varID != 0) {
                Game.player.addListenerPlayerVariable(2, varID, this._onVarChange);
            }
        };
        UIBitmap.prototype.onRemoved = function (e) {
            var varID = GameUtils.getVarID(this.image);
            if (varID != 0) {
                Game.player.removeListenerPlayerVariable(2, varID, this._onVarChange);
            }
        };
        UIBitmap.prototype.onImageChange = function (v, changeImage) {
            var _this = this;
            if (changeImage === void 0) { changeImage = false; }
            if (this.isDisposed || this._texture)
                return;
            var varID = GameUtils.getVarID(v);
            this._uiImage.width = this.width;
            this._uiImage.height = this.height;
            if (Config.EDIT_MODE) {
                if (varID != 0) {
                    v = "asset/editor/image/uibitmap.png";
                }
            }
            else {
                if (varID != 0)
                    return;
            }
            if (v != this._uiImage.skin) {
                AssetManager.disposeImage(this._uiImage.skin);
                AssetManager.loadImage(v, Callback.New(function (tex) {
                    if (_this.width == 0 && _this.height == 0) {
                        _this.width = tex.width;
                        _this.height = tex.height;
                    }
                    _this._uiImage.texture = tex;
                    _this.event(EventObject.LOADED);
                }, this), true);
            }
            this._uiImage.skin = v;
        };
        return UIBitmap;
    }(UIComponent.UIBase));
    UIComponent.UIBitmap = UIBitmap;
})(UIComponent || (UIComponent = {}));





var UIComponent;
(function (UIComponent) {
    var UIButton = (function (_super) {
        __extends(UIButton, _super);
        function UIButton() {
            _super.call(this);
            this._image1 = "";
            this._image2 = "";
            this._image3 = "";
            this._grid9 = "";
            this._state = 1;
            this._image = new UIImage();
            this.addChild(this._image);
            this.className = "UIButton";
            this.add_MOUSEOVER(this.onmouseover, this);
            this.add_MOUSEOUT(this.onmouseout, this);
            this.add_MOUSEDOWN(this.onmousedown, this);
            this.add_MOUSEUP(this.onmouseup, this);
            this.on(EventObject.RESIZE, this, this.onResize);
        }
        Object.defineProperty(UIButton.prototype, "image1", {
            get: function () {
                return this._image1;
            },
            set: function (v) {
                AssetManager.disposeImage(this._image1);
                this._image1 = v;
                AssetManager.loadImage(v);
                this.onImageChange(v);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UIButton.prototype, "image2", {
            get: function () {
                return this._image2;
            },
            set: function (v) {
                AssetManager.disposeImage(this._image2);
                this._image2 = v;
                AssetManager.loadImage(v);
                this.onImageChange(v);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UIButton.prototype, "image3", {
            get: function () {
                return this._image3;
            },
            set: function (v) {
                AssetManager.disposeImage(this._image3);
                this._image3 = v;
                AssetManager.loadImage(v);
                this.onImageChange(v);
            },
            enumerable: true,
            configurable: true
        });
        UIButton.prototype.inEditorInit = function () {
            this.width = 272;
            this.height = 32;
            this.image1 = "asset/editor/image/btn1.png";
            this.image2 = "asset/editor/image/btn2.png";
            this.image3 = "asset/editor/image/btn3.png";
        };
        UIButton.prototype.onImageChange = function (v) {
            this.setState(this._state);
        };
        UIButton.prototype.clearMouseEvent = function () {
            this.remove_MOUSEOVER(this.onmouseover, this);
            this.remove_MOUSEOUT(this.onmouseout, this);
            this.remove_MOUSEDOWN(this.onmousedown, this);
            this.remove_MOUSEUP(this.onmouseup, this);
        };
        UIButton.prototype.loadAssetTest = function () {
            var _this = this;
            AssetManager.loadImages([this.image1, this.image2, this.image3], Callback.New(function () {
                _this.event(GameUI.EVENT_TEST_LOAD_CHILD_UI);
            }, this), this._syncLoadedEventWhenAssetExist, false);
        };
        UIButton.prototype.dispose = function () {
            if (!this.isDisposed) {
                AssetManager.disposeImages([this.image1, this.image2, this.image3]);
            }
            _super.prototype.dispose.call(this, true);
        };
        Object.defineProperty(UIButton.prototype, "grid9", {
            get: function () {
                return this._grid9;
            },
            set: function (v) {
                this._grid9 = this._image.sizeGrid = v;
            },
            enumerable: true,
            configurable: true
        });
        UIButton.prototype.onmouseover = function (e) {
            if (e.target == this)
                this.setState(2);
        };
        UIButton.prototype.onmouseout = function (e) {
            if (e.target == this)
                this.setState(1);
        };
        UIButton.prototype.onmousedown = function (e) {
            if (e.target == this)
                this.setState(3);
        };
        UIButton.prototype.onmouseup = function (e) {
            if (e.target == this)
                this.setState(2);
        };
        UIButton.prototype.onResize = function () {
            this.setState(this._state);
        };
        UIButton.prototype.setState = function (state) {
            this._state = state;
            this.graphics.clear();
            var url = this["image" + this._state];
            if (url) {
                this._image.skin = url;
                this._image.width = this.width;
                this._image.height = this.height;
            }
        };
        return UIButton;
    }(UIComponent.UIBase));
    UIComponent.UIButton = UIButton;
})(UIComponent || (UIComponent = {}));





var UIComponent;
(function (UIComponent) {
    var UICheckBox = (function (_super) {
        __extends(UICheckBox, _super);
        function UICheckBox() {
            _super.call(this);
            this._grid9 = "";
            this._image = new UIImage();
            this.addChild(this._image);
            this.className = "UICheckBox";
            this.on(EventObject.RESIZE, this, this.refresh);
            if (!Config.EDIT_MODE) {
                this.add_CLICK(function () {
                    this.selected = !this.selected;
                }, this);
            }
        }
        UICheckBox.prototype.inEditorInit = function () {
            this.width = 14;
            this.height = 14;
            this.image1 = "asset/editor/image/checkBox1.png";
            this.image2 = "asset/editor/image/checkBox2.png";
        };
        UICheckBox.prototype.loadAssetTest = function () {
            AssetManager.loadImages([this.image1, this.image2], Callback.New(function () {
                this.event(GameUI.EVENT_TEST_LOAD_CHILD_UI);
            }, this), this._syncLoadedEventWhenAssetExist, false);
        };
        UICheckBox.prototype.dispose = function () {
            if (!this.isDisposed) {
                AssetManager.disposeImages([this.image1, this.image2]);
            }
            _super.prototype.dispose.call(this);
        };
        Object.defineProperty(UICheckBox.prototype, "image1", {
            get: function () {
                return this._image1;
            },
            set: function (v) {
                trace("---------sf");
                AssetManager.disposeImage(this._image1);
                this._image1 = v;
                trace("+++++++++sf", v);
                AssetManager.loadImage(v);
                this.refresh();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UICheckBox.prototype, "image2", {
            get: function () {
                return this._image2;
            },
            set: function (v) {
                AssetManager.disposeImage(this._image2);
                this._image2 = v;
                AssetManager.loadImage(v);
                this.refresh();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UICheckBox.prototype, "selected", {
            get: function () {
                return this._selected;
            },
            set: function (v) {
                if (v != this._selected) {
                    this._selected = v;
                    this.refresh();
                    this.event(EventObject.CHANGE);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UICheckBox.prototype, "grid9", {
            get: function () {
                return this._grid9;
            },
            set: function (v) {
                this._grid9 = this._image.sizeGrid = v;
            },
            enumerable: true,
            configurable: true
        });
        UICheckBox.prototype.refresh = function () {
            this.graphics.clear();
            var url = this._selected ? this.image2 : this.image1;
            if (url) {
                this._image.skin = url;
                this._image.width = this.width;
                this._image.height = this.height;
            }
        };
        return UICheckBox;
    }(UIComponent.UIBase));
    UIComponent.UICheckBox = UICheckBox;
})(UIComponent || (UIComponent = {}));





var UIComponent;
(function (UIComponent) {
    var UIGUI = (function (_super) {
        __extends(UIGUI, _super);
        function UIGUI() {
            _super.call(this);
            this._guiID = 0;
            this._root = new Sprite();
            this._instanceClassName = "";
            this.addChild(this._root);
            this.className = "UIGUI";
            this.modifyWidthHeightEnabled = false;
            this._lastRect = this.getSelfBounds().clone();
        }
        UIGUI.prototype.inEditorInit = function () {
            this.clear(0);
        };
        UIGUI.prototype.loadAssetTest = function () {
            if (Config.EDIT_MODE) {
                Callback.New(checkUIRoot, this).delayRun(0);
            }
            else {
                checkUIRoot.call(this);
            }
            function checkUIRoot() {
                if (this._ui) {
                    this._ui.once(EventObject.LOADED, this, this.event, [EventObject.LOADED]);
                    this._ui["loadAssetTest"](true);
                }
                else {
                    this.event(EventObject.LOADED);
                }
            }
        };
        Object.defineProperty(UIGUI.prototype, "guiID", {
            get: function () {
                return this._guiID;
            },
            set: function (v) {
                if (this._guiID != v) {
                    this.loadGUI(v);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UIGUI.prototype, "instanceClassName", {
            get: function () {
                return this._instanceClassName;
            },
            set: function (v) {
                this._instanceClassName = v;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UIGUI.prototype, "root", {
            get: function () {
                return this._ui;
            },
            enumerable: true,
            configurable: true
        });
        UIGUI.prototype.loadGUI = function (guiID) {
            this._guiID = guiID;
            this.clear(guiID);
            if (guiID == 0)
                return;
            if (Config.EDIT_MODE) {
                Callback.New(function () {
                    var _this = this;
                    if (this.isDeepLoop(this._guiID)) {
                        AlertUtils.alert("不允许循环嵌套!");
                        var p = this.parent;
                        while (p) {
                            if (p instanceof UIGUI) {
                                p.guiID = 0;
                            }
                            p = p.parent;
                        }
                        this.loadGUI(0);
                        return;
                    }
                    var uiData = Common.uiList.data[guiID];
                    if (!uiData) {
                        return;
                    }
                    this._ui = GameUI.parse(uiData.uiDisplayData);
                    this._ui.once(EventObject.LOADED, this, function () {
                        _this.event(GameUI.EVENT_TEST_LOAD_CHILD_UI);
                    });
                    this._root.addChild(this._ui);
                    EUIRoot.dataBaseWindow.win6.off(EUIWindowUI.EVENT_GUI_DATA_SYNC_COMPLETE, this, this.onGUIDataChange);
                    EUIRoot.dataBaseWindow.win6.once(EUIWindowUI.EVENT_GUI_DATA_SYNC_COMPLETE, this, this.onGUIDataChange);
                }, this).delayRun(0);
            }
            else {
                var ui = GameUI.load(guiID, true);
                this._root.addChild(ui);
                this._ui = ui;
                this.event(EventObject.LOADED);
            }
        };
        UIGUI.prototype.onGUIDataChange = function () {
            this.loadGUI(this.guiID);
        };
        UIGUI.prototype.isDeepLoop = function (guiID) {
            var p = this.parent;
            while (p) {
                if (p instanceof UIGUI) {
                    if (p.guiID == guiID)
                        return true;
                }
                if (p instanceof UIComponent.UIRoot) {
                    if (p.guiID == guiID)
                        return true;
                }
                p = p.parent;
            }
            return false;
        };
        UIGUI.prototype.clear = function (guiID) {
            this.graphics.clear();
            this._root.removeChildren();
            if (!guiID) {
                this._lastRect = new Rectangle;
                this.graphics.drawRect(0, 0, 100, 100, "#000000");
                this.width = 100;
                this.height = 100;
                this.event(EventObject.LOADED);
            }
            else {
                this.width = 0;
                this.height = 0;
            }
        };
        UIGUI.prototype.onEditorCheckLoaded = function () {
            var rect = this.getSelfBounds();
            if (!rect.equals(this._lastRect)) {
                this._lastRect = rect.clone();
                this.hitArea = rect;
                os.remove_ENTERFRAME(this.onEditorCheckLoaded, this);
                this.event(EventObject.LOADED);
            }
        };
        return UIGUI;
    }(UIComponent.UIBase));
    UIComponent.UIGUI = UIGUI;
})(UIComponent || (UIComponent = {}));





var UIComponent;
(function (UIComponent) {
    var UIRoot = (function (_super) {
        __extends(UIRoot, _super);
        function UIRoot(isRoot, guiID) {
            if (isRoot === void 0) { isRoot = false; }
            if (guiID === void 0) { guiID = null; }
            _super.call(this);
            this._myScrollRect = new Rectangle(0, 0, 0, 0);
            this._scrollShowType = 1;
            this._scrollWidth = 17;
            this.guiID = guiID;
            this._isRoot = isRoot;
            this.className = "UIRoot";
            this._vScrollBar = new VScrollBar();
            this._hScrollBar = new HScrollBar();
            this._vScrollBar.showButtons = false;
            this._hScrollBar.showButtons = false;
            if (Config.EDIT_MODE) {
                this.width = this._contentWidth = 100;
                this.height = this._contentHeight = 100;
            }
            this._vScrollBar.max = 100;
            this._vScrollBar.min = 0;
            this._hScrollBar.max = 100;
            this._hScrollBar.min = 0;
            this.on(EventObject.MOUSE_WHEEL, this, this.onMouseWheel);
            this.on(EventObject.RESIZE, this, this.onResize);
            this._vScrollBar.add_CHANGE(this.onScrollBarChange, this);
            this._hScrollBar.add_CHANGE(this.onScrollBarChange, this);
            if (Config.EDIT_MODE) {
                this._vScrollBar.mouseEnabled = this._hScrollBar.mouseEnabled = false;
            }
            this.onResize();
        }
        UIRoot.prototype.inEditorInit = function () {
        };
        UIRoot.prototype.inEditorCurrentOperactionLayer = function (isInCurrentLayer) {
            _super.prototype.inEditorCurrentOperactionLayer.call(this, isInCurrentLayer);
            this.enabledLimitView = this.enabledLimitView;
        };
        Object.defineProperty(UIRoot.prototype, "enabledLimitView", {
            get: function () {
                return this._enabledLimitView;
            },
            set: function (v) {
                this._enabledLimitView = v;
                this.scrollRect = (v && (!Config.EDIT_MODE || (Config.EDIT_MODE && this._isInCurrentLayer))) ? this._myScrollRect : null;
                if (v) {
                    this.addChild(this._vScrollBar);
                    this.addChild(this._hScrollBar);
                    this.refresh();
                }
                else {
                    this.removeChild(this._vScrollBar);
                    this.removeChild(this._hScrollBar);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UIRoot.prototype, "scrollShowType", {
            get: function () {
                return this._scrollShowType;
            },
            set: function (v) {
                this._scrollShowType = v;
                this.refresh();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UIRoot.prototype, "scrollWidth", {
            get: function () {
                return this._scrollWidth;
            },
            set: function (v) {
                this._scrollWidth = v;
                this.vScrollBar = this.vScrollBar;
                this.hScrollBar = this.hScrollBar;
                this.vScrollBg = this.vScrollBg;
                this.hScrollBg = this.hScrollBg;
                this.refreshScrollPos();
                this.onResize();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UIRoot.prototype, "vScrollBg", {
            get: function () {
                return this._vScroollBarImage1;
            },
            set: function (v) {
                AssetManager.disposeImage(this._vScroollBarImage1);
                AssetManager.loadImage(v);
                this._vScroollBarImage1 = v;
                this._vScrollBar.slider["_bg"].skin = v;
                this._vScrollBar.slider["_bg"].width = this._scrollWidth;
                this._vScrollBar.slider["setBarPoint"]();
                this._vScrollBar.slider["callLater"](this._vScrollBar.slider["changeValue"]);
                this.refreshScrollPos();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UIRoot.prototype, "vScrollBar", {
            get: function () {
                return this._vScroollBarImage2;
            },
            set: function (v) {
                AssetManager.disposeImage(this._vScroollBarImage2);
                this._vScroollBarImage2 = v;
                AssetManager.loadImage(v, Callback.New(this.setVScrollBarSkin, this, [v]), true);
            },
            enumerable: true,
            configurable: true
        });
        UIRoot.prototype.setVScrollBarSkin = function (v) {
            if (!this._vScrollBar.slider)
                return;
            this._vScrollBar.slider.bar.skin = v;
            this._vScrollBar.slider.bar.width = this._scrollWidth;
            this._vScrollBar.slider["setBarPoint"]();
            this._vScrollBar.slider["callLater"](this._vScrollBar.slider["changeValue"]);
            this.refreshScrollPos();
            this.onResize();
        };
        Object.defineProperty(UIRoot.prototype, "hScrollBg", {
            get: function () {
                return this._hScroollBarImage1;
            },
            set: function (v) {
                AssetManager.disposeImage(this._hScroollBarImage1);
                AssetManager.loadImage(v);
                this._hScroollBarImage1 = v;
                this._hScrollBar.slider["_bg"].skin = v;
                this._hScrollBar.slider["_bg"].height = this._scrollWidth;
                this._hScrollBar.slider["setBarPoint"]();
                this._hScrollBar.slider["callLater"](this._hScrollBar.slider["changeValue"]);
                this.refreshScrollPos();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UIRoot.prototype, "hScrollBar", {
            get: function () {
                return this._hScroollBarImage2;
            },
            set: function (v) {
                AssetManager.disposeImage(this._hScroollBarImage2);
                this._hScroollBarImage2 = v;
                AssetManager.loadImage(v, Callback.New(this.setHScrollBarSkin, this, [v]), true);
            },
            enumerable: true,
            configurable: true
        });
        UIRoot.prototype.setHScrollBarSkin = function (v) {
            if (!this._hScrollBar.slider)
                return;
            this._hScrollBar.slider.bar.skin = v;
            this._hScrollBar.slider.bar.height = this._scrollWidth;
            this._hScrollBar.slider["setBarPoint"]();
            this._hScrollBar.slider["callLater"](this._hScrollBar.slider["changeValue"]);
            this.refreshScrollPos();
            this.onResize();
        };
        UIRoot.prototype.calcTotalContentSize = function () {
            var maxH = 0, maxW = 0;
            for (var i = this.numChildren - 1; i > -1; i--) {
                var comp = this.getChildAt(i);
                if (comp == this._vScrollBar || comp == this._hScrollBar)
                    continue;
                var compRect = comp.getBounds();
                if (compRect.isEmpty()) {
                    compRect = new Rectangle(comp.x, comp.y, comp.width ? comp.width : 0, comp.height ? comp.height : 0);
                }
                maxH = Math.max(compRect.bottom, maxH, 1);
                maxW = Math.max(compRect.right, maxW, 1);
            }
            return { maxW: maxW, maxH: maxH };
        };
        UIRoot.prototype.refresh = function () {
            if (this._enabledLimitView) {
                var lastVPer = this._vScrollBar.thumbPercent;
                var c = this.calcTotalContentSize();
                var maxH = c.maxH, maxW = c.maxW;
                if (this.scrollShowType == 0) {
                    this._vScrollBar.visible = this._hScrollBar.visible = false;
                }
                else if (this.scrollShowType == 1) {
                    this._vScrollBar.visible = this._hScrollBar.visible = true;
                    maxH += this._scrollWidth;
                    maxW += this._scrollWidth;
                }
                else {
                    this._vScrollBar.visible = (this.height / maxH) < 1;
                    this._hScrollBar.visible = (this.width / maxW) < 1;
                    if (this._vScrollBar.visible)
                        maxW += this._scrollWidth;
                    if (this._hScrollBar.visible)
                        maxH += this._scrollWidth;
                }
                this._vScrollBar.thumbPercent = maxH == 0 ? 1 : Math.min(this.height / maxH, 1);
                this._hScrollBar.thumbPercent = maxW == 0 ? 1 : Math.min(this.width / maxW, 1);
                this._hScrollBar.disabled = this.width >= maxW;
                this._vScrollBar.disabled = this.height >= maxH;
                this._contentWidth = maxW;
                this._contentHeight = maxH;
                var dV = this._vScrollBar.thumbPercent / lastVPer;
                this._vScrollBar.value = this._vScrollBar.value * dV;
                if (!this._vScrollBar.visible) {
                    this._vScrollBar.value = 0;
                }
            }
            this._myScrollRect.width = this.width;
            this._myScrollRect.height = this.height;
            this._vScrollBar.height = this.height;
            this._hScrollBar.width = this.width - (this._vScrollBar.displayedInStage && this._vScrollBar.visible ? this._vScrollBar.width : 0);
        };
        UIRoot.prototype.refreshScrollPos = function () {
            this._vScrollBar.x = this.width - this._vScrollBar.width + this._myScrollRect.x;
            this._vScrollBar.y = this._myScrollRect.y;
            this._hScrollBar.y = this.height - this._hScrollBar.height + this._myScrollRect.y;
            this._hScrollBar.x = this._myScrollRect.x;
        };
        UIRoot.prototype.onResize = function () {
            this.refresh();
            this.refreshScrollPos();
            this.enabledLimitView = this.enabledLimitView;
        };
        UIRoot.prototype.onMouseWheel = function (e) {
            if (Config.EDIT_MODE || !this._enabledLimitView)
                return;
            if (!this._contentHeight || !this._contentWidth)
                return;
            var float = e.delta < 0 ? -1 : 1;
            if (ClientMain.shiftKey) {
                if (this._hScrollBar.disabled || (!this._hScrollBar.visible && this.scrollShowType == 1))
                    return;
                var px = Math.max(this._contentWidth * 0.01 * Math.abs(e.delta), 10);
                var per = Math.max(px * 100 / this._contentWidth, 1);
                this._hScrollBar.value -= per * float;
            }
            else {
                if (this._vScrollBar.disabled || !this._vScrollBar.visible && this.scrollShowType == 1)
                    return;
                var px = Math.max(this._contentHeight * 0.01 * Math.abs(e.delta), 10);
                var per = Math.max(px * 100 / this._contentHeight, 1);
                this._vScrollBar.value -= per * float;
            }
        };
        UIRoot.prototype.onScrollBarChange = function (e) {
            if (Config.EDIT_MODE)
                return;
            this._myScrollRect.y = MathUtils.float(this._vScrollBar.value / 100 * (this._contentHeight - this.height));
            this._myScrollRect.x = MathUtils.float(this._hScrollBar.value / 100 * (this._contentWidth - this.width));
            this.refreshScrollPos();
        };
        UIRoot.prototype.addChild = function (node) {
            var node = _super.prototype.addChild.call(this, node);
            this.refreshAddchild();
            return node;
        };
        ;
        UIRoot.prototype.addChildren = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            _super.prototype.addChildren.apply(this, args);
            this.refreshAddchild();
        };
        ;
        UIRoot.prototype.addChildAt = function (node, index) {
            var node = _super.prototype.addChildAt.call(this, node, index);
            this.refreshAddchild();
            return node;
        };
        ;
        UIRoot.prototype.refreshAddchild = function () {
            if (this._enabledLimitView) {
                _super.prototype.addChild.call(this, this._vScrollBar);
                _super.prototype.addChild.call(this, this._hScrollBar);
            }
            Callback.CallLater(this.refresh, this);
        };
        UIRoot.prototype.constructorInit = function (uiID, syncLoadedEventWhenAssetExist) {
            if (syncLoadedEventWhenAssetExist === void 0) { syncLoadedEventWhenAssetExist = false; }
            _super.prototype.constructorInit.apply(this, arguments);
            this.loadAssetTest();
        };
        UIRoot.prototype.loadAssetTest = function (checkAllChildren) {
            if (checkAllChildren === void 0) { checkAllChildren = false; }
            var mySkins = [this._vScroollBarImage1, this._vScroollBarImage2, this._hScroollBarImage1, this._hScroollBarImage2];
            if (this._isRoot || checkAllChildren) {
                var uiRoots = [];
                function onLoadedCheck(ui) {
                    count--;
                    if (count == 0) {
                        setTimeout(function (uiRoots) {
                            for (var i in uiRoots) {
                                var ro = uiRoots[i];
                                if (ro.stage) {
                                    ro.refresh();
                                }
                            }
                        }, 0, uiRoots);
                        this.event(EventObject.LOADED);
                    }
                }
                var uiArr = this.getAllUIChildren();
                var count = uiArr.length;
                for (var s in uiArr) {
                    var ui = uiArr[s];
                    ui.once(GameUI.EVENT_TEST_LOAD_CHILD_UI, this, onLoadedCheck, [ui]);
                    if (ui instanceof UIComponent.UIRoot) {
                        ui.loadSelfAssetTest();
                        uiRoots.push(ui);
                    }
                    else {
                        ui["loadAssetTest"]();
                    }
                }
            }
        };
        UIRoot.prototype.loadSelfAssetTest = function () {
            var mySkins = [this._vScroollBarImage1, this._vScroollBarImage2, this._hScroollBarImage1, this._hScroollBarImage2];
            AssetManager.loadImages(mySkins, Callback.New(function () {
                this.event(GameUI.EVENT_TEST_LOAD_CHILD_UI);
            }, this), this._syncLoadedEventWhenAssetExist, false);
        };
        UIRoot.prototype.disposeSelfAsset = function () {
            var mySkins = [this._vScroollBarImage1, this._vScroollBarImage2, this._hScroollBarImage1, this._hScroollBarImage2];
            AssetManager.disposeImages(mySkins);
        };
        UIRoot.prototype.getAllUIChildren = function () {
            var allChildren = ArrayUtils.getTreeNodeArray(this, "_childs");
            var uiArr = [];
            for (var i = 0; i < allChildren.length; i++) {
                var ui = allChildren[i];
                if (ui instanceof UIComponent.UIBase && ui["_needLoad"]) {
                    uiArr.push(ui);
                }
            }
            return uiArr;
        };
        UIRoot.prototype.dispose = function () {
            if (!this.isDisposed) {
                if (this._isRoot && GameUI.get(this.guiID) == this) { }
                else {
                    var uiArr = this.getAllUIChildren();
                    for (var s in uiArr) {
                        var ui = uiArr[s];
                        if (ui instanceof UIComponent.UIRoot) {
                            ui.disposeSelfAsset();
                        }
                        else {
                            ui.dispose();
                        }
                    }
                }
            }
            _super.prototype.dispose.call(this, true);
        };
        return UIRoot;
    }(UIComponent.UIBase));
    UIComponent.UIRoot = UIRoot;
})(UIComponent || (UIComponent = {}));





var UIComponent;
(function (UIComponent) {
    var UISlider = (function (_super) {
        __extends(UISlider, _super);
        function UISlider() {
            _super.call(this);
            this._image1 = "";
            this._image2 = "";
            this._bgImg = new UIImage();
            this._blockImg = new UIImage();
            this._grid9 = "";
            this._bgGrid9 = "";
            this.addChild(this._bgImg);
            this._bgImg.addChild(this._blockImg);
            this.className = "UISlider";
            this.add_MOUSEOVER(this.onmouseover, this);
            this.add_MOUSEOUT(this.onmouseout, this);
            this.on(EventObject.RESIZE, this, this.refreshSize);
            if (!Config.EDIT_MODE) {
                this._blockImg.add_MOUSEDOWN(this.onMouseDown, this);
            }
        }
        UISlider.prototype.inEditorInit = function () {
            this.min = 0;
            this.max = 100;
            this.value = 50;
            this.step = 1;
            this.width = 272;
            this.height = 32;
            this.transverseMode = true;
            this.image1 = "asset/editor/image/btn1.png";
            this.image2 = "asset/editor/image/empty.png";
        };
        UISlider.prototype.loadAssetTest = function () {
            AssetManager.loadImages([this.image1, this.image2], Callback.New(function () {
                this.event(GameUI.EVENT_TEST_LOAD_CHILD_UI);
            }, this), this._syncLoadedEventWhenAssetExist, false);
        };
        UISlider.prototype.dispose = function () {
            if (!this.isDisposed) {
                AssetManager.disposeImages([this.image1, this.image2]);
            }
            _super.prototype.dispose.call(this);
        };
        Object.defineProperty(UISlider.prototype, "image1", {
            get: function () {
                return this._image1;
            },
            set: function (v) {
                AssetManager.disposeImage(this._image1);
                this._image1 = v;
                AssetManager.loadImage(v, Callback.New(this.refresh, this), true);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UISlider.prototype, "image2", {
            get: function () {
                return this._image2;
            },
            set: function (v) {
                AssetManager.disposeImage(this._image2);
                this._image2 = v;
                AssetManager.loadImage(v, Callback.New(this.refresh, this), true);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UISlider.prototype, "blockFillMode", {
            get: function () {
                return this._blockFillMode;
            },
            set: function (v) {
                this._blockFillMode = v;
                this.refreshSize();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UISlider.prototype, "transverseMode", {
            get: function () {
                return this._transverseMode;
            },
            set: function (v) {
                this._transverseMode = v;
                this.refreshSize();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UISlider.prototype, "min", {
            get: function () {
                return this._min;
            },
            set: function (v) {
                this._min = v;
                this.refreshSize();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UISlider.prototype, "max", {
            get: function () {
                return this._max;
            },
            set: function (v) {
                this._max = v;
                this.refreshSize();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UISlider.prototype, "value", {
            get: function () {
                return this._value;
            },
            set: function (v) {
                if (v != this._value) {
                    this._value = v;
                    this.refreshSize();
                    this.event(EventObject.CHANGE);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UISlider.prototype, "step", {
            get: function () {
                return this._step;
            },
            set: function (v) {
                this._step = v;
            },
            enumerable: true,
            configurable: true
        });
        UISlider.prototype.onmouseover = function (e) {
        };
        UISlider.prototype.onmouseout = function (e) {
        };
        UISlider.prototype.onMouseDown = function (e) {
            if (this._blockFillMode)
                return;
            var rect = new Rectangle();
            var blockTex = AssetManager.getImage(this.image2);
            if (!blockTex)
                return;
            if (this.transverseMode) {
                rect.x = -blockTex.width / 2;
                rect.y = (this.height - blockTex.height) / 2;
                rect.width = this.width;
                rect.height = 0;
            }
            else {
                rect.x = (this.width - blockTex.width) / 2;
                rect.y = -blockTex.height / 2;
                rect.width = 0;
                rect.height = this.height;
            }
            this._blockImg.startDrag(rect);
            this._blockImg.on(EventObject.DRAG_MOVE, this, this.onMouseDrag);
            stage.once(EventObject.MOUSE_UP, this, this.onMouseUp);
        };
        UISlider.prototype.onMouseDrag = function () {
            var blockTex = AssetManager.getImage(this.image2);
            var per;
            if (this.transverseMode) {
                per = (this._blockImg.x + blockTex.width / 2) / this.width;
            }
            else {
                per = (this._blockImg.y + blockTex.height / 2) / this.height;
            }
            if (this.step == 0)
                return;
            var value = per * (this.max - this.min) + this.min;
            this._value = Math.round(value / this.step) * this.step;
            this.event(EventObject.CHANGE);
        };
        UISlider.prototype.onMouseUp = function () {
            this._blockImg.stopDrag();
            this._blockImg.off(EventObject.DRAG_MOVE, this, this.onMouseDrag);
        };
        Object.defineProperty(UISlider.prototype, "bgGrid9", {
            get: function () {
                return this._bgGrid9;
            },
            set: function (v) {
                this._bgGrid9 = this._bgImg.sizeGrid = v;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UISlider.prototype, "grid9", {
            get: function () {
                return this._grid9;
            },
            set: function (v) {
                this._grid9 = this._blockImg.sizeGrid = v;
            },
            enumerable: true,
            configurable: true
        });
        UISlider.prototype.refresh = function () {
            this._bgImg.skin = this.image1;
            this._blockImg.skin = this.image2;
            this.refreshSize();
        };
        UISlider.prototype.refreshSize = function () {
            this._bgImg.width = this.width;
            this._bgImg.height = this.height;
            var blockTex = AssetManager.getImage(this.image2);
            if (!blockTex)
                return;
            var value = Math.max(Math.min(this.value, this.max), this.min);
            var per = this.max - this.min == 0 ? 0 : (value - this.min) / (this.max - this.min);
            if (this.transverseMode) {
                if (this._blockFillMode) {
                    this._blockImg.x = 0;
                    this._blockImg.y = 0;
                    this._blockImg.height = this.height;
                    this._blockImg.width = per * this.width;
                }
                else {
                    this._blockImg.y = (this.height - blockTex.height) / 2;
                    this._blockImg.x = per * this.width - blockTex.width / 2;
                    this._blockImg.width = blockTex.width;
                    this._blockImg.height = blockTex.height;
                }
            }
            else {
                if (this._blockFillMode) {
                    this._blockImg.x = 0;
                    this._blockImg.y = 0;
                    this._blockImg.height = per * this.height;
                    this._blockImg.width = this.width;
                }
                else {
                    this._blockImg.x = (this.width - blockTex.width) / 2;
                    this._blockImg.y = per * this.height - blockTex.height / 2;
                }
            }
        };
        return UISlider;
    }(UIComponent.UIBase));
    UIComponent.UISlider = UISlider;
})(UIComponent || (UIComponent = {}));





var UIComponent;
(function (UIComponent) {
    var UIString = (function (_super) {
        __extends(UIString, _super);
        function UIString(inputMode) {
            if (inputMode === void 0) { inputMode = false; }
            _super.call(this);
            this._align = 0;
            this._valign = 0;
            this._overflow = 0;
            this._lastVarID = 0;
            this.className = "UIString";
            this._tf = inputMode ? new TextInput : new Label();
            this._tf.wordWrap = !inputMode;
            this.on(EventObject.RESIZE, this, this.onResize);
            this.addChild(this._tf);
            this._tf.font = "宋体";
            this._needLoad = false;
            if (!Config.EDIT_MODE) {
                this._onVarChange = Callback.New(this.onVarChange, this);
                this.add_DISPLAY(this.onAdded, this);
                this.add_UNDISPLAY(this.onRemoved, this);
                this.mouseEventEnabled = false;
            }
            else {
                this.tips = Callback.New(function () {
                    return this.inEditorInfo();
                }, this);
            }
        }
        UIString.prototype.inEditorInit = function () {
            this.width = 200;
            this.height = 30;
            this.text = "字符串";
            this.fontSize = 16;
            this.mouseEventEnabledData = false;
        };
        UIString.prototype.onResize = function () {
            this._tf.width = this.width;
            this._tf.height = this.height;
        };
        Object.defineProperty(UIString.prototype, "text", {
            get: function () {
                return this._tf.text;
            },
            set: function (v) {
                if (Config.EDIT_MODE) {
                    var varID = GameUtils.getVarID(v);
                    if (varID != 0) {
                        this._tf.text = v;
                        return;
                    }
                }
                this._tf.text = v;
                if (!Config.EDIT_MODE) {
                    var varID = GameUtils.getVarID(this.text);
                    if (varID != 0) {
                        this._tf.text = "";
                        if (this._lastVarID != 0)
                            Game.player.removeListenerPlayerVariable(2, this._lastVarID, this._onVarChange);
                        if (this.displayedInStage)
                            Game.player.addListenerPlayerVariable(2, varID, this._onVarChange);
                        this._lastVarID = varID;
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UIString.prototype, "varID", {
            get: function () {
                return this._lastVarID;
            },
            set: function (v) {
                this.text = "$" + v;
                this._lastVarID = v;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UIString.prototype, "color", {
            get: function () {
                return this._tf.color;
            },
            set: function (v) {
                this._tf.color = v;
                this.width += 1;
                this.width -= 1;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UIString.prototype, "fontSize", {
            get: function () {
                return this._tf.fontSize;
            },
            set: function (v) {
                this._tf.fontSize = v;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UIString.prototype, "leading", {
            get: function () {
                return this._tf.leading;
            },
            set: function (v) {
                this._tf.leading = v;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UIString.prototype, "align", {
            get: function () {
                return this._align;
            },
            set: function (v) {
                this._align = v;
                switch (v) {
                    case 0:
                        this._tf.align = "left";
                        break;
                    case 1:
                        this._tf.align = "center";
                        break;
                    case 2:
                        this._tf.align = "right";
                        break;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UIString.prototype, "valign", {
            get: function () {
                return this._valign;
            },
            set: function (v) {
                this._valign = v;
                switch (v) {
                    case 0:
                        this._tf.valign = "top";
                        break;
                    case 1:
                        this._tf.valign = "middle";
                        break;
                    case 2:
                        this._tf.valign = "bottom";
                        break;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UIString.prototype, "bold", {
            get: function () {
                return this._tf.bold;
            },
            set: function (v) {
                this._tf.bold = v;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UIString.prototype, "width", {
            get: function () {
                return this._tf.width;
            },
            set: function (v) {
                this._tf.width = v;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UIString.prototype, "height", {
            get: function () {
                return this._tf.height;
            },
            set: function (v) {
                this._tf.height = v;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UIString.prototype, "font", {
            get: function () {
                return this._tf.font;
            },
            set: function (v) {
                this._tf.font = v;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UIString.prototype, "overflow", {
            get: function () {
                return this._overflow;
            },
            set: function (v) {
                this._overflow = v;
                this._tf.overflow = v == 1 ? "hidden" : "visible";
                this._tf.text = this._tf.text;
                this.width += 1;
                this.width -= 1;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UIString.prototype, "wordWrap", {
            get: function () {
                return this._tf.wordWrap;
            },
            set: function (v) {
                this._tf.wordWrap = v;
            },
            enumerable: true,
            configurable: true
        });
        UIString.prototype.inEditorInfo = function () {
            var varID = GameUtils.getVarID(this.text);
            if (varID != 0) {
                var varName = GameListData.getName(Game.data.playerStringNameList, varID);
                return "【" + MathUtils.fixIntDigit(varID.toString()) + ":" + varName + "】";
            }
            else {
                return "";
            }
        };
        UIString.prototype.onAdded = function (e) {
            var varID = this._lastVarID;
            if (varID != 0) {
                Game.player.addListenerPlayerVariable(2, varID, this._onVarChange);
            }
        };
        UIString.prototype.onRemoved = function (e) {
            var varID = this._lastVarID;
            if (varID != 0) {
                Game.player.removeListenerPlayerVariable(2, varID, this._onVarChange);
            }
        };
        UIString.prototype.onVarChange = function (typeID, varID, value) {
            this._tf.text = value.toString();
        };
        return UIString;
    }(UIComponent.UIBase));
    UIComponent.UIString = UIString;
    ObjectUtils.redefinedEventFunc("UIComponent.UIString", [EventObject.ENTER, EventObject.INPUT, EventObject.CHANGE, EventObject.FOCUS, EventObject.BLUR], "_tf");
})(UIComponent || (UIComponent = {}));





var UIComponent;
(function (UIComponent) {
    var UISwitch = (function (_super) {
        __extends(UISwitch, _super);
        function UISwitch() {
            _super.call(this);
            this.className = "UISwitch";
            this._selected = 1;
            if (!Config.EDIT_MODE) {
                this._selected = 0;
                this._onVarChange = Callback.New(this.refresh, this);
                this.add_DISPLAY(this.onAdded, this);
                this.add_UNDISPLAY(this.onRemoved, this);
                this.offAll(EventObject.CLICK);
            }
        }
        Object.defineProperty(UISwitch.prototype, "switchID", {
            get: function () {
                return this.getVarID();
            },
            set: function (v) {
                var lastVarID = this.getVarID();
                if (lastVarID != 0)
                    Game.player.removeListenerPlayerVariable(1, lastVarID, this._onVarChange);
                this._selected = v;
                var varID = this.getVarID();
                if (this.displayedInStage && varID != 0)
                    Game.player.addListenerPlayerVariable(1, varID, this._onVarChange);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UISwitch.prototype, "selected", {
            get: function () {
                return this._selected;
            },
            set: function (v) {
                this._selected = v;
                if (!Config.EDIT_MODE) {
                    this.switchID = v;
                }
            },
            enumerable: true,
            configurable: true
        });
        UISwitch.prototype.getVarID = function () {
            return this._selected;
        };
        UISwitch.prototype.onAdded = function (e) {
            var varID = this.getVarID();
            if (varID != 0) {
                Game.player.addListenerPlayerVariable(1, varID, this._onVarChange);
            }
        };
        UISwitch.prototype.onRemoved = function (e) {
            var varID = this.getVarID();
            if (varID != 0) {
                Game.player.removeListenerPlayerVariable(1, varID, this._onVarChange);
            }
        };
        UISwitch.prototype.refresh = function () {
            if (!Config.EDIT_MODE) {
                this.graphics.clear();
                var varID = this.getVarID();
                if (varID) {
                    var url = Game.player.variable.getSwitch(varID) ? this.image2 : this.image1;
                    if (url) {
                        this._image.skin = url;
                        this._image.width = this.width;
                        this._image.height = this.height;
                    }
                }
            }
            else {
                _super.prototype.refresh.call(this);
            }
        };
        return UISwitch;
    }(UIComponent.UICheckBox));
    UIComponent.UISwitch = UISwitch;
})(UIComponent || (UIComponent = {}));





var UIComponent;
(function (UIComponent) {
    var UITabBox = (function (_super) {
        __extends(UITabBox, _super);
        function UITabBox() {
            _super.call(this);
            this._selectedIndex = -1;
            this._rowMode = false;
            this._spacing = 0;
            this._labelSelectedColor = "#FFFFFF";
            this._labelColor = "#666666";
            this._labelSize = 14;
            this._labelAlign = 1;
            this._grid9 = "";
            this._tabRoot = new Sprite();
            this._itemButtons = [];
            this._itemLabels = [];
            this.addChild(this._tabRoot);
            this.className = "UITabBox";
            if (Config.EDIT_MODE) {
                this.modifyWidthHeightEnabled = false;
            }
        }
        UITabBox.prototype.inEditorInit = function () {
            this.items = "标签项1,标签项2,标签项3";
            this.itemImage1 = "asset/editor/image/btn1.png";
            this.itemImage2 = "asset/editor/image/btn2.png";
            this.rowMode = false;
            this.itemWidth = 272;
            this.itemHeight = 32;
            this.spacing = 5;
            this.selectedIndex = 0;
        };
        UITabBox.prototype.loadAssetTest = function () {
            var _this = this;
            AssetManager.loadImages([this.itemImage1, this.itemImage2], Callback.New(function () {
                _this.event(GameUI.EVENT_TEST_LOAD_CHILD_UI);
            }, this), this._syncLoadedEventWhenAssetExist, false);
        };
        UITabBox.prototype.dispose = function () {
            if (!this.isDisposed) {
                this.clearItems();
            }
            _super.prototype.dispose.call(this);
        };
        Object.defineProperty(UITabBox.prototype, "selectedIndex", {
            get: function () {
                return this._selectedIndex;
            },
            set: function (v) {
                if (this._selectedIndex != v) {
                    this._selectedIndex = v;
                    this.refreshSelected();
                    this.onSelected();
                    this.event(EventObject.CHANGE);
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UITabBox.prototype, "items", {
            get: function () {
                return this._items;
            },
            set: function (v) {
                this._items = v;
                this.refreshItems();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UITabBox.prototype, "itemImage1", {
            get: function () {
                return this._itemImage1;
            },
            set: function (v) {
                this._itemImage1 = v;
                this.refreshButtonImage();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UITabBox.prototype, "itemImage2", {
            get: function () {
                return this._itemImage2;
            },
            set: function (v) {
                this._itemImage2 = v;
                this.refreshButtonImage();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UITabBox.prototype, "grid9", {
            get: function () {
                return this._grid9;
            },
            set: function (v) {
                this._grid9 = v;
                this.refreshButtonImage(false);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UITabBox.prototype, "rowMode", {
            get: function () {
                return this._rowMode;
            },
            set: function (v) {
                this._rowMode = v;
                this.refreshItemSize();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UITabBox.prototype, "itemWidth", {
            get: function () {
                return this._itemWidth;
            },
            set: function (v) {
                this._itemWidth = v;
                this.refreshItemSize();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UITabBox.prototype, "itemHeight", {
            get: function () {
                return this._itemHeight;
            },
            set: function (v) {
                this._itemHeight = v;
                this.refreshItemSize();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UITabBox.prototype, "spacing", {
            get: function () {
                return this._spacing;
            },
            set: function (v) {
                this._spacing = v;
                this.refreshItemSize();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UITabBox.prototype, "labelSelectedColor", {
            get: function () {
                return this._labelSelectedColor;
            },
            set: function (v) {
                this._labelSelectedColor = v;
                this.refreshSelected();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UITabBox.prototype, "labelColor", {
            get: function () {
                return this._labelColor;
            },
            set: function (v) {
                this._labelColor = v;
                this.refreshSelected();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UITabBox.prototype, "labelSize", {
            get: function () {
                return this._labelSize;
            },
            set: function (v) {
                this._labelSize = v;
                this.refreshLabels();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UITabBox.prototype, "labelAlign", {
            get: function () {
                return this._labelAlign;
            },
            set: function (v) {
                this._labelAlign = v;
                this.refreshLabels();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UITabBox.prototype, "labelBold", {
            get: function () {
                return this._labelBold;
            },
            set: function (v) {
                this._labelBold = v;
                this.refreshLabels();
            },
            enumerable: true,
            configurable: true
        });
        UITabBox.prototype.clearItems = function () {
            for (var i = 0; i < this._itemButtons.length; i++) {
                var button = this._itemButtons[i];
                button.dispose();
            }
            this._itemButtons = [];
            this._itemLabels = [];
        };
        UITabBox.prototype.refreshItems = function () {
            this.clearItems();
            if (!this.items)
                return;
            var itemArr = this.items.split(",");
            for (var i = 0; i < itemArr.length; i++) {
                var button = new UIComponent.UIButton;
                button["_needLoad"] = false;
                button.clearMouseEvent();
                var label = new UIComponent.UIString;
                label.text = itemArr[i];
                label.valign = 1;
                label.overflow = 1;
                button.addChild(label);
                this._tabRoot.addChild(button);
                this._itemLabels.push(label);
                this._itemButtons.push(button);
                if (!Config.EDIT_MODE) {
                    button.add_CLICK(this.setSelectedIndex, this, [i]);
                }
            }
            this.refreshButtonImage();
            this.refreshItemSize();
            this.refreshLabels();
            this.refreshSelected();
            this.onSelected();
        };
        UITabBox.prototype.refreshItemSize = function () {
            for (var i = 0; i < this._itemButtons.length; i++) {
                var button = this._itemButtons[i];
                var label = this._itemLabels[i];
                label.width = this.itemWidth;
                label.height = this.itemHeight;
                button.width = this.itemWidth;
                button.height = this.itemHeight;
                if (this.rowMode) {
                    button.x = 0;
                    button.y = (this.itemHeight + this.spacing) * i;
                }
                else {
                    button.x = (this.itemWidth + this.spacing) * i;
                    button.y = 0;
                }
            }
        };
        UITabBox.prototype.refreshButtonImage = function (refreshImage) {
            if (refreshImage === void 0) { refreshImage = true; }
            for (var i = 0; i < this._itemButtons.length; i++) {
                var button = this._itemButtons[i];
                if (refreshImage) {
                    button.image1 = this.itemImage1;
                    button.image2 = this.itemImage2;
                }
                button.grid9 = this.grid9;
            }
        };
        UITabBox.prototype.refreshLabels = function () {
            for (var i = 0; i < this._itemButtons.length; i++) {
                var label = this._itemLabels[i];
                label.fontSize = this.labelSize;
                label.bold = this.labelBold;
                label.align = this.labelAlign;
            }
        };
        UITabBox.prototype.refreshSelected = function () {
            for (var i = 0; i < this._itemButtons.length; i++) {
                var button = this._itemButtons[i];
                var label = this._itemLabels[i];
                label.color = this.labelColor;
                button.setState(1);
            }
            if (this.selectedIndex < 0 || this.selectedIndex >= this._itemButtons.length)
                return;
            this._itemButtons[this.selectedIndex].setState(2);
            this._itemLabels[this.selectedIndex].color = this.labelSelectedColor;
        };
        UITabBox.prototype.setSelectedIndex = function (v) {
            this.selectedIndex = v;
        };
        UITabBox.prototype.onSelected = function () {
            if (Config.EDIT_MODE)
                return;
            var len = Math.min(this._itemButtons.length, this.numChildren - 1);
            for (var i = 1; i <= len; i++) {
                var btn = this.getChildAt(i);
                btn.visible = false;
            }
            if (this.selectedIndex < 0 || this.selectedIndex >= len)
                return;
            this.getChildAt(this.selectedIndex + 1).visible = true;
        };
        UITabBox.prototype.addChild = function (node) {
            var n = _super.prototype.addChild.call(this, node);
            this.onSelected();
            return n;
        };
        UITabBox.prototype.addChildAt = function (node, index) {
            var n = _super.prototype.addChildAt.call(this, node, index);
            this.onSelected();
            return n;
        };
        UITabBox.prototype.addChildren = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i - 0] = arguments[_i];
            }
            var n = _super.prototype.addChildren.apply(this, args);
            this.onSelected();
        };
        return UITabBox;
    }(UIComponent.UIBase));
    UIComponent.UITabBox = UITabBox;
})(UIComponent || (UIComponent = {}));





var UIComponent;
(function (UIComponent) {
    var UIVariable = (function (_super) {
        __extends(UIVariable, _super);
        function UIVariable() {
            _super.call(this);
            this.className = "UIVariable";
            this._tf.text = "";
        }
        UIVariable.prototype.inEditorInit = function () {
            _super.prototype.inEditorInit.call(this);
            this.varID = 1;
        };
        Object.defineProperty(UIVariable.prototype, "text", {
            get: function () {
                return this._tf.text;
            },
            set: function (v) {
                if (Config.EDIT_MODE) {
                    var varID = GameUtils.getVarID(v);
                    if (varID != 0) {
                        this._tf.text = v;
                        return;
                    }
                }
                this._tf.text = v;
                if (!Config.EDIT_MODE) {
                    var varID = GameUtils.getVarID(this.text);
                    if (varID != 0) {
                        this._tf.text = "";
                        if (this._lastVarID != 0)
                            Game.player.removeListenerPlayerVariable(0, this._lastVarID, this._onVarChange);
                        if (this.displayedInStage)
                            Game.player.addListenerPlayerVariable(0, varID, this._onVarChange);
                        this._lastVarID = varID;
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
        UIVariable.prototype.inEditorInfo = function () {
            var varName = GameListData.getName(Game.data.playerVariableNameList, this.varID);
            return "【" + MathUtils.fixIntDigit(this.varID) + ":" + varName + "】";
        };
        UIVariable.prototype.onAdded = function (e) {
            if (this.varID == 0)
                return;
            Game.player.addListenerPlayerVariable(0, this.varID, this._onVarChange);
        };
        UIVariable.prototype.onRemoved = function (e) {
            if (this.varID == 0)
                return;
            Game.player.removeListenerPlayerVariable(0, this.varID, this._onVarChange);
        };
        UIVariable.prototype.onVarChange = function (typeID, varID, value) {
            this._tf.text = value.toString();
        };
        return UIVariable;
    }(UIComponent.UIString));
    UIComponent.UIVariable = UIVariable;
})(UIComponent || (UIComponent = {}));





var Avatar = (function (_super) {
    __extends(Avatar, _super);
    function Avatar() {
        _super.call(this);
        this.autoID = ObjectUtils.getInstanceID();
        this.picUrls = [];
        this.oriMode = 8;
        this.playInterval = 5;
        this.currentFrame = 0;
        this.ori = 2;
        this.actIndex = 0;
        this.actID = 1;
        this.actionListArr = [];
        this.avatarList = [];
        this.renderCount = 999999;
        this._body = new GameSprite();
        this._bodyGraphics = new Sprite();
        this.refObjs = {};
        this.addChild(this._body);
        this._body.addChild(this._bodyGraphics);
    }
    Object.defineProperty(Avatar.prototype, "id", {
        get: function () { return this._id; },
        set: function (v) {
            if (v == this.id)
                return;
            AssetManager.disposeAvatarAsset(this.id);
            this._id = v;
            this._loadIDRD = Math.random();
            this.loadData(v, this._loadIDRD);
        },
        enumerable: true,
        configurable: true
    });
    Avatar.prototype.loadData = function (avatarID, loadIDRD) {
        var _this = this;
        if (!Config.EDIT_MODE && avatarID == 0) {
            this.clear();
            return;
        }
        if (Config.EDIT_MODE) {
            var avatarList = Common.avatarList;
            this.parseData(avatarList.data[avatarID], avatarList, loadIDRD);
        }
        else {
            AssetManager.loadJson("asset/json/avatar/data/avatar" + avatarID + ".json", Callback.New(function (avatarJson) {
                _this.parseData(avatarJson, null, loadIDRD);
            }, this), this.syncLoadWhenAssetExist);
        }
    };
    Avatar.prototype.clear = function (clearGraphics) {
        if (clearGraphics === void 0) { clearGraphics = true; }
        for (var i = 0; i < this.avatarList.length; i++) {
            var avatarPart = this.avatarList[i];
            if (avatarPart == this)
                continue;
            this.removePart(avatarPart);
            i--;
        }
        if (clearGraphics)
            this._bodyGraphics.graphics = null;
        this.actionListArr = [];
    };
    Avatar.prototype.parseData = function (avatarJson, avatarListData, loadIDRD) {
        if (avatarListData === void 0) { avatarListData = null; }
        if (loadIDRD === void 0) { loadIDRD = null; }
        if (this.isDisposed)
            return;
        if (!avatarJson) {
            avatarListData = avatarListData ? avatarListData : Common.avatarList;
            if (Config.EDIT_MODE && avatarListData.data[0]) {
                this.parseData(avatarListData.data[0], avatarListData, loadIDRD);
                return;
            }
            this.clear(false);
            this.event(EventObject.LOADED);
            return;
        }
        this._id = avatarJson.id;
        var oriArr = [1, 2, 3, 4, 6, 7, 8, 9];
        this.picUrls = avatarJson.picUrls;
        var h = Callback.New(function () {
            if (this.isDisposed)
                return;
            var loadRandName = "loadAvatar" + this.autoID;
            this.clear(false);
            this.oriMode = avatarJson.oriMode;
            this.name = avatarJson.name;
            for (var i = 0; i < avatarJson.actionListArr.length; i++) {
                var actData = avatarJson.actionListArr[i];
                var act = new AvatarAction();
                act.id = actData.id;
                act.oriMode = avatarJson.oriMode;
                var frameImageInfoData = actData.frameImageInfo;
                for (var s = 0; s < frameImageInfoData.length; s++) {
                    var oriActData = frameImageInfoData[s];
                    var ori = GameUtils.getOriByIndex(s, this.oriMode);
                    act.frameImageInfo[ori] = [];
                    for (var f = 0; f < oriActData.length; f++) {
                        var frameData = oriActData[f];
                        var aImg = new AvatarFrameImage();
                        aImg.index = f;
                        aImg.picUrlIndex = frameData.picUrlIndex;
                        aImg.rect = new Rectangle(frameData.rect[0], frameData.rect[1], frameData.rect[2], frameData.rect[3]);
                        aImg.x = frameData.x;
                        aImg.y = frameData.y;
                        aImg.width = frameData.width ? frameData.width : frameData.rect[2];
                        aImg.height = frameData.height ? frameData.height : frameData.rect[3];
                        aImg.rotation = frameData.rotation ? frameData.rotation : 0;
                        aImg.alpha = frameData.alpha ? frameData.alpha : 1;
                        aImg.hue = frameData.hue;
                        aImg.blur = frameData.blur;
                        aImg.tonal_r = frameData.tonal_r;
                        aImg.tonal_g = frameData.tonal_g;
                        aImg.tonal_b = frameData.tonal_b;
                        aImg.tonal_gray = frameData.tonal_gray;
                        aImg.tonal_mr = frameData.tonal_mr;
                        aImg.tonal_mg = frameData.tonal_mg;
                        aImg.tonal_mb = frameData.tonal_mb;
                        act.frameImageInfo[ori][f] = aImg;
                    }
                }
                this.actionListArr[i] = act;
            }
            this.actionID = this.actID;
            if (avatarJson.refObjs)
                this.refObjs = avatarJson.refObjs;
            for (var i = 0; i < avatarJson.parts.length; i++) {
                var partData = avatarJson.parts[i];
                if (partData.id == 0) {
                    if (!this.partData)
                        this.partData = partData;
                    this.addChild(this._body);
                    this.avatarList.push(this);
                    continue;
                }
                var avatarPart = new Avatar();
                avatarPart.on(EventObject.LOADED, this, SyncTask.taskOver, [loadRandName]);
                avatarPart.partData = partData;
                if (avatarListData) {
                    avatarPart.parseData(avatarListData.data[partData.id], avatarListData, loadIDRD);
                }
                else {
                    avatarPart.loadData(partData.id, loadIDRD);
                }
                this.addPart(avatarPart);
                ObjectUtils.clone(partData, avatarPart);
                new SyncTask(loadRandName);
            }
            for (var s = 0; s < this.actionListArr.length; s++) {
                var avatarAct = this.actionListArr[s];
                if (!avatarAct)
                    continue;
                for (var o in oriArr) {
                    var ori = oriArr[o];
                    var frameLength = avatarAct.getFrameLength(ori);
                    for (var f = 0; f < frameLength; f++) {
                        var frame = avatarAct.getFrameImage(ori, f);
                        if (!frame)
                            continue;
                        var imgUrl = this.picUrls[frame.picUrlIndex];
                        var g = AssetManager.getClipImage(imgUrl, 0, 0, frame.rect);
                        frame.graphics = g;
                    }
                }
            }
            new SyncTask(loadRandName, function (loadRandName) {
                this.actionID = this.actID;
                this.onRender(false);
                if (!loadIDRD || loadIDRD == this._loadIDRD)
                    this.event(EventObject.LOADED);
                SyncTask.clear(loadRandName);
            }, [loadRandName], this);
        }, this);
        AssetManager.loadImages(this.picUrls, h, this.syncLoadWhenAssetExist);
    };
    Avatar.prototype.dispose = function (disposeChild) {
        if (disposeChild === void 0) { disposeChild = false; }
        if (!this.isDisposed) {
            this.stop(0, false);
            AssetManager.disposeAvatarAsset(this.id);
            this.removeSelf();
        }
        _super.prototype.dispose.call(this, disposeChild);
    };
    Object.defineProperty(Avatar.prototype, "realBound", {
        get: function () {
            var myRect = this.getSelfBounds();
            return myRect;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Avatar.prototype, "orientation", {
        get: function () {
            return this.ori;
        },
        set: function (v) {
            if (this.fixedOrientation)
                return;
            for (var i in this.avatarList) {
                if (this.avatarList[i] == this)
                    continue;
                this.avatarList[i].orientation = v;
            }
            this.ori = v;
            this.onRender(false);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Avatar.prototype, "actionIndex", {
        get: function () {
            return this.actIndex;
        },
        set: function (index) {
            this.actIndex = index;
            var act = this.actionList[index];
            for (var i = 0; i < this.avatarList.length; i++) {
                var avatarPart = this.avatarList[i];
                if (avatarPart == this)
                    continue;
                if (act) {
                    avatarPart.actionID = act.id;
                }
                else {
                    avatarPart.actionIndex = index;
                }
            }
            this.onRender(false);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Avatar.prototype, "actionID", {
        get: function () {
            var avatarAct = this.actionListArr[this.actIndex];
            return avatarAct ? avatarAct.id : this.actID;
        },
        set: function (id) {
            this.actID = id;
            var arr = ArrayUtils.matchAttributes(this.actionListArr, { id: id }, true);
            if (arr.length == 0) {
                this.actionIndex = -1;
                return;
            }
            ;
            var avatarAct = arr[0];
            var index = this.actionListArr.indexOf(avatarAct);
            this.actIndex = index;
            for (var i = 0; i < this.avatarList.length; i++) {
                var avatarPart = this.avatarList[i];
                if (avatarPart == this)
                    continue;
                avatarPart.actionID = id;
            }
            this.onRender(false);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Avatar.prototype, "actionList", {
        get: function () {
            return this.actionListArr;
        },
        enumerable: true,
        configurable: true
    });
    Avatar.prototype.changePart = function (avatar, partIndex) {
        var oldAvatar = this.avatarList[partIndex];
        var idx = this.getChildIndex(oldAvatar);
        this.removeChildAt(idx);
        this.addChildAt(avatar, idx);
        avatar.orientation = this.orientation;
        avatar.actionIndex = this.actionIndex;
        this.avatarList[partIndex] = avatar;
    };
    Avatar.prototype.addPart = function (avatar, partIndex) {
        if (partIndex === void 0) { partIndex = -1; }
        if (partIndex == -1) {
            this.avatarList.push(avatar);
            this.addChild(avatar);
        }
        else {
            this.avatarList.splice(partIndex, 0, avatar);
            this.addChildAt(avatar, partIndex);
        }
        avatar.playInterval = this.playInterval;
        avatar.orientation = this.orientation;
        avatar.actionIndex = this.actionIndex;
        return partIndex == -1 ? this.avatarList.length - 1 : partIndex;
    };
    Avatar.prototype.removePart = function (avatar, isDispose) {
        if (isDispose === void 0) { isDispose = false; }
        var partIdx = this.avatarList.indexOf(avatar);
        this.avatarList.splice(partIdx, 1);
        this.removeChild(avatar);
        if (isDispose)
            avatar.dispose();
        return partIdx;
    };
    Avatar.prototype.removePartAt = function (partIndex, isDispose) {
        if (isDispose === void 0) { isDispose = false; }
        var avatar = this.avatarList.splice(partIndex, 1)[0];
        if (isDispose)
            avatar.dispose();
        this.removeChild(avatar);
    };
    Avatar.prototype.getPartByName = function (avatarName) {
        for (var i in this.avatarList) {
            var avatar = this.avatarList[i];
            if (avatar.name == avatarName)
                return avatar;
        }
        return null;
    };
    Avatar.prototype.getPartAt = function (avatarIndex) {
        return this.avatarList[avatarIndex];
    };
    Avatar.prototype.getPartByID = function (avatarID) {
        var m = ArrayUtils.matchAttributes(this.avatarList, { id: avatarID }, true, "==");
        return m[0];
    };
    Avatar.prototype.getPartIndex = function (avatar) {
        return this.avatarList.indexOf(avatar);
    };
    Object.defineProperty(Avatar.prototype, "PartLength", {
        get: function () {
            return this.avatarList.length;
        },
        enumerable: true,
        configurable: true
    });
    Avatar.prototype.setPlayInterval = function (v) {
        this.playInterval = v;
        for (var i = 0; i < this.avatarList.length; i++) {
            var avatarPart = this.avatarList[i];
            if (avatarPart == this)
                continue;
            avatarPart.setPlayInterval(v);
        }
    };
    Avatar.prototype.setCurrentFrame = function (v, immediatelyRender) {
        if (immediatelyRender === void 0) { immediatelyRender = true; }
        this.currentFrame = v;
        for (var i = 0; i < this.avatarList.length; i++) {
            var avatarPart = this.avatarList[i];
            if (avatarPart == this)
                continue;
            avatarPart.setCurrentFrame(v);
        }
        if (immediatelyRender)
            this.onRender(false, true, v + 1);
    };
    Avatar.prototype.getCurrentFrame = function () {
        return this.currentFrame;
    };
    Object.defineProperty(Avatar.prototype, "frameCount", {
        get: function () {
            var avatarAct = this.actionListArr[this.actIndex];
            return avatarAct ? avatarAct.getFrameLength(this.ori) : 0;
        },
        enumerable: true,
        configurable: true
    });
    Avatar.prototype.gotoAndPlay = function (frame, isHit, loop) {
        if (frame === void 0) { frame = 0; }
        if (isHit === void 0) { isHit = true; }
        if (loop === void 0) { loop = false; }
        this.setCurrentFrame(frame);
        this.isHit = isHit;
        this.loop = loop;
        this.play();
    };
    Avatar.prototype.play = function () {
        if (!this.isPlaying) {
            this.isPlaying = true;
            os.add_ENTERFRAME(this.onRender, this);
        }
        this.onRender(false);
    };
    Avatar.prototype.stop = function (frame, immediatelyRender) {
        if (frame === void 0) { frame = 0; }
        if (immediatelyRender === void 0) { immediatelyRender = true; }
        if (this.isPlaying) {
            this.isPlaying = false;
            os.remove_ENTERFRAME(this.onRender, this);
        }
        this.renderCount = 999999;
        this.setCurrentFrame(frame, immediatelyRender);
        if (immediatelyRender)
            this.onRender(false);
    };
    Avatar.prototype.onRender = function (autoPlay, useMapping, playFrame, renderCount) {
        if (autoPlay === void 0) { autoPlay = true; }
        if (useMapping === void 0) { useMapping = true; }
        if (playFrame === void 0) { playFrame = null; }
        if (renderCount === void 0) { renderCount = null; }
        if (this.isDisposed)
            return;
        if (renderCount == null) {
            renderCount = this.renderCount;
        }
        if (playFrame == null)
            playFrame = this.currentFrame;
        if (renderCount >= this.playInterval || !autoPlay) {
            this._bodyGraphics.graphics = null;
            this.currentFrameImage = null;
            var avatarAct = this.actionListArr[this.actIndex];
            if (!avatarAct) {
                return;
            }
            var frameLength = avatarAct.getFrameLength(this.ori, useMapping);
            if (autoPlay && (playFrame == frameLength || (playFrame > frameLength && playFrame % frameLength == 0))) {
                this.event(Avatar.EVENT_ACTION_PLAY_COMPLETED);
            }
            avatarAct = this.actionListArr[this.actIndex];
            if (!avatarAct) {
                return;
            }
            frameLength = avatarAct.getFrameLength(this.ori, useMapping);
            if (autoPlay)
                this.renderCount = 0;
            var currentFrame = Math.max(autoPlay ? playFrame : (playFrame > 0 ? playFrame - 1 : 0), 0);
            var realFrame = useMapping ? currentFrame % frameLength : currentFrame;
            var frame = avatarAct.getFrameImage(this.ori, realFrame, useMapping);
            if (frame) {
                this.currentFrameImage = frame;
                this._bodyGraphics.graphics = frame.graphics;
                this._bodyGraphicsFlip = (this.oriMode % 2 == 1) && (this.ori == 3 || this.ori == 6 || this.ori == 9);
                if (this._bodyGraphicsFlip) {
                    this._bodyGraphics.scaleX = -1;
                    this._bodyGraphics.x = -frame.x * 2;
                }
                else {
                    this._bodyGraphics.scaleX = 1;
                    this._bodyGraphics.x = 0;
                }
                this._body.x = frame.x;
                this._body.y = frame.y;
                this._body.scaleX = frame.width / frame.rect.width;
                this._body.scaleY = frame.height / frame.rect.height;
                this._body.rotation = frame.rotation;
                this._body.alpha = frame.alpha;
                this._body.hue = frame.hue;
                this._body.blur = frame.blur;
                this._body.tonal_r = frame.tonal_r;
                this._body.tonal_g = frame.tonal_g;
                this._body.tonal_b = frame.tonal_b;
                this._body.tonal_gray = frame.tonal_gray;
                this._body.tonal_mr = frame.tonal_mr;
                this._body.tonal_mg = frame.tonal_mg;
                this._body.tonal_mb = frame.tonal_mb;
            }
            if (autoPlay) {
                this.currentFrame++;
            }
        }
        if (autoPlay)
            this.renderCount++;
        for (var i = 0; i < this.avatarList.length; i++) {
            var avatarPart = this.avatarList[i];
            if (avatarPart == this)
                continue;
            avatarPart.onRender(autoPlay, useMapping, playFrame, renderCount);
        }
    };
    Avatar.prototype.hitTestPoint = function (x, y) {
        if (this.isDisposed)
            return false;
        for (var i = 0; i < this.avatarList.length; i++) {
            var avatarPart = this.avatarList[i];
            if (avatarPart == this)
                continue;
            if (avatarPart.hitTestPoint(x, y)) {
                return true;
            }
        }
        if (!this.currentFrameImage)
            return false;
        var inRect = _super.prototype.hitTestPoint.call(this, x, y);
        if (!inRect)
            return false;
        var imgUrl = this.picUrls[this.currentFrameImage.picUrlIndex];
        var tex = AssetManager.getImage(imgUrl);
        if (!tex)
            return false;
        var localP = this._bodyGraphics.globalToLocal(new Point(x, y), false);
        var tx = localP.x - this.currentFrameImage.rect.x;
        var ty = localP.y - this.currentFrameImage.rect.y;
        if (!this.currentFrameImage.positiveRect.contains(tx, ty)) {
            return false;
        }
        var c = tex.getPixels(tx, ty, 1, 1);
        return c[3] != 0;
    };
    Avatar.EVENT_ACTION_PLAY_COMPLETED = "Avatar_EVENT_PLAY_COMPLETED";
    return Avatar;
}(GameSprite));





var GameCommand = (function (_super) {
    __extends(GameCommand, _super);
    function GameCommand(mainType, indexType) {
        _super.call(this);
        this.mainType = mainType;
        this.indexType = indexType;
    }
    GameCommand.init = function () {
        this.start();
    };
    GameCommand.start = function (triggerLineID) {
        if (triggerLineID === void 0) { triggerLineID = null; }
        if (triggerLineID == null) {
            os.remove_ENTERFRAME(GameCommand.execCommand, GameCommand.execCommand);
            os.add_ENTERFRAME(GameCommand.execCommand, GameCommand.execCommand);
            GameCommand.execCommand();
        }
        else {
            var cmds = GameCommand.cmdTriggerLines[triggerLineID];
            if (cmds)
                cmds.stop = false;
        }
    };
    GameCommand.startSceneCommand = function (indexType, inputMessage, onCommandExecuteOver) {
        if (inputMessage === void 0) { inputMessage = null; }
        if (onCommandExecuteOver === void 0) { onCommandExecuteOver = null; }
        if (!Game.currentScene)
            return false;
        var cmd = new GameCommand(0, indexType);
        cmd.startExecute(0, inputMessage, onCommandExecuteOver);
        return true;
    };
    GameCommand.startSceneObjectCommand = function (sceneObjectIndex, indexType, inputMessage, onCommandExecuteOver) {
        if (inputMessage === void 0) { inputMessage = null; }
        if (onCommandExecuteOver === void 0) { onCommandExecuteOver = null; }
        if (!Game.currentScene)
            return false;
        var soc = Game.currentScene.sceneObjects[sceneObjectIndex];
        if (soc) {
            var hasCommand = soc.hasCommand[indexType];
            if (hasCommand) {
                var cmd = new GameCommand(1, indexType);
                cmd.startExecute(sceneObjectIndex, inputMessage, onCommandExecuteOver);
                return true;
            }
        }
        return false;
    };
    GameCommand.startUICommand = function (comp, indexType, inputMessage, onCommandExecuteOver) {
        if (inputMessage === void 0) { inputMessage = null; }
        if (onCommandExecuteOver === void 0) { onCommandExecuteOver = null; }
        if (!Game.currentScene)
            return false;
        var commandID = comp._commondID;
        var hasCommand = comp.hasCommand[indexType];
        if (hasCommand) {
            var cmd = new GameCommand(2, indexType);
            cmd.startExecute(commandID, inputMessage, onCommandExecuteOver);
            return true;
        }
        return false;
    };
    GameCommand.startCommonCommand = function (id, inputMessage, onCommandExecuteOver) {
        if (inputMessage === void 0) { inputMessage = null; }
        if (onCommandExecuteOver === void 0) { onCommandExecuteOver = null; }
        ClientMsgSender.requestTriggerEvent(2, 0, 0, id, inputMessage, onCommandExecuteOver);
    };
    GameCommand.rpcCall = function (triggerLineID, params) {
        var cmds = GameCommand.cmdTriggerLines[triggerLineID];
        if (!cmds) {
            cmds = GameCommand.cmdTriggerLines[triggerLineID] = { stop: false, funcs: [] };
        }
        var cmdID = params.shift();
        var func = CommandExecuteGame["command_" + cmdID];
        if (!func) {
            var gameFuncName = params.shift();
            cmds.funcs.push([GameFunction[gameFuncName], params, GameFunction]);
            return;
        }
        cmds.funcs.push([func, [triggerLineID].concat(params), CommandExecuteGame]);
    };
    GameCommand.execCommand = function () {
        for (var i in GameCommand.cmdTriggerLines) {
            var cmds = GameCommand.cmdTriggerLines[i];
            if (cmds.stop)
                continue;
            while (cmds.funcs.length > 0) {
                var cmd = cmds.funcs.shift();
                var state = cmd[0].apply(cmd[2], cmd[1]);
                var inputTriggerLine = cmd[1][0];
                if (state == GameCommand.COMMAND_STATE_STOP) {
                    cmds.stop = true;
                    break;
                }
                else if (state == GameCommand.COMMAND_STATE_NEED_INPUT) {
                    if (GameCommand.isNeedPlayerInput) {
                        if (inputTriggerLine != GameCommand.inputTriggerLine) {
                            cmds.funcs.unshift(cmd);
                            break;
                        }
                    }
                    GameCommand.inputTriggerLine = inputTriggerLine;
                    GameCommand.isNeedPlayerInput = true;
                }
            }
        }
    };
    GameCommand.prototype.startExecute = function (commandID, inputMessage, onCommandExecuteOver) {
        if (inputMessage === void 0) { inputMessage = null; }
        if (onCommandExecuteOver === void 0) { onCommandExecuteOver = null; }
        ClientMsgSender.requestTriggerEvent(0, this.mainType, this.indexType, commandID, inputMessage, onCommandExecuteOver);
    };
    GameCommand.inputMessageAndContinueExecute = function (inputMessage, force, delay) {
        if (inputMessage === void 0) { inputMessage = null; }
        if (force === void 0) { force = false; }
        if (delay === void 0) { delay = 1; }
        function doInputMessageAndContinueExecute(inputMessage, force, delay) {
            if (inputMessage === void 0) { inputMessage = null; }
            if (force === void 0) { force = false; }
            if (force || GameCommand.isNeedPlayerInput) {
                GameCommand.isNeedPlayerInput = false;
                ClientMsgSender.requestTriggerEvent(1, 0, 0, GameCommand.inputTriggerLine, inputMessage);
            }
        }
        if (delay == 0) {
            doInputMessageAndContinueExecute.apply(this, arguments);
        }
        else {
            setTimeout(doInputMessageAndContinueExecute, delay, inputMessage, force, delay);
        }
    };
    GameCommand.EVENT_SCENE_OBJECT_CLICK_COMMAND = "GameCommand_EVENT_SCENE_OBJECT_CLICK_COMMAND";
    GameCommand.EVENT_IN_SCENE_COMMAND = "GameCommand_EVENT_IN_SCENE_COMMAND";
    GameCommand.COMMAND_STATE_CONTINUE = 0;
    GameCommand.COMMAND_STATE_STOP = 1;
    GameCommand.COMMAND_STATE_NEED_INPUT = 2;
    GameCommand.triggerCmdMapping = {};
    GameCommand.cmdTriggerLines = {};
    return GameCommand;
}(IdentityObject));





var GameImage = (function (_super) {
    __extends(GameImage, _super);
    function GameImage() {
        _super.call(this);
        this._pivotType = 0;
        this.mouseEnabled = true;
    }
    Object.defineProperty(GameImage.prototype, "pivotType", {
        get: function () {
            return this._pivotType;
        },
        set: function (v) {
            this._pivotType = v;
            this.refreshPivotType();
        },
        enumerable: true,
        configurable: true
    });
    GameImage.prototype.refreshPivotType = function () {
        if (this.pivotType == 1) {
            this.pivotX = this.width * 0.5;
            this.pivotY = this.height * 0.5;
        }
        else {
            this.pivotX = 0;
            this.pivotY = 0;
        }
    };
    GameImage.prototype.onImageChange = function (v) {
        _super.prototype.onImageChange.call(this, v);
        this.refreshPivotType();
    };
    Object.defineProperty(GameImage, "imageLayer", {
        get: function () {
            if (GameImage._imageLayer) {
                return GameImage._imageLayer;
            }
            return Game.layer.imageLayer;
        },
        set: function (v) {
            GameImage._imageLayer = v;
        },
        enumerable: true,
        configurable: true
    });
    GameImage.init = function () {
        os.add_ENTERFRAME(this.onEnterFrame, this, [true]);
    };
    GameImage.clear = function () {
        for (var i in this.imageInfos) {
            var ani = this.imageInfos[i].image;
            if (ani instanceof Animation) {
                ani.dispose();
            }
        }
        this.imageInfos = {};
        this.executeFuncs.length = 0;
        this.motionImages.length = 0;
        this.motionAnimations.length = 0;
        this.autoRotations.length = 0;
        this.changeTonals.length = 0;
        this.delayFrame = 0;
    };
    GameImage.showImage = function (id, url, pivotType, x, y, width, height, rotation, alpha, blendMode) {
        if (width === void 0) { width = 0; }
        if (height === void 0) { height = 0; }
        if (rotation === void 0) { rotation = 0; }
        if (alpha === void 0) { alpha = 1; }
        if (blendMode === void 0) { blendMode = null; }
        GameImage.executeFuncs.push({ func: GameImage.doShowImage, params: arguments });
        GameImage.onEnterFrame(false);
    };
    GameImage.moveImage = function (id, time, pivotType, x, y, width, height, rotation, alpha, blendMode, tweenID) {
        if (pivotType === void 0) { pivotType = 0; }
        if (width === void 0) { width = 0; }
        if (height === void 0) { height = 0; }
        if (rotation === void 0) { rotation = 0; }
        if (alpha === void 0) { alpha = 1; }
        if (blendMode === void 0) { blendMode = null; }
        if (tweenID === void 0) { tweenID = null; }
        GameImage.executeFuncs.push({ func: GameImage.doMoveImage, params: arguments });
    };
    GameImage.autoRotation = function (id, angle) {
        GameImage.executeFuncs.push({ func: GameImage.doAutoRotation, params: arguments });
    };
    GameImage.changeTonal = function (id, r, g, b, gray, t, mr, mg, mb, tweenID) {
        if (mr === void 0) { mr = 1; }
        if (mg === void 0) { mg = 1; }
        if (mb === void 0) { mb = 1; }
        if (tweenID === void 0) { tweenID = null; }
        GameImage.executeFuncs.push({ func: GameImage.doChangeTonal, params: arguments });
    };
    GameImage.deleteImage = function (id) {
        GameImage.executeFuncs.push({ func: GameImage.doDeleteImage, params: arguments });
    };
    GameImage.showAnimation = function (id, url, x, y, scaleX, scaleY, rotation, alpha, loop) {
        if (scaleX === void 0) { scaleX = 1; }
        if (scaleY === void 0) { scaleY = 1; }
        if (rotation === void 0) { rotation = 0; }
        if (alpha === void 0) { alpha = 1; }
        if (loop === void 0) { loop = 0; }
        GameImage.executeFuncs.push({ func: GameImage.doShowAnimation, params: arguments });
        GameImage.onEnterFrame(false);
    };
    GameImage.moveAnimation = function (id, time, x, y, scaleX, scaleY, rotation, alpha, tweenID) {
        if (scaleX === void 0) { scaleX = 1; }
        if (scaleY === void 0) { scaleY = 1; }
        if (rotation === void 0) { rotation = 0; }
        if (alpha === void 0) { alpha = 1; }
        if (tweenID === void 0) { tweenID = null; }
        GameImage.executeFuncs.push({ func: GameImage.doMoveAnimation, params: arguments });
    };
    GameImage.delay = function (time) {
        GameImage.executeFuncs.push({ func: GameImage.doDelay, params: arguments });
    };
    GameImage.onEnterFrame = function (realFrame) {
        if (realFrame === void 0) { realFrame = true; }
        while (GameImage.executeFuncs.length > 0) {
            GameImage.isPlayerOver = false;
            if (GameImage.delayFrame > 0)
                break;
            var f = GameImage.executeFuncs.shift();
            f.func.apply(GameImage, f.params);
            if (GameImage.executeFuncs.length == 0)
                GameImage.isPlayerOver = true;
        }
        if (realFrame) {
            GameImage.delayFrame--;
            if (GameImage.delayFrame <= 0 && GameImage.isPlayerOver) {
                GameImage.isPlayerOver = false;
                EventUtils.happen(GameImage, GameImage.EVENT_PLAY_OVER);
            }
            for (var i = 0; i < GameImage.motionImages.length; i++) {
                var m = GameImage.motionImages[i];
                var imageInfo = GameImage.imageInfos[m.id];
                if (!imageInfo)
                    continue;
                if (!(imageInfo.image instanceof GameImage))
                    continue;
                var image = imageInfo.image;
                if (m.curTime == 1) {
                    m.x = image.x;
                    m.y = image.y;
                    m.width = image.width;
                    m.height = image.height;
                    m.rotation = image.rotation;
                    m.alpha = image.alpha;
                }
                var per = m.curTime / m.time;
                var func = m.tween;
                image.pivotType = m.pivotType;
                image.blendMode = m.blendMode;
                image.x = func(per, m.x, m.x2 - m.x, 1);
                image.y = func(per, m.y, m.y2 - m.y, 1);
                var newW = func(per, m.width, m.width2 - m.width, 1);
                var newH = func(per, m.height, m.height2 - m.height, 1);
                if (newW != image.width || newH != image.height) {
                    image.width = newW;
                    image.height = newH;
                }
                image.rotation = func(per, m.rotation, m.rotation2 - m.rotation, 1);
                image.alpha = func(per, m.alpha, m.alpha2 - m.alpha, 1);
                m.curTime++;
                if (per == 1) {
                    GameImage.motionImages.splice(i, 1);
                    i--;
                }
            }
            for (var i = 0; i < GameImage.motionAnimations.length; i++) {
                var a = GameImage.motionAnimations[i];
                var imageInfo = GameImage.imageInfos[a.id];
                if (!imageInfo)
                    continue;
                if (!(imageInfo.image instanceof Animation))
                    continue;
                var ani = imageInfo.image;
                if (a.curTime == 1) {
                    a.x = ani.x;
                    a.y = ani.y;
                    a.scaleX = ani.scaleX;
                    a.scaleY = ani.scaleY;
                    a.rotation = ani.rotation;
                    a.alpha = ani.alpha;
                }
                var per = a.curTime / a.time;
                var func = a.tween;
                ani.x = func(per, a.x, a.x2 - a.x, 1);
                ani.y = func(per, a.y, a.y2 - a.y, 1);
                ani.scaleX = func(per, a.scaleX, a.scaleX2 - a.scaleX, 1);
                ani.scaleY = func(per, a.scaleY, a.scaleY2 - a.scaleY, 1);
                ani.rotation = func(per, a.rotation, a.rotation2 - a.rotation, 1);
                ani.alpha = func(per, a.alpha, a.alpha2 - a.alpha, 1);
                a.curTime++;
                if (per == 1) {
                    GameImage.motionAnimations.splice(i, 1);
                    i--;
                }
            }
            for (var i = 0; i < GameImage.autoRotations.length; i++) {
                var roInfo = GameImage.autoRotations[i];
                var id = roInfo.id;
                var angle = roInfo.angle;
                var imageInfo = GameImage.imageInfos[id];
                if (!imageInfo)
                    continue;
                imageInfo.image.rotation += angle;
            }
            for (var i = 0; i < GameImage.changeTonals.length; i++) {
                var t = GameImage.changeTonals[i];
                var l = t.tween;
                var imageInfo = GameImage.imageInfos[t.id];
                if (!imageInfo)
                    continue;
                var per = t.curTime / t.time;
                var targetObj = imageInfo.image;
                if (t.curTime == 1) {
                    t.old = targetObj.getTonal().concat();
                }
                targetObj.setTonal(l(per, t.old[0], t.r - t.old[0], 1), l(per, t.old[1], t.g - t.old[1], 1), l(per, t.old[2], t.b - t.old[2], 1), l(per, t.old[3], t.gray - t.old[3], 1), l(per, t.old[4], t.mr - t.old[4], 1), l(per, t.old[5], t.mg - t.old[5], 1), l(per, t.old[6], t.mb - t.old[6], 1));
                t.curTime++;
                if (per == 1) {
                    GameImage.changeTonals.splice(i, 1);
                    i--;
                }
            }
        }
    };
    GameImage.addImageToLayer = function (id, image) {
        var newImageInfo = {
            image: image
        };
        var insertImageInfo;
        for (var i in GameImage.imageInfos) {
            var imageInfo = GameImage.imageInfos[i];
            if (parseInt(i) > id) {
                insertImageInfo = imageInfo;
            }
        }
        if (insertImageInfo) {
            var index = GameImage.imageLayer.getChildIndex(insertImageInfo.image);
            GameImage.imageLayer.addChildAt(image, index);
        }
        else {
            GameImage.imageLayer.addChild(image);
        }
        GameImage.imageInfos[id] = newImageInfo;
    };
    GameImage.doShowImage = function (id, url, pivotType, x, y, width, height, rotation, alpha, blendMode) {
        if (width === void 0) { width = 0; }
        if (height === void 0) { height = 0; }
        if (rotation === void 0) { rotation = 0; }
        if (alpha === void 0) { alpha = 1; }
        if (blendMode === void 0) { blendMode = null; }
        var imageInfo = GameImage.imageInfos[id];
        GameImage.doDeleteImage(id);
        var newImage = new GameImage();
        if (width != null)
            newImage.width = width;
        if (height != null)
            newImage.height = height;
        newImage.image = url;
        newImage.x = x;
        newImage.y = y;
        newImage.alpha = alpha;
        newImage.rotation = rotation;
        newImage.blendMode = blendMode;
        newImage.pivotType = pivotType;
        GameImage.addImageToLayer(id, newImage);
    };
    GameImage.doMoveImage = function (id, time, pivotType, x, y, width, height, rotation, alpha, blendMode, tweenID) {
        if (pivotType === void 0) { pivotType = 0; }
        if (width === void 0) { width = 0; }
        if (height === void 0) { height = 0; }
        if (rotation === void 0) { rotation = 0; }
        if (alpha === void 0) { alpha = 1; }
        if (blendMode === void 0) { blendMode = null; }
        if (tweenID === void 0) { tweenID = null; }
        if (time < 1)
            time = 1;
        var imageInfo = GameImage.imageInfos[id];
        if (!imageInfo || !(imageInfo.image instanceof GameImage))
            return;
        var mArr = ArrayUtils.matchAttributes(GameImage.motionImages, { id: id }, true);
        if (mArr.length == 1) {
            GameImage.motionImages.splice(GameImage.motionImages.indexOf(mArr[0]), 1);
        }
        var image = imageInfo.image;
        var m = { id: id, time: time, curTime: 1, pivotType: pivotType, blendMode: blendMode, x2: x, y2: y, width2: width, height2: height, rotation2: rotation, alpha2: alpha, tween: GameUtils.getTween(tweenID)[0] };
        GameImage.motionImages.push(m);
    };
    GameImage.doAutoRotation = function (id, angle) {
        var imageInfo = GameImage.imageInfos[id];
        if (!imageInfo)
            return;
        var mArr = ArrayUtils.matchAttributes(GameImage.autoRotations, { id: id }, true);
        if (mArr.length == 1) {
            GameImage.autoRotations.splice(GameImage.autoRotations.indexOf(mArr[0]), 1);
        }
        var m = { id: id, angle: angle };
        GameImage.autoRotations.push(m);
    };
    GameImage.doDeleteImage = function (id) {
        var imageInfo = GameImage.imageInfos[id];
        if (imageInfo) {
            GameImage.imageLayer.removeChild(imageInfo.image);
            if (imageInfo.image instanceof Animation) {
                imageInfo.image.dispose();
            }
            var arr = [GameImage.motionImages, GameImage.motionAnimations, GameImage.autoRotations, GameImage.changeTonals];
            for (var i in arr) {
                var mArr = arr[i];
                var m = ArrayUtils.matchAttributes(mArr, { id: id }, true);
                if (m.length == 1) {
                    mArr.splice(mArr.indexOf(m[0]), 1);
                }
            }
            delete GameImage.imageInfos[id];
        }
    };
    GameImage.doShowAnimation = function (id, aniId, x, y, scaleX, scaleY, rotation, alpha, loop) {
        if (scaleX === void 0) { scaleX = 1; }
        if (scaleY === void 0) { scaleY = 1; }
        if (rotation === void 0) { rotation = 0; }
        if (alpha === void 0) { alpha = 1; }
        if (loop === void 0) { loop = 0; }
        var imageInfo = GameImage.imageInfos[id];
        GameImage.doDeleteImage(id);
        var animation = new Animation();
        animation.id = aniId;
        animation.loop = loop == 1 ? true : false;
        animation.gotoAndPlay();
        if (scaleX)
            animation.scaleX = scaleX;
        if (scaleY)
            animation.scaleY = scaleY;
        animation.x = x;
        animation.y = y;
        animation.alpha = alpha;
        animation.rotation = rotation;
        GameImage.addImageToLayer(id, animation);
    };
    GameImage.doChangeTonal = function (id, r, g, b, gray, t, mr, mg, mb, tweenID) {
        if (mr === void 0) { mr = 1; }
        if (mg === void 0) { mg = 1; }
        if (mb === void 0) { mb = 1; }
        if (tweenID === void 0) { tweenID = null; }
        var imageInfo = GameImage.imageInfos[id];
        if (!imageInfo)
            return;
        var mArr = ArrayUtils.matchAttributes(GameImage.changeTonals, { id: id }, true);
        if (mArr.length == 1) {
            GameImage.changeTonals.splice(GameImage.changeTonals.indexOf(mArr[0]), 1);
        }
        var m = { id: id, time: t, curTime: 1, r: r, g: g, b: b, gray: gray, mr: mr, mg: mg, mb: mb, tween: GameUtils.getTween(tweenID)[0] };
        GameImage.changeTonals.push(m);
    };
    GameImage.doMoveAnimation = function (id, time, x, y, scaleX, scaleY, rotation, alpha, tweenID) {
        if (scaleX === void 0) { scaleX = 1; }
        if (scaleY === void 0) { scaleY = 1; }
        if (rotation === void 0) { rotation = 0; }
        if (alpha === void 0) { alpha = 1; }
        if (tweenID === void 0) { tweenID = null; }
        if (time < 1)
            time = 1;
        var imageInfo = GameImage.imageInfos[id];
        if (!imageInfo || !(imageInfo.image instanceof Animation))
            return;
        var mArr = ArrayUtils.matchAttributes(GameImage.motionAnimations, { id: id }, true);
        if (mArr.length == 1) {
            GameImage.motionAnimations.splice(GameImage.motionAnimations.indexOf(mArr[0]), 1);
        }
        var image = imageInfo.image;
        var m = { id: id, time: time, curTime: 1, x2: x, y2: y, scaleX2: scaleX, scaleY2: scaleY, rotation2: rotation, alpha2: alpha, tween: GameUtils.getTween(tweenID)[0] };
        GameImage.motionAnimations.push(m);
    };
    GameImage.doDelay = function (time) {
        if (time < 1)
            time = 1;
        GameImage.delayFrame = time;
    };
    GameImage.EVENT_PLAY_OVER = "GameImage_EVENT_PLAY_OVER";
    GameImage.delayFrame = 0;
    GameImage.executeFuncs = [];
    GameImage.imageInfos = {};
    GameImage.motionImages = [];
    GameImage.motionAnimations = [];
    GameImage.autoRotations = [];
    GameImage.changeTonals = [];
    return GameImage;
}(UIComponent.UIBitmap));





var AnimationAudioLayer = (function (_super) {
    __extends(AnimationAudioLayer, _super);
    function AnimationAudioLayer() {
        _super.apply(this, arguments);
        this.type = AnimationItemType.Audio;
        this._audioInfo = { url: "", volume: 1, pitch: 1 };
    }
    Object.defineProperty(AnimationAudioLayer.prototype, "audioInfo", {
        get: function () { return this._audioInfo; },
        set: function (v) {
            this._audioInfo = v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AnimationAudioLayer.prototype, "audioUrl", {
        get: function () {
            if (!this._audioInfo.url)
                this._audioInfo.url = "";
            return this._audioInfo.url.split(",")[0];
        },
        enumerable: true,
        configurable: true
    });
    AnimationAudioLayer.prototype.setData = function (data) {
        _super.prototype.setData.call(this, data);
        this.audioInfo = data.audioInfo || { url: "", volume: 1, pitch: 1 };
    };
    AnimationAudioLayer.prototype.toAnimationLayerData = function () {
        var data = _super.prototype.toAnimationLayerData.call(this);
        data.audioInfo = this.audioInfo;
        return data;
    };
    AnimationAudioLayer.prototype.showFrame = function (frameIndex) {
        var preFrameIndex = this._frameIndex;
        _super.prototype.showFrame.call(this, frameIndex);
        if (!this._audioInfo)
            return;
        if (!this.animation)
            return;
        if (!this.animation.isPlaying)
            return;
        if (this.frames.length == 0)
            return;
        if (this.visible == false)
            return;
        var len = this.frames ? this.frames.length : 0;
        var totalFrame = this.animation.totalFrame ? this.animation.totalFrame : 0;
        if (len == 0 || totalFrame == 0) {
            this.stopAudio();
            return;
        }
        var firstFrame = this.frames[0].index;
        var lastFrame = 0;
        if (len == 1) {
            lastFrame = totalFrame - 1;
        }
        else if (len >= 2) {
            lastFrame = this.frames[len - 1].index;
        }
        if (!this.animation.silentMode) {
            if ((preFrameIndex <= this._frameIndex && preFrameIndex <= firstFrame && this._frameIndex >= firstFrame) ||
                (preFrameIndex > this._frameIndex && preFrameIndex > firstFrame && preFrameIndex < lastFrame && this._frameIndex >= firstFrame && this._frameIndex <= lastFrame)) {
                this.stopAudio();
                this._soundChannel = GameAudio.playSE(this.audioUrl, this._audioInfo.volume, this._audioInfo.pitch, this.animation.sceneObject);
            }
        }
    };
    AnimationAudioLayer.prototype.stopAudio = function () {
        if (this._soundChannel) {
            GameAudio.stopSE(this._soundChannel);
            this._soundChannel = null;
        }
    };
    return AnimationAudioLayer;
}(AnimationLayer));
AnimationLayer.typeClsMap[AnimationItemType.Audio] = AnimationAudioLayer;





var AnimationDisplayLayer = (function (_super) {
    __extends(AnimationDisplayLayer, _super);
    function AnimationDisplayLayer() {
        _super.apply(this, arguments);
        this._horizontalReversal = false;
    }
    Object.defineProperty(AnimationDisplayLayer.prototype, "horizontalReversal", {
        get: function () {
            return this._horizontalReversal;
        },
        set: function (v) {
            this._horizontalReversal = v;
        },
        enumerable: true,
        configurable: true
    });
    AnimationDisplayLayer.prototype.fromAnimationFrameData = function (framedata) {
        _super.prototype.fromAnimationFrameData.call(this, framedata);
        this.horizontalReversal = framedata.horizontalReversal;
        this.hue = framedata.hue;
        this.blur = framedata.blur;
        this.tonal_r = framedata.tonal_r;
        this.tonal_g = framedata.tonal_g;
        this.tonal_b = framedata.tonal_b;
        this.tonal_gray = framedata.tonal_gray;
        this.tonal_mr = framedata.tonal_mr;
        this.tonal_mg = framedata.tonal_mg;
        this.tonal_mb = framedata.tonal_mb;
        this.x = framedata.x;
        this.y = framedata.y;
        this.rotation = framedata.rotation;
        this.opacity = framedata.alpha;
    };
    AnimationDisplayLayer.prototype.toAnimationFrameData = function (framedata) {
        framedata = _super.prototype.toAnimationFrameData.call(this, framedata);
        framedata.horizontalReversal = this.horizontalReversal;
        framedata.hue = this.hue;
        framedata.blur = this.blur;
        framedata.tonal_r = this.tonal_r;
        framedata.tonal_g = this.tonal_g;
        framedata.tonal_b = this.tonal_b;
        framedata.tonal_gray = this.tonal_gray;
        framedata.tonal_mr = this.tonal_mr;
        framedata.tonal_mg = this.tonal_mg;
        framedata.tonal_mb = this.tonal_mb;
        framedata.x = this.x;
        framedata.y = this.y;
        framedata.rotation = this.rotation;
        framedata.alpha = this.alpha;
        return framedata;
    };
    AnimationDisplayLayer.prototype.interpolationFrame = function (pf, nf, frameIndex) {
        var frame = _super.prototype.interpolationFrame.call(this, pf, nf, frameIndex);
        var t = (frameIndex - pf.index) / (nf.index - pf.index);
        var tween = GameUtils.getTween(nf.tweenID)[0];
        frame.tweenID = nf.tweenID;
        frame.horizontalReversal = pf.horizontalReversal;
        frame.hue = Math.round(tween(t, pf.hue, nf.hue - pf.hue, 1));
        frame.blur = tween(t, pf.blur, nf.blur - pf.blur, 1);
        frame.tonal_r = Math.round(tween(t, pf.tonal_r, nf.tonal_r - pf.tonal_r, 1));
        frame.tonal_g = Math.round(tween(t, pf.tonal_g, nf.tonal_g - pf.tonal_g, 1));
        frame.tonal_b = Math.round(tween(t, pf.tonal_b, nf.tonal_b - pf.tonal_b, 1));
        frame.tonal_gray = Math.round(tween(t, pf.tonal_gray, nf.tonal_gray - pf.tonal_gray, 1));
        frame.tonal_mr = tween(t, pf.tonal_mr, nf.tonal_mr - pf.tonal_mr, 1);
        frame.tonal_mg = tween(t, pf.tonal_mg, nf.tonal_mg - pf.tonal_mg, 1);
        frame.tonal_mb = tween(t, pf.tonal_mb, nf.tonal_mb - pf.tonal_mb, 1);
        frame.x = tween(t, pf.x, nf.x - pf.x, 1);
        frame.y = tween(t, pf.y, nf.y - pf.y, 1);
        frame.rotation = tween(t, pf.rotation, nf.rotation - pf.rotation, 1);
        frame.alpha = tween(t, pf.alpha, nf.alpha - pf.alpha, 1);
        return frame;
    };
    return AnimationDisplayLayer;
}(AnimationLayer));





var AnimationImageLayer = (function (_super) {
    __extends(AnimationImageLayer, _super);
    function AnimationImageLayer() {
        _super.call(this);
        this.type = AnimationItemType.Image;
        this._pivotX = 0;
        this._pivotY = 0;
        this.img = new Sprite();
        this.addChild(this.img);
        this.on(EventObject.RESIZE, this, this.onResize);
        this.add_DISPLAY(this.onDisplay, this);
        this.add_UNDISPLAY(this.onUnDisplay, this);
    }
    Object.defineProperty(AnimationImageLayer.prototype, "imageSource", {
        get: function () {
            return this._imageSource;
        },
        set: function (v) {
            this._imageSource = v;
            timer.callLater(this, this.updateImage);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AnimationImageLayer.prototype, "blendModeType", {
        get: function () { return this._blendModeType; },
        set: function (v) {
            this._blendModeType = v;
            this.img.blendMode = [null, "lighter"][v] || null;
        },
        enumerable: true,
        configurable: true
    });
    AnimationImageLayer.prototype.onDisplay = function () {
        this.updateImage();
    };
    AnimationImageLayer.prototype.onUnDisplay = function () {
    };
    AnimationImageLayer.prototype.updateImage = function () {
        if (!this.animation)
            return;
        var imageSource = this.animation.imageSources[this._imageSource];
        if (!imageSource) {
            this.img.graphics = null;
            return;
        }
        var _this = this;
        var imagegraphics = AssetManager.getClipImage(imageSource.url, 0, 0, new Rectangle(imageSource.x, imageSource.y, imageSource.width, imageSource.height));
        _this.setSouce(imagegraphics, imageSource.width, imageSource.height);
    };
    AnimationImageLayer.prototype.repaint = function () {
        _super.prototype.repaint.call(this);
        this.onResize();
    };
    AnimationImageLayer.prototype.setSouce = function (v, width, height, pivotX, pivotY) {
        if (pivotX === void 0) { pivotX = 0; }
        if (pivotY === void 0) { pivotY = 0; }
        if (v == null || v instanceof Graphics) {
            this.img.graphics = v;
        }
        else if (v instanceof Avatar) {
            this.img.addChild(v);
        }
        else {
            AssetManager.loadImage(v, Callback.New(function (t) {
                var g = new Graphics();
                if (t) {
                    g.fillTexture(t, 0, 0, t.width, t.height);
                    this.setSouce(g, t.width, t.height);
                }
                else {
                    this.setSouce(g, 0, 0);
                }
            }, this));
            return;
        }
        this.img.width = width;
        this.img.height = height;
        if (this.width == 0 || isNaN(this.width))
            this.width = width;
        if (this.height == 0 || isNaN(this.height))
            this.height = height;
        this._pivotX = pivotX;
        this._pivotY = pivotY;
        this.onResize();
    };
    AnimationImageLayer.prototype.setAutoHitArea = function (isAutoHitArea) {
        this._isAutoHitArea = isAutoHitArea;
        this.onResize();
    };
    Object.defineProperty(AnimationImageLayer.prototype, "lockScale", {
        get: function () {
            return this._lockScale;
        },
        set: function (v) {
            this._lockScale = v;
            if (!v) {
                this.img.x = 0;
                this.img.y = 0;
            }
            this.onResize();
        },
        enumerable: true,
        configurable: true
    });
    AnimationImageLayer.prototype.onResize = function () {
        if (!this.img.graphics || this.img.width == 0 || this.img.height == 0)
            return;
        var scaleX = this.width / this.img.width;
        var scaleY = this.height / this.img.height;
        if (this.lockScale) {
            var scale = Math.min(scaleX, scaleY);
            this.img.scaleX = scale;
            this.img.scaleY = scale;
            var imgW = this.img.width * scale;
            var imgH = this.img.height * scale;
            this.img.x = Math.round((this.width - imgW) / 2);
            this.img.y = Math.round((this.height - imgH) / 2);
        }
        else {
            this.img.scaleX = scaleX;
            this.img.scaleY = scaleY;
        }
        if (this._isAutoHitArea) {
            var rect = this.img.getBounds();
            this.hitArea = rect;
        }
    };
    AnimationImageLayer.prototype.interpolationFrame = function (pf, nf, frameIndex) {
        var frame = _super.prototype.interpolationFrame.call(this, pf, nf, frameIndex);
        var t = (frameIndex - pf.index) / (nf.index - pf.index);
        var tween = GameUtils.getTween(nf.tweenID)[0];
        frame.width = tween(t, pf.width, nf.width - pf.width, 1);
        frame.height = tween(t, pf.height, nf.height - pf.height, 1);
        frame.imageSource = Math.round(tween(t, pf.imageSource, nf.imageSource - pf.imageSource, 1));
        frame.blendModeType = pf.blendModeType;
        return frame;
    };
    AnimationImageLayer.prototype.fromAnimationFrameData = function (framedata) {
        _super.prototype.fromAnimationFrameData.call(this, framedata);
        this.width = framedata.width;
        this.height = framedata.height;
        this.imageSource = framedata.imageSource;
        this.blendModeType = framedata.blendModeType;
        if (!this.animation)
            return;
        if (!this.img)
            return;
        this.img.visible = false;
        var len = this.frames ? this.frames.length : 0;
        var totalFrame = this.animation.totalFrame ? this.animation.totalFrame : 0;
        if (len == 0 || totalFrame == 0)
            return;
        var firstFrame = this.frames[0].index;
        var lastFrame = 0;
        if (len == 1) {
            lastFrame = totalFrame - 1;
        }
        else if (len >= 2) {
            lastFrame = this.frames[len - 1].index;
        }
        if (this._frameIndex >= firstFrame && this._frameIndex <= lastFrame) {
            this.img.visible = true;
        }
        else {
            this.img.visible = false;
        }
    };
    AnimationImageLayer.prototype.toAnimationFrameData = function (framedata) {
        framedata = _super.prototype.toAnimationFrameData.call(this, framedata);
        framedata.width = this.width;
        framedata.height = this.height;
        framedata.imageSource = this.imageSource;
        framedata.blendModeType = this.blendModeType;
        return framedata;
    };
    return AnimationImageLayer;
}(AnimationDisplayLayer));
AnimationLayer.typeClsMap[AnimationItemType.Image] = AnimationImageLayer;





var AnimationTargetLayer = (function (_super) {
    __extends(AnimationTargetLayer, _super);
    function AnimationTargetLayer() {
        _super.apply(this, arguments);
        this.type = AnimationItemType.Target;
    }
    AnimationTargetLayer.prototype._updateView = function () {
        if (!this.animation)
            return;
        var target = this.animation.target;
        if (!target)
            return;
        if (target instanceof GameSprite) {
            target.refreshAnimationTargetEffect();
        }
    };
    AnimationTargetLayer.prototype.fromAnimationFrameData = function (framedata) {
        _super.prototype.fromAnimationFrameData.call(this, framedata);
        if (framedata.scaleX == undefined)
            framedata.scaleX = 1;
        if (framedata.scaleY == undefined)
            framedata.scaleY = 1;
        this.scaleX = framedata.scaleX;
        this.scaleY = framedata.scaleY;
        this._updateView();
    };
    AnimationTargetLayer.prototype.toAnimationFrameData = function (framedata) {
        framedata = _super.prototype.toAnimationFrameData.call(this, framedata);
        framedata.scaleX = this.scaleX;
        framedata.scaleY = this.scaleY;
        return framedata;
    };
    AnimationTargetLayer.prototype.interpolationFrame = function (pf, nf, frameIndex) {
        var frame = _super.prototype.interpolationFrame.call(this, pf, nf, frameIndex);
        if (pf.scaleX == undefined)
            pf.scaleX = 1;
        if (pf.scaleY == undefined)
            pf.scaleY = 1;
        var t = (frameIndex - pf.index) / (nf.index - pf.index);
        var tween = GameUtils.getTween(nf.tweenID)[0];
        frame.scaleX = tween(t, pf.scaleX, nf.scaleX - pf.scaleX, 1);
        frame.scaleY = tween(t, pf.scaleY, nf.scaleY - pf.scaleY, 1);
        return frame;
    };
    return AnimationTargetLayer;
}(AnimationDisplayLayer));
AnimationLayer.typeClsMap[AnimationItemType.Target] = AnimationTargetLayer;





var UIComponent;
(function (UIComponent) {
    (function (UIAnimationPlayType) {
        UIAnimationPlayType[UIAnimationPlayType["none"] = 0] = "none";
        UIAnimationPlayType[UIAnimationPlayType["once"] = 1] = "once";
        UIAnimationPlayType[UIAnimationPlayType["loop"] = 2] = "loop";
    })(UIComponent.UIAnimationPlayType || (UIComponent.UIAnimationPlayType = {}));
    var UIAnimationPlayType = UIComponent.UIAnimationPlayType;
    var UIAnimation = (function (_super) {
        __extends(UIAnimation, _super);
        function UIAnimation() {
            _super.call(this);
            this._animationID = -1;
            this._playType = UIAnimationPlayType.none;
            this.className = "UIAnimation";
            if (Config.EDIT_MODE) {
                this.modifyWidthHeightEnabled = false;
                this._bg = new Sprite();
                this.addChild(this._bg);
                this.hitArea = new Rectangle(-10, -10, 20, 20);
                this._bg.graphics.drawCircle(0, 0, 10, "#FF0000");
                this._bg.alpha = 0.4;
            }
            this.on(EventObject.DISPLAY, this, this.onDisplay);
            this.on(EventObject.UNDISPLAY, this, this.onUnDisplay);
        }
        Object.defineProperty(UIAnimation.prototype, "animationID", {
            get: function () {
                return this._animationID;
            },
            set: function (value) {
                if (this._animationID == value)
                    return;
                this._animationID = value;
                this.invalidateView();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UIAnimation.prototype, "playType", {
            get: function () { return this._playType; },
            set: function (v) { this._playType = v; this.updateAnimationPlayType(); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UIAnimation.prototype, "playFps", {
            get: function () { return this._playFps; },
            set: function (v) { this._playFps = v; this.updateAnimationPlayType(); },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UIAnimation.prototype, "scaleNumber", {
            get: function () {
                return this._animation ? this._animation.scaleX : 1;
            },
            set: function (v) {
                if (this._animation)
                    this._animation.scaleX = this._animation.scaleY = v;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UIAnimation.prototype, "animation", {
            get: function () {
                return this._animation;
            },
            enumerable: true,
            configurable: true
        });
        UIAnimation.prototype.loadAssetTest = function () {
            var aniID = this.animationID;
            AssetManager.preLoadAnimationAsset(aniID, Callback.New(function () {
                this.event(GameUI.EVENT_TEST_LOAD_CHILD_UI);
            }, this), this._syncLoadedEventWhenAssetExist);
        };
        UIAnimation.prototype.dispose = function () {
            if (!this.isDisposed) {
                if (this._animation) {
                    this._animation.dispose();
                    this._animation = null;
                }
                else if (this.animationID > 0) {
                    AssetManager.disposeAnimationAsset(this.animationID);
                }
            }
            _super.prototype.dispose.call(this, true);
        };
        UIAnimation.prototype.onDisplay = function () {
            this.invalidateView();
        };
        UIAnimation.prototype.onUnDisplay = function () {
            this.removeAnimation();
        };
        UIAnimation.prototype.removeAnimation = function () {
            if (this._animation) {
                this._animation.dispose();
                this._animation = null;
            }
        };
        UIAnimation.prototype.inEditorInit = function () {
            this.width = 192;
            this.height = 192;
            this.animationID = 1;
        };
        UIAnimation.prototype.invalidateView = function () {
            timer.callLater(this, this._updateView);
        };
        UIAnimation.prototype._updateView = function () {
            if (this.isDisposed)
                return;
            this.removeAnimation();
            this._animation = new Animation();
            if (Config.EDIT_MODE) {
                this._animation.silentMode = true;
            }
            this._animation.once(EventObject.LOADED, this, this.onAnimationLoaded);
            this._animation.on(Animation.PLAY_COMPLETED, this, this.onAnimationPlayCompleted);
            this._animation.id = this.animationID;
        };
        UIAnimation.prototype.onAnimationPlayCompleted = function () {
            this.event(Animation.PLAY_COMPLETED);
        };
        UIAnimation.prototype.onAnimationLoaded = function () {
            if (this.displayedInStage) {
                var realBound = this._animation.getBounds();
                this.width = realBound.width;
                this.height = realBound.height;
                this._animation.x = -realBound.x;
                this._animation.y = -realBound.y;
                this.updateAnimationPlayType();
                this.addChildAt(this._animation, 0);
            }
            this.event(EventObject.LOADED);
        };
        UIAnimation.prototype.updateAnimationPlayType = function () {
            if (!this._animation)
                return;
            if (this.playType == UIAnimationPlayType.none)
                this._animation.stop();
            else if (this.playType == UIAnimationPlayType.once) {
                this._animation.loop = false;
                if (this._playFps)
                    this._animation.fps = this._playFps;
                this._animation.play();
            }
            else if (this.playType == UIAnimationPlayType.loop) {
                this._animation.loop = true;
                if (this._playFps)
                    this._animation.fps = this._playFps;
                this._animation.play();
            }
        };
        return UIAnimation;
    }(UIComponent.UIBase));
    UIComponent.UIAnimation = UIAnimation;
})(UIComponent || (UIComponent = {}));





var UIComponent;
(function (UIComponent) {
    var UIAvatar = (function (_super) {
        __extends(UIAvatar, _super);
        function UIAvatar() {
            _super.call(this);
            this._orientationIndex = 6;
            this._isPlay = true;
            this._avatarFrame = 0;
            this._avatarInterval = 5;
            this._actionID = 1;
            this._scaleNumber = 1;
            this.className = "UIAvatar";
            if (Config.EDIT_MODE) {
                this.modifyWidthHeightEnabled = false;
            }
        }
        UIAvatar.prototype.loadAssetTest = function () {
            AssetManager.preLoadAvatarAsset(this._avatarID, Callback.New(function () {
                this.event(GameUI.EVENT_TEST_LOAD_CHILD_UI);
            }, this), this._syncLoadedEventWhenAssetExist);
        };
        UIAvatar.prototype.dispose = function () {
            if (!this.isDisposed) {
                if (this._avatar) {
                    this._avatar.dispose();
                    this._avatar = null;
                }
                else if (this._avatarID > 0) {
                    AssetManager.disposeAvatarAsset(this._avatarID);
                }
            }
            _super.prototype.dispose.call(this, true);
        };
        UIAvatar.prototype.inEditorInit = function () {
            this.width = 192;
            this.height = 192;
            this.avatarID = 1;
        };
        Object.defineProperty(UIAvatar.prototype, "avatar", {
            get: function () { return this._avatar; },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UIAvatar.prototype, "avatarID", {
            get: function () {
                return this._avatarID;
            },
            set: function (v) {
                if (v == this._avatarID)
                    return;
                this._avatarID = v;
                this.refresh();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UIAvatar.prototype, "scaleNumber", {
            get: function () {
                return this._scaleNumber;
            },
            set: function (v) {
                if (this._avatar)
                    this._avatar.scaleX = this._scaleNumber = this._avatar.scaleY = v;
                this.refreshSize();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UIAvatar.prototype, "orientationIndex", {
            get: function () {
                return this._orientationIndex;
            },
            set: function (v) {
                this._orientationIndex = v;
                this.refreshAvatar();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UIAvatar.prototype, "avatarFrame", {
            get: function () {
                return this._avatarFrame;
            },
            set: function (v) {
                this._avatarFrame = v;
                this.refreshAvatar();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UIAvatar.prototype, "isPlay", {
            get: function () {
                return this._isPlay;
            },
            set: function (v) {
                this._isPlay = v;
                this.refreshAvatar();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UIAvatar.prototype, "avatarInterval", {
            get: function () {
                return this._avatarInterval;
            },
            set: function (v) {
                this._avatarInterval = v;
                this.refreshAvatar();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UIAvatar.prototype, "actionID", {
            get: function () {
                return this._actionID;
            },
            set: function (v) {
                this._actionID = v;
                this.refreshAvatar();
            },
            enumerable: true,
            configurable: true
        });
        UIAvatar.prototype.refresh = function () {
            var _this = this;
            if (this._avatar) {
                this._avatar.dispose();
            }
            this._avatar = new Avatar();
            this._avatar.id = this.avatarID;
            this._avatar.actionID = this.actionID;
            this._avatar.orientation = GameUtils.getOriByIndex(this.orientationIndex);
            this._avatar.once(EventObject.LOADED, this, function () {
                if (_this.isDisposed)
                    return;
                var realBound = _this._avatarBound = _this._avatar.getBounds();
                _this.refreshAvatar();
                _this.refreshSize();
                _this.addChildAt(_this._avatar, 0);
                _this.event(EventObject.LOADED);
            });
        };
        UIAvatar.prototype.refreshAvatar = function () {
            if (!this._avatar)
                return;
            this._avatar.orientation = GameUtils.getOriByIndex(this.orientationIndex);
            this.isPlay ? this._avatar.gotoAndPlay(this.avatarFrame, true, true) : this._avatar.stop(this.avatarFrame);
            this._avatar.setPlayInterval(this.avatarInterval);
            this._avatar.actionID = this.actionID;
            this.scaleNumber = this.scaleNumber;
        };
        UIAvatar.prototype.refreshSize = function () {
            if (this._avatarBound) {
                var realBound = this._avatarBound;
                this.width = realBound.width * this._avatar.scaleX;
                this.height = realBound.height * this._avatar.scaleY;
                this.hitArea = new Rectangle(realBound.x * this._avatar.scaleX, realBound.y * this._avatar.scaleY, this.width, this.height);
            }
        };
        return UIAvatar;
    }(UIComponent.UIBase));
    UIComponent.UIAvatar = UIAvatar;
})(UIComponent || (UIComponent = {}));





var UIComponent;
(function (UIComponent) {
    var UIInput = (function (_super) {
        __extends(UIInput, _super);
        function UIInput() {
            _super.call(this, !Config.EDIT_MODE);
            this._inputMode = 0;
            this.className = "UIInput";
        }
        UIInput.prototype.inEditorInit = function () {
            this.width = 200;
            this.height = 30;
            this.text = "默认文本";
            this.fontSize = 16;
            this.mouseEventEnabledData = true;
            this.valign = 1;
            this.align = 1;
        };
        UIInput.prototype.focus = function () {
            this._tf.focus = true;
        };
        Object.defineProperty(UIInput.prototype, "restrict", {
            get: function () {
                return this._restrict ? this._restrict : "";
            },
            set: function (v) {
                this._restrict = this._tf.restrict = v ? v : "";
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UIInput.prototype, "inputMode", {
            get: function () {
                return this._inputMode;
            },
            set: function (v) {
                var lastInputMode = this._inputMode;
                this._inputMode = v;
                switch (v) {
                    case 0:
                        this._tf.type = "text";
                        break;
                    case 1:
                        this._tf.type = "password";
                        break;
                    case 2:
                        this._tf.type = "number";
                        break;
                    case 3:
                        break;
                }
                if ((lastInputMode <= 2 && v == 3) || (lastInputMode == 3 && v < 3)) {
                    this.changeTextInputType();
                }
            },
            enumerable: true,
            configurable: true
        });
        UIInput.prototype.changeTextInputType = function () {
            var oldTf = this._tf;
            if (this._tf.parent)
                this._tf.parent.removeChild(this._tf);
            if (this._inputMode == 3) {
                this._tf = new TextArea();
            }
            else {
                this._tf = new TextInput();
            }
            this.addChild(this._tf);
            var recoveryAttrs = ["text", "color", "fontSize", "leading", "align", "valign",
                "bold", "width", "height", "font", "overflow", "wordWrap", "restrict"];
            for (var i in recoveryAttrs) {
                this._tf[recoveryAttrs[i]] = oldTf[recoveryAttrs[i]];
            }
            if (this._inputMode == 3) {
                this._tf.valign = "top";
            }
            if (Config.EDIT_MODE) {
                this._tf.mouseEnabled = false;
            }
        };
        return UIInput;
    }(UIComponent.UIString));
    UIComponent.UIInput = UIInput;
})(UIComponent || (UIComponent = {}));





var UIComponent;
(function (UIComponent) {
    var UIList = (function (_super) {
        __extends(UIList, _super);
        function UIList() {
            _super.call(this);
            this._selectEnable = true;
            this._selectedIndex = -1;
            this._items = [];
            this._selectedImageOnTop = true;
            this._overImageOnTop = true;
            this._itemSize = 0;
            this.subitemIndentation = 20;
            this.className = "UIList";
            this._contentArea = new GameSprite();
            this._overImage = new UIImage();
            this._selectedImage = new UIImage();
            this._overImage.visible = false;
            this.refreshLayer();
            this.enabledLimitView = true;
            this.scrollShowType = 2;
            if (Config.EDIT_MODE) {
                Callback.CallLater(this.itemsPreview, this);
            }
        }
        UIList.prototype.inEditorInit = function () {
            this._itemWidth = 200;
            this._itemHeight = 50;
            this._spaceX = 2;
            this._spaceY = 20;
            this.overImageURL = "asset/image/picture/UI/dgm_input2.png";
            this.selectImageURL = "asset/image/picture/UI/dgm_input3.png";
            this.selectedImageAlpha = 0.5;
            this.overImageAlpha = 0.5;
        };
        UIList.prototype.itemsPreview = function () {
            if (!Config.EDIT_MODE || !this.stage)
                return;
            var arr = [];
            for (var i = 0; i < 50; i++) {
                var d = new UIListItemData();
                arr.push(d);
            }
            this.items = arr;
            this.selectedIndex = 0;
        };
        Object.defineProperty(UIList.prototype, "selectEnable", {
            get: function () {
                return this._selectEnable;
            },
            set: function (v) {
                if (this._selectEnable != v) {
                    this._selectEnable = v;
                    this._overImage.visible = v;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UIList.prototype, "repeatX", {
            get: function () {
                return this._repeatX;
            },
            set: function (v) {
                if (this._repeatX != v) {
                    this._repeatX = v;
                    if (this._repeatX < 1)
                        this._repeatX = 1;
                    this.refreshOrder();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UIList.prototype, "spaceX", {
            get: function () {
                return this._spaceX;
            },
            set: function (v) {
                if (this._spaceX != v) {
                    this._spaceX = v;
                    this.refreshOrder();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UIList.prototype, "spaceY", {
            get: function () {
                return this._spaceY;
            },
            set: function (v) {
                if (this._spaceY != v) {
                    this._spaceY = v;
                    this.refreshOrder();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UIList.prototype, "itemWidth", {
            get: function () {
                return this._itemWidth;
            },
            set: function (v) {
                if (this._itemWidth != v) {
                    this._itemWidth = v;
                    if (this._itemWidth < 1)
                        this._itemWidth = 1;
                    this.refreshOrder();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UIList.prototype, "itemHeight", {
            get: function () {
                return this._itemHeight;
            },
            set: function (v) {
                if (this._itemHeight != v) {
                    this._itemHeight = v;
                    if (this._itemHeight < 1)
                        this._itemHeight = 1;
                    this.refreshOrder();
                }
            },
            enumerable: true,
            configurable: true
        });
        UIList.prototype.scrollTo = function (index, ignoreAlreadyInVisible, tween, duration, ease, complete) {
            if (ignoreAlreadyInVisible === void 0) { ignoreAlreadyInVisible = true; }
            if (tween === void 0) { tween = false; }
            if (duration === void 0) { duration = 0; }
            if (ease === void 0) { ease = null; }
            if (complete === void 0) { complete = null; }
            var column = index % this.repeatX;
            var row = Math.floor(index / this.repeatX);
            var px = column * (this.itemWidth + this.spaceX);
            var py = row * (this.itemHeight + this.spaceY);
            var rect = new Rectangle(px, py, this.itemWidth, this.itemHeight);
            var points = [[rect.x, rect.y], [rect.right, rect.y], [rect.right, rect.bottom], [rect.x, rect.bottom]];
            var needScrollTo = false;
            var myScrollRect = this._myScrollRect.clone();
            if (this._vScrollBar.visible)
                myScrollRect.width -= this.scrollWidth;
            if (this._hScrollBar.visible)
                myScrollRect.height -= this.scrollWidth;
            if (ignoreAlreadyInVisible) {
                for (var i in points) {
                    var p = points[i];
                    if (!myScrollRect.contains(p[0], p[1])) {
                        needScrollTo = true;
                    }
                }
                if (!needScrollTo)
                    return;
            }
            var totalWidth = this._contentWidth - this._myScrollRect.width;
            var totalHeight = this._contentHeight - this._myScrollRect.height;
            var perX = px / totalWidth * 100;
            var perY = py / totalHeight * 100;
            if (tween) {
                Tween.to(this._hScrollBar, { value: perX }, duration, ease, complete);
                Tween.to(this._vScrollBar, { value: perY }, duration, ease, complete);
            }
            else {
                this._hScrollBar.value = perX;
                this._vScrollBar.value = perY;
            }
        };
        UIList.prototype.calcTotalContentSize = function () {
            var itemLen = this._itemSize;
            var itemColumnNum = Math.min(itemLen, this.repeatX);
            var itemRowNum = Math.ceil(itemLen / this.repeatX);
            var maxW = (itemColumnNum * this.itemWidth) + Math.max(itemColumnNum - 1, 0) * this.spaceX;
            var maxH = (itemRowNum * this.itemHeight) + Math.max(itemRowNum - 1, 0) * this.spaceY;
            return { maxW: maxW, maxH: maxH };
        };
        Object.defineProperty(UIList.prototype, "overImageURL", {
            get: function () {
                return this._overImageURL;
            },
            set: function (v) {
                if (this._overImageURL != v) {
                    this._overImageURL = v;
                    this._overImage.skin = v;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UIList.prototype, "overImage", {
            get: function () {
                return this._overImage;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UIList.prototype, "selectImageURL", {
            get: function () {
                return this._selectImageURL;
            },
            set: function (v) {
                if (this._selectImageURL != v) {
                    this._selectImageURL = v;
                    this._selectedImage.skin = v;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UIList.prototype, "selectImage", {
            get: function () {
                return this._selectedImage;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UIList.prototype, "overImageGrid9", {
            get: function () {
                return this._overImageGrid9;
            },
            set: function (v) {
                if (this._overImageGrid9 != v) {
                    this._overImageGrid9 = v;
                    this._overImage.sizeGrid = v;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UIList.prototype, "selectImageGrid9", {
            get: function () {
                return this._selectImageGrid9;
            },
            set: function (v) {
                if (this._selectImageGrid9 != v) {
                    this._selectImageGrid9 = v;
                    this._selectedImage.sizeGrid = v;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UIList.prototype, "selectedImageAlpha", {
            get: function () {
                return this._selectedImageAlpha;
            },
            set: function (v) {
                if (this._selectedImageAlpha != v) {
                    this._selectedImageAlpha = v;
                    this._selectedImage.alpha = v;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UIList.prototype, "overImageAlpha", {
            get: function () {
                return this._overImageAlpha;
            },
            set: function (v) {
                if (this._overImageAlpha != v) {
                    this._overImageAlpha = v;
                    this._overImage.alpha = v;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UIList.prototype, "selectedImageOnTop", {
            get: function () {
                return this._selectedImageOnTop;
            },
            set: function (v) {
                if (this._selectedImageOnTop != v) {
                    this._selectedImageOnTop = v;
                    this.refreshLayer();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UIList.prototype, "overImageOnTop", {
            get: function () {
                return this._overImageOnTop;
            },
            set: function (v) {
                if (this._overImageOnTop != v) {
                    this._overImageOnTop = v;
                    this.refreshLayer();
                }
            },
            enumerable: true,
            configurable: true
        });
        UIList.prototype.refreshLayer = function () {
            if (!this._selectedImageOnTop) {
                this.addChild(this._selectedImage);
            }
            if (!this._overImageOnTop) {
                this.addChild(this._overImage);
            }
            this.addChild(this._contentArea);
            if (this._selectedImageOnTop) {
                this.addChild(this._selectedImage);
            }
            if (this._overImageOnTop) {
                this.addChild(this._overImage);
            }
        };
        Object.defineProperty(UIList.prototype, "itemModelClass", {
            get: function () {
                return this._itemModelClass;
            },
            set: function (v) {
                if (this._itemModelClass != v) {
                    this._itemModelClass = v;
                    this._itemModelGUI = 0;
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UIList.prototype, "itemModelGUI", {
            get: function () {
                return this._itemModelGUI;
            },
            set: function (v) {
                if (this._itemModelGUI != v) {
                    this._itemModelGUI = v;
                    var uiData = Common.uiList.data[v];
                    if (!uiData) {
                        this._itemModelClass = null;
                        this.itemsPreview();
                        return;
                    }
                    var instanceClassName = uiData.uiDisplayData.instanceClassName;
                    var classObj = window[instanceClassName];
                    if (!classObj)
                        classObj = window["GUI_" + v];
                    this._itemModelClass = classObj;
                    this.itemsPreview();
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UIList.prototype, "items", {
            get: function () {
                return this._items;
            },
            set: function (v) {
                var lastSelectedItem = this.selectedItem;
                for (var i = 0; i < this._contentArea.numChildren; i++) {
                    var item = this._contentArea.getChildAt(i);
                    item.dispose();
                    i--;
                }
                this._items = [];
                if (Config.EDIT_MODE || this._itemModelClass) {
                    var len = v.length;
                    for (var i = 0; i < len; i++) {
                        var node = v[i];
                        var nodeChildren = node.getList();
                        var childrenlen = nodeChildren.length;
                        for (var s = 0; s < childrenlen; s++) {
                            var data = nodeChildren[s];
                            this._items.push(data);
                            var ui;
                            if (Config.EDIT_MODE) {
                                ui = GameUI.load(this.itemModelGUI, true);
                            }
                            else {
                                ui = new this._itemModelClass(false, this._itemModelGUI);
                            }
                            this._contentArea.addChild(ui);
                            this.itemInit(ui, data);
                        }
                    }
                    this.refreshOrder();
                }
                this.selectedItem = this.selectedItem;
            },
            enumerable: true,
            configurable: true
        });
        UIList.prototype.itemInit = function (ui, data) {
            var _this = this;
            if (!ui)
                return;
            ui.data = data;
            ui.hitArea = new Rectangle(0, 0, this.itemWidth, this.itemHeight);
            ui.on(EventObject.MOUSE_OVER, this, function (ui) {
                _this._overImage.x = ui.x;
                _this._overImage.y = ui.y;
                _this._overItem = ui;
            }, [ui]);
            ui.on(EventObject.MOUSE_DOWN, this, function (ui, data) {
                _this.selectedItem = data;
            }, [ui, data]);
            ui.on(EventObject.DOUBLE_CLICK, this, function (ui, data) {
                data.isOpen = !data.isOpen;
                _this.refreshOrder();
                _this.event(UIList.EVENT_OPEN_STATE_CHANGE, [ui, data]);
            }, [ui, data]);
            this.refreshItem(data);
            this.onCreateItem && this.onCreateItem.runWith([ui, data]);
        };
        UIList.prototype.refreshItem = function (item) {
            var idx = this.items.indexOf(item);
            if (idx == -1)
                return;
            var ui = this._contentArea.getChildAt(idx);
            var uiNames = item.uiNames;
            for (var i = 0; i < uiNames.length; i++) {
                var attrName = uiNames[i];
                var comp = ui[attrName];
                var value = item[attrName];
                if (comp && comp instanceof UIComponent.UIBase && value != null) {
                    switch (comp.className) {
                        case "UIBitmap":
                            comp.image = value;
                            break;
                        case "UIString":
                            comp.text = value;
                            break;
                        case "UIVariable":
                            comp.varID = value;
                            break;
                        case "UIAvatar":
                            comp.avatarID = value;
                            break;
                        case "UIAnimation":
                            comp.animationID = value;
                            break;
                        case "UIInput":
                            comp.text = value;
                            break;
                        case "UICheckBox":
                            comp.selected = value;
                            break;
                        case "UISwitch":
                            comp.switchID = value;
                            break;
                        case "UITabBox":
                            comp.items = value;
                            break;
                        case "UISlider":
                            comp.value = value;
                            break;
                        case "UIGUI":
                            comp.guiID = value;
                            break;
                        case "UIList":
                            comp.items = value;
                            break;
                    }
                }
            }
        };
        Object.defineProperty(UIList.prototype, "length", {
            get: function () { return this._items.length; },
            enumerable: true,
            configurable: true
        });
        ;
        Object.defineProperty(UIList.prototype, "selectedItem", {
            get: function () {
                return this._selectedItem;
            },
            set: function (v) {
                var idx = this._items.indexOf(v);
                this._selectedItem = idx != -1 ? v : null;
                this.selectedIndex = idx;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(UIList.prototype, "selectedIndex", {
            get: function () {
                return this._selectedIndex;
            },
            set: function (v) {
                if (this._selectedIndex != v) {
                    this._selectedIndex = v;
                    this.refreshSelectedImagePos();
                    this.event(EventObject.CHANGE);
                }
            },
            enumerable: true,
            configurable: true
        });
        UIList.prototype.refreshSelectedImagePos = function () {
            if (this.selectedIndex < 0 || this.selectedIndex >= this._contentArea.numChildren) {
                this._selectedImage.visible = false;
                return;
            }
            var ui = this._contentArea.getChildAt(this.selectedIndex);
            if (!ui) {
                this._selectedImage.visible = false;
                return;
            }
            this._selectedImage.visible = ui.visible;
            this._selectedImage.x = ui.x;
            this._selectedImage.y = ui.y;
        };
        UIList.prototype.refreshOrder = function () {
            var len = this._contentArea.numChildren;
            this._itemSize = 0;
            for (var i = 0, s = 0; i < len; i++) {
                var ui = this._contentArea.getChildAt(i);
                var data = ui.data;
                if (data.isHideNode) {
                    ui.visible = false;
                    continue;
                }
                this._itemSize++;
                ui.visible = true;
                ui.x = (s % this.repeatX) * (this._itemWidth + this._spaceX) + data.depth * this.subitemIndentation;
                ui.y = Math.floor(s / this.repeatX) * (this._itemHeight + this._spaceY);
                s++;
            }
            this._overImage.visible = s > 0 && this.selectEnable;
            this._contentArea.width = (this._itemWidth * this.repeatX) + (this._spaceX * this.repeatX - 1);
            this._contentArea.height = Math.ceil(len / this.repeatX) * this._itemHeight + Math.max(0, Math.ceil(len / this.repeatX) - 1) * this._spaceY;
            this._overImage.width = this._itemWidth;
            this._overImage.height = this._itemHeight;
            if (this._overItem) {
                this._overImage.x = this._overItem.x;
                this._overImage.y = this._overItem.y;
            }
            this._selectedImage.width = this._itemWidth;
            this._selectedImage.height = this._itemHeight;
            this.refreshSelectedImagePos();
            this.refresh();
        };
        UIList.EVENT_OPEN_STATE_CHANGE = "UIList_EVENT_OPEN_STATE_CHANGE";
        return UIList;
    }(UIComponent.UIRoot));
    UIComponent.UIList = UIList;
})(UIComponent || (UIComponent = {}));





var AnimationAnimationLayer = (function (_super) {
    __extends(AnimationAnimationLayer, _super);
    function AnimationAnimationLayer() {
        _super.apply(this, arguments);
        this.type = AnimationItemType.Animation;
        this.loop = false;
    }
    Object.defineProperty(AnimationAnimationLayer.prototype, "animationId", {
        get: function () { return this._animationId; },
        set: function (v) {
            if (this._animationId == v)
                return;
            this._animationId = v;
            if (this._animationInstance)
                this.removeChild(this._animationInstance);
            this._animationInstance = null;
            this._animationInstance = new Animation();
            this._animationInstance.once(EventObject.LOADED, this, this.onAnimationLoaded);
            this._animationInstance.id = v;
            this.addChildAt(this._animationInstance, 0);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AnimationAnimationLayer.prototype, "animationInstance", {
        get: function () { return this._animationInstance; },
        enumerable: true,
        configurable: true
    });
    AnimationAnimationLayer.prototype.onAnimationLoaded = function () {
        if (this._animationInstance.isParticle) {
            this.setBounds(new Rectangle(-96, -133, 192, 192));
            this.hitArea = new Rectangle(-96, -133, 192, 192);
        }
        this.event(EventObject.LOADED);
        this.updateFrame();
    };
    AnimationAnimationLayer.prototype.setData = function (data) {
        _super.prototype.setData.call(this, data);
        this.animationId = data.animationId;
    };
    AnimationAnimationLayer.prototype.toAnimationLayerData = function () {
        var data = _super.prototype.toAnimationLayerData.call(this);
        data.animationId = this.animationId;
        return data;
    };
    AnimationAnimationLayer.prototype.fromAnimationFrameData = function (framedata) {
        _super.prototype.fromAnimationFrameData.call(this, framedata);
        if (framedata.scaleX == undefined)
            framedata.scaleX = 1;
        if (framedata.scaleY == undefined)
            framedata.scaleY = 1;
        this.scaleX = framedata.scaleX;
        this.scaleY = framedata.scaleY;
        if (!this.animation)
            return;
        if (!this._animationInstance)
            return;
        this._animationInstance.visible = false;
        var len = this.frames ? this.frames.length : 0;
        var totalFrame = this.animation.totalFrame ? this.animation.totalFrame : 0;
        if (len == 0 || totalFrame == 0) {
            this._animationInstance.stop();
            return;
        }
        var firstFrame = this.frames[0].index;
        var lastFrame = 0;
        if (len == 1) {
            lastFrame = totalFrame - 1;
        }
        else if (len >= 2) {
            lastFrame = this.frames[len - 1].index;
        }
        if (this._frameIndex >= firstFrame && this._frameIndex <= lastFrame) {
            this._animationInstance.visible = true;
            if (!this._animationInstance.isParticle) {
                this._animationInstance["_isPlaying"] = this.animation["_isPlaying"];
                var subFrame = ((this._frameIndex - firstFrame) / this.animation.fps) * this._animationInstance.fps;
                if (this.loop)
                    subFrame = subFrame % this._animationInstance.totalFrame;
                Animation.getChildrenLayers(this._animationInstance).forEach(function (layer) {
                    layer.showFrame(subFrame);
                });
            }
            else {
                this._animationInstance.play();
            }
        }
        else {
            this._animationInstance.stop();
        }
    };
    AnimationAnimationLayer.prototype.toAnimationFrameData = function (framedata) {
        framedata = _super.prototype.toAnimationFrameData.call(this, framedata);
        framedata.scaleX = this.scaleX;
        framedata.scaleY = this.scaleY;
        return framedata;
    };
    AnimationAnimationLayer.prototype.interpolationFrame = function (pf, nf, frameIndex) {
        var frame = _super.prototype.interpolationFrame.call(this, pf, nf, frameIndex);
        if (pf.scaleX == undefined)
            pf.scaleX = 1;
        if (pf.scaleY == undefined)
            pf.scaleY = 1;
        var t = (frameIndex - pf.index) / (nf.index - pf.index);
        var tween = GameUtils.getTween(nf.tweenID)[0];
        frame.scaleX = tween(t, pf.scaleX, nf.scaleX - pf.scaleX, 1);
        frame.scaleY = tween(t, pf.scaleY, nf.scaleY - pf.scaleY, 1);
        return frame;
    };
    return AnimationAnimationLayer;
}(AnimationDisplayLayer));
AnimationLayer.typeClsMap[AnimationItemType.Animation] = AnimationAnimationLayer;
var playerMap = {};
Game.playerKey = Math.floor(Math.random() * 20000 + 20) + "_asdasdasd";
var layer3Test;
var globalC;
function main() {
    var _this = this;
    ClientWorld.init();
    return;
    EventUtils.addEventListener(ClientWorld, ClientWorld.EVENT_INITED, Callback.New(function () {
        var a = new GUI_1();
        stage.addChild(a);
        AssetManager.preLoadUIAsset(6, Callback.New(function () {
            var root1 = new UIListItemData();
            var root2 = new UIListItemData();
            var arr = [];
            for (var i = 0; i < 5; i++) {
                var d = new UIListItemData();
                root1.addChild(d);
            }
            root2.isOpen = false;
            for (var i = 0; i < 5; i++) {
                var d = new UIListItemData();
                root2.addChild(d);
            }
            for (var i = 0; i < 5; i++) {
                var d = new UIListItemData();
                root1.getChildAt(2).addChild(d);
            }
            a.List.items = [root1, root2];
        }, _this));
        a.Login.on(EventObject.CLICK, _this, function () {
            stage.removeChild(a);
            a.dispose();
            ClientWorld.startLogin(Callback.New(function () {
            }, this), Callback.New(function () {
            }, this));
        });
    }, this), true);
    Stat.show();
    return;
    var clientMain = new ClientMain(new Callback(function () {
        return;
        clientMain.startLogin(new Callback(function () {
            Font.defaultFamily = "微软雅黑";
            var d = new GameData();
            var a = {
                set scale(v) {
                    Game.currentScene.setCameraScale(v, v);
                },
                get scale() {
                    return Game.currentScene.displayObject.scaleX;
                }
            };
            function goto(sx, sy) {
                Tween.to(a, { scale: sx }, 2000, Ease.backInOut, Handler.create(this, function () {
                    goto(sx == 0.5 ? 2 : 0.5, sy == 0.5 ? 2 : 0.5);
                }));
            }
            globalC = new ColorFilter([
                1, 0, 0, 0.3, 0,
                0, 1, 0, 0, 0,
                0, 0, 1, 0, 0,
                0, 0, 0, 1, 0,
            ]);
            setTimeout(function () {
                if ("图层1色调变更" == "") {
                    var a = 0, d = 0.01;
                    os.add_ENTERFRAME(function () {
                        var c = new ColorFilter([
                            1, 0, 0, a, 0,
                            0, 1, 0, 0, 0,
                            0, 0, 1, 0, 0,
                            0, 0, 0, 1, 0,
                        ]);
                        Game.currentScene.layers[0].filters = [c];
                        a += d;
                        if (a >= 1 || a <= -1) {
                            d *= -1;
                        }
                    }, this);
                }
            }, 2000);
            function tonal() {
            }
            return;
            for (var n = 0; n < 100; n++) {
                var oriMapping = {
                    0: 4,
                    1: 7,
                    2: 8,
                    3: 9,
                    4: 6,
                    5: 3,
                    6: 2,
                    7: 1
                };
                var avatar = new Avatar();
                avatar.picUrls = [
                    "asset/test/哥布林-攻击.png",
                    "asset/test/哥布林-移动.png",
                    "asset/test/哥布林-待机.png"
                ];
                var act0 = new AvatarAction();
                act0.id = 1;
                var debugStr = "[";
                for (var y = 0; y < 8; y++) {
                    var ori = oriMapping[y];
                    act0.frameImageInfo[ori] = [];
                    debugStr += "[";
                    for (var x = 0; x < 8; x++) {
                        var aImg = new AvatarFrameImage();
                        aImg.picUrlIndex = 0;
                        aImg.rect = new Rectangle(-x * 192, -y * 192, 192, 192);
                        act0.frameImageInfo[ori][x] = aImg;
                        debugStr += "{\"picUrlIndex\":" + aImg.picUrlIndex + ",\"rect\":[" + aImg.rect.x + "," + aImg.rect.y + "," + aImg.rect.width + "," + aImg.rect.height + "],\"x\":-85,\"y\":-117}";
                        if (x != 7) {
                            debugStr += ",";
                        }
                    }
                    debugStr += "]";
                    if (y != 7) {
                        debugStr += ",";
                    }
                }
                debugStr += "]";
                trace(debugStr);
                return;
                avatar.actionListArr.push(act0);
                avatar.orientation = 9;
                avatar.x = Math.floor(n / 7) * 50;
                avatar.y = n % 7 * 50;
                stage.addChild(avatar);
                os.add_ENTERFRAME(function (avatar) {
                    avatar.onRender();
                }, this, [avatar]);
            }
        }, this), new Callback(function () {
            trace("网络错误");
        }, this));
    }, this));
    stage.add_KEYDOWN(function (e) {
        if (e.keyCode == Keyboard.A) {
            for (var i in AssetManager.assetMap) {
                trace(i, "=", AssetManager.assetMap[i]);
            }
        }
    }, this);
}
parent.window["onunload"] = window["onunload"] = function (isRealClose) {
    parent.window["onunload"] = window["onunload"] = null;
    GameAudio.stopBGM();
    GameAudio.stopSE();
    GameAudio.stopBGS();
    if (typeof top["kdsrpg"] != "undefined") {
        top["frameRef"](-1);
    }
    return false;
};
window.addEventListener("mousedown", function (e) {
    if (typeof top["kdsrpg"] == "undefined")
        return;
    var ev = new Event("mousedown");
    ev.domain = "midCanvas";
    ev.clientX = e.clientX;
    ev.clientY = e.clientY + 32;
    parent.window.dispatchEvent(ev);
});
window.addEventListener("mousemove", function (e) {
    if (typeof top["kdsrpg"] == "undefined")
        return;
    var ev = new Event("mousemove");
    ev.domain = "midCanvas";
    ev.clientX = e.clientX;
    ev.clientY = e.clientY + 32;
    parent.window.dispatchEvent(ev);
});
window.addEventListener("onmouseup", function (e) {
    if (typeof top["kdsrpg"] == "undefined")
        return;
    var ev = new Event("mouseup");
    ev.domain = "midCanvas";
    ev.clientX = e.clientX;
    ev.clientY = e.clientY + 32;
    parent.window.dispatchEvent(ev);
});





var MyGameCreatorEditorUI;
(function (MyGameCreatorEditorUI) {
    var Editor;
    (function (Editor) {
        var blockchain;
        (function (blockchain) {
            var NeoInvokeViewUI = (function (_super) {
                __extends(NeoInvokeViewUI, _super);
                function NeoInvokeViewUI() {
                    _super.call(this);
                }
                NeoInvokeViewUI.prototype.createChildren = function () {
                    View.regComponent("NeoInvokeRender", NeoInvokeRender);
                    _super.prototype.createChildren.call(this);
                    this.createView(MyGameCreatorEditorUI.Editor.blockchain.NeoInvokeViewUI.uiView);
                };
                NeoInvokeViewUI.uiView = { "type": "View", "props": { "width": 800, "height": 600 }, "child": [{ "type": "Image", "props": { "y": 30, "x": 30, "top": 0, "skin": "asset/editor/blockchain/neo/dgm_bg.png", "sizeGrid": "2,2,2,2", "right": 0, "left": 0, "bottom": 0 } }, { "type": "Image", "props": { "y": 30, "x": 30, "top": 1, "skin": "asset/editor/blockchain/neo/dgm_bg11.png", "sizeGrid": "2,2,3,14", "right": 1, "left": 1, "height": 25 } }, { "type": "Image", "props": { "width": 599, "top": 85, "skin": "asset/editor/blockchain/neo/dgm_bg8.png", "sizeGrid": "2,2,2,2", "centerX": 0, "bottom": 70 } }, { "type": "Label", "props": { "y": 30, "x": 50, "top": 7, "text": "调用NEO钱包", "styleSkin": "comp/label.png", "left": 20, "color": "#ffffff" } }, { "type": "Clip", "props": { "y": 25, "x": 499, "width": 16, "var": "closeBtn", "top": 5, "skin": "asset/editor/blockchain/neo/a_close.png", "right": 5, "index": 0, "height": 16, "clipY": 3 } }, { "type": "Box", "props": { "width": 592, "top": 85, "centerX": 0, "bottom": 70 }, "child": [{ "type": "Label", "props": { "y": -40, "x": -84, "var": "nameText", "top": 7, "text": "名称", "styleSkin": "comp/label.png", "left": 20, "fontSize": 16, "color": "#ffffff" } }, { "type": "Label", "props": { "top": 44, "text": "您的钱包：", "styleSkin": "comp/label.png", "left": 20, "color": "#ffffff" } }, { "type": "Label", "props": { "var": "walletText", "underline": true, "top": 44, "text": "未登陆", "styleSkin": "comp/label.png", "left": 89, "color": "#ffffff" } }, { "type": "Label", "props": { "top": 74, "text": "合约地址：", "styleSkin": "comp/label.png", "left": 20, "color": "#ffffff" } }, { "type": "Label", "props": { "var": "contractText", "top": 74, "text": 0, "styleSkin": "comp/label.png", "left": 91, "color": "#ffffff" } }, { "type": "Label", "props": { "top": 106, "text": "操作参数:", "styleSkin": "comp/label.png", "left": 20, "color": "#ffffff" } }, { "type": "Label", "props": { "var": "operationText", "top": 106, "text": 0, "styleSkin": "comp/label.png", "left": 91, "color": "#ffffff" } }, { "type": "Label", "props": { "top": 136, "text": "参数:", "styleSkin": "comp/label.png", "left": 20, "color": "#ffffff" } }, { "type": "Label", "props": { "var": "argsText", "top": 136, "text": 0, "styleSkin": "comp/label.png", "left": 91, "color": "#ffffff" } }, { "type": "Image", "props": { "y": 171, "var": "listBg", "skin": "asset/editor/blockchain/neo/dgm_bg9.png", "sizeGrid": "2,2,2,2", "right": 20, "left": 20, "height": 225 } }, { "type": "List", "props": { "y": 175, "width": 552, "var": "argsList", "vScrollBarSkin": "“”", "spaceY": 4, "right": 20, "repeatY": 5, "repeatX": 1, "left": 20, "height": 220 }, "child": [{ "type": "Box", "props": { "y": 0, "runtime": "NeoInvokeRender", "right": 0, "renderType": "render", "left": 0, "height": 40 }, "child": [{ "type": "Image", "props": { "top": 0, "skin": "asset/editor/blockchain/neo/dgm_bg8.png", "sizeGrid": "2,2,2,2", "right": 5, "left": 5, "bottom": 0 } }, { "type": "Label", "props": { "text": "参数名称:", "styleSkin": "comp/label.png", "name": "argsName", "left": 20, "color": "#ffffff", "centerY": 0 } }, { "type": "Image", "props": { "y": 12, "x": 94, "width": 188, "skin": "asset/editor/blockchain/neo/dgm_btn.png", "sizeGrid": "2,2,2,2", "left": 94, "height": 20, "centerY": 0 } }, { "type": "TextInput", "props": { "width": 188, "valign": "middle", "type": "text", "text": "000", "name": "paramText", "left": 94, "height": 20, "color": "#ffffff", "centerY": 0 } }] }] }] }, { "type": "Clip", "props": { "width": 105, "var": "sureBtn", "skin": "asset/editor/blockchain/neo/dgm_pressbtn.png", "right": 260, "height": 26, "clipY": 2, "bottom": 20 }, "child": [{ "type": "Label", "props": { "valign": "middle", "text": "确定", "styleSkin": "comp/label.png", "color": "#a5a5a5", "centerY": -2, "centerX": 0, "align": "center" } }] }, { "type": "Clip", "props": { "width": 105, "var": "cancelBtn", "skin": "asset/editor/blockchain/neo/dgm_pressbtn.png", "right": 105, "height": 26, "clipY": 2, "bottom": 20 }, "child": [{ "type": "Label", "props": { "valign": "middle", "text": "取消", "styleSkin": "comp/label.png", "color": "#a5a5a5", "centerY": -2, "centerX": 0, "align": "center" } }] }] };
                return NeoInvokeViewUI;
            }(View));
            blockchain.NeoInvokeViewUI = NeoInvokeViewUI;
        })(blockchain = Editor.blockchain || (Editor.blockchain = {}));
    })(Editor = MyGameCreatorEditorUI.Editor || (MyGameCreatorEditorUI.Editor = {}));
})(MyGameCreatorEditorUI || (MyGameCreatorEditorUI = {}));
var MyGameCreatorEditorUI;
(function (MyGameCreatorEditorUI) {
    var Editor;
    (function (Editor) {
        var blockchain;
        (function (blockchain) {
            var NeoLoginViewUI = (function (_super) {
                __extends(NeoLoginViewUI, _super);
                function NeoLoginViewUI() {
                    _super.call(this);
                }
                NeoLoginViewUI.prototype.createChildren = function () {
                    _super.prototype.createChildren.call(this);
                    this.createView(MyGameCreatorEditorUI.Editor.blockchain.NeoLoginViewUI.uiView);
                };
                NeoLoginViewUI.uiView = { "type": "View", "props": { "width": 800, "height": 600 }, "child": [{ "type": "Image", "props": { "y": 20, "x": 20, "top": 0, "skin": "asset/editor/blockchain/neo/dgm_bg.png", "sizeGrid": "2,2,2,2", "right": 0, "left": 0, "bottom": 0 } }, { "type": "Image", "props": { "y": 20, "x": 20, "top": 1, "skin": "asset/editor/blockchain/neo/dgm_bg11.png", "sizeGrid": "2,2,3,14", "right": 1, "left": 1, "height": 25 } }, { "type": "Image", "props": { "width": 599, "skin": "asset/editor/blockchain/neo/dgm_bg8.png", "sizeGrid": "2,2,2,2", "height": 530, "centerY": 0, "centerX": 0 } }, { "type": "Label", "props": { "y": 20, "x": 40, "top": 7, "text": "NEO钱包", "styleSkin": "comp/label.png", "left": 20, "color": "#ffffff" } }, { "type": "Clip", "props": { "y": 15, "x": 489, "width": 16, "var": "closeBtn", "top": 5, "skin": "asset/editor/blockchain/neo/a_close.png", "right": 5, "index": 0, "height": 16, "clipY": 3 } }, { "type": "Box", "props": { "y": 37, "width": 592, "height": 500, "centerX": 0 }, "child": [{ "type": "Clip", "props": { "y": 0, "width": 296, "var": "loginBtn", "skin": "asset/editor/blockchain/neo/dgm_left.png", "index": 1, "height": 58, "clipY": 2 }, "child": [{ "type": "Label", "props": { "text": "登陆", "styleSkin": "comp/label.png", "fontSize": 24, "color": "#a5a5a5", "centerY": -2, "centerX": 0 } }] }, { "type": "Clip", "props": { "y": 0, "x": 297, "width": 296, "var": "buildBtn", "skin": "asset/editor/blockchain/neo/dgm_right.png", "index": 0, "height": 58, "clipY": 2 }, "child": [{ "type": "Label", "props": { "valign": "middle", "text": "新建", "styleSkin": "comp/label.png", "fontSize": 24, "color": "#a5a5a5", "centerY": -2, "centerX": 0 } }] }, { "type": "Box", "props": { "y": 90, "var": "loginBox", "right": 10, "left": 10, "height": 400 }, "child": [{ "type": "Image", "props": { "y": 20, "width": 262, "skin": "asset/editor/blockchain/neo/dgm_tile.png", "height": 73, "centerX": 0 }, "child": [{ "type": "Label", "props": { "text": "登陆你的钱包", "styleSkin": "comp/label.png", "fontSize": 30, "color": "#a5a5a5", "centerY": -2, "centerX": 0 } }] }, { "type": "Box", "props": { "y": 130, "centerX": 0 }, "child": [{ "type": "Label", "props": { "valign": "middle", "text": "输入你的密钥库文件地址", "styleSkin": "comp/label.png", "fontSize": 20, "color": "#a5a5a5", "align": "center" }, "child": [{ "type": "Label", "props": { "y": 0, "x": 223, "valign": "middle", "text": "*", "styleSkin": "comp/label.png", "fontSize": 20, "color": "#f81612", "align": "center" } }] }, { "type": "Image", "props": { "y": 32, "width": 275, "skin": "asset/editor/blockchain/neo/dgm_input.png", "height": 32 }, "child": [{ "type": "TextInput", "props": { "y": 0, "x": 0, "width": 275, "var": "fileUrl", "height": 32, "fontSize": 20, "editable": false, "color": "#a5a5a5" } }] }, { "type": "Clip", "props": { "y": 32, "x": 313, "width": 120, "var": "openAssetBtn", "skin": "asset/editor/blockchain/neo/dgm_pressbtn.png", "height": 32, "clipY": 2 }, "child": [{ "type": "Label", "props": { "text": "打开文件", "styleSkin": "comp/label.png", "fontSize": 20, "color": "#a5a5a5", "centerY": -2, "centerX": 0 } }] }, { "type": "Image", "props": { "y": 107, "width": 275, "skin": "asset/editor/blockchain/neo/dgm_input.png", "height": 32 }, "child": [{ "type": "TextInput", "props": { "y": 0, "x": 0, "width": 275, "var": "pwInput", "type": "password", "height": 32, "fontSize": 20, "color": "#a5a5a5" } }] }, { "type": "Label", "props": { "y": 73, "valign": "middle", "text": "输入密码", "styleSkin": "comp/label.png", "fontSize": 20, "color": "#a5a5a5", "align": "center" }, "child": [{ "type": "Label", "props": { "y": 0, "x": 85, "valign": "middle", "text": "*", "styleSkin": "comp/label.png", "fontSize": 20, "color": "#f81612", "align": "center" } }] }] }, { "type": "Clip", "props": { "y": 24, "width": 96, "var": "wifLogin", "skin": "asset/editor/blockchain/neo/dgm_pressbtn.png", "right": 5, "height": 28, "clipY": 2 }, "child": [{ "type": "Label", "props": { "text": "WIF登陆", "styleSkin": "comp/label.png", "fontSize": 18, "color": "#a5a5a5", "centerY": -2, "centerX": 0 } }] }, { "type": "Image", "props": { "y": 318, "skin": "asset/editor/blockchain/neo/dgm_line.png", "right": 0, "left": 0, "height": 5 } }, { "type": "Clip", "props": { "y": 338, "width": 200, "var": "toLogin", "skin": "asset/editor/blockchain/neo/dgm_pressbtn.png", "height": 40, "clipY": 2, "centerX": 0 }, "child": [{ "type": "Label", "props": { "text": "登陆", "styleSkin": "comp/label.png", "fontSize": 20, "color": "#a5a5a5", "centerY": -2, "centerX": 0 } }] }] }, { "type": "Box", "props": { "y": 90, "width": 572, "visible": false, "var": "buildBox", "right": 10, "left": 10, "height": 400 }, "child": [{ "type": "Image", "props": { "y": 20, "width": 262, "skin": "asset/editor/blockchain/neo/dgm_tile.png", "height": 73, "centerX": 0 }, "child": [{ "type": "Label", "props": { "valign": "middle", "text": "新建一个钱包", "styleSkin": "comp/label.png", "fontSize": 30, "color": "#a5a5a5", "centerY": -2, "centerX": 0, "align": "center" } }] }, { "type": "Box", "props": { "y": 107, "centerX": 0 }, "child": [{ "type": "Label", "props": { "valign": "middle", "text": "钱包名称", "styleSkin": "comp/label.png", "fontSize": 20, "color": "#a5a5a5", "align": "center" }, "child": [{ "type": "Label", "props": { "y": 0, "x": 85, "valign": "middle", "text": "*", "styleSkin": "comp/label.png", "fontSize": 20, "color": "#f81612", "align": "center" } }] }, { "type": "Image", "props": { "y": 26, "width": 275, "skin": "asset/editor/blockchain/neo/dgm_input.png", "height": 32 } }, { "type": "TextInput", "props": { "y": 26, "width": 275, "var": "registerName", "height": 32, "fontSize": 20, "color": "#a5a5a5" } }, { "type": "Label", "props": { "y": 66, "valign": "middle", "text": "输入密码", "styleSkin": "comp/label.png", "fontSize": 20, "color": "#a5a5a5", "align": "center" }, "child": [{ "type": "Label", "props": { "y": 0, "x": 85, "valign": "middle", "text": "*", "styleSkin": "comp/label.png", "fontSize": 20, "color": "#f81612", "align": "center" } }] }, { "type": "Image", "props": { "y": 93, "width": 275, "skin": "asset/editor/blockchain/neo/dgm_input.png", "height": 32 } }, { "type": "TextInput", "props": { "y": 93, "width": 275, "var": "registerPW", "type": "password", "height": 32, "fontSize": 20, "color": "#a5a5a5" } }, { "type": "Label", "props": { "y": 132, "valign": "middle", "text": "重复密码", "styleSkin": "comp/label.png", "fontSize": 20, "color": "#a5a5a5", "align": "center" }, "child": [{ "type": "Label", "props": { "y": 0, "x": 85, "valign": "middle", "text": "*", "styleSkin": "comp/label.png", "fontSize": 20, "color": "#f81612", "align": "center" } }] }, { "type": "Image", "props": { "y": 160, "width": 275, "skin": "asset/editor/blockchain/neo/dgm_input.png", "height": 32 } }, { "type": "TextInput", "props": { "y": 160, "width": 275, "var": "registerPW2", "type": "password", "height": 32, "fontSize": 20, "color": "#a5a5a5" } }] }, { "type": "Image", "props": { "y": 318, "skin": "asset/editor/blockchain/neo/dgm_line.png", "right": 0, "left": 0, "height": 5 } }, { "type": "Clip", "props": { "y": 338, "width": 200, "var": "toBuild", "skin": "asset/editor/blockchain/neo/dgm_pressbtn.png", "height": 40, "clipY": 2, "centerX": 0 }, "child": [{ "type": "Label", "props": { "valign": "middle", "text": "新建", "styleSkin": "comp/label.png", "fontSize": 20, "color": "#a5a5a5", "centerY": -2, "centerX": 0, "align": "center" } }] }] }, { "type": "Box", "props": { "y": 90, "x": 10, "visible": false, "var": "loadBox", "right": 10, "left": 10, "height": 400 }, "child": [{ "type": "Image", "props": { "y": 20, "width": 262, "skin": "asset/editor/blockchain/neo/dgm_tile.png", "height": 73, "centerX": 0 }, "child": [{ "type": "Label", "props": { "valign": "middle", "text": "下载钱包文件", "styleSkin": "comp/label.png", "fontSize": 30, "color": "#a5a5a5", "centerY": -2, "centerX": 0, "align": "center" } }] }, { "type": "Clip", "props": { "width": 200, "var": "loadBtn", "skin": "asset/editor/blockchain/neo/dgm_pressbtn.png", "height": 40, "clipY": 2, "centerY": 0, "centerX": 0 }, "child": [{ "type": "Label", "props": { "valign": "middle", "text": "下载", "styleSkin": "comp/label.png", "fontSize": 20, "color": "#a5a5a5", "centerY": -2, "centerX": 0, "align": "center" } }] }, { "type": "Image", "props": { "y": 318, "skin": "asset/editor/blockchain/neo/dgm_line.png", "right": 0, "left": 0, "height": 5 } }, { "type": "Label", "props": { "valign": "middle", "text": "文件一旦丢失，无法恢复，请妥善保管！", "styleSkin": "comp/label.png", "fontSize": 20, "color": "#a5a5a5", "centerX": 0, "bottom": 23, "align": "center" } }] }] }] };
                return NeoLoginViewUI;
            }(View));
            blockchain.NeoLoginViewUI = NeoLoginViewUI;
        })(blockchain = Editor.blockchain || (Editor.blockchain = {}));
    })(Editor = MyGameCreatorEditorUI.Editor || (MyGameCreatorEditorUI.Editor = {}));
})(MyGameCreatorEditorUI || (MyGameCreatorEditorUI = {}));
var MyGameCreatorEditorUI;
(function (MyGameCreatorEditorUI) {
    var Editor;
    (function (Editor) {
        var blockchain;
        (function (blockchain) {
            var NeoTransferViewUI = (function (_super) {
                __extends(NeoTransferViewUI, _super);
                function NeoTransferViewUI() {
                    _super.call(this);
                }
                NeoTransferViewUI.prototype.createChildren = function () {
                    _super.prototype.createChildren.call(this);
                    this.createView(MyGameCreatorEditorUI.Editor.blockchain.NeoTransferViewUI.uiView);
                };
                NeoTransferViewUI.uiView = { "type": "View", "props": { "width": 400, "height": 200 }, "child": [{ "type": "Image", "props": { "y": 40, "x": 40, "top": 0, "skin": "asset/editor/blockchain/neo/dgm_bg.png", "sizeGrid": "2,2,2,2", "right": 0, "left": 0, "bottom": 0 } }, { "type": "Image", "props": { "y": 40, "x": 40, "top": 1, "skin": "asset/editor/blockchain/neo/dgm_bg11.png", "sizeGrid": "2,2,3,14", "right": 1, "left": 1, "height": 25 } }, { "type": "Image", "props": { "top": 35, "skin": "asset/editor/blockchain/neo/dgm_bg8.png", "sizeGrid": "2,2,2,2", "right": 20, "left": 20, "bottom": 35 } }, { "type": "Label", "props": { "y": 40, "x": 60, "top": 7, "text": "转账", "styleSkin": "comp/label.png", "left": 20, "color": "#ffffff" } }, { "type": "Clip", "props": { "y": 35, "x": 509, "width": 16, "var": "closeBtn", "top": 5, "skin": "asset/editor/blockchain/neo/a_close.png", "right": 5, "index": 0, "height": 16, "clipY": 3 } }, { "type": "Box", "props": { "top": 35, "right": 20, "left": 20, "bottom": 35 }, "child": [{ "type": "Label", "props": { "y": -40, "x": -84, "var": "nameText", "top": 7, "text": "土豪请充值", "styleSkin": "comp/label.png", "left": 20, "fontSize": 16, "color": "#ffffff" } }, { "type": "Label", "props": { "top": 33, "text": "您的钱包：", "styleSkin": "comp/label.png", "left": 20, "color": "#ffffff" } }, { "type": "Label", "props": { "var": "walletText", "underline": true, "top": 33, "text": "未登陆", "styleSkin": "comp/label.png", "left": 89, "color": "#ffffff" } }, { "type": "Label", "props": { "top": 56, "text": "收款地址：", "styleSkin": "comp/label.png", "left": 20, "color": "#ffffff" } }, { "type": "Label", "props": { "var": "toAddressText", "top": 56, "text": 0, "styleSkin": "comp/label.png", "left": 89, "color": "#ffffff" } }, { "type": "Label", "props": { "y": 79, "x": 20, "top": 79, "text": "资产类别：", "styleSkin": "comp/label.png", "left": 20, "color": "#ffffff" } }, { "type": "Label", "props": { "y": 79, "x": 89, "var": "assetType", "top": 79, "text": "GAS", "styleSkin": "comp/label.png", "left": 89, "color": "#ffffff" } }, { "type": "Label", "props": { "y": 102, "x": 20, "top": 102, "text": "数额：", "styleSkin": "comp/label.png", "left": 20, "color": "#ffffff" } }, { "type": "Label", "props": { "y": 102, "x": 89, "var": "valueText", "top": 102, "text": 0, "styleSkin": "comp/label.png", "left": 89, "color": "#ffffff" } }, { "type": "Image", "props": { "width": 188, "visible": false, "var": "valueInputBox", "top": 98, "skin": "asset/editor/blockchain/neo/dgm_btn.png", "sizeGrid": "2,2,2,2", "left": 89, "height": 20 }, "child": [{ "type": "TextInput", "props": { "var": "valueInput", "type": "number", "top": -2, "right": 0, "left": 0, "color": "#a5a5a5", "bottom": 2 } }] }] }, { "type": "Clip", "props": { "width": 80, "var": "sureBtn", "skin": "asset/editor/blockchain/neo/dgm_pressbtn.png", "right": 109, "height": 20, "clipY": 2, "bottom": 8 }, "child": [{ "type": "Label", "props": { "valign": "middle", "text": "确定", "styleSkin": "comp/label.png", "color": "#a5a5a5", "centerY": -2, "centerX": 0, "align": "center" } }] }, { "type": "Clip", "props": { "width": 80, "var": "cancelBtn", "skin": "asset/editor/blockchain/neo/dgm_pressbtn.png", "right": 19, "height": 20, "clipY": 2, "bottom": 8 }, "child": [{ "type": "Label", "props": { "valign": "middle", "text": "取消", "styleSkin": "comp/label.png", "color": "#a5a5a5", "centerY": -2, "centerX": 0, "align": "center" } }] }] };
                return NeoTransferViewUI;
            }(View));
            blockchain.NeoTransferViewUI = NeoTransferViewUI;
        })(blockchain = Editor.blockchain || (Editor.blockchain = {}));
    })(Editor = MyGameCreatorEditorUI.Editor || (MyGameCreatorEditorUI.Editor = {}));
})(MyGameCreatorEditorUI || (MyGameCreatorEditorUI = {}));





var NeoInvoke = (function (_super) {
    __extends(NeoInvoke, _super);
    function NeoInvoke() {
        _super.call(this);
        this.closeBtn.add_CLICK(this.closeView, this);
        this.cancelBtn.add_CLICK(this.closeView, this);
        this.sureBtn.add_CLICK(this.onInvoke, this);
        this.walletText.add_CLICK(this.onClickWallet, this);
        this.walletText.add_MOUSEOVER(this.onMouseover, this, [this.walletText]);
        this.walletText.add_MOUSEOUT(this.onMouseout, this, [this.walletText]);
        this.closeBtn.add_MOUSEOVER(this.onMouseover, this, [this.closeBtn]);
        this.closeBtn.add_MOUSEOUT(this.onMouseout, this, [this.closeBtn]);
        this.sureBtn.add_MOUSEOVER(this.onMouseover, this, [this.sureBtn]);
        this.sureBtn.add_MOUSEOUT(this.onMouseout, this, [this.sureBtn]);
        this.cancelBtn.add_MOUSEOVER(this.onMouseover, this, [this.cancelBtn]);
        this.cancelBtn.add_MOUSEOUT(this.onMouseout, this, [this.cancelBtn]);
    }
    NeoInvoke.prototype.init = function (name, contract, operation, params, isAllowCancle) {
        this.closeBtn.visible = !isAllowCancle;
        this.cancelBtn.visible = !isAllowCancle;
        this.sureBtn.right = this.cancelBtn.visible ? 260 : 105;
        this.nameText.text = name;
        this.contractText.text = contract;
        if (DNeoWallet.isLogin) {
            this.walletText.text = DNeoWallet.address;
            this.walletText.underline = false;
            this.walletText.mouseEnabled = false;
        }
        else {
            this.walletText.text = "未登陆";
            this.walletText.underline = true;
            this.walletText.mouseEnabled = true;
        }
        this.operationText.text = operation;
        this.paramsList = [];
        this.noplayerInputlist = [];
        this.showArgsView(params);
    };
    NeoInvoke.prototype.showArgsView = function (params) {
        var show = false;
        var list = [];
        var showList = [];
        for (var i = 0; i < params.length; i++) {
            var data = params[i];
            if (data.isAllow) {
                show = true;
                var item = new NeoInvokeItemData();
                item.name = data.name;
                item.typeNum = data.typeNum;
                item.value = data.value;
                item.index = i;
                list.push(item);
            }
            else {
                if (data.typeNum == 4) {
                    data.value = DNeoWallet.isLogin ? DNeoWallet.address : "未登陆";
                }
                this.noplayerInputlist.push({ index: i, typeNum: data.typeNum, name: data.name, value: data.value });
                var str = data.name + ":" + data.value;
                showList.push(str);
            }
        }
        this.argsText.text = showList.join(",");
        this.argsList.array = list;
        this.height = show ? 600 : 400;
        this.listBg.visible = show;
        this.argsList.visible = show;
    };
    NeoInvoke.prototype.closeView = function () {
        this.removeSelf();
        GameCommand.inputMessageAndContinueExecute();
    };
    NeoInvoke.prototype.onMouseover = function (ui) {
        if (ui instanceof Clip) {
            ui.index = 1;
        }
        else {
            ui.color = "#67c511";
        }
    };
    NeoInvoke.prototype.onMouseout = function (ui) {
        if (ui instanceof Clip) {
            ui.index = 0;
        }
        else {
            ui.color = "#ffffff";
        }
    };
    NeoInvoke.prototype.onClickWallet = function () {
        BlockChainManager.openNeoLoginView(false, true, Callback.New(this.refreshView, this));
    };
    NeoInvoke.prototype.refreshView = function () {
        this.walletText.text = DNeoWallet.address;
        this.walletText.underline = false;
        this.walletText.mouseEnabled = false;
        var showList = [];
        for (var i = 0; i < this.noplayerInputlist.length; i++) {
            var data = this.noplayerInputlist[i];
            if (data.typeNum == 4)
                data.value = DNeoWallet.address;
            var str = data.name + ":" + data.value;
            showList.push(str);
        }
        this.argsText.text = showList.join(",");
    };
    NeoInvoke.prototype.onInvoke = function () {
        if (!DNeoWallet.isLogin) {
            alert("请登陆钱包");
            return;
        }
        var isAddress = DNeoTool.verifyAddr(this.walletText.text);
        if (isAddress) {
            var list = this.argsList.array;
            for (var i = 0; i < list.length; i++) {
                var item = list[i];
                this.createParamsByType(item.index, item.typeNum, item.value);
            }
            for (var index = 0; index < this.noplayerInputlist.length; index++) {
                var data = this.noplayerInputlist[index];
                this.createParamsByType(data.index, data.typeNum, data.value);
            }
            this.toInvokeContract();
        }
        else {
            alert("钱包地址不正确，请确认！");
        }
    };
    NeoInvoke.prototype.createParamsByType = function (index, typeNum, value) {
        if (typeNum == 0) {
            this.paramsList[index] = "(str)" + value;
        }
        else if (typeNum == 1) {
            this.paramsList[index] = "(int)" + value;
        }
        else if (typeNum == 2 || typeNum == 4) {
            this.paramsList[index] = "(addr)" + value;
        }
        else if (typeNum == 3) {
            this.paramsList[index] = "(bytes)" + value;
        }
    };
    NeoInvoke.prototype.toInvokeContract = function () {
        return __awaiter(this, void 0, void 0, function* () {
            var arg0 = "(str)" + this.operationText.text;
            var param = [arg0, this.paramsList];
            var res = yield DNeoContract.invokescript(this.contractText.text, param);
            if (res) {
                console.log("++++调用成功++++", true);
                this.closeView();
            }
            else {
                alert("调用失败！");
            }
        });
    };
    return NeoInvoke;
}(MyGameCreatorEditorUI.Editor.blockchain.NeoInvokeViewUI));





var NeoTransfer = (function (_super) {
    __extends(NeoTransfer, _super);
    function NeoTransfer() {
        _super.call(this);
        this.allowTransfer = true;
        this.closeBtn.add_CLICK(this.closeView, this);
        this.walletText.add_MOUSEOVER(this.onMouseover, this, [this.walletText]);
        this.walletText.add_MOUSEOUT(this.onMouseout, this, [this.walletText]);
        this.walletText.add_CLICK(this.onClickWallet, this);
        this.sureBtn.add_CLICK(this.onTransfer, this);
        this.cancelBtn.add_CLICK(this.closeView, this);
        this.closeBtn.add_MOUSEOVER(this.onMouseover, this, [this.closeBtn]);
        this.closeBtn.add_MOUSEOUT(this.onMouseout, this, [this.closeBtn]);
        this.sureBtn.add_MOUSEOVER(this.onMouseover, this, [this.sureBtn]);
        this.sureBtn.add_MOUSEOUT(this.onMouseout, this, [this.sureBtn]);
        this.cancelBtn.add_MOUSEOVER(this.onMouseover, this, [this.cancelBtn]);
        this.cancelBtn.add_MOUSEOUT(this.onMouseout, this, [this.cancelBtn]);
        this.valueInput.add_INPUT(this.onTextInput, this);
    }
    NeoTransfer.prototype.init = function (name, toAddress, assetType, value, isAllowInput, isAllowCancle) {
        this.closeBtn.visible = !isAllowCancle;
        this.cancelBtn.visible = !isAllowCancle;
        this.sureBtn.right = this.cancelBtn.visible ? 109 : 19;
        this.nameText.text = name;
        this.toAddressText.text = toAddress;
        this.assetType.text = assetType == 0 ? "NEO" : "GAS";
        this.assetID = assetType == 0 ? DNeoTool.id_NEO : DNeoTool.id_GAS;
        if (DNeoWallet.isLogin) {
            this.walletText.text = DNeoWallet.address;
            this.walletText.underline = false;
            this.walletText.mouseEnabled = false;
        }
        else {
            this.walletText.text = "未登陆";
            this.walletText.underline = true;
            this.walletText.mouseEnabled = true;
        }
        if (isAllowInput) {
            this.valueText.text = "";
            this.valueInput.text = value;
            this.valueInputBox.visible = true;
        }
        else {
            this.valueText.text = value;
            this.valueInputBox.visible = false;
        }
        this.transferValue = value;
    };
    NeoTransfer.prototype.onTextInput = function (input) {
        this.transferValue = input.text;
    };
    NeoTransfer.prototype.onMouseover = function (ui) {
        if (ui instanceof Clip) {
            ui.index = 1;
        }
        else {
            ui.color = "#67c511";
        }
    };
    NeoTransfer.prototype.onMouseout = function (ui) {
        if (ui instanceof Clip) {
            ui.index = 0;
        }
        else {
            ui.color = "#ffffff";
        }
    };
    NeoTransfer.prototype.closeView = function () {
        this.removeSelf();
        GameCommand.inputMessageAndContinueExecute();
    };
    NeoTransfer.prototype.onClickWallet = function () {
        BlockChainManager.openNeoLoginView(false, true, Callback.New(this.refreshView, this));
    };
    NeoTransfer.prototype.refreshView = function () {
        this.walletText.text = DNeoWallet.address;
        this.walletText.underline = false;
        this.walletText.mouseEnabled = false;
    };
    NeoTransfer.prototype.onTransfer = function () {
        if (!this.allowTransfer)
            return;
        if (!DNeoWallet.isLogin) {
            alert("请登陆钱包");
            return;
        }
        var isAddress = DNeoTool.verifyAddr(this.toAddressText.text);
        if (isAddress) {
            this.allowTransfer = false;
            this.toTransfer();
        }
        else {
            alert("钱包地址不正确，请确认！");
        }
    };
    NeoTransfer.prototype.toTransfer = function () {
        return __awaiter(this, void 0, void 0, function* () {
            var result = yield DNeoWallet.transferToAccount(this.toAddressText.text, this.transferValue, this.assetID);
            this.allowTransfer = true;
            if (result) {
                this.closeView();
            }
            else {
                alert("转账失败！");
            }
        });
    };
    return NeoTransfer;
}(MyGameCreatorEditorUI.Editor.blockchain.NeoTransferViewUI));





var NeoLogin = (function (_super) {
    __extends(NeoLogin, _super);
    function NeoLogin() {
        _super.call(this);
        this.selectedIndex = 0;
        this.closeBtn.add_MOUSEOVER(this.onMouseover, this, [this.closeBtn]);
        this.closeBtn.add_MOUSEOUT(this.onMouseout, this, [this.closeBtn]);
        this.closeBtn.add_CLICK(this.closeView, this);
        this.selectElement = document.createElement("input");
        this.selectElement.type = "file";
        this.selectElement.style.position = "absolute";
        this.selectElement.style.opacity = "0";
        this.selectElement.onmouseover = this.overAsset.bind(this);
        this.selectElement.onmouseout = this.outAsset.bind(this);
        this.selectElement.onchange = this.clickAsset.bind(this);
        this.loadElement = document.createElement('a');
        this.loadElement.style.position = "absolute";
        this.loadElement.style.opacity = "0";
        this.loadElement.style.display = "none";
        this.loadElement.textContent = "下载";
        this.loadElement.onmouseover = this.overAsset.bind(this);
        this.loadElement.onmouseout = this.outAsset.bind(this);
        Neo.Cryptography.RandomNumberGenerator.startCollectors();
        this.loginBtn.add_CLICK(this.selectFun, this, [0]);
        this.buildBtn.add_CLICK(this.selectFun, this, [1]);
        this.toLogin.add_CLICK(this.loginClick, this);
        this.toLogin.add_MOUSEOVER(this.onMouseover, this, [this.toLogin]);
        this.toLogin.add_MOUSEOUT(this.onMouseout, this, [this.toLogin]);
        this.toBuild.add_CLICK(this.clickBuild, this);
        this.toBuild.add_MOUSEOVER(this.onMouseover, this, [this.toBuild]);
        this.toBuild.add_MOUSEOUT(this.onMouseout, this, [this.toBuild]);
        this.wifLogin.add_CLICK(this.clickWif, this);
        this.wifLogin.add_MOUSEOVER(this.onMouseover, this, [this.wifLogin]);
        this.wifLogin.add_MOUSEOUT(this.onMouseout, this, [this.wifLogin]);
        this.pwInput.add_ENTER(this.loginClick, this);
        this.registerPW2.add_ENTER(this.clickBuild, this);
        stage.add_RESIZE(this.onResize, this);
    }
    NeoLogin.prototype.init = function (hideCloseBtn, loginCallBack) {
        if (loginCallBack) {
            this.loginCallBack = loginCallBack;
        }
        else {
            this.loginCallBack = null;
        }
        this.closeBtn.visible = !hideCloseBtn;
        document.body.appendChild(this.selectElement);
        document.body.appendChild(this.loadElement);
        Handler.create(this, this.refreshElementPosition).delayRun(100);
    };
    NeoLogin.prototype.closeView = function () {
        document.body.removeChild(this.selectElement);
        document.body.removeChild(this.loadElement);
        this.removeSelf();
        if (!this.loginCallBack) {
            var address = DNeoWallet.isLogin ? DNeoWallet.address : "";
            GameCommand.inputMessageAndContinueExecute([address]);
        }
    };
    NeoLogin.prototype.onResize = function () {
        Handler.create(this, this.refreshElementPosition).delayRun(100);
    };
    NeoLogin.prototype.refreshElementPosition = function () {
        if (this.selectElement)
            Utils.fitDOMElementInArea(this.selectElement, this.openAssetBtn, 0, 0, this.openAssetBtn.width, this.openAssetBtn.height);
        if (this.loadElement)
            Utils.fitDOMElementInArea(this.loadElement, this.loadBtn, 0, 0, this.loadBtn.width, this.loadBtn.height);
    };
    NeoLogin.prototype.selectFun = function (index) {
        if (this.selectedIndex != index) {
            this.selectedIndex = index;
            if (index == 0) {
                this.registerName.focus = false;
                this.loginBtn.index = 1;
                this.buildBtn.index = 0;
                this.loginBox.visible = true;
                this.buildBox.visible = false;
                this.loadBox.visible = false;
                this.selectElement.style.display = "block";
                this.loadElement.style.display = "none";
            }
            else if (index == 1) {
                this.registerName.focus = true;
                this.loginBtn.index = 0;
                this.buildBtn.index = 1;
                this.loginBox.visible = false;
                this.buildBox.visible = true;
                this.loadBox.visible = false;
                this.selectElement.style.display = "none";
                this.loadElement.style.display = "none";
            }
        }
    };
    NeoLogin.prototype.onMouseover = function (ui) {
        ui.index = 1;
    };
    NeoLogin.prototype.onMouseout = function (ui) {
        ui.index = 0;
    };
    NeoLogin.prototype.overAsset = function () {
        if (this.selectedIndex == 0) {
            this.openAssetBtn.index = 1;
        }
        else if (this.selectedIndex == 2) {
            this.loadBtn.index = 1;
        }
    };
    NeoLogin.prototype.outAsset = function () {
        if (this.selectedIndex == 0) {
            this.openAssetBtn.index = 0;
        }
        else if (this.selectedIndex == 2) {
            this.loadBtn.index = 0;
        }
    };
    NeoLogin.prototype.clickAsset = function (e) {
        var file = e.target.files[0];
        this.fileUrl.text = file.name;
        var reader = new FileReader();
        reader.readAsText(file);
        reader.onload = function (e) {
            var walletstr = reader.result;
            var account = walletstr.includes("accounts");
            if (!walletstr || !walletstr.includes("accounts")) {
                alert(" 加载钱包文件失败！");
                return;
            }
            DNeoWallet.wallet.fromJsonStr(walletstr);
            this.isloadFile = true;
        };
    };
    NeoLogin.prototype.loginClick = function () {
        if (this.isloadFile == false) {
            alert("请加载钱包文件");
            return;
        }
        if (this.pwInput.text == null || this.pwInput.text == "") {
            alert("请输入密码！");
            return;
        }
        this.toLoginWallet(this.pwInput.text);
    };
    NeoLogin.prototype.toLoginWallet = function (password) {
        return __awaiter(this, void 0, void 0, function* () {
            var result = yield DNeoWallet.loginWallet(password);
            if (result && result.res) {
                this.closeView();
                if (this.loginCallBack)
                    this.loginCallBack.run();
            }
            else {
                alert(" 登陆失败！");
            }
        });
    };
    NeoLogin.prototype.clickWif = function () {
        var str = prompt("请输入WIF字符串：");
        if (str == null || str == "")
            return;
        var res = DNeoWallet.wifDecode(str);
        if (res) {
            this.closeView();
            if (this.loginCallBack)
                this.loginCallBack.run();
        }
        else {
            alert("wif字符串错误，登陆失败!");
        }
    };
    NeoLogin.prototype.clickBuild = function () {
        if (this.registerName.text == "" || this.registerName.text == null) {
            alert("请输入账号名！");
            return;
        }
        if (this.registerPW.text == "" || this.registerPW.text == null) {
            alert("请输入密码！");
            return;
        }
        if (this.registerPW2.text == "" || this.registerPW2.text == null) {
            alert("请输入重复密码！");
            return;
        }
        if (this.registerPW.text != this.registerPW2.text) {
            this.registerPW2.text = "";
            alert("重复密码不匹配，请重新输入！");
            return;
        }
        this.toBuildAccount();
    };
    NeoLogin.prototype.toBuildAccount = function () {
        return __awaiter(this, void 0, void 0, function* () {
            var result = yield DNeoWallet.create(this.registerPW.text);
            if (result && result.res) {
                var jsonstr = JSON.stringify(DNeoWallet.wallet.toJson());
                var blob = new Blob([ThinNeo.Helper.String2Bytes(jsonstr)]);
                this.loadElement.style.display = "block";
                this.loadElement.href = URL.createObjectURL(blob);
                this.loadElement["download"] = this.registerName.text + ".json";
                this.fileUrl.text = this.registerName.text + ".json";
                this.pwInput.text = this.registerPW.text;
                this.selectedIndex = 2;
                this.loginBox.visible = false;
                this.buildBox.visible = false;
                this.loadBox.visible = true;
            }
            else {
                alert("钱包创建失败！");
            }
        });
    };
    return NeoLogin;
}(MyGameCreatorEditorUI.Editor.blockchain.NeoLoginViewUI));





var NeoInvokeRender = (function (_super) {
    __extends(NeoInvokeRender, _super);
    function NeoInvokeRender() {
        _super.call(this);
        new Handler(this, this.init).delayRun(0);
    }
    NeoInvokeRender.prototype.init = function () {
        this.paramText.add_INPUT(this.onchangeInput, this);
    };
    NeoInvokeRender.prototype.onchangeInput = function () {
        if (this.data == null)
            return;
        this.data.value = this.paramText.text;
    };
    NeoInvokeRender.prototype.addChild = function (node) {
        this[node.name] = node;
        return _super.prototype.addChild.call(this, node);
    };
    Object.defineProperty(NeoInvokeRender.prototype, "dataSource", {
        get: function () {
            return this.data;
        },
        set: function (v) {
            if (this.data != v) {
                this.data = v;
                this.updateAppearance();
            }
        },
        enumerable: true,
        configurable: true
    });
    NeoInvokeRender.prototype.updateAppearance = function () {
        if (this.data == null)
            return;
        this.argsName.text = this.data.name;
        this.paramText.text = this.data.value;
    };
    return NeoInvokeRender;
}(Box));
var NeoInvokeItemData = (function () {
    function NeoInvokeItemData() {
    }
    return NeoInvokeItemData;
}());
