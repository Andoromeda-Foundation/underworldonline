{
    "title": [
        "Logic_Battle",
        "Logic_Hall",
        "Deck",
        "test",
        "============================",
        "ServerWorld",
        "RequestHandler",
        "GameServerScene",
        "BattleServerScene",
        "GameServerSceneObject_Core",
        "GameServerSceneObject_1",
        "ServerSceneObjectBehavior"
    ],
    "src": [
        "/**\r\n * 战场逻辑\r\n */\r\nclass Logic_Battle{\r\n    \r\n}",
        "/**\r\n * 大厅逻辑\r\n */\r\nclass Logic_Hall {\r\n    /**\r\n     * 对战场景信息\r\n     */\r\n    static battleSceneInfo: { [sceneID: number]: BattleSceneInfo } = {};\r\n    /**\r\n     * 获取可匹配的玩家集合\r\n     */\r\n    static getMatchablePlayers(player: ServerPlayer): { name: string, id: number } {\r\n        // 玩家所在场景必须在大厅(包括大厅的各种GUI页面)\r\n        if (player.sceneID != 1) return;\r\n        let scene: ServerScene = player.scene;\r\n        if (!scene) return;\r\n        let playerInfo = [];\r\n        // 获取其他匹配中玩家\r\n        for (let i in ServerPlayer.playerList) {\r\n            let targetPlayer: ServerPlayer = ServerPlayer.playerList[i];\r\n            // 除去自身\r\n            if (targetPlayer == player) continue;\r\n            // 去除不在匹配等待的(0：空闲，1：等待匹配中，2：匹配成功战斗中)\r\n            if (targetPlayer.variable.getVariable(1) != 1) continue;\r\n            // 获取数据\r\n            playerInfo.push({ name: targetPlayer.variable.getString(1), id: targetPlayer.uid });\r\n        }\r\n        // 没有可匹配玩家的时候\r\n        if (playerInfo.length == 0) {\r\n            return { name: \"\", id: -1 };\r\n        }\r\n        // 随机一个作为对手\r\n        let index_player: number = MathUtils.rand(playerInfo.length);\r\n        // 返回该旗鼓相当的对手\r\n        return playerInfo[index_player];\r\n    }\r\n    // 获取对战目标玩家\r\n    private static getBattleTargetPlayer(player: ServerPlayer, targetPlayerID: number): ServerPlayer {\r\n        let scene: ServerScene = player.scene;\r\n        if (!scene || scene.id != 1) return null;\r\n        let targetPlayer: ServerPlayer = ServerPlayer.getPlayerByUID(targetPlayerID);\r\n        if (!targetPlayer || targetPlayer.sceneID != 1) return null;\r\n        return targetPlayer;\r\n    }\r\n    // 请求对战\r\n    static requestBattle(player: ServerPlayer, targetPlayerID: number): number {\r\n        let targetPlayer: ServerPlayer = this.getBattleTargetPlayer(player, targetPlayerID);\r\n        // 如果没有目标玩家\r\n        if (!targetPlayer) return 0;\r\n        // 加入已请求列表\r\n        player.data.battleRequestTargetID.push(targetPlayerID);\r\n        // 目标玩家接收对战信息\r\n        targetPlayer.data.battleAcceptID = player.uid;\r\n        let playerName = player.variable.getString(1);\r\n        ServerMsgSender.rpc(targetPlayer, \"GUI_Alert\", \"alert\", [`${playerName}来找你踢馆啦！`]);\r\n    }\r\n    /**\r\n     * 接受对战\r\n     * @param player \r\n     * @return [number] 0-对方不在大厅上 1-目标已更换对战目标 2-成功进入对战场景\r\n     */\r\n    static accessBattle(player: ServerPlayer): number {\r\n        // 获取目标对手\r\n        let targetPlayerID: number = player.data.battleAcceptID;\r\n        let targetPlayer: ServerPlayer = this.getBattleTargetPlayer(player, targetPlayerID);\r\n        // 对手不见的情况\r\n        if (!targetPlayer) return 0;\r\n        // 对手的请求列表没有你的情况\r\n        if (targetPlayer.data.battleRequestTargetID.indexOf(player.uid) == -1) return 1;\r\n        // 清空对战请求列表\r\n        targetPlayer.data.battleRequestTargetID.length = 0;\r\n        player.data.battleRequestTargetID.length = 0;\r\n        // 创建战场副本\r\n        let battleSceneID: number = ServerScene.createScene(2, true);\r\n        let scene = ServerScene.getScene(battleSceneID) as BattleServerScene;\r\n        scene.initBattleHandler();\r\n        // 设置顺序（随机排序）\r\n        player.data.battlePlayerID = [player.uid, targetPlayerID];\r\n        ArrayUtils.randOrder(player.data.battlePlayerID);\r\n        // 设置身份（1:对战者）\r\n        player.data.battleActor = 1;\r\n        targetPlayer.data.battleActor = 1;\r\n        // // 获取玩家姓名\r\n        // let playerName:string = player.variable.getString(1);\r\n        // let targetPlayerName:string = targetPlayer.variable.getString(1);\r\n        // // 记录\r\n        // Logic_Hall.\r\n        // 进入对战场景\r\n        player.toScene(battleSceneID, 0, 0);\r\n        targetPlayer.toScene(battleSceneID, 0, 0);\r\n        return 2;\r\n    }\r\n}\r\n//============================================\r\n//              客户端开放方法列表\r\n//============================================\r\nServerWorld.addServerFunction(\"Logic_Hall\", \"getMatchablePlayers\");\r\nServerWorld.addServerFunction(\"Logic_Hall\", \"requestBattle\");\r\nServerWorld.addServerFunction(\"Logic_Hall\", \"accessBattle\");\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
        "function a22(){\r\n    \r\n}",
        "globalThis.aaaaaa = function(id){\r\n    var player = ServerPlayer.getPlayerByUID(id);\r\n    // trace(kdsrpg_scriptID,\"玩家结构AAA=\",(player.sceneObject as ServerSceneObject_2).结构.AAA)\r\n}\r\n\r\n\r\nfunction showPlayers() {\r\n    trace(\"============check player\");\r\n    var pArr = [];\r\n    for (var key in ServerPlayer.playerList) {\r\n        var p = ServerPlayer.playerList[key];\r\n        trace(\"线程\" + kdsrpg_scriptID + \"消息\", \"玩家KEY=\", p.key, `所在场景${p.sceneID}，所在线程${p.threadID}`);\r\n        pArr.push(p.key);\r\n    }\r\n    return pArr;\r\n}\r\n\r\nif (kdsrpg_scriptID == 2) {\r\n    // showPlayers();\r\n}\r\n\r\nfunction threadTest(p) {\r\n    trace(\"我所在的线程是\", kdsrpg_scriptID, \"接受的参数=\", p);\r\n    return kdsrpg_scriptID;\r\n}\r\n\r\nclass AAA {\r\n    static wagagagaga(p, a) {\r\n        trace(\"11111111111111111111wagagaga\", a);\r\n    }\r\n    static threadID(p:ServerPlayer){\r\n        if(!p.scene)return [];\r\n        return [p.sceneID,ServerThread.threadID,p.scene.modelID];\r\n    }\r\n    \r\n}\r\nServerWorld.addServerFunction(\"AAA\");\r\n\r\n\r\nServerWorld.setWorldVariableAccessible(0,1,true);\r\n\r\n\r\n\r\n\r\nEventUtils.addEventListener(ServerPlayer, ServerPlayer.EVENT_PLAYER_DISPLACEMENT, Callback.New(function (player: ServerPlayer) {\r\n    trace(ServerThread.threadID, \"有个玩家挤号\", player.uid, player.key)\r\n}, this))\r\nEventUtils.addEventListener(ServerPlayer, ServerPlayer.EVENT_PLAYER_LOGIN, Callback.New(function (player: ServerPlayer) {\r\n    trace(ServerThread.threadID, \"有个玩家登录\", player.uid, player.key)\r\n}, this))\r\nEventUtils.addEventListener(ServerPlayer, ServerPlayer.EVENT_PLAYER_LOGOUT, Callback.New(function (player: ServerPlayer) {\r\n    trace(ServerThread.threadID, \"有个玩家下线\", player.uid, player.key)\r\n}, this))\r\nEventUtils.addEventListener(ServerPlayer, ServerPlayer.EVENT_PLAYER_MESSAGE, Callback.New(function (player: ServerPlayer, msg) {\r\n    trace(ServerThread.threadID, \"++++++++++++++\", player.uid, player.key, msg);\r\n}, this))\r\n\r\n\r\nEventUtils.addEventListener(ServerWorld, ServerWorld.EVENT_STARTUP_COMPLETE, Callback.New(() => {\r\n    trace(kdsrpg_scriptID,\"世界启动完毕。。。。。。。。\")\r\n}, this))\r\n\r\n\r\n\r\n",
        "",
        "/**\r\n * 开始执行命令\r\n * @param player \r\n * @param mainType \r\n * @param indexType \r\n * @param params \r\n * @param onTriggerCreated\r\n */\r\nServerWorld.startTriggerCommand = function (player: ServerPlayer, mainType: number, indexType: number, params: any[], onTriggerCreated: Callback): CommandTarget {\r\n    var scene: ServerScene = ServerScene.getScene(player.sceneID);\r\n    if (!scene || indexType < 0) return;\r\n    if (params.length < 1) return;\r\n    var commandID = params[0];\r\n    var playerInput = params[1];\r\n    if (playerInput == null) playerInput = [];\r\n    switch (mainType) {\r\n        case CommandTarget.COMMAND_MAIN_TYPE_SCENE:\r\n            var cmdPage = scene.customCommandPages[indexType];\r\n            if (cmdPage) {\r\n                var trigger = player.sceneObject.getCommandTrigger(mainType, indexType);\r\n                if (trigger) {\r\n                    onTriggerCreated && onTriggerCreated.runWith([trigger]);\r\n                    cmdPage.startTriggerEvent(trigger, player.sceneObject, playerInput);\r\n                }\r\n                return trigger;\r\n            }\r\n            break;\r\n        case CommandTarget.COMMAND_MAIN_TYPE_SCENE_OBJECT:\r\n            if (commandID < 0) return;\r\n            var so = scene.sceneObjects[commandID] as ServerSceneObject;\r\n            if (so) {\r\n                var trigger = player.sceneObject.getCommandTrigger(mainType, indexType);\r\n                if (trigger) {\r\n                    onTriggerCreated && onTriggerCreated.runWith([trigger]);\r\n                    var cmdPage = so.customCommandPages[indexType];\r\n                    if (cmdPage) {\r\n                        cmdPage.startTriggerEvent(trigger, so, playerInput);\r\n                        return trigger;\r\n                    }\r\n                }\r\n            }\r\n            break;\r\n        case CommandTarget.COMMAND_MAIN_TYPE_UI:\r\n            var commands = ServerWorld.uiCustomCommandPages[commandID]\r\n            if (commands) {\r\n                var cmdPage = commands[indexType];\r\n                if (cmdPage) {\r\n                    var trigger = player.sceneObject.getCommandTrigger(mainType, indexType);\r\n                    if (trigger) {\r\n                        onTriggerCreated && onTriggerCreated.runWith([trigger]);\r\n                        cmdPage.startTriggerEvent(trigger, player.sceneObject, playerInput);\r\n                    }\r\n                    return trigger;\r\n                }\r\n            }\r\n            break;\r\n    }\r\n}",
        "/**\r\n * 请求信息：基础功能\r\n * Created by 黑暗之神KDS on 2018-10-08 03:51:02.\r\n */\r\nclass RequestHandler {\r\n    /**\r\n     * 进入场景\r\n     * @param player \r\n     */\r\n    protected static inScene(player: ServerPlayer): void {\r\n        var scene: ServerScene = ServerScene.getScene(player.sceneID);\r\n        // 不存在场景的话调用系统公共事件\r\n        if (!scene) {\r\n            // test 跳转到第2个场景\r\n            // ServerScript.runSystemScript(3);\r\n        }\r\n        else {\r\n            scene.addPlayer(player);\r\n            trace(\"添加玩家！！！玩家总数=\", scene.playerCount);\r\n        }\r\n    }\r\n    //------------------------------------------------------------------------------------------------------\r\n    // 操作\r\n    //------------------------------------------------------------------------------------------------------\r\n    /**\r\n     * 请求移动\r\n     * @param player \r\n     * @param lines 路线 [[start.x,start.y],[...],[end.x,end.y]]\r\n     */\r\n    protected static requestMove(player: ServerPlayer, lines: number[][]): void {\r\n        var scene: ServerScene = ServerScene.getScene(player.sceneID);\r\n        if (!scene) return;\r\n        if (!player.controlEnabled) return;\r\n        var now = new Date().getTime();\r\n        // 更新坐标\r\n        var soe: GameServerSceneObject_Core = player.sceneObject as any;\r\n        soe.moveStart(now, lines, true);\r\n    }\r\n}\r\nServerWorld.addServerFunction(\"RequestHandler\");",
        "\r\n//■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■\r\n// 服务器的游戏场景\r\n//■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■\r\nclass GameServerScene extends ServerScene {\r\n    /**\r\n     * 副本生命周期（没有玩家时超过的时间<s>来决定）\r\n     */\r\n    static COPY_SCENE_LIFE: number = 5000;\r\n    /**\r\n     * 副本生命时间开始 ms\r\n     */\r\n    copySceneLifeStart: number;\r\n\r\n    constructor() {\r\n        super();\r\n        trace(\"服务器场景===GameServerScene\");\r\n    }\r\n\r\n    /**\r\n     * 准备进入场景：通知玩家加载场景\r\n     * @param player \r\n     */\r\n    readyInScene(player: ServerPlayer): void {\r\n        super.readyInScene.apply(this, arguments);\r\n        trace(\"====>readyInScene\");\r\n        this.sendToPlayer(player, \"loadNewScene\", [{\r\n            modelID: this.modelID,\r\n            thread: ServerThread.getSceneThread(this.id)\r\n        }]);\r\n    }\r\n    //------------------------------------------------------------------------------------------------------\r\n    // 玩家\r\n    //------------------------------------------------------------------------------------------------------\r\n    /**\r\n     * 添加玩家\r\n     * @param player \r\n     */\r\n    addPlayer(player: ServerPlayer): void {\r\n        trace(\">>>>>>>>>>>>>addPlayer!!!!\" + player.uid)\r\n        super.addPlayer(player);\r\n        var sceneCmdTypeIndex = 0;\r\n        var commandPageInScene = this.customCommandPages[sceneCmdTypeIndex];\r\n        this.sendToPlayer(player, \"inNewScene\", [this.getAroundSceneObjects(player.sceneObject, false), commandPageInScene.commands.length > 0 ? true : false]);\r\n        // 执行场景事件\r\n        var inSceneCmdLength = commandPageInScene.commands.length;\r\n        if (inSceneCmdLength > 0) {\r\n            var commandTargetInScene = player.sceneObject.getCommandTrigger(CommandTarget.COMMAND_MAIN_TYPE_SCENE, sceneCmdTypeIndex);\r\n            EventUtils.addEventListener(commandTargetInScene, CommandTarget.EVENT_OVER, Callback.New((player: ServerPlayer) => {\r\n                this.sendToPlayer(player, \"inSceneCommandExecuteOver\", []);\r\n            }, this, [player]), true);\r\n            commandPageInScene.startTriggerEvent(commandTargetInScene, player.sceneObject);\r\n        }\r\n    }\r\n    /**\r\n     * 移除玩家\r\n     * @param player \r\n     */\r\n    removePlayer(player: ServerPlayer): void {\r\n        super.removePlayer(player);\r\n    }\r\n    //------------------------------------------------------------------------------------------------------\r\n    // 场景对象\r\n    //------------------------------------------------------------------------------------------------------\r\n    /**\r\n     * 添加游戏对象 并同步至客户端\r\n     * @param so 要添加的游戏对象 \r\n     * @return [number] 该游戏对象在场景上sceneObjects列表的位置\r\n     */\r\n    addSceneObject(so: ServerSceneObject, addToList: boolean = true): void {\r\n        super.addSceneObject(so, addToList);\r\n        // 传递数据：根据是否是玩家自身区分传输不同的数据\r\n        var selfSyncClientData = so.syncClientData(true);\r\n        var elseSyncClientData = so.syncClientData(false);\r\n\r\n        for (var uid in this.playerMap) {\r\n            var player: ServerPlayer = this.playerMap[uid];\r\n            var syncClientData = player == so.player ? selfSyncClientData : elseSyncClientData;\r\n            ServerMsgSender.rpc(player, \"MsgHandler\", \"addSceneObject\", [syncClientData]);\r\n        }\r\n    }\r\n    /**\r\n     * 移除游戏对象 并同步至客户端\r\n     * @param so 要移除的游戏对象\r\n     * @param removeFromList [可选] 默认值=true \r\n     * @param force [可选] 默认值=false \r\n     */\r\n    removeSceneObject(so: ServerSceneObject, removeFromList: boolean = true, force: boolean = false): boolean {\r\n        var isRemode = super.removeSceneObject(so, removeFromList, force);\r\n        if (isRemode) this.radioPlayers(\"removeSceneObject\", [{ index: so.index }]);\r\n        return isRemode;\r\n    }\r\n    //------------------------------------------------------------------------------------------------------\r\n    // AOI\r\n    //------------------------------------------------------------------------------------------------------\r\n    /**\r\n     * * 获取周围的场景对象\r\n     * -- 玩家的场景对象根据 broadcastMode 配置\r\n     * -- NPC的场景对象根据周围\r\n     * TEMP：这里暂时广播全部\r\n     * @param targetSceneObject \r\n     * @param includeSelf [可选] 默认值=false \r\n     * @return [SceneObject] \r\n     */\r\n    protected getAroundSceneObjects(targetSceneObject: SceneObject, includeSelf: boolean): SceneObject[] {\r\n        var len = this.sceneObjects.length;\r\n        var arr = [];\r\n        for (var i = 0; i < len; i++) {\r\n            var so = this.sceneObjects[i] as ServerSceneObject;\r\n            if (so) {\r\n                if (so == targetSceneObject && !includeSelf) {\r\n                    continue;\r\n                }\r\n                if (so.inScene) arr.push(so.syncClientData(false));\r\n            }\r\n        }\r\n        return arr;\r\n    }\r\n    //------------------------------------------------------------------------------------------------------\r\n    // 通信方法\r\n    //------------------------------------------------------------------------------------------------------\r\n    /**\r\n     * 广播给全体玩家\r\n     * @param funcName 方法名\r\n     * @param params 参数\r\n     */\r\n    radioPlayers(funcName: string, params: any[], rpcClass: string = \"MsgHandler\"): void {\r\n        for (var uid in this.playerMap) {\r\n            var player: ServerPlayer = this.playerMap[uid];\r\n            ServerMsgSender.rpc(player, rpcClass, funcName, params);\r\n        }\r\n    }\r\n    /**\r\n     * 发送给指定的玩家\r\n     * @param player 指定的玩家\r\n     * @param funcName 方法名\r\n     * @param params 参数\r\n     */\r\n    sendToPlayer(player: ServerPlayer, funcName: string, params: any[], rpcClass: string = \"MsgHandler\"): void {\r\n        ServerMsgSender.rpc(player, rpcClass, funcName, params);\r\n    }\r\n    //------------------------------------------------------------------------------------------------------\r\n    // \r\n    //------------------------------------------------------------------------------------------------------\r\n    /**\r\n    * 当前场景刷新\r\n    */\r\n    update(now: number): void {\r\n        if (this.playerCount != 0) {\r\n            // -- 刷新场景对象\r\n            var soLen = this.sceneObjects.length;\r\n            for (var i = 0; i < soLen; i++) {\r\n                var so: ServerSceneObject = this.sceneObjects[i] as ServerSceneObject;\r\n                if (so) so.update(now);\r\n            }\r\n        }\r\n        // 超时则销毁副本\r\n        if (this.isCopy) {\r\n            if (!this.copySceneLifeStart) this.copySceneLifeStart = now;\r\n            if (this.playerCount == 0) {\r\n                if (now - this.copySceneLifeStart >= GameServerScene.COPY_SCENE_LIFE) {\r\n                    trace(\"销毁副本++++++++++++\", this.id);\r\n                    this.dispose();\r\n                }\r\n            }\r\n            else {\r\n                this.copySceneLifeStart = now;\r\n            }\r\n        }\r\n    }\r\n\r\n}",
        "/**\r\n * 战场场景\r\n */\r\nclass BattleServerScene extends GameServerScene {\r\n    /**\r\n     * 战场处理器\r\n     */\r\n    battleHandler: BattleHandler;\r\n\r\n    constructor() {\r\n        super();\r\n    }\r\n    /**\r\n     * 初始化战场处理器\r\n     */\r\n    initBattleHandler() {\r\n        // 初始化\r\n        this.battleHandler = new BattleHandler();\r\n        // 监听回合结束\r\n        EventUtils.addEventListener(this.battleHandler, BattleHandler.EVENT_AUTO_INTO_NEXT_STEP, Callback.New(() => {\r\n            let battleTimeInfo = new BattleTimeInfo();\r\n            // 回合开始时间\r\n            battleTimeInfo.turnCostTime = new Date().getTime() - this.battleHandler.data.turnStartTime;\r\n            // 当前是谁的回合\r\n            battleTimeInfo.whoseTurn = this.battleHandler.whoseTurn;\r\n            // 玩家剩余时间\r\n            for (let i = 0; i < this.battleHandler.data.playerNumer; i++)battleTimeInfo.playerRestTime[i] = this.battleHandler.data.playerRestTime[i];\r\n            // 广播\r\n            // this.radioPlayers('refreshBattleTime',[battleTimeInfo],'GUI_BattleMain');\r\n        }, this));\r\n    }\r\n}",
        "//■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■\r\n// 服务器的游戏场景对象通用逻辑\r\n//■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■\r\nclass GameServerSceneObject_Core extends ServerSceneObject {\r\n    /**\r\n     * 所属的场景\r\n     */\r\n    scene: GameServerScene;\r\n    /**\r\n     * 状态：忽略不能移动的场合，当遇到障碍时是否忽略该步还是处于等待没有障碍时继续完成该步\r\n     */\r\n    state_ignoreCantMove: boolean;\r\n    /** 是否处于跳跃中 */\r\n    state_isJumping: boolean;\r\n    /** 是否处于移动中 */\r\n    state_isMoving: boolean;\r\n    /** 是否执行行为中 */\r\n    state_behavioring: boolean;\r\n    /** 来自玩家的移动控制*/\r\n    state_MoveByPlayerControl: boolean;\r\n    /**\r\n     * 行为集，由多个行为组合而成\r\n     */\r\n    protected behaviors: ServerSceneObjectBehavior[] = [];\r\n\r\n    constructor(soData: SceneObject = null, presetCustomAttrs: { [varName: string]: { varType: number, value: any } } = null, player: ServerPlayer = null) {\r\n        super(soData, presetCustomAttrs, player);\r\n        if (player) {\r\n            EventUtils.addEventListener(this, ServerSceneObject.EVENT_NEED_STOP_BEHAVIOR, Callback.New(this.onNeedStopBehavior, this));\r\n        }\r\n    }\r\n    //------------------------------------------------------------------------------------------------------\r\n    // \r\n    //------------------------------------------------------------------------------------------------------\r\n    /**\r\n     * 刷新\r\n     * @param now unix时间戳\r\n     */\r\n    update(now: number) {\r\n        // -- 刷新行为\r\n        this.updateBehavior();\r\n        // -- 刷新移动坐标\r\n        this.updateCoordinate(now);\r\n        // -- 刷新NPC并行事件\r\n        var updateCmdPage = this.customCommandPages[2];\r\n        if (updateCmdPage) {\r\n            var updateTrigger = this.getCommandTrigger(1, 2);\r\n            if (updateTrigger) {\r\n                updateCmdPage.startTriggerEvent(updateTrigger, this);\r\n            }\r\n        }\r\n    }\r\n    //------------------------------------------------------------------------------------------------------\r\n    // 行为\r\n    //------------------------------------------------------------------------------------------------------\r\n    /**\r\n     * 添加一组行为\r\n     * @param behaviorData 行为数据\r\n     * @param loop 是否循环\r\n     * @param targetPlayerSceneObject 存在的玩家目标对象\r\n     * @param onOver 当行为结束时回调\r\n     * @param cover 覆盖旧的行为\r\n     */\r\n    addBehavior(behaviorData: any[], loop: boolean, targetPlayerSceneObject: ServerSceneObject, onOver: Callback, cover: boolean) {\r\n        var soBehavior = new ServerSceneObjectBehavior(this, behaviorData, loop, targetPlayerSceneObject as any, onOver);\r\n        if (cover) this.behaviors.length = 0;\r\n        this.behaviors.push(soBehavior);\r\n        this.updateBehavior();\r\n    }\r\n    /**\r\n     * 移除行为\r\n     */\r\n    clearBehavior() {\r\n        this.behaviors.length = 0;\r\n    }\r\n    /**\r\n     * 来自系统底的要求停止行为\r\n     * @param mode 0-对话框显示时 1-对话选择框显示时 2-场景移动时\r\n     */\r\n    private onNeedStopBehavior(mode: number) {\r\n        this.moveStop();\r\n    }\r\n\r\n    /**\r\n     * 刷新行为\r\n     */\r\n    protected updateBehavior() {\r\n        if (this.behaviors.length > 0) {\r\n            this.state_behavioring = true;\r\n            var newestBehavior = this.behaviors[this.behaviors.length - 1];\r\n            var isExecuteOver = newestBehavior.execute();\r\n            // 当该层行为结束时，通知并直接立刻继续执行上一层的行为\r\n            if (isExecuteOver) {\r\n                this.behaviors.pop();\r\n                newestBehavior.onOver && newestBehavior.onOver.run();\r\n                this.updateBehavior();\r\n            }\r\n        }\r\n        else {\r\n            this.state_behavioring = false;\r\n        }\r\n    }\r\n    //------------------------------------------------------------------------------------------------------\r\n    // 移动实现 平面0度格子模式\r\n    //------------------------------------------------------------------------------------------------------\r\n    protected roadsArr: number[][];\r\n    protected nowRoad: number\r\n    protected nowRoadTime: number;\r\n    protected nowRoadStartDate: number;\r\n    protected roadMax: number;\r\n    /**\r\n     * 更新坐标\r\n     * @param _nowTime \r\n     */\r\n    protected updateCoordinate(_nowTime: number): void {\r\n        if (!this.scene) return;\r\n        // 更新移动中的坐标\r\n        if (this.state_isMoving) {\r\n            var per: number;\r\n            // 获取当前路段需要花费的时间段（nowRoadTime）\r\n            var thisRoadP: number[] = this.roadsArr[this.nowRoad];\r\n            var nextRoadP: number[] = this.roadsArr[this.nowRoad + 1];\r\n            // trace(\"nowRoad=\", this.nowRoad, \" ->\", this.nowRoad + 1,thisRoadP,nextRoadP)\r\n            // 没有该时间段的话就\r\n            if (this.nowRoadTime == 0) {\r\n                var ax = thisRoadP[0];\r\n                var ay = thisRoadP[1];\r\n                var bx = nextRoadP[0];\r\n                var by = nextRoadP[1];\r\n                // trace(\"->>>>>>>>AX=\", ax, ay, bx, by);\r\n                var thisRoadS: number = Point.distance2(thisRoadP[0], thisRoadP[1], nextRoadP[0], nextRoadP[1]);\r\n                // if (this.playerUID==2) trace(\"->>>>>>>>AX=\", ax, ay, bx, by,thisRoadS,new Date().getTime());\r\n\r\n                this.nowRoadTime = thisRoadS * 1000 / this.speed;\r\n                this.updateOrientation(ax, ay, bx, by);\r\n            }\r\n            // 大于当前路段终点的时间时\r\n            var nowRoadEndDate: number = this.nowRoadStartDate + this.nowRoadTime;\r\n\r\n            if (_nowTime > nowRoadEndDate) {\r\n                // 当路段未走完的情况：下一个路段 \r\n                this.nowRoad++;\r\n                if (this.nowRoad < this.roadMax - 1) {\r\n                    this.nowRoadStartDate += this.nowRoadTime;\r\n                    this.nowRoadTime = 0;\r\n                    this.updateCoordinate(_nowTime);\r\n                    return;\r\n                }\r\n                // 当路段已到达最终的情况\r\n                else {\r\n                    this.state_isMoving = false;\r\n                    this.x = Math.floor(nextRoadP[0]);\r\n                    this.y = Math.floor(nextRoadP[1]);\r\n                    this.updateObstacle();\r\n                    EventUtils.happen(this, SceneObject.EVENT_MOVE_OVER);\r\n                    return;\r\n                }\r\n            }\r\n            else {\r\n                per = (_nowTime - this.nowRoadStartDate) / this.nowRoadTime;\r\n                // temp : bug per 会小于0？后面再查\r\n                if (per < 0) per = 0;\r\n                var nowP: number[] = Point.interpolate2(nextRoadP[0], nextRoadP[1], thisRoadP[0], thisRoadP[1], per);\r\n                this.x = Math.floor(nowP[0]);\r\n                this.y = Math.floor(nowP[1]);\r\n                // if (this.playerUID==2) trace(\"最终坐标\", this.x, this.y, per, \"时间\", _nowTime, this.nowRoadStartDate, this.nowRoadTime)\r\n                this.updateObstacle();\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * 刷新面向\r\n     */\r\n    protected updateOrientation(x: number, y: number, nextX: number, nextY: number) {\r\n        if (this.fixedOrientation) return;\r\n        var dir = GameUtils.getOriByAngle(MathUtils.direction_360(x, y, nextX, nextY));\r\n        this.avatarOri = dir;\r\n    }\r\n    /**\r\n     * 刷新障碍\r\n     */\r\n    protected updateObstacle() {\r\n        if (ServerConfig.NPC_OBSTACLE) {\r\n            this.scene.updateDynamicObsAndBridge(this, true);\r\n        }\r\n    }\r\n    //------------------------------------------------------------------------------------------------------\r\n    // 功能\r\n    //------------------------------------------------------------------------------------------------------\r\n    /**\r\n     * 移动开始\r\n     * @param _nowTime \r\n     * @param lines \r\n     * @param playerControl [可选] 默认值=false \r\n     * @return 是否成功移动 \r\n     */\r\n    moveStart(_nowTime: number, lines: number[][], playerControl: boolean = false): boolean {\r\n        if (!this.scene) return;\r\n        // 跳跃中无法移动\r\n        if (this.state_isJumping) return false;\r\n        // 非玩家操作的移动中无法移动\r\n        if (playerControl && this.state_MoveByPlayerControl == false && this.state_isMoving) {\r\n            return false;\r\n        }\r\n        if (lines.length == 0) return false;\r\n        var so = this;\r\n        this.updateCoordinate(_nowTime);\r\n        if (lines[0][0] == so.x && lines[0][1] == so.y) return false;\r\n        this.state_MoveByPlayerControl = playerControl;\r\n        this.nowRoadStartDate = _nowTime;\r\n        this.roadsArr = [[so.x, so.y]].concat(lines);\r\n        // if (this.playerUID==2) trace(\"this.roadsArr=\", this.roadsArr)\r\n        this.nowRoad = 0;\r\n        this.nowRoadTime = 0;\r\n        this.state_isMoving = true;\r\n        this.roadMax = this.roadsArr.length;\r\n        // if(this.playerUID==2)trace(\"roadMax=\",this.roadMax)\r\n\r\n        this.scene.radioPlayers(\"moveTo\", [this.index, lines], \"GameFunctionClient\");\r\n        return true;\r\n    }\r\n    /**\r\n     * 停止移动\r\n     */\r\n    moveStop() {\r\n        if (!this.scene) return;\r\n        this.updateCoordinate(new Date().getTime());\r\n        this.state_isMoving = false;\r\n        this.scene.radioPlayers(\"moveStop\", [this.index, this.x, this.y], \"GameFunctionClient\");\r\n    }\r\n    /**\r\n     * 跳跃至坐标\r\n     */\r\n    jumpTo(x: number, y: number, playerControl: boolean = false): void {\r\n        if (!this.scene) return;\r\n        // 移动或跳跃中也无法再次跳跃\r\n        if (this.state_isJumping || this.state_isMoving) return;\r\n        this.x = x;\r\n        this.y = y;\r\n        this.state_isJumping = true;\r\n        setTimeout(function (so: GameServerSceneObject_Core) {\r\n            so.state_isJumping = false;\r\n            EventUtils.happen(this, SceneObject.EVENT_JUMP_OVER);\r\n        }, Config.SCENE_OBJECT_JUMP_INTERVAL, this);\r\n        this.updateObstacle();\r\n        this.scene.radioPlayers(\"jumpTo\", [this.index, x, y], \"GameFunctionClient\");\r\n    }\r\n    /**\r\n     * 设置至坐标\r\n     */\r\n    setTo(x: number, y: number): void {\r\n        if (!this.scene) return;\r\n        if(this.state_isMoving){\r\n            this.moveStop();\r\n        }\r\n        this.x = x;\r\n        this.y = y;\r\n        this.updateObstacle();\r\n        this.scene.radioPlayers(\"setTo\", [this.index, x, y], \"GameFunctionClient\");\r\n    }\r\n    /**\r\n     * 更换行走图\r\n     * @param avatarID \r\n     */\r\n    changeAvatar(avatarID: number, actID: number = -1, frame: number = -1): void {\r\n        if (!this.scene) return;\r\n        this.avatarID = avatarID;\r\n        if (actID != -1) this.avatarAct = actID;\r\n        if (frame != -1) this.avatarFrame = frame;\r\n        this.scene.radioPlayers(\"changeAvatar\", [this.index, avatarID, actID, frame], \"GameFunctionClient\");\r\n    }\r\n    /**\r\n     * 面向\r\n     */\r\n    setOrientation(v: number): void {\r\n        if (!this.scene) return;\r\n        if (!this.fixedOrientation) {\r\n            this.avatarOri = v;\r\n        }\r\n        if (!this.fixedOrientation) {\r\n            this.scene.radioPlayers(\"setOrientation\", [this.index, v], \"GameFunctionClient\");\r\n        }\r\n    }\r\n    /**\r\n     * 更改AVATAR属性\r\n     * @param type 0-体型 1-透明度 2-色相 3-动作播放间隔\r\n     * @param v \r\n     */\r\n    changeAvatarAttribute(type: number, v: number) {\r\n        if (!this.scene) return;\r\n        switch (type) {\r\n            case 0:\r\n                this.scale = v;\r\n                break;\r\n            case 1:\r\n                this.avatarAlpha = v;\r\n                break;\r\n            case 2:\r\n                this.avatarHue = v;\r\n                break;\r\n            case 3:\r\n                this.avatarPlayInterval = v;\r\n                break;\r\n        }\r\n        this.scene.radioPlayers(\"changeAvatarAttribute\", [this.index, type, v], \"GameFunctionClient\");\r\n    }\r\n    /**\r\n     * 更改移动速度，先更新移动速度，如果移动中则重新移动\r\n     * @param v \r\n     */\r\n    changeSpeed(v: number) {\r\n        if (!this.scene) return;\r\n        this.scene.radioPlayers(\"changeAvatarAttribute\", [this.index, 4, v], \"GameFunctionClient\");\r\n        var now = new Date().getTime();\r\n        this.updateCoordinate(now);\r\n        this.speed = v;\r\n        // 重新启动移动\r\n        if (this.state_isMoving) {\r\n            var lines: number[][] = this.roadsArr.splice(this.nowRoad + 1, this.roadsArr.length - this.nowRoad - 1);\r\n            this.state_isMoving = false;\r\n            this.moveStart(now, lines, this.state_MoveByPlayerControl);\r\n        }\r\n    }\r\n    /**\r\n     * 更改影子\r\n     */\r\n    changeShadow(enabled: number, w: number, h: number, alpha: number) {\r\n        if (!this.scene) return;\r\n        this.scene.radioPlayers(\"changeShadow\", [this.index, enabled, w, h, alpha], \"GameFunctionClient\");\r\n    }\r\n    /**\r\n     * 播放动画\r\n     */\r\n    playAnimation(aniID: number, loop: boolean, isHit: boolean) {\r\n        if (!this.scene) return;\r\n        this.scene.radioPlayers(\"playAnimation\", [this.index, aniID, loop, isHit], \"GameFunctionClient\");\r\n    }\r\n    /**\r\n     * 停止动画\r\n     */\r\n    stopAnimation(aniID: number) {\r\n        if (!this.scene) return;\r\n        this.scene.radioPlayers(\"stopAnimation\", [this.index, aniID], \"GameFunctionClient\");\r\n    }\r\n    /**\r\n     * 播放音效\r\n     */\r\n    playSE(seURL: string, volume: number, pitch: number) {\r\n        if (!this.scene) return;\r\n        this.scene.radioPlayers(\"playSE\", [this.index, seURL, volume, pitch], \"GameFunctionClient\");\r\n    }\r\n    /**\r\n     * 更改行走图状态\r\n     * @param type  0-允许选中 1-固定朝向 2-最前方显示 3-穿透 4-播放动作 5-桥属性\r\n     * @param v \r\n     */\r\n    changeAvatarState(type: number, v: number) {\r\n        if (!this.scene) return;\r\n        switch (type) {\r\n            case 0:\r\n                this.selectEnabled = v == 1;\r\n                break;\r\n            case 1:\r\n                this.fixedOrientation = v == 1;\r\n                break;\r\n            case 2:\r\n                this.onTop = v == 1;\r\n                break;\r\n            case 3:\r\n                this.through = v == 1;\r\n                break;\r\n            case 4:\r\n                this.autoPlayEnable = v == 1;\r\n                break;\r\n            case 5:\r\n                this.bridge = v == 1;\r\n                break;\r\n        }\r\n        this.scene.radioPlayers(\"changeAvatarState\", [this.index, type, v], \"GameFunctionClient\");\r\n    }\r\n}\r\n\r\n\r\n",
        "//■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■\r\n// 服务器的游戏场景对象\r\n//■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■\r\nclass GameServerSceneObject_1 extends ServerSceneObject_1 {\r\n\r\n    constructor(soData: SceneObject = null, presetCustomAttrs: { [varName: string]: { varType: number, value: any } } = null, player: ServerPlayer = null) {\r\n        super(soData, presetCustomAttrs, player);\r\n    }\r\n\r\n}",
        "/**\r\n * 服务端的场景对象行为处理\r\n * 一个对象可能拥有多层行为，当前总是执行最后层的行为\r\n * 当行为播放完毕的时候根据循环决定是否重复播放或是清除行为\r\n * \r\n * -- 当来自行为系统安排的移动/跳跃中或等待是会等到结束才会继续执行下一步行为\r\n *    : 玩家碰触一个对象，则可以立刻给他加速掉   \r\n * \r\n * Created by 黑暗之神KDS on 2019-01-28 13:20:45.\r\n */\r\nclass ServerSceneObjectBehavior {\r\n    /**\r\n     * 对应的场景对象\r\n     */\r\n    private so: GameServerSceneObject_Core;\r\n    /**\r\n     * 行为 对应的方法 对应的参数\r\n     */\r\n    private behaviors: [Function, any[]][] = [];\r\n    /**\r\n     * 行为索引\r\n     */\r\n    private index: number;\r\n    /**\r\n     * 是否循环\r\n     */\r\n    private loop: boolean;\r\n    /**\r\n     * 是否等待中\r\n     */\r\n    private isWait: boolean;\r\n    /**\r\n     * 当结束的时候\r\n     */\r\n    onOver: Callback;\r\n    /**\r\n     * 目标玩家的场景对象\r\n     */\r\n    private targetPlayerSceneObject: GameServerSceneObject_Core;\r\n    /**\r\n     * 构造函数\r\n     * @param so \r\n     * @param so \r\n     */\r\n    constructor(so: GameServerSceneObject_Core, behaviorData: any[], loop: boolean, targetPlayerSceneObject: GameServerSceneObject_Core, onOver: Callback) {\r\n        this.so = so;\r\n        this.loop = loop;\r\n        this.index = 0;\r\n        this.onOver = onOver;\r\n        this.targetPlayerSceneObject = targetPlayerSceneObject;\r\n        this.parseBehavior(behaviorData);\r\n\r\n    }\r\n    /**\r\n     * 解析行为，缓存为 behaviors\r\n     * @param behaviorData \r\n     */\r\n    private parseBehavior(behaviorData: any[]) {\r\n        var len = behaviorData.length;\r\n        for (var i = 0; i < len; i++) {\r\n            var behavior = behaviorData[i].concat();\r\n            var behaviorID = behavior.shift();\r\n            var behaviorParams = behavior;\r\n            var behaviorFunc = this[\"behavior\" + behaviorID];\r\n            this.behaviors.push([behaviorFunc, behaviorParams]);\r\n        }\r\n    }\r\n    /**\r\n     * 执行，返回是否删除\r\n     */\r\n    execute(): boolean {\r\n        // 无执行对象时不再执行 && !this.newSign\r\n        if (this.isWait || !this.so || !this.so.inScene) return false;\r\n        // 非立刻执行模式在系统安排的移动或跳跃中不执行\r\n        if (((this.so.state_isMoving && !this.so.state_MoveByPlayerControl) || this.so.state_isJumping)) return false;\r\n        var behavior = this.behaviors[this.index];\r\n        if (behavior) {\r\n            behavior[0].apply(this, behavior[1]);\r\n            this.index++;\r\n            // 执行命令后如果处于等待或行为命令的移动中则需要继续等待执行完毕\r\n            if (this.isWait || (this.so.state_isMoving && !this.so.state_MoveByPlayerControl)) return false;\r\n        }\r\n        if (this.index == this.behaviors.length) {\r\n            if (this.loop) {\r\n                this.index = 0;\r\n            }\r\n            else {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    //------------------------------------------------------------------------------------------------------\r\n    // 行为处理通用方法\r\n    //------------------------------------------------------------------------------------------------------\r\n    private behaviorMoveD(dx: number, dy: number): void {\r\n        var toGrid = GameUtils.getGridPostion(new Point(this.so.x, this.so.y));\r\n        toGrid.x += dx;\r\n        toGrid.y += dy;\r\n        var toP = new Point(toGrid.x * Config.SCENE_GRID_SIZE, toGrid.y * Config.SCENE_GRID_SIZE);\r\n        toP = GameUtils.getGridCenter(toP);\r\n        var hasObs = false;\r\n        // 无需移动的情况（如接近玩家或随机移动被阻挡了）：\r\n        if (dx == 0 && dy == 0) {\r\n            hasObs = true;\r\n        } else {\r\n            // -- 需要计算障碍的情况\r\n            if (ServerConfig.NPC_OBSTACLE && !this.so.through) {\r\n                if (this.so.scene.isObstacleGrid(toGrid, this.so)) {\r\n                    hasObs = true;\r\n                }\r\n            }\r\n            // -- 需要计算边界\r\n            else {\r\n                if (this.so.scene.isOutsideByGrid(toGrid)) {\r\n                    hasObs = true;\r\n                }\r\n            }\r\n        }\r\n        if (hasObs) {\r\n            // 如果不是忽略无法移动的场合则直接下一步\r\n            if (!this.so.state_ignoreCantMove) {\r\n                this.index--;\r\n            }\r\n            return;\r\n        }\r\n        // -- 判断是否允许移动的情况\r\n        this.so.moveStart(new Date().getTime(), [[toP.x, toP.y]]);\r\n    }\r\n    //------------------------------------------------------------------------------------------------------\r\n    // 行为处理\r\n    //------------------------------------------------------------------------------------------------------\r\n    /**\r\n     * 设置AVATAR图样\r\n     * @param avatarID 行走图ID\r\n     * @param actID 动作\r\n     * @param frame 帧数\r\n     */\r\n    private behavior0(avatarID: number, actID: number, frame: number): void {\r\n        this.so.changeAvatar(avatarID, actID, frame);\r\n    }\r\n    /** 向下移动一步 2 */\r\n    private behavior1() {\r\n        this.behaviorMoveD(0, 1);\r\n    }\r\n    /** 向左移动一步 4 */\r\n    private behavior2() {\r\n        this.behaviorMoveD(-1, 0);\r\n    }\r\n    /** 向上移动一步 8 */\r\n    private behavior3() {\r\n        this.behaviorMoveD(0, -1);\r\n    }\r\n    /** 向右移动一步 6 */\r\n    private behavior4() {\r\n        this.behaviorMoveD(1, 0);\r\n    }\r\n    /** 向左下移动一步 1 */\r\n    private behavior5() {\r\n        this.behaviorMoveD(-1, 1);\r\n    }\r\n    /** 向右下移动一步 3 */\r\n    private behavior6() {\r\n        this.behaviorMoveD(1, 1);\r\n    }\r\n    /** 向左上移动一步 7 */\r\n    private behavior7() {\r\n        this.behaviorMoveD(-1, -1);\r\n    }\r\n    /** 向右上移动一步 9 */\r\n    private behavior8() {\r\n        this.behaviorMoveD(1, 1);\r\n    }\r\n    /** 随机移动一步 */\r\n    private behavior9() {\r\n        var arr = [[-1, 0], [1, 0], [0, -1], [0, 1]];\r\n        if (!Config.MOVE_4_ORI) {\r\n            arr.push([-1, -1], [1, 1], [1, -1], [-1, 1]);\r\n        }\r\n        var dp = arr[MathUtils.rand(arr.length)]\r\n        this.behaviorMoveD(dp[0], dp[1]);\r\n    }\r\n    /** 朝玩家移动一步 */\r\n    private behavior10(flip: number = 1) {\r\n        if (this.targetPlayerSceneObject) {\r\n            var px = this.targetPlayerSceneObject.x - this.so.x;\r\n            var py = this.targetPlayerSceneObject.y - this.so.y;\r\n            var dx = px < 0 ? -1 : 1;\r\n            var dy = py < 0 ? -1 : 1;\r\n            if (Math.abs(px) < Config.SCENE_GRID_SIZE) { dx = 0; }\r\n            if (Math.abs(py) < Config.SCENE_GRID_SIZE) { dy = 0; }\r\n            if (Config.MOVE_4_ORI) {\r\n                if (dx == 1 && dy == 1) {\r\n                    px > py ? dy = 0 : dx = 0;\r\n                }\r\n            }\r\n            this.behaviorMoveD(dx * flip, dy * flip);\r\n        }\r\n    }\r\n    /** 远离玩家移动一步 */\r\n    private behavior11() {\r\n        this.behavior10(-1);\r\n    }\r\n    /**\r\n     * 移动至指定坐标\r\n     * @param useGrid 是否使用格子坐标\r\n     * @param x 坐标/格子坐标\r\n     * @param y 坐标/格子坐标\r\n     */\r\n    private behavior12(useGrid: boolean, x: number, y: number, mode:any) {\r\n        var toP: Point = useGrid ? GameUtils.getGridCenter(new Point(x * Config.SCENE_GRID_SIZE, y * Config.SCENE_GRID_SIZE)) : new Point(x, y);\r\n        if (this.so.scene.isOutside(toP)) {\r\n            return;\r\n        }\r\n        if (mode == null) {\r\n            this.so.moveStart(new Date().getTime(), [[toP.x, toP.y]]);\r\n        }\r\n        else if (mode == 1) {\r\n            this.so.jumpTo(toP.x, toP.y);\r\n        }\r\n        else {\r\n            this.so.setTo(toP.x, toP.y);\r\n        }\r\n    }\r\n    /**\r\n     * 跳跃至坐标\r\n     * @param useGrid 是否使用格子坐标\r\n     * @param x 坐标/格子坐标\r\n     * @param y 坐标/格子坐标\r\n     */\r\n    private behavior13(useGrid: boolean, x: number, y: number) {\r\n        this.behavior12(useGrid, x, y, 1);\r\n    }\r\n    /**\r\n     * 设置至坐标\r\n     * @param useGrid 是否使用格子坐标\r\n     * @param x 坐标/格子坐标\r\n     * @param y 坐标/格子坐标\r\n     */\r\n    private behavior14(useGrid: boolean, x: number, y: number) {\r\n        this.behavior12(useGrid, x, y, 2);\r\n    }\r\n    /**\r\n     * 停止移动\r\n     */\r\n    private behavior15() {\r\n        if (this.targetPlayerSceneObject && this.targetPlayerSceneObject.scene) {\r\n            this.targetPlayerSceneObject.moveStop();\r\n        }\r\n    }\r\n    /**\r\n     * 等待\r\n     * @param waitF 服务器帧数\r\n     */\r\n    private behavior16(waitF: number): void {\r\n        this.isWait = true;\r\n        setFrameout(function (_this: ServerSceneObjectBehavior) { _this.isWait = false; }, waitF, this);\r\n    }\r\n    /**\r\n     * 忽略无法移动的场合 ON/OFF\r\n     */\r\n    private behavior17() {\r\n        this.so.state_ignoreCantMove = true;\r\n    }\r\n    private behavior18() {\r\n        this.so.state_ignoreCantMove = false;\r\n    }\r\n    /** 面向朝下 */\r\n    private behavior19() {\r\n        this.so.setOrientation(2);\r\n    }\r\n    /** 面向朝左 */\r\n    private behavior20() {\r\n        this.so.setOrientation(4);\r\n    }\r\n    /** 面向朝上 */\r\n    private behavior21() {\r\n        this.so.setOrientation(8);\r\n    }\r\n    /** 面向朝右 */\r\n    private behavior22() {\r\n        this.so.setOrientation(6);\r\n    }\r\n    /** 面向朝左下 */\r\n    private behavior23() {\r\n        this.so.setOrientation(1);\r\n    }\r\n    /** 面向朝右下 */\r\n    private behavior24() {\r\n        this.so.setOrientation(3);\r\n    }\r\n    /** 面向朝左上 */\r\n    private behavior25() {\r\n        this.so.setOrientation(7);\r\n    }\r\n    /** 面向朝右上 */\r\n    private behavior26() {\r\n        this.so.setOrientation(9);\r\n    }\r\n    /** 面向玩家 */\r\n    private behavior27(isFlip: boolean) {\r\n        if (!this.targetPlayerSceneObject) return;\r\n        var angle = MathUtils.direction_360(this.so.x, this.so.y, this.targetPlayerSceneObject.x, this.targetPlayerSceneObject.y);\r\n        var ori = GameUtils.getOriByAngle(angle);\r\n        this.so.setOrientation(isFlip ? GameUtils.getFlipOri(ori) : ori);\r\n    }\r\n    /** 背向玩家 */\r\n    private behavior28() {\r\n        this.behavior27(true);\r\n    }\r\n    /**\r\n     * 更改体型\r\n     * @param v 体型数值 1=100%\r\n     */\r\n    private behavior29(v: number) {\r\n        this.so.changeAvatarAttribute(0, v);\r\n    }\r\n    /**\r\n     * 更改移动速度\r\n     */\r\n    private behavior30(v: number) {\r\n        this.so.changeSpeed(v);\r\n    }\r\n    /**\r\n     * 更改透明度\r\n     */\r\n    private behavior31(v: number) {\r\n        this.so.changeAvatarAttribute(1, v);\r\n    }\r\n    /**\r\n     * 更改色相 -180~180\r\n     */\r\n    private behavior32(v: number) {\r\n        this.so.changeAvatarAttribute(2, v);\r\n    }\r\n    /**\r\n     * 更改动作播放间隔 1~n\r\n     */\r\n    private behavior33(v: number) {\r\n        this.so.changeAvatarAttribute(3, v);\r\n    }\r\n    /**\r\n     * 更改影子\r\n     * @param enabled 是否启动影子\r\n     * @param w 影子宽度\r\n     * @param h 影子高度\r\n     * @param alpha 影子透明度\r\n     */\r\n    private behavior34(enabled: number, w: number, h: number, alpha: number) {\r\n        this.so.changeShadow(enabled, w, h, alpha);\r\n    }\r\n    /**\r\n     * 播放动画\r\n     * @param aniID 动画ID\r\n     * @param loop 是否循环\r\n     * @param isHit 显示击中效果\r\n     */\r\n    private behavior35(aniID: number, loop: number, isHit: boolean) {\r\n        this.so.playAnimation(aniID, loop?true:false, isHit);\r\n    }\r\n    /**\r\n     * 停止动画\r\n     * @param aniID 动画ID\r\n     */\r\n    private behavior36(aniID: number) {\r\n        this.so.stopAnimation(aniID);\r\n    }\r\n    /**\r\n     * 播放音效\r\n     * @param seURL 地址\r\n     * @param volume 音量 0-1\r\n     * @param pitch 音调 0-2 1=正常\r\n     */\r\n    private behavior37(seURL: string, volume: number, pitch: number) {\r\n        this.so.playSE(seURL, volume, pitch);\r\n    }\r\n    /**\r\n     * 允许选中 ON/OFF\r\n     */\r\n    private behavior38() {\r\n        this.so.changeAvatarState(0, 1);\r\n    }\r\n    private behavior39() {\r\n        this.so.changeAvatarState(0, 0);\r\n    }\r\n    /**\r\n     * 固定朝向 ON/OFF\r\n     */\r\n    private behavior40() {\r\n        this.so.changeAvatarState(1, 1);\r\n    }\r\n    private behavior41() {\r\n        this.so.changeAvatarState(1, 0);\r\n    }\r\n    /**\r\n     * 最前方显示 ON/OFF\r\n     */\r\n    private behavior42() {\r\n        this.so.changeAvatarState(2, 1);\r\n    }\r\n    private behavior43() {\r\n        this.so.changeAvatarState(2, 0);\r\n    }\r\n    /**\r\n     * 穿透 ON/OFF\r\n     */\r\n    private behavior44() {\r\n        this.so.changeAvatarState(3, 1);\r\n    }\r\n    private behavior45() {\r\n        this.so.changeAvatarState(3, 0);\r\n    }\r\n    /**\r\n     * 播放动作 ON/OFF\r\n     */\r\n    private behavior46() {\r\n        this.so.changeAvatarState(4, 1);\r\n    }\r\n    private behavior47() {\r\n        this.so.changeAvatarState(4, 0);\r\n    }\r\n    /**\r\n     * 桥属性 ON/OFF\r\n     */\r\n    private behavior48() {\r\n        this.so.changeAvatarState(5, 1);\r\n    }\r\n    private behavior49() {\r\n        this.so.changeAvatarState(5, 0);\r\n    }\r\n}"
    ],
    "bin": [
        "var Logic_Battle = (function () {\n    function Logic_Battle() {\n    }\n    return Logic_Battle;\n}());\n",
        "var Logic_Hall = (function () {\n    function Logic_Hall() {\n    }\n    Logic_Hall.getMatchablePlayers = function (player) {\n        if (player.sceneID != 1)\n            return;\n        var scene = player.scene;\n        if (!scene)\n            return;\n        var playerInfo = [];\n        for (var i in ServerPlayer.playerList) {\n            var targetPlayer = ServerPlayer.playerList[i];\n            if (targetPlayer == player)\n                continue;\n            if (targetPlayer.variable.getVariable(1) != 1)\n                continue;\n            playerInfo.push({ name: targetPlayer.variable.getString(1), id: targetPlayer.uid });\n        }\n        if (playerInfo.length == 0) {\n            return { name: \"\", id: -1 };\n        }\n        var index_player = MathUtils.rand(playerInfo.length);\n        return playerInfo[index_player];\n    };\n    Logic_Hall.getBattleTargetPlayer = function (player, targetPlayerID) {\n        var scene = player.scene;\n        if (!scene || scene.id != 1)\n            return null;\n        var targetPlayer = ServerPlayer.getPlayerByUID(targetPlayerID);\n        if (!targetPlayer || targetPlayer.sceneID != 1)\n            return null;\n        return targetPlayer;\n    };\n    Logic_Hall.requestBattle = function (player, targetPlayerID) {\n        var targetPlayer = this.getBattleTargetPlayer(player, targetPlayerID);\n        if (!targetPlayer)\n            return 0;\n        player.data.battleRequestTargetID.push(targetPlayerID);\n        targetPlayer.data.battleAcceptID = player.uid;\n        var playerName = player.variable.getString(1);\n        ServerMsgSender.rpc(targetPlayer, \"GUI_Alert\", \"alert\", [(playerName + \"\\u6765\\u627E\\u4F60\\u8E22\\u9986\\u5566\\uFF01\")]);\n    };\n    Logic_Hall.accessBattle = function (player) {\n        var targetPlayerID = player.data.battleAcceptID;\n        var targetPlayer = this.getBattleTargetPlayer(player, targetPlayerID);\n        if (!targetPlayer)\n            return 0;\n        if (targetPlayer.data.battleRequestTargetID.indexOf(player.uid) == -1)\n            return 1;\n        targetPlayer.data.battleRequestTargetID.length = 0;\n        player.data.battleRequestTargetID.length = 0;\n        var battleSceneID = ServerScene.createScene(2, true);\n        var scene = ServerScene.getScene(battleSceneID);\n        scene.initBattleHandler();\n        player.data.battlePlayerID = [player.uid, targetPlayerID];\n        ArrayUtils.randOrder(player.data.battlePlayerID);\n        player.data.battleActor = 1;\n        targetPlayer.data.battleActor = 1;\n        player.toScene(battleSceneID, 0, 0);\n        targetPlayer.toScene(battleSceneID, 0, 0);\n        return 2;\n    };\n    Logic_Hall.battleSceneInfo = {};\n    return Logic_Hall;\n}());\nServerWorld.addServerFunction(\"Logic_Hall\", \"getMatchablePlayers\");\nServerWorld.addServerFunction(\"Logic_Hall\", \"requestBattle\");\nServerWorld.addServerFunction(\"Logic_Hall\", \"accessBattle\");\n",
        "function a22() {\n}\n",
        "globalThis.aaaaaa = function (id) {\n    var player = ServerPlayer.getPlayerByUID(id);\n};\nfunction showPlayers() {\n    trace(\"============check player\");\n    var pArr = [];\n    for (var key in ServerPlayer.playerList) {\n        var p = ServerPlayer.playerList[key];\n        trace(\"线程\" + kdsrpg_scriptID + \"消息\", \"玩家KEY=\", p.key, \"\\u6240\\u5728\\u573A\\u666F\" + p.sceneID + \"\\uFF0C\\u6240\\u5728\\u7EBF\\u7A0B\" + p.threadID);\n        pArr.push(p.key);\n    }\n    return pArr;\n}\nif (kdsrpg_scriptID == 2) {\n}\nfunction threadTest(p) {\n    trace(\"我所在的线程是\", kdsrpg_scriptID, \"接受的参数=\", p);\n    return kdsrpg_scriptID;\n}\nvar AAA = (function () {\n    function AAA() {\n    }\n    AAA.wagagagaga = function (p, a) {\n        trace(\"11111111111111111111wagagaga\", a);\n    };\n    AAA.threadID = function (p) {\n        if (!p.scene)\n            return [];\n        return [p.sceneID, ServerThread.threadID, p.scene.modelID];\n    };\n    return AAA;\n}());\nServerWorld.addServerFunction(\"AAA\");\nServerWorld.setWorldVariableAccessible(0, 1, true);\nEventUtils.addEventListener(ServerPlayer, ServerPlayer.EVENT_PLAYER_DISPLACEMENT, Callback.New(function (player) {\n    trace(ServerThread.threadID, \"有个玩家挤号\", player.uid, player.key);\n}, this));\nEventUtils.addEventListener(ServerPlayer, ServerPlayer.EVENT_PLAYER_LOGIN, Callback.New(function (player) {\n    trace(ServerThread.threadID, \"有个玩家登录\", player.uid, player.key);\n}, this));\nEventUtils.addEventListener(ServerPlayer, ServerPlayer.EVENT_PLAYER_LOGOUT, Callback.New(function (player) {\n    trace(ServerThread.threadID, \"有个玩家下线\", player.uid, player.key);\n}, this));\nEventUtils.addEventListener(ServerPlayer, ServerPlayer.EVENT_PLAYER_MESSAGE, Callback.New(function (player, msg) {\n    trace(ServerThread.threadID, \"++++++++++++++\", player.uid, player.key, msg);\n}, this));\nEventUtils.addEventListener(ServerWorld, ServerWorld.EVENT_STARTUP_COMPLETE, Callback.New(function () {\n    trace(kdsrpg_scriptID, \"世界启动完毕。。。。。。。。\");\n}, this));\n",
        "",
        "ServerWorld.startTriggerCommand = function (player, mainType, indexType, params, onTriggerCreated) {\n    var scene = ServerScene.getScene(player.sceneID);\n    if (!scene || indexType < 0)\n        return;\n    if (params.length < 1)\n        return;\n    var commandID = params[0];\n    var playerInput = params[1];\n    if (playerInput == null)\n        playerInput = [];\n    switch (mainType) {\n        case CommandTarget.COMMAND_MAIN_TYPE_SCENE:\n            var cmdPage = scene.customCommandPages[indexType];\n            if (cmdPage) {\n                var trigger = player.sceneObject.getCommandTrigger(mainType, indexType);\n                if (trigger) {\n                    onTriggerCreated && onTriggerCreated.runWith([trigger]);\n                    cmdPage.startTriggerEvent(trigger, player.sceneObject, playerInput);\n                }\n                return trigger;\n            }\n            break;\n        case CommandTarget.COMMAND_MAIN_TYPE_SCENE_OBJECT:\n            if (commandID < 0)\n                return;\n            var so = scene.sceneObjects[commandID];\n            if (so) {\n                var trigger = player.sceneObject.getCommandTrigger(mainType, indexType);\n                if (trigger) {\n                    onTriggerCreated && onTriggerCreated.runWith([trigger]);\n                    var cmdPage = so.customCommandPages[indexType];\n                    if (cmdPage) {\n                        cmdPage.startTriggerEvent(trigger, so, playerInput);\n                        return trigger;\n                    }\n                }\n            }\n            break;\n        case CommandTarget.COMMAND_MAIN_TYPE_UI:\n            var commands = ServerWorld.uiCustomCommandPages[commandID];\n            if (commands) {\n                var cmdPage = commands[indexType];\n                if (cmdPage) {\n                    var trigger = player.sceneObject.getCommandTrigger(mainType, indexType);\n                    if (trigger) {\n                        onTriggerCreated && onTriggerCreated.runWith([trigger]);\n                        cmdPage.startTriggerEvent(trigger, player.sceneObject, playerInput);\n                    }\n                    return trigger;\n                }\n            }\n            break;\n    }\n};\n",
        "var RequestHandler = (function () {\n    function RequestHandler() {\n    }\n    RequestHandler.inScene = function (player) {\n        var scene = ServerScene.getScene(player.sceneID);\n        if (!scene) {\n        }\n        else {\n            scene.addPlayer(player);\n            trace(\"添加玩家！！！玩家总数=\", scene.playerCount);\n        }\n    };\n    RequestHandler.requestMove = function (player, lines) {\n        var scene = ServerScene.getScene(player.sceneID);\n        if (!scene)\n            return;\n        if (!player.controlEnabled)\n            return;\n        var now = new Date().getTime();\n        var soe = player.sceneObject;\n        soe.moveStart(now, lines, true);\n    };\n    return RequestHandler;\n}());\nServerWorld.addServerFunction(\"RequestHandler\");\n",
        "var __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar GameServerScene = (function (_super) {\n    __extends(GameServerScene, _super);\n    function GameServerScene() {\n        _super.call(this);\n        trace(\"服务器场景===GameServerScene\");\n    }\n    GameServerScene.prototype.readyInScene = function (player) {\n        _super.prototype.readyInScene.apply(this, arguments);\n        trace(\"====>readyInScene\");\n        this.sendToPlayer(player, \"loadNewScene\", [{\n                modelID: this.modelID,\n                thread: ServerThread.getSceneThread(this.id)\n            }]);\n    };\n    GameServerScene.prototype.addPlayer = function (player) {\n        var _this = this;\n        trace(\">>>>>>>>>>>>>addPlayer!!!!\" + player.uid);\n        _super.prototype.addPlayer.call(this, player);\n        var sceneCmdTypeIndex = 0;\n        var commandPageInScene = this.customCommandPages[sceneCmdTypeIndex];\n        this.sendToPlayer(player, \"inNewScene\", [this.getAroundSceneObjects(player.sceneObject, false), commandPageInScene.commands.length > 0 ? true : false]);\n        var inSceneCmdLength = commandPageInScene.commands.length;\n        if (inSceneCmdLength > 0) {\n            var commandTargetInScene = player.sceneObject.getCommandTrigger(CommandTarget.COMMAND_MAIN_TYPE_SCENE, sceneCmdTypeIndex);\n            EventUtils.addEventListener(commandTargetInScene, CommandTarget.EVENT_OVER, Callback.New(function (player) {\n                _this.sendToPlayer(player, \"inSceneCommandExecuteOver\", []);\n            }, this, [player]), true);\n            commandPageInScene.startTriggerEvent(commandTargetInScene, player.sceneObject);\n        }\n    };\n    GameServerScene.prototype.removePlayer = function (player) {\n        _super.prototype.removePlayer.call(this, player);\n    };\n    GameServerScene.prototype.addSceneObject = function (so, addToList) {\n        if (addToList === void 0) { addToList = true; }\n        _super.prototype.addSceneObject.call(this, so, addToList);\n        var selfSyncClientData = so.syncClientData(true);\n        var elseSyncClientData = so.syncClientData(false);\n        for (var uid in this.playerMap) {\n            var player = this.playerMap[uid];\n            var syncClientData = player == so.player ? selfSyncClientData : elseSyncClientData;\n            ServerMsgSender.rpc(player, \"MsgHandler\", \"addSceneObject\", [syncClientData]);\n        }\n    };\n    GameServerScene.prototype.removeSceneObject = function (so, removeFromList, force) {\n        if (removeFromList === void 0) { removeFromList = true; }\n        if (force === void 0) { force = false; }\n        var isRemode = _super.prototype.removeSceneObject.call(this, so, removeFromList, force);\n        if (isRemode)\n            this.radioPlayers(\"removeSceneObject\", [{ index: so.index }]);\n        return isRemode;\n    };\n    GameServerScene.prototype.getAroundSceneObjects = function (targetSceneObject, includeSelf) {\n        var len = this.sceneObjects.length;\n        var arr = [];\n        for (var i = 0; i < len; i++) {\n            var so = this.sceneObjects[i];\n            if (so) {\n                if (so == targetSceneObject && !includeSelf) {\n                    continue;\n                }\n                if (so.inScene)\n                    arr.push(so.syncClientData(false));\n            }\n        }\n        return arr;\n    };\n    GameServerScene.prototype.radioPlayers = function (funcName, params, rpcClass) {\n        if (rpcClass === void 0) { rpcClass = \"MsgHandler\"; }\n        for (var uid in this.playerMap) {\n            var player = this.playerMap[uid];\n            ServerMsgSender.rpc(player, rpcClass, funcName, params);\n        }\n    };\n    GameServerScene.prototype.sendToPlayer = function (player, funcName, params, rpcClass) {\n        if (rpcClass === void 0) { rpcClass = \"MsgHandler\"; }\n        ServerMsgSender.rpc(player, rpcClass, funcName, params);\n    };\n    GameServerScene.prototype.update = function (now) {\n        if (this.playerCount != 0) {\n            var soLen = this.sceneObjects.length;\n            for (var i = 0; i < soLen; i++) {\n                var so = this.sceneObjects[i];\n                if (so)\n                    so.update(now);\n            }\n        }\n        if (this.isCopy) {\n            if (!this.copySceneLifeStart)\n                this.copySceneLifeStart = now;\n            if (this.playerCount == 0) {\n                if (now - this.copySceneLifeStart >= GameServerScene.COPY_SCENE_LIFE) {\n                    trace(\"销毁副本++++++++++++\", this.id);\n                    this.dispose();\n                }\n            }\n            else {\n                this.copySceneLifeStart = now;\n            }\n        }\n    };\n    GameServerScene.COPY_SCENE_LIFE = 5000;\n    return GameServerScene;\n}(ServerScene));\n",
        "var __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar BattleServerScene = (function (_super) {\n    __extends(BattleServerScene, _super);\n    function BattleServerScene() {\n        _super.call(this);\n    }\n    BattleServerScene.prototype.initBattleHandler = function () {\n        var _this = this;\n        this.battleHandler = new BattleHandler();\n        EventUtils.addEventListener(this.battleHandler, BattleHandler.EVENT_AUTO_INTO_NEXT_STEP, Callback.New(function () {\n            var battleTimeInfo = new BattleTimeInfo();\n            battleTimeInfo.turnCostTime = new Date().getTime() - _this.battleHandler.data.turnStartTime;\n            battleTimeInfo.whoseTurn = _this.battleHandler.whoseTurn;\n            for (var i = 0; i < _this.battleHandler.data.playerNumer; i++)\n                battleTimeInfo.playerRestTime[i] = _this.battleHandler.data.playerRestTime[i];\n        }, this));\n    };\n    return BattleServerScene;\n}(GameServerScene));\n",
        "var __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar GameServerSceneObject_Core = (function (_super) {\n    __extends(GameServerSceneObject_Core, _super);\n    function GameServerSceneObject_Core(soData, presetCustomAttrs, player) {\n        if (soData === void 0) { soData = null; }\n        if (presetCustomAttrs === void 0) { presetCustomAttrs = null; }\n        if (player === void 0) { player = null; }\n        _super.call(this, soData, presetCustomAttrs, player);\n        this.behaviors = [];\n        if (player) {\n            EventUtils.addEventListener(this, ServerSceneObject.EVENT_NEED_STOP_BEHAVIOR, Callback.New(this.onNeedStopBehavior, this));\n        }\n    }\n    GameServerSceneObject_Core.prototype.update = function (now) {\n        this.updateBehavior();\n        this.updateCoordinate(now);\n        var updateCmdPage = this.customCommandPages[2];\n        if (updateCmdPage) {\n            var updateTrigger = this.getCommandTrigger(1, 2);\n            if (updateTrigger) {\n                updateCmdPage.startTriggerEvent(updateTrigger, this);\n            }\n        }\n    };\n    GameServerSceneObject_Core.prototype.addBehavior = function (behaviorData, loop, targetPlayerSceneObject, onOver, cover) {\n        var soBehavior = new ServerSceneObjectBehavior(this, behaviorData, loop, targetPlayerSceneObject, onOver);\n        if (cover)\n            this.behaviors.length = 0;\n        this.behaviors.push(soBehavior);\n        this.updateBehavior();\n    };\n    GameServerSceneObject_Core.prototype.clearBehavior = function () {\n        this.behaviors.length = 0;\n    };\n    GameServerSceneObject_Core.prototype.onNeedStopBehavior = function (mode) {\n        this.moveStop();\n    };\n    GameServerSceneObject_Core.prototype.updateBehavior = function () {\n        if (this.behaviors.length > 0) {\n            this.state_behavioring = true;\n            var newestBehavior = this.behaviors[this.behaviors.length - 1];\n            var isExecuteOver = newestBehavior.execute();\n            if (isExecuteOver) {\n                this.behaviors.pop();\n                newestBehavior.onOver && newestBehavior.onOver.run();\n                this.updateBehavior();\n            }\n        }\n        else {\n            this.state_behavioring = false;\n        }\n    };\n    GameServerSceneObject_Core.prototype.updateCoordinate = function (_nowTime) {\n        if (!this.scene)\n            return;\n        if (this.state_isMoving) {\n            var per;\n            var thisRoadP = this.roadsArr[this.nowRoad];\n            var nextRoadP = this.roadsArr[this.nowRoad + 1];\n            if (this.nowRoadTime == 0) {\n                var ax = thisRoadP[0];\n                var ay = thisRoadP[1];\n                var bx = nextRoadP[0];\n                var by = nextRoadP[1];\n                var thisRoadS = Point.distance2(thisRoadP[0], thisRoadP[1], nextRoadP[0], nextRoadP[1]);\n                this.nowRoadTime = thisRoadS * 1000 / this.speed;\n                this.updateOrientation(ax, ay, bx, by);\n            }\n            var nowRoadEndDate = this.nowRoadStartDate + this.nowRoadTime;\n            if (_nowTime > nowRoadEndDate) {\n                this.nowRoad++;\n                if (this.nowRoad < this.roadMax - 1) {\n                    this.nowRoadStartDate += this.nowRoadTime;\n                    this.nowRoadTime = 0;\n                    this.updateCoordinate(_nowTime);\n                    return;\n                }\n                else {\n                    this.state_isMoving = false;\n                    this.x = Math.floor(nextRoadP[0]);\n                    this.y = Math.floor(nextRoadP[1]);\n                    this.updateObstacle();\n                    EventUtils.happen(this, SceneObject.EVENT_MOVE_OVER);\n                    return;\n                }\n            }\n            else {\n                per = (_nowTime - this.nowRoadStartDate) / this.nowRoadTime;\n                if (per < 0)\n                    per = 0;\n                var nowP = Point.interpolate2(nextRoadP[0], nextRoadP[1], thisRoadP[0], thisRoadP[1], per);\n                this.x = Math.floor(nowP[0]);\n                this.y = Math.floor(nowP[1]);\n                this.updateObstacle();\n            }\n        }\n    };\n    GameServerSceneObject_Core.prototype.updateOrientation = function (x, y, nextX, nextY) {\n        if (this.fixedOrientation)\n            return;\n        var dir = GameUtils.getOriByAngle(MathUtils.direction_360(x, y, nextX, nextY));\n        this.avatarOri = dir;\n    };\n    GameServerSceneObject_Core.prototype.updateObstacle = function () {\n        if (ServerConfig.NPC_OBSTACLE) {\n            this.scene.updateDynamicObsAndBridge(this, true);\n        }\n    };\n    GameServerSceneObject_Core.prototype.moveStart = function (_nowTime, lines, playerControl) {\n        if (playerControl === void 0) { playerControl = false; }\n        if (!this.scene)\n            return;\n        if (this.state_isJumping)\n            return false;\n        if (playerControl && this.state_MoveByPlayerControl == false && this.state_isMoving) {\n            return false;\n        }\n        if (lines.length == 0)\n            return false;\n        var so = this;\n        this.updateCoordinate(_nowTime);\n        if (lines[0][0] == so.x && lines[0][1] == so.y)\n            return false;\n        this.state_MoveByPlayerControl = playerControl;\n        this.nowRoadStartDate = _nowTime;\n        this.roadsArr = [[so.x, so.y]].concat(lines);\n        this.nowRoad = 0;\n        this.nowRoadTime = 0;\n        this.state_isMoving = true;\n        this.roadMax = this.roadsArr.length;\n        this.scene.radioPlayers(\"moveTo\", [this.index, lines], \"GameFunctionClient\");\n        return true;\n    };\n    GameServerSceneObject_Core.prototype.moveStop = function () {\n        if (!this.scene)\n            return;\n        this.updateCoordinate(new Date().getTime());\n        this.state_isMoving = false;\n        this.scene.radioPlayers(\"moveStop\", [this.index, this.x, this.y], \"GameFunctionClient\");\n    };\n    GameServerSceneObject_Core.prototype.jumpTo = function (x, y, playerControl) {\n        if (playerControl === void 0) { playerControl = false; }\n        if (!this.scene)\n            return;\n        if (this.state_isJumping || this.state_isMoving)\n            return;\n        this.x = x;\n        this.y = y;\n        this.state_isJumping = true;\n        setTimeout(function (so) {\n            so.state_isJumping = false;\n            EventUtils.happen(this, SceneObject.EVENT_JUMP_OVER);\n        }, Config.SCENE_OBJECT_JUMP_INTERVAL, this);\n        this.updateObstacle();\n        this.scene.radioPlayers(\"jumpTo\", [this.index, x, y], \"GameFunctionClient\");\n    };\n    GameServerSceneObject_Core.prototype.setTo = function (x, y) {\n        if (!this.scene)\n            return;\n        if (this.state_isMoving) {\n            this.moveStop();\n        }\n        this.x = x;\n        this.y = y;\n        this.updateObstacle();\n        this.scene.radioPlayers(\"setTo\", [this.index, x, y], \"GameFunctionClient\");\n    };\n    GameServerSceneObject_Core.prototype.changeAvatar = function (avatarID, actID, frame) {\n        if (actID === void 0) { actID = -1; }\n        if (frame === void 0) { frame = -1; }\n        if (!this.scene)\n            return;\n        this.avatarID = avatarID;\n        if (actID != -1)\n            this.avatarAct = actID;\n        if (frame != -1)\n            this.avatarFrame = frame;\n        this.scene.radioPlayers(\"changeAvatar\", [this.index, avatarID, actID, frame], \"GameFunctionClient\");\n    };\n    GameServerSceneObject_Core.prototype.setOrientation = function (v) {\n        if (!this.scene)\n            return;\n        if (!this.fixedOrientation) {\n            this.avatarOri = v;\n        }\n        if (!this.fixedOrientation) {\n            this.scene.radioPlayers(\"setOrientation\", [this.index, v], \"GameFunctionClient\");\n        }\n    };\n    GameServerSceneObject_Core.prototype.changeAvatarAttribute = function (type, v) {\n        if (!this.scene)\n            return;\n        switch (type) {\n            case 0:\n                this.scale = v;\n                break;\n            case 1:\n                this.avatarAlpha = v;\n                break;\n            case 2:\n                this.avatarHue = v;\n                break;\n            case 3:\n                this.avatarPlayInterval = v;\n                break;\n        }\n        this.scene.radioPlayers(\"changeAvatarAttribute\", [this.index, type, v], \"GameFunctionClient\");\n    };\n    GameServerSceneObject_Core.prototype.changeSpeed = function (v) {\n        if (!this.scene)\n            return;\n        this.scene.radioPlayers(\"changeAvatarAttribute\", [this.index, 4, v], \"GameFunctionClient\");\n        var now = new Date().getTime();\n        this.updateCoordinate(now);\n        this.speed = v;\n        if (this.state_isMoving) {\n            var lines = this.roadsArr.splice(this.nowRoad + 1, this.roadsArr.length - this.nowRoad - 1);\n            this.state_isMoving = false;\n            this.moveStart(now, lines, this.state_MoveByPlayerControl);\n        }\n    };\n    GameServerSceneObject_Core.prototype.changeShadow = function (enabled, w, h, alpha) {\n        if (!this.scene)\n            return;\n        this.scene.radioPlayers(\"changeShadow\", [this.index, enabled, w, h, alpha], \"GameFunctionClient\");\n    };\n    GameServerSceneObject_Core.prototype.playAnimation = function (aniID, loop, isHit) {\n        if (!this.scene)\n            return;\n        this.scene.radioPlayers(\"playAnimation\", [this.index, aniID, loop, isHit], \"GameFunctionClient\");\n    };\n    GameServerSceneObject_Core.prototype.stopAnimation = function (aniID) {\n        if (!this.scene)\n            return;\n        this.scene.radioPlayers(\"stopAnimation\", [this.index, aniID], \"GameFunctionClient\");\n    };\n    GameServerSceneObject_Core.prototype.playSE = function (seURL, volume, pitch) {\n        if (!this.scene)\n            return;\n        this.scene.radioPlayers(\"playSE\", [this.index, seURL, volume, pitch], \"GameFunctionClient\");\n    };\n    GameServerSceneObject_Core.prototype.changeAvatarState = function (type, v) {\n        if (!this.scene)\n            return;\n        switch (type) {\n            case 0:\n                this.selectEnabled = v == 1;\n                break;\n            case 1:\n                this.fixedOrientation = v == 1;\n                break;\n            case 2:\n                this.onTop = v == 1;\n                break;\n            case 3:\n                this.through = v == 1;\n                break;\n            case 4:\n                this.autoPlayEnable = v == 1;\n                break;\n            case 5:\n                this.bridge = v == 1;\n                break;\n        }\n        this.scene.radioPlayers(\"changeAvatarState\", [this.index, type, v], \"GameFunctionClient\");\n    };\n    return GameServerSceneObject_Core;\n}(ServerSceneObject));\n",
        "var __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar GameServerSceneObject_1 = (function (_super) {\n    __extends(GameServerSceneObject_1, _super);\n    function GameServerSceneObject_1(soData, presetCustomAttrs, player) {\n        if (soData === void 0) { soData = null; }\n        if (presetCustomAttrs === void 0) { presetCustomAttrs = null; }\n        if (player === void 0) { player = null; }\n        _super.call(this, soData, presetCustomAttrs, player);\n    }\n    return GameServerSceneObject_1;\n}(ServerSceneObject_1));\n",
        "var ServerSceneObjectBehavior = (function () {\n    function ServerSceneObjectBehavior(so, behaviorData, loop, targetPlayerSceneObject, onOver) {\n        this.behaviors = [];\n        this.so = so;\n        this.loop = loop;\n        this.index = 0;\n        this.onOver = onOver;\n        this.targetPlayerSceneObject = targetPlayerSceneObject;\n        this.parseBehavior(behaviorData);\n    }\n    ServerSceneObjectBehavior.prototype.parseBehavior = function (behaviorData) {\n        var len = behaviorData.length;\n        for (var i = 0; i < len; i++) {\n            var behavior = behaviorData[i].concat();\n            var behaviorID = behavior.shift();\n            var behaviorParams = behavior;\n            var behaviorFunc = this[\"behavior\" + behaviorID];\n            this.behaviors.push([behaviorFunc, behaviorParams]);\n        }\n    };\n    ServerSceneObjectBehavior.prototype.execute = function () {\n        if (this.isWait || !this.so || !this.so.inScene)\n            return false;\n        if (((this.so.state_isMoving && !this.so.state_MoveByPlayerControl) || this.so.state_isJumping))\n            return false;\n        var behavior = this.behaviors[this.index];\n        if (behavior) {\n            behavior[0].apply(this, behavior[1]);\n            this.index++;\n            if (this.isWait || (this.so.state_isMoving && !this.so.state_MoveByPlayerControl))\n                return false;\n        }\n        if (this.index == this.behaviors.length) {\n            if (this.loop) {\n                this.index = 0;\n            }\n            else {\n                return true;\n            }\n        }\n        return false;\n    };\n    ServerSceneObjectBehavior.prototype.behaviorMoveD = function (dx, dy) {\n        var toGrid = GameUtils.getGridPostion(new Point(this.so.x, this.so.y));\n        toGrid.x += dx;\n        toGrid.y += dy;\n        var toP = new Point(toGrid.x * Config.SCENE_GRID_SIZE, toGrid.y * Config.SCENE_GRID_SIZE);\n        toP = GameUtils.getGridCenter(toP);\n        var hasObs = false;\n        if (dx == 0 && dy == 0) {\n            hasObs = true;\n        }\n        else {\n            if (ServerConfig.NPC_OBSTACLE && !this.so.through) {\n                if (this.so.scene.isObstacleGrid(toGrid, this.so)) {\n                    hasObs = true;\n                }\n            }\n            else {\n                if (this.so.scene.isOutsideByGrid(toGrid)) {\n                    hasObs = true;\n                }\n            }\n        }\n        if (hasObs) {\n            if (!this.so.state_ignoreCantMove) {\n                this.index--;\n            }\n            return;\n        }\n        this.so.moveStart(new Date().getTime(), [[toP.x, toP.y]]);\n    };\n    ServerSceneObjectBehavior.prototype.behavior0 = function (avatarID, actID, frame) {\n        this.so.changeAvatar(avatarID, actID, frame);\n    };\n    ServerSceneObjectBehavior.prototype.behavior1 = function () {\n        this.behaviorMoveD(0, 1);\n    };\n    ServerSceneObjectBehavior.prototype.behavior2 = function () {\n        this.behaviorMoveD(-1, 0);\n    };\n    ServerSceneObjectBehavior.prototype.behavior3 = function () {\n        this.behaviorMoveD(0, -1);\n    };\n    ServerSceneObjectBehavior.prototype.behavior4 = function () {\n        this.behaviorMoveD(1, 0);\n    };\n    ServerSceneObjectBehavior.prototype.behavior5 = function () {\n        this.behaviorMoveD(-1, 1);\n    };\n    ServerSceneObjectBehavior.prototype.behavior6 = function () {\n        this.behaviorMoveD(1, 1);\n    };\n    ServerSceneObjectBehavior.prototype.behavior7 = function () {\n        this.behaviorMoveD(-1, -1);\n    };\n    ServerSceneObjectBehavior.prototype.behavior8 = function () {\n        this.behaviorMoveD(1, 1);\n    };\n    ServerSceneObjectBehavior.prototype.behavior9 = function () {\n        var arr = [[-1, 0], [1, 0], [0, -1], [0, 1]];\n        if (!Config.MOVE_4_ORI) {\n            arr.push([-1, -1], [1, 1], [1, -1], [-1, 1]);\n        }\n        var dp = arr[MathUtils.rand(arr.length)];\n        this.behaviorMoveD(dp[0], dp[1]);\n    };\n    ServerSceneObjectBehavior.prototype.behavior10 = function (flip) {\n        if (flip === void 0) { flip = 1; }\n        if (this.targetPlayerSceneObject) {\n            var px = this.targetPlayerSceneObject.x - this.so.x;\n            var py = this.targetPlayerSceneObject.y - this.so.y;\n            var dx = px < 0 ? -1 : 1;\n            var dy = py < 0 ? -1 : 1;\n            if (Math.abs(px) < Config.SCENE_GRID_SIZE) {\n                dx = 0;\n            }\n            if (Math.abs(py) < Config.SCENE_GRID_SIZE) {\n                dy = 0;\n            }\n            if (Config.MOVE_4_ORI) {\n                if (dx == 1 && dy == 1) {\n                    px > py ? dy = 0 : dx = 0;\n                }\n            }\n            this.behaviorMoveD(dx * flip, dy * flip);\n        }\n    };\n    ServerSceneObjectBehavior.prototype.behavior11 = function () {\n        this.behavior10(-1);\n    };\n    ServerSceneObjectBehavior.prototype.behavior12 = function (useGrid, x, y, mode) {\n        var toP = useGrid ? GameUtils.getGridCenter(new Point(x * Config.SCENE_GRID_SIZE, y * Config.SCENE_GRID_SIZE)) : new Point(x, y);\n        if (this.so.scene.isOutside(toP)) {\n            return;\n        }\n        if (mode == null) {\n            this.so.moveStart(new Date().getTime(), [[toP.x, toP.y]]);\n        }\n        else if (mode == 1) {\n            this.so.jumpTo(toP.x, toP.y);\n        }\n        else {\n            this.so.setTo(toP.x, toP.y);\n        }\n    };\n    ServerSceneObjectBehavior.prototype.behavior13 = function (useGrid, x, y) {\n        this.behavior12(useGrid, x, y, 1);\n    };\n    ServerSceneObjectBehavior.prototype.behavior14 = function (useGrid, x, y) {\n        this.behavior12(useGrid, x, y, 2);\n    };\n    ServerSceneObjectBehavior.prototype.behavior15 = function () {\n        if (this.targetPlayerSceneObject && this.targetPlayerSceneObject.scene) {\n            this.targetPlayerSceneObject.moveStop();\n        }\n    };\n    ServerSceneObjectBehavior.prototype.behavior16 = function (waitF) {\n        this.isWait = true;\n        setFrameout(function (_this) { _this.isWait = false; }, waitF, this);\n    };\n    ServerSceneObjectBehavior.prototype.behavior17 = function () {\n        this.so.state_ignoreCantMove = true;\n    };\n    ServerSceneObjectBehavior.prototype.behavior18 = function () {\n        this.so.state_ignoreCantMove = false;\n    };\n    ServerSceneObjectBehavior.prototype.behavior19 = function () {\n        this.so.setOrientation(2);\n    };\n    ServerSceneObjectBehavior.prototype.behavior20 = function () {\n        this.so.setOrientation(4);\n    };\n    ServerSceneObjectBehavior.prototype.behavior21 = function () {\n        this.so.setOrientation(8);\n    };\n    ServerSceneObjectBehavior.prototype.behavior22 = function () {\n        this.so.setOrientation(6);\n    };\n    ServerSceneObjectBehavior.prototype.behavior23 = function () {\n        this.so.setOrientation(1);\n    };\n    ServerSceneObjectBehavior.prototype.behavior24 = function () {\n        this.so.setOrientation(3);\n    };\n    ServerSceneObjectBehavior.prototype.behavior25 = function () {\n        this.so.setOrientation(7);\n    };\n    ServerSceneObjectBehavior.prototype.behavior26 = function () {\n        this.so.setOrientation(9);\n    };\n    ServerSceneObjectBehavior.prototype.behavior27 = function (isFlip) {\n        if (!this.targetPlayerSceneObject)\n            return;\n        var angle = MathUtils.direction_360(this.so.x, this.so.y, this.targetPlayerSceneObject.x, this.targetPlayerSceneObject.y);\n        var ori = GameUtils.getOriByAngle(angle);\n        this.so.setOrientation(isFlip ? GameUtils.getFlipOri(ori) : ori);\n    };\n    ServerSceneObjectBehavior.prototype.behavior28 = function () {\n        this.behavior27(true);\n    };\n    ServerSceneObjectBehavior.prototype.behavior29 = function (v) {\n        this.so.changeAvatarAttribute(0, v);\n    };\n    ServerSceneObjectBehavior.prototype.behavior30 = function (v) {\n        this.so.changeSpeed(v);\n    };\n    ServerSceneObjectBehavior.prototype.behavior31 = function (v) {\n        this.so.changeAvatarAttribute(1, v);\n    };\n    ServerSceneObjectBehavior.prototype.behavior32 = function (v) {\n        this.so.changeAvatarAttribute(2, v);\n    };\n    ServerSceneObjectBehavior.prototype.behavior33 = function (v) {\n        this.so.changeAvatarAttribute(3, v);\n    };\n    ServerSceneObjectBehavior.prototype.behavior34 = function (enabled, w, h, alpha) {\n        this.so.changeShadow(enabled, w, h, alpha);\n    };\n    ServerSceneObjectBehavior.prototype.behavior35 = function (aniID, loop, isHit) {\n        this.so.playAnimation(aniID, loop ? true : false, isHit);\n    };\n    ServerSceneObjectBehavior.prototype.behavior36 = function (aniID) {\n        this.so.stopAnimation(aniID);\n    };\n    ServerSceneObjectBehavior.prototype.behavior37 = function (seURL, volume, pitch) {\n        this.so.playSE(seURL, volume, pitch);\n    };\n    ServerSceneObjectBehavior.prototype.behavior38 = function () {\n        this.so.changeAvatarState(0, 1);\n    };\n    ServerSceneObjectBehavior.prototype.behavior39 = function () {\n        this.so.changeAvatarState(0, 0);\n    };\n    ServerSceneObjectBehavior.prototype.behavior40 = function () {\n        this.so.changeAvatarState(1, 1);\n    };\n    ServerSceneObjectBehavior.prototype.behavior41 = function () {\n        this.so.changeAvatarState(1, 0);\n    };\n    ServerSceneObjectBehavior.prototype.behavior42 = function () {\n        this.so.changeAvatarState(2, 1);\n    };\n    ServerSceneObjectBehavior.prototype.behavior43 = function () {\n        this.so.changeAvatarState(2, 0);\n    };\n    ServerSceneObjectBehavior.prototype.behavior44 = function () {\n        this.so.changeAvatarState(3, 1);\n    };\n    ServerSceneObjectBehavior.prototype.behavior45 = function () {\n        this.so.changeAvatarState(3, 0);\n    };\n    ServerSceneObjectBehavior.prototype.behavior46 = function () {\n        this.so.changeAvatarState(4, 1);\n    };\n    ServerSceneObjectBehavior.prototype.behavior47 = function () {\n        this.so.changeAvatarState(4, 0);\n    };\n    ServerSceneObjectBehavior.prototype.behavior48 = function () {\n        this.so.changeAvatarState(5, 1);\n    };\n    ServerSceneObjectBehavior.prototype.behavior49 = function () {\n        this.so.changeAvatarState(5, 0);\n    };\n    return ServerSceneObjectBehavior;\n}());\n"
    ]
}