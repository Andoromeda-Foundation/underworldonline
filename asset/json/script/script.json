{
    "title": [
        "GUI_Alert",
        "GUI_BattleCommon",
        "GUI_battle1",
        "UI_cardInDeck",
        "UI_cardInEdit",
        "GUI_card",
        "GUI_mainMenu",
        "UIBase",
        "GameFunctionClient",
        "MsgHandler",
        "Controller",
        "Login",
        "GameClientScene",
        "GameClientSceneObject_Core",
        "GameClientSceneObject_1"
    ],
    "src": [
        "class GUI_Alert {\r\n    static alert(content: string) {\r\n        alert(content);\r\n        ClientMsgSender.rpc(\"Logic_Hall\", \"accessBattle\", [], Callback.New((state: number) => {\r\n            if(state == 0){\r\n                alert(\"您的对手已神隐不见了\");\r\n            }\r\n            else if(state == 1){\r\n                alert(\"对方已经和别人打起来了\");\r\n            }\r\n        }, this));\r\n    }\r\n}",
        "/**\r\n * 战场 - 通用\r\n */\r\nclass GUI_BattleCommon extends GUI_4 {\r\n    /**\r\n     * 战场 UI 实例\r\n     */\r\n    protected static ui: GUI_BattleCommon = GameUI.get(5) as any;\r\n    /**\r\n     * 时间信息\r\n     */\r\n    protected battleTimeInfo: BattleTimeInfo;\r\n    /**\r\n     * 阶段步骤\r\n     */\r\n    protected stageStep: number;\r\n    /**\r\n     * 我是否为参赛者\r\n     */\r\n    protected isBattlePlayer: boolean;\r\n    /**\r\n     * 是否为我的回合\r\n     */\r\n    protected isMyTurn: boolean;\r\n    /**\r\n     * 是否为我的行动\r\n     */\r\n    protected isMyAction: boolean;\r\n    /**\r\n     * 我的玩家序号\r\n     */\r\n    protected myPlayerIndex: number;\r\n    /**\r\n     * 构造函数\r\n     */\r\n    constructor() {\r\n        super();\r\n\r\n    }\r\n    //------------------------------------------------------------------------------------------------------\r\n    // STATIC 静态方法\r\n    //------------------------------------------------------------------------------------------------------\r\n    /**\r\n     * 刷新状态\r\n     */\r\n    protected static refreshStageStep(stageStep: number) {\r\n        this.ui.refreshStageStep(stageStep);\r\n    }\r\n    /**\r\n     * 静止\r\n     */\r\n    protected static pause(stageStep: number) {\r\n        this.ui.refreshStageStep(stageStep);\r\n        this.ui.refreshTurn();\r\n    }\r\n    /**\r\n     * 恢复\r\n     */\r\n    // protected static restore\r\n\r\n    //------------------------------------------------------------------------------------------------------\r\n    // 方法 - 刷新\r\n    //------------------------------------------------------------------------------------------------------\r\n    /**\r\n     * （根据阶段）刷新\r\n     */\r\n    protected refreshStageStep(stageStep: number) {\r\n        this.stageStep = stageStep;\r\n        switch (stageStep) {\r\n            case BattleHandler.STAGE_BATTLE: // 对战阶段\r\n                // os.add_ENTERFRAME()\r\n                break;\r\n            case BattleHandler.STAGE_END: // 结束阶段\r\n                //\r\n                break;\r\n        }\r\n    }\r\n    /**\r\n     * 刷新回合\r\n     */\r\n    protected refreshTurn() {\r\n\r\n    }\r\n    /**\r\n     * 刷新时间\r\n     */\r\n    protected refreshTime() {\r\n\r\n    }\r\n\r\n    //------------------------------------------------------------------------------------------------------\r\n    // 方法 - 玩法行动\r\n    //------------------------------------------------------------------------------------------------------\r\n    /**\r\n     * \r\n     */\r\n    // private \r\n\r\n    //------------------------------------------------------------------------------------------------------\r\n    // 方法 - 监听其他行动\r\n    //------------------------------------------------------------------------------------------------------\r\n    /**\r\n     * 退出\r\n     */\r\n    protected onExit() {\r\n        ClientMsgSender.rpc(\"Logic_Battle\", )\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
        "/**\r\n * 战场 - 初级\r\n */\r\nclass GUI_battle1 extends GUI_BattleCommon {\r\n    public libraryList: Module_卡牌[];\r\n    public HandList: Module_卡牌[];\r\n    constructor() {\r\n        super();\r\n    }\r\n    //=======================================\r\n    //              牌库相关\r\n    //=======================================\r\n    // 初始化牌库\r\n    public initLibrary(index_deck: number) {\r\n        // 初始化牌库的卡牌列表\r\n        this.libraryList.length = 0;\r\n        let cardList: DataStructure_卡堆[] = Game.player.data.卡组[index_deck].卡牌列表;\r\n        for (let i = 0; i < cardList.length; i++) {\r\n            for (let j = 0; j < cardList[i].数量; j++) {\r\n                this.libraryList.push(cardList[i].卡牌);\r\n            }\r\n        }\r\n        // 打乱牌序\r\n        this.randLibraryOrder();\r\n        // 将前 N 张给手牌\r\n        this.fromLibraryToHand(6);\r\n        // \r\n    }\r\n    // 打乱牌库的牌序\r\n    public randLibraryOrder() {\r\n        ArrayUtils.randOrder(this.libraryList);\r\n    }\r\n    // 从牌库加入到手牌\r\n    public fromLibraryToHand(cardNum: number) {\r\n        for (let i = 0; i < cardNum; i++) {\r\n            this.HandList.push(this.libraryList.shift());\r\n        }\r\n    }\r\n\r\n    //=======================================\r\n    //              手牌相关\r\n    //=======================================\r\n    // 初始化手牌\r\n    public initHand() {\r\n        this.HandList.length = 0;\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n}",
        "class UI_cardInDeck extends GUI_2001 {\r\n    constructor() {\r\n        super();\r\n        this.on(EventObject.CLICK, this, this.removeCard);\r\n        this.文本_卡牌名称.on(EventObject.CHANGE, this, this.updateFontSize);\r\n        this.文本_卡牌数量.on(EventObject.CHANGE, this, this.updateNumberColor);\r\n    }\r\n    // 【移出】左键点击卡牌\r\n    private removeCard() {\r\n        let gui_card: GUI_card = GameUI.get(3) as any;\r\n        gui_card.removeCardFromDeck(Number(this.卡牌编号.text));\r\n    }\r\n    // 刷新卡组内卡牌名称大小\r\n    public updateFontSize() {\r\n        if (this.文本_卡牌名称.text.length == 8) this.文本_卡牌名称.fontSize = 17;\r\n        else if (this.文本_卡牌名称.text.length == 9) this.文本_卡牌名称.fontSize = 16;\r\n        else if (this.文本_卡牌名称.text.length == 10) this.文本_卡牌名称.fontSize = 15;\r\n        else if (this.文本_卡牌名称.text.length > 10) this.文本_卡牌名称.fontSize = 14;\r\n    }\r\n    // 刷新卡组内卡牌数量的颜色\r\n    public updateNumberColor() {\r\n        // 定义变量\r\n        let card: Module_卡牌 = GameData.customModulePresetDatas[1][Number(this.卡牌编号.text)];\r\n        // 判断是否满足最大张数\r\n        if (Number(this.文本_卡牌数量.text.substr(0, this.文本_卡牌数量.text.length - 1)) >= card.数量限制) {\r\n            this.文本_卡牌数量.color = \"#FFD700\"; // 金色\r\n        }\r\n        else {\r\n            this.文本_卡牌数量.color = \"#eeeeee\"; // 白色\r\n        }\r\n    }\r\n}",
        "class UI_cardInEdit extends GUI_1001 {\r\n    private listener_mouse_up: EventDispatcher;\r\n    private listener_mouse_move: EventDispatcher;\r\n    constructor() {\r\n        super();\r\n        this.on(EventObject.CLICK, this, this.addCard);\r\n        // this.on(EventObject.DRAG_START, this, this.dragStart);\r\n        // this.on(EventObject.MOUSE_DOWN, this, this.mouseDown);\r\n    }\r\n    // 【加入】左键点击卡牌\r\n    private addCard() {\r\n        let gui_card: GUI_card = GameUI.get(3) as any;\r\n        gui_card.addCardToDeck(Number(this.卡牌编号.text));\r\n    }\r\n    // // 鼠标按下\r\n    // private mouseDown() {\r\n    //     // 定义变量\r\n    //     let mouseX: number = Game.currentScene.localX;\r\n    //     let mouseY: number = Game.currentScene.localY;\r\n    //     // 监听鼠标松开事件\r\n    //     this.listener_mouse_up = this.once(EventObject.MOUSE_UP, this, this.mouseUp);\r\n    //     // 监听鼠标位移\r\n    //     this.listener_mouse_move = this.on(EventObject.MOUSE_MOVE, this, this.mouseMove, [mouseX, mouseY]);\r\n    // }\r\n    // // 鼠标松开\r\n    // private mouseUp() {\r\n    //     // 停止监听鼠标移动\r\n    //     this.listener_mouse_move.offAll();\r\n    //     // 加入卡牌\r\n    //     this.addCard();\r\n    // }\r\n    // // 鼠标移动\r\n    // private mouseMove(mouseX1: number, mouseY1: number) {\r\n    //     // 定义变量\r\n    //     let mouseX2: number = Game.currentScene.localX;\r\n    //     let mouseY2: number = Game.currentScene.localY;\r\n    //     let distance: number = Math.sqrt(Math.pow(mouseX2 - mouseX1, 2) + Math.pow(mouseY2 - mouseY1, 2));\r\n    //     // 当鼠标移动距离大于10像素时，判断为拖拽\r\n    //     if (distance > 10) {\r\n    //         this.listener_mouse_move.offAll();\r\n    //         this.startDrag();\r\n    //     }\r\n    // }\r\n}",
        "var GameListData;\r\nvar GameData;\r\nvar Common;\r\nclass GUI_card extends GUI_3 {\r\n    public index_deck: number;\r\n    private interactive_turnDownTip: Tween;\r\n    constructor() {\r\n        super();\r\n        // 显示卡库的卡牌\r\n        this.updateCardList();\r\n        // 显示卡组1的卡牌\r\n        this.index_deck = 0;\r\n        this.updateDeckName();\r\n        this.updateCardInDeck();\r\n        // 交互效果\r\n        this.interactiveEffect();\r\n        // 【控件】可输入文本的监听\r\n        this.可输入文本_搜索内容.on(EventObject.BLUR, this, this.searchCard);\r\n        this.可输入文本_搜索内容.on(EventObject.ENTER, this, this.searchCardUIEnter);\r\n        this.可输入文本_卡组标题.on(EventObject.BLUR, this, this.deckNameEdit);\r\n        this.可输入文本_卡组标题.on(EventObject.ENTER, this, this.deckNameUIEnter);\r\n    }\r\n    //=======================================\r\n    //              左侧界面相关\r\n    //=======================================\r\n    // 刷新卡组名称\r\n    private updateDeckName() {\r\n        this.文本_卡组标题.text = Game.player.data.卡组[this.index_deck].卡组名称;\r\n    }\r\n    // 卡组名称输入框 按下回车，跳转至失去焦点\r\n    private deckNameUIEnter() {\r\n        this.可输入文本_备用.focus();\r\n    }\r\n    // 卡组名称编辑\r\n    private deckNameEdit() {\r\n        let deck: DataStructure_卡组 = Game.player.data.卡组[this.index_deck];\r\n        if (this.可输入文本_卡组标题.text != \"\") deck.卡组名称 = this.可输入文本_卡组标题.text;\r\n        this.可输入文本_卡组标题.visible = false;\r\n        this.updateDeckName();\r\n        this.文本_卡组标题.visible = true;\r\n        this.图片_卡组标题编辑.visible = true;\r\n    }\r\n    // 刷新卡组内费用分布\r\n    private changeCostInDeck(_cost: number, _num: number, _symbol: string = \"+\") {\r\n        if (_cost > 7) _cost = 7;\r\n        eval(\"this.图片_费用条\" + _cost + \".width\" + _symbol + \"=\" + _num * 8);\r\n        if (eval(\"this.图片_费用条\" + _cost).width > 25 * 8) eval(\"this.图片_费用条\" + _cost).width = 25 * 8;\r\n    }\r\n    // 刷新卡组内能力图标数量\r\n    private changeAbilityIconInDeck(_card: Module_卡牌, _num: number, _symbol: string = \"+\") {\r\n        if (_symbol == \"+\") {\r\n            this.文本_调查图标数量.text = (Number(this.文本_调查图标数量.text) + _card.调查图标 * _num).toString();\r\n            this.文本_战斗图标数量.text = (Number(this.文本_战斗图标数量.text) + _card.战斗图标 * _num).toString();\r\n            this.文本_势力图标数量.text = (Number(this.文本_势力图标数量.text) + _card.势力图标 * _num).toString();\r\n        }\r\n        else if (_symbol == \"-\") {\r\n            this.文本_调查图标数量.text = (Number(this.文本_调查图标数量.text) - _card.调查图标 * _num).toString();\r\n            this.文本_战斗图标数量.text = (Number(this.文本_战斗图标数量.text) - _card.战斗图标 * _num).toString();\r\n            this.文本_势力图标数量.text = (Number(this.文本_势力图标数量.text) - _card.势力图标 * _num).toString();\r\n        }\r\n    }\r\n    // 刷新卡组内卡牌列表\r\n    public updateCardInDeck() {\r\n        // 定义变量\r\n        let cardList = [];\r\n        let theDeck = Game.player.data.卡组[this.index_deck];\r\n        // 初始化\r\n        for (let i = 0; i < 8; i++)eval(\"this.图片_费用条\" + i).width = 0;\r\n        this.文本_调查图标数量.text = \"0\";\r\n        this.文本_战斗图标数量.text = \"0\";\r\n        this.文本_势力图标数量.text = \"0\";\r\n        // 赋值列表\r\n        for (let i = 0; i < theDeck.卡牌列表.length; i++) {\r\n            // 定义变量\r\n            let card: DataStructure_卡堆 = theDeck.卡牌列表[i];\r\n            // console.log(\"card2:\", card);\r\n            let itemData: ListItem_2001 = new ListItem_2001();\r\n            // 赋值卡牌\r\n            itemData.卡牌编号 = card.卡牌.id.toString();\r\n            itemData.文本_卡牌数量 = card.数量.toString().concat(\"x\");\r\n            itemData.文本_卡牌名称 = GameListData.getName(Common.customModuleDataList[1], card.卡牌.id);\r\n            itemData.文本_费用 = card.卡牌.费用.toString();\r\n            cardList.push(itemData);\r\n            // 修改费用分布\r\n            this.changeCostInDeck(card.卡牌.费用, card.数量);\r\n            // 修改能力图标数量\r\n            this.changeAbilityIconInDeck(card.卡牌, card.数量);\r\n        }\r\n        this.列表_组内卡牌.items = cardList;\r\n        // 刷新卡组内卡牌数量\r\n        let cardNumber: number = 0;\r\n        for (let i = 0; i < theDeck.卡牌列表.length; i++) {\r\n            cardNumber += theDeck.卡牌列表[i].数量;\r\n        }\r\n        this.文本_卡牌数量.text = cardNumber.toString();\r\n    }\r\n    // 从卡组中移出卡牌\r\n    public removeCardFromDeck(id: number) {\r\n        // 定义变量\r\n        let card: Module_卡牌 = GameData.customModulePresetDatas[1][id];\r\n        let theDeck = Game.player.data.卡组[this.index_deck];\r\n        let temp_卡牌列表: DataStructure_卡堆[] = ArrayUtils.matchAttributesD2(theDeck.卡牌列表, \"卡牌\", { id: id }, true) as any;\r\n        let temp_卡堆: DataStructure_卡堆 = temp_卡牌列表[0];\r\n        if (temp_卡堆.数量 == 1) { // 当卡牌数量为 1 时，去除该卡牌\r\n            ArrayUtils.remove(theDeck.卡牌列表, temp_卡堆);\r\n        }\r\n        else {\r\n            temp_卡堆.数量--; // 当卡牌数量大于 1 时，卡牌数量减 1\r\n        }\r\n        // 刷新卡组列表\r\n        this.updateCardInDeck();\r\n    }\r\n    //=======================================\r\n    //              右上界面相关\r\n    //=======================================\r\n    // 搜索卡牌框 按下回车，跳转至失去焦点\r\n    private searchCardUIEnter() {\r\n        this.可输入文本_备用.focus();\r\n    }\r\n    // 搜索卡牌\r\n    private searchCard() {\r\n        // 刷新卡库列表\r\n        this.updateCardList();\r\n        // 如果没有搜索内容，则重新显示提示文本\r\n        if (this.可输入文本_搜索内容.text == \"\") {\r\n            this.可输入文本_搜索内容.visible = false;\r\n            this.文本_搜索内容.visible = true;\r\n        }\r\n    }\r\n    // 派系选择，顺序按从左到右对应0~8\r\n    public factionSelect(faction: number) {\r\n        // 定义变量\r\n        let theFactionUI: UIBitmap = eval(\"this.图片_派系\" + faction);\r\n        // 显示 / 隐藏\r\n        theFactionUI.visible = !theFactionUI.visible;\r\n        // 影响卡库显示\r\n        if (theFactionUI.visible) { // 转换为显示的情况\r\n            this.updateCardList();\r\n        }\r\n        else { // 转换为隐藏的情况\r\n            this.列表_卡牌.items = ArrayUtils.matchAttributes(this.列表_卡牌.items, { 卡牌派系: faction }, false, \"!=\") as any;\r\n        }\r\n    }\r\n    // 费用选择\r\n    public costSelect(cost: number) {\r\n        // 定义变量\r\n        let theCostUI: UIBitmap = eval(\"this.图片_费用\" + String(cost > 7 ? 7 : cost));\r\n        // 显示 / 隐藏\r\n        theCostUI.visible = !theCostUI.visible;\r\n        // 影响卡库显示\r\n        if (theCostUI.visible) { // 转换为显示的情况\r\n            this.updateCardList();\r\n        }\r\n        else { // 转换为隐藏的情况\r\n            this.列表_卡牌.items = ArrayUtils.matchAttributes(this.列表_卡牌.items, { 费用: cost }, false, \"!=\") as any;\r\n        }\r\n    }\r\n    //=======================================\r\n    //              右下界面相关\r\n    //=======================================\r\n    // 刷新卡库显示\r\n    public updateCardList() {\r\n        // 定义变量\r\n        let cardList = [];\r\n        // 依次判断卡库中卡牌\r\n        for (let i = 0; i < Game.player.data.卡库.length; i++) {\r\n            // 定义变量\r\n            let card: DataStructure_卡堆 = Game.player.data.卡库[i];\r\n            let itemData: ListItem_1001 = new ListItem_1001();\r\n            // 判断所属派系是否显示\r\n            if (eval(\"this.图片_派系\" + card.卡牌.卡牌派系).visible == false) continue;\r\n            // 判断对应费用是否显示\r\n            if (eval(\"this.图片_费用\" + String(card.卡牌.费用 > 7 ? 7 : card.卡牌.费用)).visible == false) continue;\r\n            // 拷贝\r\n            ObjectUtils.clone(card.卡牌, itemData);\r\n            itemData.卡牌编号 = card.卡牌.id.toString();\r\n            itemData.卡牌名称 = GameListData.getName(Common.customModuleDataList[1], card.卡牌.id);\r\n            // 判断名称是否符合\r\n            if (this.可输入文本_搜索内容.text != \"\" && itemData.卡牌名称.indexOf(this.可输入文本_搜索内容.text) < 0) continue;\r\n            // 拷贝细节修正\r\n            if (itemData.卡牌类别 == \"0\") itemData.卡牌类别 = \"地区\";\r\n            else if (itemData.卡牌类别 == \"1\") itemData.卡牌类别 = \"角色\";\r\n            else if (itemData.卡牌类别 == \"2\") itemData.卡牌类别 = \"事务\";\r\n            else if (itemData.卡牌类别 == \"3\") itemData.卡牌类别 = \"附属\";\r\n            else if (itemData.卡牌类别 == \"4\") itemData.卡牌类别 = \"秘社\";\r\n            if (card.卡牌.卡牌派系 == 0) itemData.图片_卡框 = \"asset/image/picture/卡配/frame_small/frame0.png\";\r\n            else if (card.卡牌.卡牌派系 == 1) itemData.图片_卡框 = \"asset/image/picture/卡配/frame_small/frame1.png\";\r\n            else if (card.卡牌.卡牌派系 == 2) itemData.图片_卡框 = \"asset/image/picture/卡配/frame_small/frame2.png\";\r\n            else if (card.卡牌.卡牌派系 == 3) itemData.图片_卡框 = \"asset/image/picture/卡配/frame_small/frame3.png\";\r\n            else if (card.卡牌.卡牌派系 == 4) itemData.图片_卡框 = \"asset/image/picture/卡配/frame_small/frame4.png\";\r\n            else if (card.卡牌.卡牌派系 == 5) itemData.图片_卡框 = \"asset/image/picture/卡配/frame_small/frame5.png\";\r\n            else if (card.卡牌.卡牌派系 == 6) itemData.图片_卡框 = \"asset/image/picture/卡配/frame_small/frame6.png\";\r\n            else if (card.卡牌.卡牌派系 == 7) itemData.图片_卡框 = \"asset/image/picture/卡配/frame_small/frame7.png\";\r\n            else if (card.卡牌.卡牌派系 == 8) itemData.图片_卡框 = \"asset/image/picture/卡配/frame_small/frame8.png\";\r\n            // 加入待显示列表\r\n            cardList.push(itemData);\r\n        }\r\n        // 更新列表\r\n        this.列表_卡牌.items = cardList;\r\n    }\r\n    // 向卡组中加入卡库中的卡牌\r\n    public addCardToDeck(id: number) {\r\n        // 定义变量\r\n        let card: Module_卡牌 = GameData.customModulePresetDatas[1][id];\r\n        let theDeck = Game.player.data.卡组[this.index_deck];\r\n        // 查询卡组内是否有该卡牌\r\n        let temp_卡牌列表: DataStructure_卡堆[] = ArrayUtils.matchAttributesD2(theDeck.卡牌列表, \"卡牌\", { id: id }, true) as any;\r\n        let temp_卡堆: DataStructure_卡堆;\r\n        if (temp_卡牌列表[0] == undefined) { // 卡组内没有该卡牌时\r\n            temp_卡堆 = new DataStructure_卡堆();\r\n            temp_卡堆.卡牌 = ObjectUtils.depthClone<Module_卡牌>(card);\r\n            temp_卡堆.数量 = 1;\r\n            theDeck.卡牌列表.push(temp_卡堆);\r\n        }\r\n        else { // 卡组内有该卡牌时\r\n            temp_卡堆 = temp_卡牌列表[0];\r\n            // 最大张数限制\r\n            if (temp_卡堆.数量 >= temp_卡堆.卡牌.数量限制) {\r\n                // alert(\"超过最大张数，每个卡组内最多放入\" + temp_卡堆.卡牌.数量限制 + \"张\");\r\n                GameCommand.startCommonCommand(1002);\r\n                return;\r\n            }\r\n            temp_卡堆.数量 += 1;\r\n        }\r\n        // 加入卡组\r\n        this.updateCardInDeck();\r\n    }\r\n    // 交互效果\r\n    private interactiveEffect() {\r\n        // 卡组向下滚动提示\r\n        // this.turnDownTip();\r\n    }\r\n    // 卡组向下滚动提示\r\n    private turnDownTip() {\r\n        this.interactive_turnDownTip = Tween.to(this.图片_向下滚动提示, { alpha: 0, y: 620 }, 1000, null, Callback.New(() => {\r\n            setTimeout(() => {\r\n                this.图片_向下滚动提示.alpha = 1;\r\n                this.图片_向下滚动提示.y = 605;\r\n                this.turnDownTip();\r\n            }, 500);\r\n        }, this))\r\n    }\r\n}",
        "class GUI_mainMenu extends GUI_2 {\r\n    private tweens: Tween[];\r\n    constructor() {\r\n        super();\r\n        this.tweens = new Array<Tween>();\r\n        this.按钮_匹配.on(EventObject.MOUSE_OVER, this, this.btnMatch1_mouseOver);\r\n        this.按钮_匹配.on(EventObject.MOUSE_OUT, this, this.btnMatch1_mouseOut);\r\n        // 上方按钮\r\n        this.文本_主菜单_大厅.on(EventObject.MOUSE_OVER, this, this.btnTop_mouseOver, [this.文本_主菜单_大厅2]);\r\n        this.文本_主菜单_大厅.on(EventObject.MOUSE_OUT, this, this.btnTop_mouseOut, [this.文本_主菜单_大厅2]);\r\n        this.文本_主菜单_卡牌.on(EventObject.MOUSE_OVER, this, this.btnTop_mouseOver, [this.文本_主菜单_卡牌2]);\r\n        this.文本_主菜单_卡牌.on(EventObject.MOUSE_OUT, this, this.btnTop_mouseOut, [this.文本_主菜单_卡牌2]);\r\n        this.文本_主菜单_召唤.on(EventObject.MOUSE_OVER, this, this.btnTop_mouseOver, [this.文本_主菜单_召唤2]);\r\n        this.文本_主菜单_召唤.on(EventObject.MOUSE_OUT, this, this.btnTop_mouseOut, [this.文本_主菜单_召唤2]);\r\n        this.文本_主菜单_交易.on(EventObject.MOUSE_OVER, this, this.btnTop_mouseOver, [this.文本_主菜单_交易2]);\r\n        this.文本_主菜单_交易.on(EventObject.MOUSE_OUT, this, this.btnTop_mouseOut, [this.文本_主菜单_交易2]);\r\n        this.文本_主菜单_黑市.on(EventObject.MOUSE_OVER, this, this.btnTop_mouseOver, [this.文本_主菜单_黑市2]);\r\n        this.文本_主菜单_黑市.on(EventObject.MOUSE_OUT, this, this.btnTop_mouseOut, [this.文本_主菜单_黑市2]);\r\n        // 左侧按钮\r\n        this.按钮_任务.on(EventObject.MOUSE_OVER, this, this.btnLeft_mouseOver, [this.按钮_任务]);\r\n        this.按钮_任务.on(EventObject.MOUSE_OUT, this, this.btnLeft_mouseOut, [this.按钮_任务]);\r\n        this.按钮_好友.on(EventObject.MOUSE_OVER, this, this.btnLeft_mouseOver, [this.按钮_好友]);\r\n        this.按钮_好友.on(EventObject.MOUSE_OUT, this, this.btnLeft_mouseOut, [this.按钮_好友]);\r\n        this.按钮_信箱.on(EventObject.MOUSE_OVER, this, this.btnLeft_mouseOver, [this.按钮_信箱]);\r\n        this.按钮_信箱.on(EventObject.MOUSE_OUT, this, this.btnLeft_mouseOut, [this.按钮_信箱]);\r\n        this.按钮_设置.on(EventObject.MOUSE_OVER, this, this.btnLeft_mouseOver, [this.按钮_设置]);\r\n        this.按钮_设置.on(EventObject.MOUSE_OUT, this, this.btnLeft_mouseOut, [this.按钮_设置]);\r\n        this.按钮_帮助.on(EventObject.MOUSE_OVER, this, this.btnLeft_mouseOver, [this.按钮_帮助]);\r\n        this.按钮_帮助.on(EventObject.MOUSE_OUT, this, this.btnLeft_mouseOut, [this.按钮_帮助]);\r\n        this.按钮_活动.on(EventObject.MOUSE_OVER, this, this.btnLeft_mouseOver, [this.按钮_活动]);\r\n        this.按钮_活动.on(EventObject.MOUSE_OUT, this, this.btnLeft_mouseOut, [this.按钮_活动]);\r\n    }\r\n    // 上方菜单按钮 鼠标划过\r\n    private btnTop_mouseOver(theBtn: UIString) {\r\n        // 外发光\r\n        let glowFilter: GlowFilter = new GlowFilter(\"#eeeeee\", 15, 0, 0);\r\n        theBtn.filters = [glowFilter];\r\n    }\r\n    // 上方菜单按钮 鼠标划出\r\n    private btnTop_mouseOut(theBtn: UIString) {\r\n        // 外发光 消失\r\n        theBtn.filters = [];\r\n    }\r\n    // 左侧菜单按钮 鼠标划过\r\n    private btnLeft_mouseOver(theBtn: UIButton) {\r\n        // 按钮变化\r\n        // theBtn.x += 10;\r\n        // 底图 出现\r\n        if (this.tweens[1]) {\r\n            this.tweens[1].clear();\r\n            this.tweens[1].recover();\r\n        }\r\n        this.图片_leftBg.x = -160;\r\n        this.图片_leftBg.y = theBtn.y;\r\n        this.图片_leftBg.visible = true;\r\n        this.tweens[1] = Tween.to(this.图片_leftBg, { x: -39 }, 450, Ease.strongOut);\r\n    }\r\n    // 左侧菜单按钮 鼠标划出\r\n    private btnLeft_mouseOut(theBtn: UIButton) {\r\n        // 按钮变化\r\n        // theBtn.x -= 10;\r\n        // 底图 消失\r\n        if (this.tweens[1]) this.tweens[1].clear();\r\n        this.图片_leftBg.visible = false;\r\n        this.图片_leftBg.x = -160;\r\n    }\r\n    // 匹配按钮 鼠标划过\r\n    private btnMatch1_mouseOver() {\r\n        // 匹配按钮_文字 移动\r\n        if (this.tweens[0]) {\r\n            this.tweens[0].clear();\r\n            this.tweens[0].recover();\r\n        }\r\n        this.按钮_匹配_文本.alpha = 0;\r\n        this.按钮_匹配_文本.y = 15;\r\n        this.按钮_匹配_文本.fontSize = 20;\r\n        this.按钮_匹配_文本.x = 0;\r\n        this.tweens[0] = Tween.to(this.按钮_匹配_文本, { alpha: 1, x: this.按钮_匹配_文本.x + 90 }, 400, Ease.strongOut);\r\n        // 匹配按钮 放大 位移\r\n        this.按钮_匹配.x -= 12;\r\n        this.按钮_匹配.y -= 41;\r\n        this.按钮_匹配.width += 21;\r\n        this.按钮_匹配.height += 50;\r\n        // 遮罩\r\n        this.按钮_匹配_遮罩.visible = true;\r\n        // 文字移动\r\n        // this.按钮_匹配_文本.x += 6;\r\n        // 外发光\r\n        // let glowFilter: GlowFilter = new GlowFilter(\"#f6aa27\", 20, 0, 0);\r\n        // this.按钮_匹配.filters = [glowFilter];\r\n    }\r\n    // 匹配按钮 鼠标划出\r\n    private btnMatch1_mouseOut() {\r\n        // 遮罩 消失\r\n        this.按钮_匹配_遮罩.visible = false;\r\n        // 文字移动\r\n        if (this.tweens[0]) this.tweens[0].clear();\r\n        this.按钮_匹配_文本.x = 12;\r\n        this.按钮_匹配_文本.y = 338;\r\n        this.按钮_匹配_文本.fontSize = 16;\r\n        this.按钮_匹配_文本.alpha = 1;\r\n        // 外发光 消失\r\n        // this.按钮_匹配.filters = [];\r\n        // 匹配按钮 缩小 位移\r\n        this.按钮_匹配.x += 12;\r\n        this.按钮_匹配.y += 41;\r\n        this.按钮_匹配.width -= 21;\r\n        this.按钮_匹配.height -= 50;\r\n        // Tween.to(this.按钮_匹配, { weight: 206, height: 369, x: 60, y: 150 }, 15);\r\n    }\r\n}",
        "EventUtils.addEventListener(UIBase, UIBase.EVENT_COMPONENT_CONSTRUCTOR_INIT, Callback.New(uiComponentInit, this));\r\n\r\nfunction uiComponentInit(uiComp: UIBase) {\r\n    // 点击事件\r\n    if (uiComp.hasCommand[0]) {\r\n        this.mouseEnabled = true;\r\n        uiComp.on(EventObject.CLICK,uiComp,() => {\r\n            var commandInputMessage;\r\n            if (uiComp.commandInputMessage instanceof Callback) {\r\n                commandInputMessage = (uiComp.commandInputMessage as Callback).run();\r\n            }\r\n            else {\r\n                commandInputMessage = uiComp.commandInputMessage;\r\n            }\r\n            GameCommand.startUICommand(uiComp,0, commandInputMessage);\r\n        });\r\n    }\r\n}",
        "class GameFunctionClient extends GameFunction {\r\n    //------------------------------------------------------------------------------------------------------\r\n    // 场景和场景对象\r\n    //------------------------------------------------------------------------------------------------------\r\n    /**\r\n     * 移动至\r\n     * @param soIndex 场景对象ID\r\n     * @param lines 移动路线 无需包含该对象当前的位置，直接输入需要移动至的地方\r\n     */\r\n    static moveTo(soIndex: number, lines: number[][]) {\r\n        var soc: GameClientSceneObject_Core = Game.currentScene.sceneObjects[soIndex] as GameClientSceneObject_Core;\r\n        if (!soc) return;\r\n        var lastTo = lines[lines.length - 1];\r\n        if (lastTo[0] == soc.x && lastTo[1] == soc.y) {\r\n            return;\r\n        }\r\n        // 临时拼上坐标\r\n        lines.splice(0, 0, [soc.x, soc.y]);\r\n        soc.startMove(lines);\r\n    }\r\n    /**\r\n     * 跳跃至\r\n     * @param soIndex 场景对象ID\r\n     * @param x 实际坐标x\r\n     * @param y 实际坐标y\r\n     */\r\n    static jumpTo(soIndex: number, x: number, y: number): void {\r\n        var soc: GameClientSceneObject_Core = Game.currentScene.sceneObjects[soIndex] as GameClientSceneObject_Core;\r\n        if (!soc) return;\r\n        soc.jumpTo(x, y);\r\n    }\r\n    /**\r\n     * 设置坐标\r\n     * @param soIndex 场景对象ID\r\n     * @param x 实际坐标x\r\n     * @param y 实际坐标y\r\n     */\r\n    static setTo(soIndex: number, x: number, y: number): void {\r\n        var soc: GameClientSceneObject_Core = Game.currentScene.sceneObjects[soIndex] as GameClientSceneObject_Core;\r\n        if (!soc) return;\r\n        soc.setTo(x, y);\r\n    }\r\n    /**\r\n     * 移动停止\r\n     * @param soIndex 场景对象ID\r\n     * @param x 实际坐标x\r\n     * @param y 实际坐标y\r\n     */\r\n    static moveStop(soIndex: number, x: number, y: number): void {\r\n        var soc: GameClientSceneObject_Core = Game.currentScene.sceneObjects[soIndex] as GameClientSceneObject_Core;\r\n        if (!soc) return;\r\n        soc.stopMove();\r\n        soc.correctTo(x, y);\r\n    }\r\n    /**\r\n    * 更换行走图\r\n    * @param soIndex 场景对象ID\r\n    * @param avatarID 行走图ID\r\n    * @param actID [可选] 默认值=-1 动作ID\r\n    * @param frame [可选] 默认值=-1 帧数\r\n    */\r\n    static changeAvatar(soIndex: number, avatarID: number, actID: number = -1, frame: number = -1) {\r\n        var soc: GameClientSceneObject_Core = Game.currentScene.sceneObjects[soIndex] as GameClientSceneObject_Core;\r\n        if (!soc) return;\r\n        soc.avatarID = avatarID;\r\n        if (actID != -1) {\r\n            soc.avatarAct = actID;\r\n        }\r\n        if (frame != -1) {\r\n            soc.avatarFrame = frame;\r\n        }\r\n    }\r\n    /**\r\n     * 设置面向\r\n     * @param soIndex 场景对象ID\r\n     * @param ori 面向，参考小键盘以5为准8个数字的朝向\r\n     */\r\n    static setOrientation(soIndex: number, ori: number) {\r\n        var soc: GameClientSceneObject_Core = Game.currentScene.sceneObjects[soIndex] as GameClientSceneObject_Core;\r\n        if (!soc) return;\r\n        soc.avatarOri = ori;\r\n    }\r\n    /**\r\n     * 更改行走图属性\r\n     * @param soIndex 场景对象ID\r\n     * @param type 0-缩放 1-透明度 2-色相 3-播放间隔 4-移动速度\r\n     * @param v 值\r\n     */\r\n    static changeAvatarAttribute(soIndex: number, type: number, v: number) {\r\n        var soc: GameClientSceneObject_Core = Game.currentScene.sceneObjects[soIndex] as GameClientSceneObject_Core;\r\n        if (!soc) return;\r\n        switch (type) {\r\n            case 0:\r\n                soc.scale = v;\r\n                break;\r\n            case 1:\r\n                soc.avatarAlpha = v;\r\n                break;\r\n            case 2:\r\n                soc.avatarHue = v;\r\n                break;\r\n            case 3:\r\n                soc.avatarPlayInterval = v;\r\n                break;\r\n            case 4:\r\n                soc.speed = v;\r\n                break;\r\n        }\r\n    }\r\n    /**\r\n     * 更改影子\r\n     * @param soIndex 场景对象ID\r\n     * @param enabled 启用影子\r\n     * @param w 影子宽度\r\n     * @param h 影子高度\r\n     * @param alpha 透明度\r\n     */\r\n    static changeShadow(soIndex: number, enabled: number, w: number, h: number, alpha: number) {\r\n        var soc: GameClientSceneObject_Core = Game.currentScene.sceneObjects[soIndex] as GameClientSceneObject_Core;\r\n        if (!soc) return;\r\n        soc.shadowEnable = enabled == 1 ? true : false;\r\n        soc.shadowWidth = w;\r\n        soc.shadowHeight = h;\r\n        soc.shadowAlpha = alpha;\r\n    }\r\n    /**\r\n     * 在场景对象身上播放动画\r\n     * @param soIndex 场景对象ID\r\n     * @param aniID 动画ID\r\n     * @param loop 是否循环\r\n     * @param isHit 是否击中\r\n     */\r\n    static playAnimation(soIndex: number, aniID: number, loop: boolean, isHit: boolean) {\r\n        var soc: GameClientSceneObject_Core = Game.currentScene.sceneObjects[soIndex] as GameClientSceneObject_Core;\r\n        if (!soc) return;\r\n        soc.playAnimation(aniID, loop, isHit);\r\n    }\r\n    /**\r\n     * 停止场景对象身上的动画\r\n     * @param soIndex 场景对象ID\r\n     * @param aniID 动画ID\r\n     */\r\n    static stopAnimation(soIndex: number, aniID: number) {\r\n        var soc: GameClientSceneObject_Core = Game.currentScene.sceneObjects[soIndex] as GameClientSceneObject_Core;\r\n        if (!soc) return;\r\n        soc.stopAnimation(aniID);\r\n    }\r\n    /**\r\n     * 更改行走图状态\r\n     * @param soIndex 场景对象ID\r\n     * @param type 0-允许选中 1-固定朝向 2-最前方显示 3-穿透 4-播放动作 5-桥属性\r\n     * @param v 值\r\n     */\r\n    static changeAvatarState(soIndex: number, type: number, v: number) {\r\n        var soc: GameClientSceneObject_Core = Game.currentScene.sceneObjects[soIndex] as GameClientSceneObject_Core;\r\n        if (!soc) return;\r\n        switch (type) {\r\n            case 0:\r\n                soc.selectEnabled = v == 1;\r\n                break;\r\n            case 1:\r\n                soc.fixedOrientation = v == 1;\r\n                break;\r\n            case 2:\r\n                soc.onTop = v;\r\n                break;\r\n            case 3:\r\n                soc.through = v == 1;\r\n                break;\r\n            case 4:\r\n                soc.autoPlayEnable = v == 1;\r\n                break;\r\n            case 5:\r\n                soc.bridge = v == 1;\r\n                break;\r\n        }\r\n    }\r\n}",
        "/**\r\n * Created by 黑暗之神KDS on 2018-10-12 23:55:43.\r\n */\r\nclass MsgHandler {\r\n    /**\r\n     * [FROM RPC]加载新的场景\r\n     * @param sceneData \r\n     */\r\n    protected static loadNewScene(sceneData: { modelID: number, thread: number }) {\r\n        // 清理场景\r\n        var lastTonal;\r\n        if (Game.currentScene) {\r\n            lastTonal = Game.currentScene.displayObject.getTonal();\r\n            Game.layer.sceneLayer.removeChildren();\r\n            Game.currentScene.dispose();\r\n            if (typeof Controller != \"undefined\") Controller.stop();\r\n        }\r\n        ClientScene.createScene(sceneData.modelID, Callback.New(onLoadedNewScene, this), null, true);\r\n        function onLoadedNewScene(scene:ClientScene): void {\r\n            Game.currentScene = scene;\r\n            // 通知服务器加载完毕，可以出现在场景上了\r\n            ClientMsgSender.rpc(\"RequestHandler\", \"inScene\");\r\n        }\r\n    }\r\n    /**\r\n     * [FROM RPC]进入新的场景\r\n     * -- 立即清理掉当前场景\r\n     * -- 无缝加载新的场景\r\n     * \r\n     * @param sceneObjects 场景已有的游戏对象列表\r\n     * @param isExecuteSceneCommand 是否执行场景\r\n     * @param triggerLineID 触发线\r\n     */\r\n    protected static inNewScene(sceneObjects: SceneObject[], isExecuteSceneCommand: boolean): void {\r\n        // 添加游戏对象\r\n        for (var i = 0; i < sceneObjects.length; i++) {\r\n            var so: SceneObject = sceneObjects[i];\r\n            if (so) {\r\n                var playerData = so[\"player\"];\r\n                delete so[\"player\"];\r\n                var soc: ClientSceneObject = Game.currentScene.addSceneObject(so, false, true);\r\n                MsgHandler.addPlayer(soc, playerData);\r\n            }\r\n        }\r\n        // 开始渲染\r\n        Game.currentScene.startRender();\r\n        // 添加到场景中\r\n        Game.layer.sceneLayer.addChild(Game.currentScene.displayObject);\r\n        // 背景音乐播放\r\n        if (Game.currentScene.bgm) {\r\n            GameAudio.playBGM(Game.currentScene.bgm, Game.currentScene.bgmVolume, 9999, true, Config.SCENE_BGM_TWEEN, Game.currentScene.bgmPitch);\r\n        }\r\n        if (Game.currentScene.bgs) {\r\n            GameAudio.playBGS(Game.currentScene.bgs, Game.currentScene.bgsVolume, 9999, true, Config.SCENE_BGM_TWEEN, Game.currentScene.bgsPitch);\r\n        }\r\n        // 清理事件\r\n        Controller.clearEvent();\r\n        // 是否执行场景事件中\r\n        if (isExecuteSceneCommand) {\r\n            EventUtils.happen(Controller,Controller.EVENT_IN_SCENE_COMMAND,[true]);\r\n        }\r\n    }\r\n    /**\r\n     * 执行场景进入事件完毕\r\n     */\r\n    private static inSceneCommandExecuteOver():void{\r\n        EventUtils.happen(Controller,Controller.EVENT_IN_SCENE_COMMAND,[false]);\r\n    }\r\n\r\n    /**\r\n     * 添加对象\r\n     * @param so 场景对象 \r\n     */\r\n    protected static addSceneObject(so: SceneObject): void {\r\n        if (!Game.currentScene) return;\r\n        var playerData = so[\"player\"];\r\n        delete so[\"player\"];\r\n        var soc = Game.currentScene.addSceneObject(so, false, true);\r\n        MsgHandler.addPlayer(soc, playerData);\r\n        // AssetManager.loadSceneObjectAsset(so, Callback.New(function () {\r\n        //     trace(\"*********************\",1)\r\n        //     AssetManager.loadSceneObjectAsset(so, Callback.New(function (r) {\r\n        //         trace(\"*********************\",2+\":\"+r)\r\n        //     }, this,[Math.random()]),true);\r\n        //     trace(\"*********************\",3)\r\n        // }, this))\r\n\r\n        // 如果是我可控制的场景对象则添加至列表中\r\n        if (soc.playerUID == Game.player.uid) {\r\n            Game.mySceneObject = soc;\r\n            // 设置镜头并绑定到主角身上\r\n            Game.currentScene.setCameraSceneObject(soc);\r\n            // 开始可控\r\n            if (typeof Controller != \"undefined\") Controller.start();\r\n        }\r\n    }\r\n    /**\r\n     * 有游戏对象从场景上移除\r\n     * @param sceneData \r\n     * @param so \r\n     */\r\n    protected static removeSceneObject(so: SceneObject) {\r\n        if (!Game.currentScene) return;\r\n        var soc = Game.currentScene.removeSceneObject(so);\r\n        if (soc && soc.player) {\r\n            Game.currentScene.removePlayer(soc.player);\r\n        }\r\n        soc.dispose();\r\n    }\r\n    /**\r\n     * 添加玩家\r\n     */\r\n    private static addPlayer(soc: ClientSceneObject, playerData: any): void {\r\n        if (playerData) {\r\n            if (soc.playerUID == Game.player.uid) {\r\n                soc.player = Game.player;\r\n            }\r\n            else {\r\n                soc.player = new ClientPlayer();\r\n            }\r\n            ObjectUtils.clone(playerData, soc.player);\r\n            soc.player.sceneObject = soc;\r\n            Game.currentScene.addPlayer(soc.player);\r\n        }\r\n    }\r\n}",
        "/**\r\n * 游戏控制器：系统级\r\n * -- 移动\r\n * -- 场景对象的操作（选中、点击、相关事件）\r\n * Created by 黑暗之神KDS on 2018-10-07 16:18:25.\r\n */\r\nclass Controller {\r\n    /** 点击事件的命令 true=开始 false=结束 */\r\n    static EVENT_SCENE_OBJECT_CLICK_COMMAND: string = \"GameCommand_EVENT_SCENE_OBJECT_CLICK_COMMAND\";\r\n    /** 进入场景的命令 true=开始 false=结束 */\r\n    static EVENT_IN_SCENE_COMMAND: string = \"GameCommand_EVENT_IN_SCENE_COMMAND\";\r\n    /** 点击事件执行中 */\r\n    private static ENABLED_COMMAND_SCENE_OBJECT_CLICK_EXECUTE: number = 0;\r\n    /** 进入场景的事件执行中 */\r\n    private static ENABLED_COMMAND_IN_SCENE_EXECUTE: number = 1;\r\n    /**\r\n     * 是否可控，需要条件全满足才可控制\r\n     */\r\n    private static enabledMapping = {\r\n        0: true,\r\n        1: true\r\n    }\r\n    /**\r\n     * 选中的场景对象\r\n     */\r\n    static selectSceneObject: ClientSceneObject;\r\n    /**\r\n    * 颜色滤镜\r\n    */\r\n    private static selectEffect: ColorFilter;\r\n    private static onCommandStartCB: Callback;\r\n    /**\r\n     * 初始化\r\n     */\r\n    static init(): void {\r\n        this.onCommandStartCB = Callback.New(this.onCommandStart, this, [Controller.ENABLED_COMMAND_SCENE_OBJECT_CLICK_EXECUTE])\r\n    }\r\n\r\n    /**\r\n     * 启动控制\r\n     */\r\n    static start(): void {\r\n        // 初始化\r\n        var sceneLayer = Game.currentScene.displayObject;\r\n        sceneLayer.width = Game.currentScene.width;\r\n        sceneLayer.height = Game.currentScene.height;\r\n        // 场景对象\r\n        sceneLayer.on(EventObject.MOUSE_DOWN, this, Controller.onMouseDown);\r\n        sceneLayer.on(EventObject.MOUSE_MOVE, this, Controller.onMouseMove);\r\n        // 移动\r\n        stage.on(EventObject.RIGHT_CLICK, this, Controller.onMove);\r\n        // 监听相关事件：\r\n        EventUtils.addEventListener(Controller, Controller.EVENT_SCENE_OBJECT_CLICK_COMMAND, Callback.New(this.onCommandStart, this, [Controller.ENABLED_COMMAND_SCENE_OBJECT_CLICK_EXECUTE]));\r\n        EventUtils.addEventListener(Controller, Controller.EVENT_IN_SCENE_COMMAND, Callback.New(this.onCommandStart, this, [Controller.ENABLED_COMMAND_IN_SCENE_EXECUTE]));\r\n        // select effect\r\n        Controller.selectEffect = new ColorFilter([\r\n            1, 0, 0, 0.4, 0,\r\n            0, 1, 0, 0.4, 0,\r\n            0, 0, 1, 0.4, 0,\r\n            0, 0, 0, 1, 0\r\n        ]);\r\n    }\r\n    /**\r\n     * 停止控制\r\n     */\r\n    static stop(): void {\r\n        Controller.selectSceneObject = null;\r\n        var sceneLayer = Game.currentScene.displayObject;\r\n        // 场景对象\r\n        sceneLayer.off(EventObject.MOUSE_DOWN, this, Controller.onMouseDown);\r\n        sceneLayer.off(EventObject.MOUSE_MOVE, this, Controller.onMouseMove);\r\n        // 移动\r\n        sceneLayer.off(EventObject.RIGHT_CLICK, this, Controller.onMove);\r\n        // 监听相关事件：\r\n        EventUtils.clear(GameCommand, GameCommand.EVENT_SCENE_OBJECT_CLICK_COMMAND);\r\n    }\r\n    //------------------------------------------------------------------------------------------------------\r\n    // 可控设定\r\n    //------------------------------------------------------------------------------------------------------\r\n    /**\r\n     * 是否可控\r\n     */\r\n    static get enabled() {\r\n        for (var i in Controller.enabledMapping) {\r\n            if (!Controller.enabledMapping[i]) return false;\r\n        }\r\n        return true;\r\n    }\r\n    /**\r\n     * 清理事件\r\n     */\r\n    static clearEvent() {\r\n        EventUtils.happen(Controller, Controller.EVENT_SCENE_OBJECT_CLICK_COMMAND, [false]);\r\n        EventUtils.happen(Controller, Controller.EVENT_IN_SCENE_COMMAND, [false]);\r\n    }\r\n    /**\r\n     * 当命令开始时\r\n     */\r\n    private static onCommandStart(enabledID: number, isStart: boolean) {\r\n        Controller.enabledMapping[enabledID] = !isStart;\r\n    }\r\n    /**\r\n     * 当命令结束时\r\n     */\r\n    private static onCommandOver() {\r\n        // var lastEnable = this.enabled;\r\n        // Controller.enabledMapping[Controller.ENABLED_COMMAND_EXECUTE] = true;\r\n        // if (this.enabled != lastEnable) Controller.stopControl;\r\n    }\r\n    /**\r\n     * 停止控制\r\n     */\r\n    private static stopControl() {\r\n\r\n    }\r\n    //------------------------------------------------------------------------------------------------------\r\n    // 场景角色\r\n    //------------------------------------------------------------------------------------------------------\r\n    /**\r\n     * [场景对象-碰撞事件]开始 需要检查碰触事件：玩家与NPC碰触\r\n     * 检查玩家与NPC的碰撞，碰撞后需要两者离开后才可继续碰撞\r\n     * *在两者都移动的过程中，如果玩家跟着一起移动的话不能触发\r\n     */\r\n    static checkTouch(so: ClientSceneObject) {\r\n        if (Config.EDIT_MODE) return;\r\n        // 如果没有主角或主角处于跳跃中的话或不场景上的时候则忽略\r\n        if (!Game.currentScene || !Game.mySceneObject || Game.mySceneObject.state_isJumping || !Game.mySceneObject.inScene || !so.inScene) return;\r\n        // 玩家对象移动的情况：检测玩家所在格子所有场景对象，执行他们的碰触事件\r\n        if (so == Game.mySceneObject) {\r\n            var gridSos = so.scene.gridSceneObjects[so.posGrid.x][so.posGrid.y];\r\n            for (var i = gridSos.length - 1; i >= 0; i--) {\r\n                var gridSo: ClientSceneObject = gridSos[i] as ClientSceneObject;\r\n                GameCommand.startSceneObjectCommand(gridSo.index, 1);\r\n            }\r\n        }\r\n        // 非玩家对象移动：检测是否与玩家同坐标，同坐标则执行\r\n        else {\r\n            if (so.posGrid.x == Game.mySceneObject.posGrid.x && so.posGrid.y == Game.mySceneObject.posGrid.y) {\r\n                // trace(\"Touch!\" + Math.random());\r\n                GameCommand.startSceneObjectCommand(so.index, 1);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * 更新选中场景对象的效果\r\n     * @param e \r\n     */\r\n    static updateSelectSceneObject() {\r\n        if (Config.EDIT_MODE) return;\r\n        var len = Game.currentScene.sceneObjects.length;\r\n        var globalP = Game.currentScene.globalPos;\r\n        for (var i = len - 1; i >= 0; i--) {\r\n            var soc: ClientSceneObject = Game.currentScene.sceneObjects[i] as ClientSceneObject;\r\n            if (!soc) continue;\r\n            if (!soc.root.stage) continue;\r\n            if (!soc.selectEnabled) continue;\r\n            // 非选中效果\r\n            this.unselectOneSceneObject(soc);\r\n            // 在矩形中\r\n            if (soc.avatar.hitTestPoint(globalP.x, globalP.y)) {\r\n                this.selectOneSceneObject(soc);\r\n                return;\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * 选中场景对象\r\n     */\r\n    static selectOneSceneObject(soc: ClientSceneObject): void {\r\n        if (this.selectSceneObject) this.unselectOneSceneObject(this.selectSceneObject);\r\n        this.selectSceneObject = soc;\r\n        soc.avatar.appendGameFilter(Controller.selectEffect);\r\n        // soc.avatar.blendMode = \"lighter\"; // temp\r\n    }\r\n    /**\r\n     * 取消选中场景对象\r\n     */\r\n    static unselectOneSceneObject(soc: ClientSceneObject): void {\r\n        // soc.avatar.blendMode = null; // temp\r\n        if (soc == this.selectSceneObject) {\r\n            this.selectSceneObject = null;\r\n            soc.avatar.subtractGameFilter(Controller.selectEffect);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 当鼠标按下时\r\n     * @param e \r\n     */\r\n    private static onMouseDown(e: EventObject): void {\r\n        this.updateSelectSceneObject();\r\n        if (!Controller.enabled) return;\r\n        if (this.selectSceneObject && this.selectSceneObject.inScene) {\r\n            if (this.selectSceneObject.hasCommand[0]) {\r\n                EventUtils.happen(Controller, Controller.EVENT_SCENE_OBJECT_CLICK_COMMAND, [true]);\r\n                GameCommand.startSceneObjectCommand(this.selectSceneObject.index, 0, null, Callback.New(function () {\r\n                    EventUtils.happen(Controller, Controller.EVENT_SCENE_OBJECT_CLICK_COMMAND, [false]);\r\n                }, this));\r\n            }\r\n        }\r\n        else {\r\n            if (Game.mySceneObject.state_isJumping) return;\r\n            this.onMove(e);\r\n        }\r\n    }\r\n    /**\r\n     * 当鼠标移动时\r\n     * @param e \r\n     */\r\n    private static onMouseMove(e: EventObject): void {\r\n        this.updateSelectSceneObject();\r\n    }\r\n\r\n    //------------------------------------------------------------------------------------------------------\r\n    // 移动\r\n    //------------------------------------------------------------------------------------------------------\r\n    private static onMove(e: EventObject): void {\r\n        if (!Controller.enabled) return;\r\n        if (Game.mySceneObject.state_isJumping) return;\r\n        var realLineArr: number[][];\r\n        // 获取目的地\r\n        var toP: Point = new Point(Game.currentScene.localX, Game.currentScene.localY);\r\n        // 限制在屏幕范围内\r\n        Game.currentScene.limitInside(toP);\r\n        // 限制在格子中间\r\n        if (Config.MOVE_TO_GRID_CENTER) {\r\n            GameUtils.getGridCenter(toP, toP);\r\n        }\r\n        // 忽略掉同位置\r\n        if (toP.x == Game.mySceneObject.x && toP.y == Game.mySceneObject.y) return;\r\n        // 如果我是可穿透事件的话直接两点\r\n        if (Game.mySceneObject.through && !Config.MOVE_4_ORI) {\r\n            realLineArr = [[toP.x, toP.y]];\r\n        }\r\n        else {\r\n            // 如果是障碍点则优先选择就近的点\r\n            if (Game.currentScene.isObstacle(toP, Game.mySceneObject)) {\r\n                var gridP = GameUtils.getGridPostion(toP);\r\n                var myGridP = GameUtils.getGridPostion(new Point(Game.mySceneObject.x, Game.mySceneObject.y));\r\n                gridP = this.getNearThrouughGrid(gridP, myGridP);\r\n                if (!gridP) return;\r\n                gridP.x *= Config.SCENE_GRID_SIZE;\r\n                gridP.y *= Config.SCENE_GRID_SIZE;\r\n                toP = GameUtils.getGridCenter(gridP, toP);\r\n                if (!toP) return;\r\n            }\r\n            // 计算A星\r\n            // 两点间是否存在障碍点\r\n            if (GameUtils.twoPointHasObstacle(Game.mySceneObject.x, Game.mySceneObject.y, toP.x, toP.y, Game.currentScene, Game.mySceneObject) || Config.MOVE_4_ORI) {\r\n                var gridW = Math.floor(Game.currentScene.width / Config.SCENE_GRID_SIZE);\r\n                var gridH = Math.floor(Game.currentScene.height / Config.SCENE_GRID_SIZE);\r\n                realLineArr = AstarUtils.moveTo(Game.mySceneObject.x, Game.mySceneObject.y, toP.x, toP.y, gridW, gridH, Game.currentScene);\r\n                if (!realLineArr) return;\r\n                // trace(\"Astar=\", realLineArr);\r\n                // realLineArr.shift();\r\n            }\r\n            else {\r\n                realLineArr = [[toP.x, toP.y]]\r\n            }\r\n\r\n        }\r\n        ClientMsgSender.rpc(\"RequestHandler\", \"requestMove\", [realLineArr]);\r\n    }\r\n    /**\r\n     * 获取附近可通行的格子点\r\n     * @param gridP 障碍格子点\r\n     * @param targetP [可选] 默认值=null 参考目标点，会优先选择与该目标点最近的点\r\n     * @return [Point] \r\n     */\r\n    private static getNearThrouughGrid(gridP: Point, targetP: Point = null): Point {\r\n        var nearGrid = 5;\r\n        var n_32_x1: number = gridP.x - nearGrid;\r\n        var n_32_x2: number = gridP.x + nearGrid;\r\n        var n_32_y1: number = gridP.y - nearGrid;\r\n        var n_32_y2: number = gridP.y + nearGrid;\r\n        n_32_x1 = n_32_x1 < 0 ? 0 : n_32_x1\r\n        n_32_y1 = n_32_y1 < 0 ? 0 : n_32_y1\r\n        n_32_x2 = n_32_x2 > Game.currentScene.gridWidth ? Game.currentScene.gridWidth : n_32_x2;\r\n        n_32_y2 = n_32_y2 > Game.currentScene.gridHeight ? Game.currentScene.gridHeight : n_32_y2;\r\n        var findGrid: Point = new Point(-1, -1);\r\n        var helpP: Point = new Point();\r\n        var dis_x: number = 9999;\r\n        var findGrids = [];\r\n        for (var x = n_32_x1; x < n_32_x2; x++) {\r\n            for (var y = n_32_y1; y < n_32_y2; y++) {\r\n                helpP.x = x;\r\n                helpP.y = y;\r\n                // 如果是界外\r\n                if (Game.currentScene.isOutsideByGrid(helpP)) { continue }\r\n                // 如果是障碍\r\n                if (Game.currentScene.isObstacleGrid(helpP)) { continue }\r\n                // 当前点与终点的距离\r\n                var n_jin_x32: number = Math.abs(x - gridP.x);\r\n                var n_jin_y32: number = Math.abs(y - gridP.y);\r\n                var dis = n_jin_x32 + n_jin_y32;\r\n                if (targetP) {\r\n                    if (dis <= dis_x) {\r\n                        findGrid.x = x;\r\n                        findGrid.y = y;\r\n                        if (dis_x != dis) findGrids.length = 0;\r\n                        dis_x = dis;\r\n                        findGrids.push(new Point(findGrid.x, findGrid.y));\r\n                    }\r\n                }\r\n                else {\r\n                    if (dis < dis_x) {\r\n                        findGrid.x = x;\r\n                        findGrid.y = y;\r\n                        dis_x = dis;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (targetP) {\r\n            findGrid = new Point(-1, -1);\r\n            dis_x = 9999;\r\n            for (var p in findGrids) {\r\n                var tp = findGrids[p];\r\n                var n_jin_x32: number = Math.abs(tp.x - targetP.x);\r\n                var n_jin_y32: number = Math.abs(tp.y - targetP.y);\r\n                var dis = n_jin_x32 + n_jin_y32;\r\n                if (dis < dis_x) {\r\n                    findGrid = tp;\r\n                    dis_x = dis;\r\n                }\r\n            }\r\n        }\r\n        if (findGrid.x == -1) return null;\r\n        return findGrid;\r\n    }\r\n}",
        "os.defaultFamily = \"黑体\";\r\nif (ClientWorld.isGame) {\r\n    EventUtils.addEventListener(ClientWorld, ClientWorld.EVENT_INITED, Callback.New(() => {\r\n        // Game.playerKey = \"13133_asdasdasd\";\r\n        ClientWorld.startLogin(Callback.New(function () {\r\n            // login success\r\n        }, this), Callback.New(function () {\r\n            // login fail\r\n        }, this));\r\n\r\n    }, this), true);\r\n\r\n}",
        "//■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■\r\n// 游戏场景\r\n//■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■\r\nclass GameClientScene extends ClientScene {\r\n    //------------------------------------------------------------------------------------------------------\r\n    // 基本\r\n    //------------------------------------------------------------------------------------------------------\r\n    constructor() {\r\n        super();\r\n    }\r\n    /**\r\n     * 销毁\r\n     * @param autoStopAudio [可选] 默认值=true \r\n     */\r\n    dispose(autoStopAudio: boolean = true): void {\r\n        super.dispose.apply(this, arguments);\r\n    }\r\n    /**\r\n     * 当渲染时：每帧执行的逻辑\r\n     */\r\n    onRender() {\r\n        super.onRender.apply(this, arguments);\r\n    }\r\n    //------------------------------------------------------------------------------------------------------\r\n    // 显示对象\r\n    //------------------------------------------------------------------------------------------------------\r\n    /**\r\n     * 添加显示对象\r\n     * @param soData 场景对象数据\r\n     * @param isSoc [可选] 默认值=false 是否是实际的对象而非数据\r\n     * @param useModelClass [可选] 默认值=false 是否使用场景对象模型的实现类\r\n     * @return [ClientSceneObject] 添加的场景对象实例\r\n     */\r\n    addSceneObject(soData: SceneObject, isSoc: boolean = false, useModelClass: boolean = false): ClientSceneObject {\r\n        trace(\"添加场景对象\"+soData.index);\r\n        return super.addSceneObject.apply(this, arguments);\r\n    }\r\n    /**\r\n     * 移除显示对象\r\n     * @param so 显示对象\r\n     * @return [ClientSceneObject] \r\n     */\r\n    removeSceneObject(so: SceneObject): ClientSceneObject {\r\n        return super.removeSceneObject.apply(this, arguments);\r\n    }\r\n}",
        "//■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■\r\n// 通用客户端对象逻辑\r\n//■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■\r\nclass GameClientSceneObject_Core extends ClientSceneObject {\r\n    private state_ignoreCantMove: boolean;\r\n    constructor(soData: SceneObject = null, scene: ClientScene = null) {\r\n        super(soData, scene);\r\n    }\r\n    //------------------------------------------------------------------------------------------------------\r\n    // 移动相关函数（当前坐标-P2-P3-P...） A,B|C,D|E,F\r\n    //   \r\n    //------------------------------------------------------------------------------------------------------\r\n    // 障碍\r\n    //★ A,B|C,D|E,F 转换为 [p1,p2,p3] 开始移动\r\n    private _isMoving: boolean\r\n    private roadsArr: Point[]; //当前路程数组（全，不抽离）serverA-B-C-D\r\n    private roadMax: number; //总段：路段总数0-1-2-3 == 4段\r\n    private nowRoad: number; //当前所在的路段：如果是0表示0-1，如果是1表示1-2\r\n    private nowRoadStartDate: number; //当前所在路段起点的绝对时间t（比如1-2中1在2014-3-22 23:21:55 789毫秒）\r\n    private nowRoadTime: number; //当前所在路段到下一个路段的相对时间段t0（比如1-2应该花费1379ms）\r\n    // 启动移动\r\n    public endPoint: Point;\r\n    /**\r\n     * 移动\r\n     * @param arr 首个坐标是自己当前的坐标\r\n     * @param _costTime [可选] 默认值=0 当前移动已花费的时间（客户端出现时可能其已在移动中途）\r\n     */\r\n    public startMove(arr: number[][], _costTime: number = 0): void {\r\n        var _arr: Point[] = [];\r\n        for (var i in arr) {\r\n            _arr.push(new Point(arr[i][0], arr[i][1]));\r\n        }\r\n        //\t\t\ttrace(s,arr)\r\n        this.roadMax = arr.length;\r\n        // if(this.playerUID==2)trace(\"roadMax=\",this.roadMax)\r\n        if (arr && this.roadMax > 1) {\r\n            this.endPoint = _arr[arr.length - 1];\r\n            this.myLastX32 = Math.floor(this.x / Config.SCENE_GRID_SIZE);\r\n            this.myLastY32 = Math.floor(this.y / Config.SCENE_GRID_SIZE);\r\n\r\n            // 允许移动标识：记录起步时间（同时减去已移动过的时间）\r\n            this.nowRoadStartDate = (new Date()).getTime();\r\n            this.nowRoadStartDate -= _costTime\r\n            // 允许移动标识：储存可直接用的路径数组\r\n            this.roadsArr = _arr\r\n            // if(this.playerUID==2)trace(\"this.roadsArr=\",this.roadsArr)\r\n            // 允许移动标识：标识开启\r\n            this.state_isMoving = true\r\n        }\r\n        // trace(\"走\" + Math.random());\r\n    }\r\n    // 更改移动状态\r\n    public get state_isMoving(): boolean { return this._isMoving; }\r\n\r\n    public set state_isMoving(_isMove: boolean) {\r\n        // 更改移动状态\r\n        //if(_isMoving==_isMove){return}\r\n        // 改变移动状态后的初始化:移动开始\r\n        if (_isMove) {\r\n            // trace(\"移动时动画\");\r\n            this.avatarAct = 2;\r\n            //初始化当前路段的信息\r\n            this.nowRoad = 0\r\n            this.nowRoadTime = 0\r\n            // 取消玩家setTimeout申请\r\n            //如果差异大于10，计算第一段路的速度变换数值，否则直接设置为服务器坐标\r\n            //\t\t\t\tif(Math.abs(this.x-roadsArr[0].x)<15 && Math.abs(this.y-roadsArr[0].y)<15){\r\n            //\t\t\t\t    //this.x = roadsArr[0].x\r\n            //\t\t\t\t\t//this.y = roadsArr[0].y\r\n            //\t\t\t\t\trealMoveSpeed = move_speed\r\n            //\t\t\t\t    trace(\"差异大于10，使用真的速度\")\r\n            //\t\t\t\t}\r\n            //\t\t\t\telse{\r\n            // 设置第一段的临时速度   Point.distance(roadsArr[0],roadsArr[1])\r\n            var serverS = this.roadsArr[0].distance(this.roadsArr[1].x, this.roadsArr[1].y);\r\n            //  Point.distance(new Point(this.x,this.y),roadsArr[1])\r\n            var clientS = new Point(this.x, this.y).distance(this.roadsArr[1].x, this.roadsArr[1].y);\r\n            this.roadsArr[0].x = this.x\r\n            this.roadsArr[0].y = this.y\r\n            this.realMoveSpeed = clientS * this.speed / serverS\r\n            //\t\t\t\t\ttrace(\"差异小于10，使用临时\")\r\n            //\t\t\t\t}\r\n            this._isMoving = _isMove\r\n            this.updateCoordinate((new Date()).getTime());\r\n        }\r\n        // 改变移动状态后的初始化:移动停止\r\n        else {\r\n            this._isMoving = _isMove\r\n            // 停止时动画\r\n            // trace(\"停止时动画\");\r\n            // thischangeAct(0)\r\n            this.avatarAct = 1;\r\n        }\r\n\r\n    }\r\n\r\n    // 更新坐标(移动）\r\n    //------------------------------------------------------------------------------------------------------\r\n    // 更新坐标（移动）\r\n    // 优化方案：\r\n    //   -- 可以缓存 roadIndex 之类，等我醒来强力优化，然后服务端也这样，然后OK。（这里还有面向的问题），嗯当改变路段的时候才改变面向啊\r\n    //------------------------------------------------------------------------------------------------------\r\n    private realMoveSpeed: number\r\n    private myLastX32: number;\r\n    private myLastY32: number;\r\n    public updateCoordinate(_nowTime: number): void {\r\n        var per: number\r\n        var isChangeDir: boolean\r\n        // 获取当前路段需要花费的时间段（nowRoadTime）\r\n        var thisRoadP: Point = this.roadsArr[this.nowRoad]\r\n        var nextRoadP: Point = this.roadsArr[this.nowRoad + 1]\r\n        // 没有该事件段的话就\r\n        if (this.nowRoadTime == 0) {\r\n            var thisRoadS: number = thisRoadP.distance(nextRoadP.x, nextRoadP.y);\r\n            //  if (this.playerUID == 2)trace(\"->>>>>>>>AX=\", thisRoadP.x, thisRoadP.y, nextRoadP.x, nextRoadP.y,thisRoadS,new Date().getTime());\r\n            this.nowRoadTime = thisRoadS * 1000 / this.realMoveSpeed;\r\n            isChangeDir = true\r\n        }\r\n        // 大于当前路段终点的时间时\r\n        var nowRoadEndDate: number = this.nowRoadStartDate + this.nowRoadTime;\r\n        if (_nowTime > nowRoadEndDate) {\r\n            // 当路段未走完的情况：下一个路段\r\n            this.nowRoad++\r\n            // trace(\"当前路线\",this.nowRoad)\r\n            if (this.nowRoad < this.roadMax - 1) {\r\n                this.nowRoadStartDate += this.nowRoadTime;\r\n                this.nowRoadTime = 0\r\n                this.realMoveSpeed = this.speed;\r\n                this.updateCoordinate(_nowTime)\r\n                return\r\n            }\r\n            // 当路段已到达最终的情况\r\n            else {\r\n                per = 1\r\n                this.state_isMoving = false;\r\n                EventUtils.happen(this, SceneObject.EVENT_MOVE_OVER);\r\n            }\r\n        }\r\n        else {\r\n            per = (_nowTime - this.nowRoadStartDate) / this.nowRoadTime\r\n        }\r\n        if (isChangeDir) {\r\n            var dir = GameUtils.getOriByAngle(MathUtils.direction_360(this.x, this.y, nextRoadP.x, nextRoadP.y));\r\n            this.avatarOri = dir;\r\n        }\r\n        // 计算当前路段\r\n        var nowP: Point = Point.interpolate(nextRoadP, thisRoadP, per);\r\n        this.setTo(nowP.x, nowP.y, false);\r\n    }\r\n    /**\r\n     * 停止移动\r\n     */\r\n    public stopMove() {\r\n        this.state_isMoving = false;\r\n    }\r\n    /**\r\n     * 更新\r\n     * @param _nowTime unix时间戳\r\n     */\r\n    public update(_nowTime: number) {\r\n        if (this.state_isMoving) {\r\n            this.updateCoordinate(_nowTime);\r\n        }\r\n    }\r\n\r\n\r\n    //------------------------------------------------------------------------------------------------------\r\n    // 跳跃至\r\n    //------------------------------------------------------------------------------------------------------\r\n    /**\r\n     * 跳跃至\r\n     * @param x \r\n     * @param y \r\n     */\r\n    jumpTo(x: number, y: number) {\r\n        this.state_isMoving = false;\r\n        this.state_isJumping = true;\r\n        Tween.to(this, { x: x, y: y }, Config.SCENE_OBJECT_JUMP_INTERVAL, null, Callback.New(() => {\r\n            if (this.isDisposed) return;\r\n            this.state_isJumping = false;\r\n            this.refreshCoordinate();\r\n            EventUtils.happen(this, ClientSceneObject.EVENT_JUMP_OVER);\r\n        }, this));\r\n        Tween.to(this, { jumpY: -Config.SCENE_OBJECT_JUMP_HEIGHT }, Math.floor(Config.SCENE_OBJECT_JUMP_INTERVAL / 2), Ease.quintOut, Callback.New(() => {\r\n            if (this.isDisposed) return;\r\n            Tween.to(this, { jumpY: 0 }, Config.SCENE_OBJECT_JUMP_INTERVAL - Math.floor(Config.SCENE_OBJECT_JUMP_INTERVAL / 2), Ease.quintIn);\r\n        }, this));\r\n    }\r\n    private get jumpY() {\r\n        return this.avatar ? this.avatar.y : 0;\r\n    }\r\n    private set jumpY(v) {\r\n        this.avatar.y = v;\r\n        var scale = 1 - (this.avatar.y / -Config.SCENE_OBJECT_JUMP_HEIGHT) * 0.5;\r\n        this.refreshShadow(scale);\r\n    }\r\n    /**\r\n     * 直接设置坐标\r\n     * @param x \r\n     * @param y \r\n     */\r\n    setTo(x: number, y: number, stopMove: boolean = true) {\r\n        if (stopMove) this.state_isMoving = false;\r\n        this._x = x;\r\n        this._y = y;\r\n        this.root.pos(x, y);\r\n        this.refreshCoordinate();\r\n    }\r\n    /**\r\n     * 修正，当大于1个格子的误差时则强制修正\r\n     */\r\n    correctTo(x: number, y: number) {\r\n        if (Math.abs(x - this.x) >= Config.SCENE_GRID_SIZE || Math.abs(y - this.y) >= Config.SCENE_GRID_SIZE) {\r\n            this.setTo(x, y);\r\n        }\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * 进入新的坐标后进行一些刷新\r\n     * @param refreshCamera [可选] 默认值=true 是否刷新镜头\r\n     * @param refreshShadow [可选] 默认值=true 刷新阴影\r\n     * @param refreshGridPos [可选] 默认值=true 刷新格子坐标\r\n     * @param refreshDynamicObs [可选] 默认值=true 刷新碰撞和场景动态障碍信息\r\n     * @param refreshMask [可选] 默认值=true 刷新遮罩显示\r\n     */\r\n    refreshCoordinate(refreshCamera: boolean = true, refreshShadow: boolean = true, refreshGridPos: boolean = true, refreshDynamicObs: boolean = true, refreshMask: boolean = true) {\r\n        if (!this.inScene) return;\r\n\r\n        if (this.scene.cameraObject == this) {\r\n            this.scene.updateCamera();\r\n        }\r\n        this.updateShadow();\r\n        this.posHelper.x = this.x;\r\n        this.posHelper.y = this.y;\r\n        GameUtils.getGridPostion(this.posHelper, this.tempPosHelper);\r\n        if (this.posGrid.x != this.tempPosHelper.x || this.posGrid.y != this.tempPosHelper.y) {\r\n            this.posGrid.x = this.tempPosHelper.x;\r\n            this.posGrid.y = this.tempPosHelper.y;\r\n            Controller.checkTouch(this);\r\n            this.scene.updateDynamicObsAndBridge(this, true, this.posGrid);\r\n            this.root.alpha = this.scene.isMask(new Point(this.x, this.y)) ? 0.5 : 1;\r\n        }\r\n    }\r\n\r\n    //------------------------------------------------------------------------------------------------------\r\n    // 自定义行为：编辑器预览用\r\n    //------------------------------------------------------------------------------------------------------\r\n    /**\r\n     * 还原预览用的最初的行为状态\r\n     * @param defSceneObejct 默认场景对象数据\r\n     */\r\n    private setPreviewSceneObjectBehaviorInit(defSceneObejct: SceneObject) {\r\n        // var lastFrame = this.avatar.getCurrentFrame();\r\n        ObjectUtils.clone(defSceneObejct, this);\r\n        this.state_ignoreCantMove = false;\r\n        // if (this.operate.soc) {\r\n        // this.avatarID = this.operate.soc.avatarID;\r\n        // this.avatarAct = this.operate.soc.avatarAct;\r\n        // this.avatarFrame = this.operate.soc.avatarFrame;\r\n        // }\r\n        this.stopMove();\r\n        this.stopAllAnimation();\r\n        this.refreshShadow();\r\n        this.scene.setCameraSceneObject(this);\r\n        this.root.skewX = 0;\r\n        this.root.skewY = 0;\r\n\r\n\r\n        // this.previewBox.currentOperateScene.scene.setCameraSceneObject(this);\r\n        // this.avatar.setCurrentFrame(lastFrame);\r\n    }\r\n    /**\r\n     * 设置预览用的的行为命令\r\n     * @param behaviorStage 行为命令集\r\n     * @param index 行为索引\r\n     * @param playMode  是否播放模式\r\n     * @param onPlayFin [可选] 默认值=null 当播放完毕时回调\r\n     */\r\n    private setPreviewSceneObjectBehaviorPlay(behaviorStage: any[], index: number, playMode: boolean, onPlayFin: Callback = null) {\r\n        var behavior = behaviorStage[index];\r\n        if (!behavior) return;\r\n        var id = behavior[0];\r\n        if (id == 0) {\r\n            this.avatarID = behavior[1];\r\n            this.avatarAct = behavior[2];\r\n            this.avatarFrame = behavior[3];\r\n        }\r\n        else if (id >= 1 && id <= 8) {\r\n            var dArr = [[0, 1, 2], [-1, 0, 4], [0, -1, 8], [1, 0, 6], [-1, 1, 1], [1, 1, 3], [-1, -1, 7], [1, -1, 9]];\r\n            var dIndex = id - 1;\r\n            var toP = new Point(this.x + dArr[dIndex][0] * Config.SCENE_GRID_SIZE, this.y + dArr[dIndex][1] * Config.SCENE_GRID_SIZE);\r\n            var toP32 = GameUtils.getGridPostion(toP);\r\n            if (this.scene.isObstacleGrid(toP32)) {\r\n                if (!this.through) {\r\n                    if (this.state_ignoreCantMove) {\r\n                        onPlayFin && onPlayFin.run();\r\n                        return;\r\n                    }\r\n                    else {\r\n                        onPlayFin && onPlayFin.runWith([true]);\r\n                        return;\r\n                    }\r\n                }\r\n                else if (this.scene.isOutsideByGrid(toP32)) {\r\n                    onPlayFin && onPlayFin.runWith([true]);\r\n                    return;\r\n                }\r\n            }\r\n            if (playMode) {\r\n                this.avatarOri = dArr[dIndex][2];\r\n                this.startMove([[this.x, this.y], [toP.x, toP.y]]);\r\n                EventUtils.addEventListener(this, SceneObject.EVENT_MOVE_OVER, Callback.New(() => {\r\n                    onPlayFin && onPlayFin.run();\r\n                }, this), true);\r\n                return;\r\n            }\r\n            else {\r\n                this.x = toP.x;\r\n                this.y = toP.y;\r\n                this.avatarOri = dArr[dIndex][2];\r\n                this.scene.updateCamera();\r\n            }\r\n        }\r\n        else if (id >= 12 && id <= 14) {\r\n            // if(behavior[])\r\n            var isGrid = behavior[1];\r\n            if (isGrid) {\r\n                toP = GameUtils.getGridCenter(new Point(behavior[2] * Config.SCENE_GRID_SIZE, behavior[3] * Config.SCENE_GRID_SIZE));\r\n            }\r\n            else {\r\n                toP = new Point(behavior[2], behavior[3]);\r\n            }\r\n            if (!playMode) {\r\n                this.x = toP.x;\r\n                this.y = toP.y;\r\n            }\r\n            else {\r\n                if (id == 12) {\r\n                    this.startMove([[this.x, this.y], [toP.x, toP.y]]);\r\n                    EventUtils.addEventListener(this, SceneObject.EVENT_MOVE_OVER, Callback.New(() => {\r\n                        onPlayFin && onPlayFin.run();\r\n                    }, this), true);\r\n                    return;\r\n                }\r\n                else if (id == 13) {\r\n                    this.jumpTo(toP.x, toP.y);\r\n                    EventUtils.addEventListener(this, SceneObject.EVENT_JUMP_OVER, Callback.New(() => {\r\n                        onPlayFin && onPlayFin.run();\r\n                    }, this), true);\r\n                    return;\r\n                }\r\n                else {\r\n                    this.setTo(toP.x, toP.y);\r\n                }\r\n            }\r\n        }\r\n        else if (id == 16) {\r\n            if (playMode) {\r\n                setFrameout(function () {\r\n                    onPlayFin && onPlayFin.run();\r\n                }, behavior[1]);\r\n                return;\r\n            }\r\n        }\r\n        else if (id == 17) {\r\n            this.state_ignoreCantMove = true;\r\n        }\r\n        else if (id == 18) {\r\n            this.state_ignoreCantMove = false;\r\n        }\r\n        else if (id >= 19 && id <= 26) {\r\n            var oriArr = [2, 4, 8, 6, 1, 3, 7, 9];\r\n            this.avatarOri = oriArr[id - 19];\r\n        }\r\n        else if (id == 29) {\r\n            this.scale = behavior[1];\r\n        }\r\n        else if (id == 30) {\r\n            this.speed = behavior[1];\r\n        }\r\n        else if (id == 31) {\r\n            this.avatarAlpha = behavior[1];\r\n        }\r\n        else if (id == 32) {\r\n            this.avatarHue = behavior[1];\r\n        }\r\n        else if (id == 33) {\r\n            this.avatarPlayInterval = behavior[1];\r\n        }\r\n        else if (id == 34) {\r\n            this.shadowEnable = behavior[1];\r\n            this.shadowWidth = behavior[2];\r\n            this.shadowHeight = behavior[3];\r\n            this.shadowAlpha = behavior[4];\r\n            this.refreshShadow();\r\n        }\r\n        else if (id == 35) {\r\n            let loop = Boolean(Number(behavior[2]));\r\n            let isHit = Boolean(Number(behavior[3]));\r\n            this.playAnimation(behavior[1], loop, isHit);\r\n        }\r\n        else if (id == 36) {\r\n            this.stopAnimation(behavior[1])\r\n        }\r\n        else if (id == 37) {\r\n            if (playMode) {\r\n                GameAudio.playSE(behavior[1], behavior[2], behavior[3]);\r\n            }\r\n        }\r\n        else if (id == 40) {\r\n            this.fixedOrientation = true;\r\n        }\r\n        else if (id == 41) {\r\n            this.fixedOrientation = false;\r\n        }\r\n        else if (id == 42) {\r\n            this.onTop = 2;\r\n        }\r\n        else if (id == 43) {\r\n            this.onTop = 1;\r\n        }\r\n        else if (id == 44) {\r\n            this.through = true;\r\n        }\r\n        else if (id == 45) {\r\n            this.through = false;\r\n        }\r\n        else if (id == 46) {\r\n            this.autoPlayEnable = true;\r\n        }\r\n        else if (id == 47) {\r\n            this.autoPlayEnable = false;\r\n        }\r\n        else if (id == 50) {\r\n            Tween.to(this.root, { skewY: 200 }, 2000, null, Callback.New(function () {\r\n                onPlayFin && onPlayFin.run();\r\n            }, this));\r\n            return;\r\n        }\r\n        else if (id == 51) {\r\n            Tween.to(this.root, { scaleX: 2, scaleY: 2 }, 2000, null, Callback.New(function () {\r\n                onPlayFin && onPlayFin.run();\r\n            }, this));\r\n            return;\r\n        }\r\n        onPlayFin && onPlayFin.run();\r\n    }\r\n}",
        "//■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■\r\n// 游戏场景\r\n//■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■\r\nclass GameClientSceneObject_1 extends ClientSceneObject_1 {\r\n    //------------------------------------------------------------------------------------------------------\r\n    // 基本\r\n    //------------------------------------------------------------------------------------------------------\r\n    constructor(soData: SceneObject, scene: ClientScene=null) {\r\n        super(soData, scene);\r\n    }\r\n\r\n\r\n}"
    ],
    "bin": [
        "var GUI_Alert = (function () {\n    function GUI_Alert() {\n    }\n    GUI_Alert.alert = function (content) {\n        alert(content);\n        ClientMsgSender.rpc(\"Logic_Hall\", \"accessBattle\", [], Callback.New(function (state) {\n            if (state == 0) {\n                alert(\"您的对手已神隐不见了\");\n            }\n            else if (state == 1) {\n                alert(\"对方已经和别人打起来了\");\n            }\n        }, this));\n    };\n    return GUI_Alert;\n}());\n",
        "var __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar GUI_BattleCommon = (function (_super) {\n    __extends(GUI_BattleCommon, _super);\n    function GUI_BattleCommon() {\n        _super.call(this);\n    }\n    GUI_BattleCommon.refreshStageStep = function (stageStep) {\n        this.ui.refreshStageStep(stageStep);\n    };\n    GUI_BattleCommon.pause = function (stageStep) {\n        this.ui.refreshStageStep(stageStep);\n        this.ui.refreshTurn();\n    };\n    GUI_BattleCommon.prototype.refreshStageStep = function (stageStep) {\n        this.stageStep = stageStep;\n        switch (stageStep) {\n            case BattleHandler.STAGE_BATTLE:\n                break;\n            case BattleHandler.STAGE_END:\n                break;\n        }\n    };\n    GUI_BattleCommon.prototype.refreshTurn = function () {\n    };\n    GUI_BattleCommon.prototype.refreshTime = function () {\n    };\n    GUI_BattleCommon.prototype.onExit = function () {\n        ClientMsgSender.rpc(\"Logic_Battle\");\n    };\n    GUI_BattleCommon.ui = GameUI.get(5);\n    return GUI_BattleCommon;\n}(GUI_4));\n",
        "var __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar GUI_battle1 = (function (_super) {\n    __extends(GUI_battle1, _super);\n    function GUI_battle1() {\n        _super.call(this);\n    }\n    GUI_battle1.prototype.initLibrary = function (index_deck) {\n        this.libraryList.length = 0;\n        var cardList = Game.player.data.卡组[index_deck].卡牌列表;\n        for (var i = 0; i < cardList.length; i++) {\n            for (var j = 0; j < cardList[i].数量; j++) {\n                this.libraryList.push(cardList[i].卡牌);\n            }\n        }\n        this.randLibraryOrder();\n        this.fromLibraryToHand(6);\n    };\n    GUI_battle1.prototype.randLibraryOrder = function () {\n        ArrayUtils.randOrder(this.libraryList);\n    };\n    GUI_battle1.prototype.fromLibraryToHand = function (cardNum) {\n        for (var i = 0; i < cardNum; i++) {\n            this.HandList.push(this.libraryList.shift());\n        }\n    };\n    GUI_battle1.prototype.initHand = function () {\n        this.HandList.length = 0;\n    };\n    return GUI_battle1;\n}(GUI_BattleCommon));\n",
        "var __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar UI_cardInDeck = (function (_super) {\n    __extends(UI_cardInDeck, _super);\n    function UI_cardInDeck() {\n        _super.call(this);\n        this.on(EventObject.CLICK, this, this.removeCard);\n        this.文本_卡牌名称.on(EventObject.CHANGE, this, this.updateFontSize);\n        this.文本_卡牌数量.on(EventObject.CHANGE, this, this.updateNumberColor);\n    }\n    UI_cardInDeck.prototype.removeCard = function () {\n        var gui_card = GameUI.get(3);\n        gui_card.removeCardFromDeck(Number(this.卡牌编号.text));\n    };\n    UI_cardInDeck.prototype.updateFontSize = function () {\n        if (this.文本_卡牌名称.text.length == 8)\n            this.文本_卡牌名称.fontSize = 17;\n        else if (this.文本_卡牌名称.text.length == 9)\n            this.文本_卡牌名称.fontSize = 16;\n        else if (this.文本_卡牌名称.text.length == 10)\n            this.文本_卡牌名称.fontSize = 15;\n        else if (this.文本_卡牌名称.text.length > 10)\n            this.文本_卡牌名称.fontSize = 14;\n    };\n    UI_cardInDeck.prototype.updateNumberColor = function () {\n        var card = GameData.customModulePresetDatas[1][Number(this.卡牌编号.text)];\n        if (Number(this.文本_卡牌数量.text.substr(0, this.文本_卡牌数量.text.length - 1)) >= card.数量限制) {\n            this.文本_卡牌数量.color = \"#FFD700\";\n        }\n        else {\n            this.文本_卡牌数量.color = \"#eeeeee\";\n        }\n    };\n    return UI_cardInDeck;\n}(GUI_2001));\n",
        "var __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar UI_cardInEdit = (function (_super) {\n    __extends(UI_cardInEdit, _super);\n    function UI_cardInEdit() {\n        _super.call(this);\n        this.on(EventObject.CLICK, this, this.addCard);\n    }\n    UI_cardInEdit.prototype.addCard = function () {\n        var gui_card = GameUI.get(3);\n        gui_card.addCardToDeck(Number(this.卡牌编号.text));\n    };\n    return UI_cardInEdit;\n}(GUI_1001));\n",
        "var __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar GameListData;\nvar GameData;\nvar Common;\nvar GUI_card = (function (_super) {\n    __extends(GUI_card, _super);\n    function GUI_card() {\n        _super.call(this);\n        this.updateCardList();\n        this.index_deck = 0;\n        this.updateDeckName();\n        this.updateCardInDeck();\n        this.interactiveEffect();\n        this.可输入文本_搜索内容.on(EventObject.BLUR, this, this.searchCard);\n        this.可输入文本_搜索内容.on(EventObject.ENTER, this, this.searchCardUIEnter);\n        this.可输入文本_卡组标题.on(EventObject.BLUR, this, this.deckNameEdit);\n        this.可输入文本_卡组标题.on(EventObject.ENTER, this, this.deckNameUIEnter);\n    }\n    GUI_card.prototype.updateDeckName = function () {\n        this.文本_卡组标题.text = Game.player.data.卡组[this.index_deck].卡组名称;\n    };\n    GUI_card.prototype.deckNameUIEnter = function () {\n        this.可输入文本_备用.focus();\n    };\n    GUI_card.prototype.deckNameEdit = function () {\n        var deck = Game.player.data.卡组[this.index_deck];\n        if (this.可输入文本_卡组标题.text != \"\")\n            deck.卡组名称 = this.可输入文本_卡组标题.text;\n        this.可输入文本_卡组标题.visible = false;\n        this.updateDeckName();\n        this.文本_卡组标题.visible = true;\n        this.图片_卡组标题编辑.visible = true;\n    };\n    GUI_card.prototype.changeCostInDeck = function (_cost, _num, _symbol) {\n        if (_symbol === void 0) { _symbol = \"+\"; }\n        if (_cost > 7)\n            _cost = 7;\n        eval(\"this.图片_费用条\" + _cost + \".width\" + _symbol + \"=\" + _num * 8);\n        if (eval(\"this.图片_费用条\" + _cost).width > 25 * 8)\n            eval(\"this.图片_费用条\" + _cost).width = 25 * 8;\n    };\n    GUI_card.prototype.changeAbilityIconInDeck = function (_card, _num, _symbol) {\n        if (_symbol === void 0) { _symbol = \"+\"; }\n        if (_symbol == \"+\") {\n            this.文本_调查图标数量.text = (Number(this.文本_调查图标数量.text) + _card.调查图标 * _num).toString();\n            this.文本_战斗图标数量.text = (Number(this.文本_战斗图标数量.text) + _card.战斗图标 * _num).toString();\n            this.文本_势力图标数量.text = (Number(this.文本_势力图标数量.text) + _card.势力图标 * _num).toString();\n        }\n        else if (_symbol == \"-\") {\n            this.文本_调查图标数量.text = (Number(this.文本_调查图标数量.text) - _card.调查图标 * _num).toString();\n            this.文本_战斗图标数量.text = (Number(this.文本_战斗图标数量.text) - _card.战斗图标 * _num).toString();\n            this.文本_势力图标数量.text = (Number(this.文本_势力图标数量.text) - _card.势力图标 * _num).toString();\n        }\n    };\n    GUI_card.prototype.updateCardInDeck = function () {\n        var cardList = [];\n        var theDeck = Game.player.data.卡组[this.index_deck];\n        for (var i = 0; i < 8; i++)\n            eval(\"this.图片_费用条\" + i).width = 0;\n        this.文本_调查图标数量.text = \"0\";\n        this.文本_战斗图标数量.text = \"0\";\n        this.文本_势力图标数量.text = \"0\";\n        for (var i = 0; i < theDeck.卡牌列表.length; i++) {\n            var card = theDeck.卡牌列表[i];\n            var itemData = new ListItem_2001();\n            itemData.卡牌编号 = card.卡牌.id.toString();\n            itemData.文本_卡牌数量 = card.数量.toString().concat(\"x\");\n            itemData.文本_卡牌名称 = GameListData.getName(Common.customModuleDataList[1], card.卡牌.id);\n            itemData.文本_费用 = card.卡牌.费用.toString();\n            cardList.push(itemData);\n            this.changeCostInDeck(card.卡牌.费用, card.数量);\n            this.changeAbilityIconInDeck(card.卡牌, card.数量);\n        }\n        this.列表_组内卡牌.items = cardList;\n        var cardNumber = 0;\n        for (var i = 0; i < theDeck.卡牌列表.length; i++) {\n            cardNumber += theDeck.卡牌列表[i].数量;\n        }\n        this.文本_卡牌数量.text = cardNumber.toString();\n    };\n    GUI_card.prototype.removeCardFromDeck = function (id) {\n        var card = GameData.customModulePresetDatas[1][id];\n        var theDeck = Game.player.data.卡组[this.index_deck];\n        var temp_卡牌列表 = ArrayUtils.matchAttributesD2(theDeck.卡牌列表, \"卡牌\", { id: id }, true);\n        var temp_卡堆 = temp_卡牌列表[0];\n        if (temp_卡堆.数量 == 1) {\n            ArrayUtils.remove(theDeck.卡牌列表, temp_卡堆);\n        }\n        else {\n            temp_卡堆.数量--;\n        }\n        this.updateCardInDeck();\n    };\n    GUI_card.prototype.searchCardUIEnter = function () {\n        this.可输入文本_备用.focus();\n    };\n    GUI_card.prototype.searchCard = function () {\n        this.updateCardList();\n        if (this.可输入文本_搜索内容.text == \"\") {\n            this.可输入文本_搜索内容.visible = false;\n            this.文本_搜索内容.visible = true;\n        }\n    };\n    GUI_card.prototype.factionSelect = function (faction) {\n        var theFactionUI = eval(\"this.图片_派系\" + faction);\n        theFactionUI.visible = !theFactionUI.visible;\n        if (theFactionUI.visible) {\n            this.updateCardList();\n        }\n        else {\n            this.列表_卡牌.items = ArrayUtils.matchAttributes(this.列表_卡牌.items, { 卡牌派系: faction }, false, \"!=\");\n        }\n    };\n    GUI_card.prototype.costSelect = function (cost) {\n        var theCostUI = eval(\"this.图片_费用\" + String(cost > 7 ? 7 : cost));\n        theCostUI.visible = !theCostUI.visible;\n        if (theCostUI.visible) {\n            this.updateCardList();\n        }\n        else {\n            this.列表_卡牌.items = ArrayUtils.matchAttributes(this.列表_卡牌.items, { 费用: cost }, false, \"!=\");\n        }\n    };\n    GUI_card.prototype.updateCardList = function () {\n        var cardList = [];\n        for (var i = 0; i < Game.player.data.卡库.length; i++) {\n            var card = Game.player.data.卡库[i];\n            var itemData = new ListItem_1001();\n            if (eval(\"this.图片_派系\" + card.卡牌.卡牌派系).visible == false)\n                continue;\n            if (eval(\"this.图片_费用\" + String(card.卡牌.费用 > 7 ? 7 : card.卡牌.费用)).visible == false)\n                continue;\n            ObjectUtils.clone(card.卡牌, itemData);\n            itemData.卡牌编号 = card.卡牌.id.toString();\n            itemData.卡牌名称 = GameListData.getName(Common.customModuleDataList[1], card.卡牌.id);\n            if (this.可输入文本_搜索内容.text != \"\" && itemData.卡牌名称.indexOf(this.可输入文本_搜索内容.text) < 0)\n                continue;\n            if (itemData.卡牌类别 == \"0\")\n                itemData.卡牌类别 = \"地区\";\n            else if (itemData.卡牌类别 == \"1\")\n                itemData.卡牌类别 = \"角色\";\n            else if (itemData.卡牌类别 == \"2\")\n                itemData.卡牌类别 = \"事务\";\n            else if (itemData.卡牌类别 == \"3\")\n                itemData.卡牌类别 = \"附属\";\n            else if (itemData.卡牌类别 == \"4\")\n                itemData.卡牌类别 = \"秘社\";\n            if (card.卡牌.卡牌派系 == 0)\n                itemData.图片_卡框 = \"asset/image/picture/卡配/frame_small/frame0.png\";\n            else if (card.卡牌.卡牌派系 == 1)\n                itemData.图片_卡框 = \"asset/image/picture/卡配/frame_small/frame1.png\";\n            else if (card.卡牌.卡牌派系 == 2)\n                itemData.图片_卡框 = \"asset/image/picture/卡配/frame_small/frame2.png\";\n            else if (card.卡牌.卡牌派系 == 3)\n                itemData.图片_卡框 = \"asset/image/picture/卡配/frame_small/frame3.png\";\n            else if (card.卡牌.卡牌派系 == 4)\n                itemData.图片_卡框 = \"asset/image/picture/卡配/frame_small/frame4.png\";\n            else if (card.卡牌.卡牌派系 == 5)\n                itemData.图片_卡框 = \"asset/image/picture/卡配/frame_small/frame5.png\";\n            else if (card.卡牌.卡牌派系 == 6)\n                itemData.图片_卡框 = \"asset/image/picture/卡配/frame_small/frame6.png\";\n            else if (card.卡牌.卡牌派系 == 7)\n                itemData.图片_卡框 = \"asset/image/picture/卡配/frame_small/frame7.png\";\n            else if (card.卡牌.卡牌派系 == 8)\n                itemData.图片_卡框 = \"asset/image/picture/卡配/frame_small/frame8.png\";\n            cardList.push(itemData);\n        }\n        this.列表_卡牌.items = cardList;\n    };\n    GUI_card.prototype.addCardToDeck = function (id) {\n        var card = GameData.customModulePresetDatas[1][id];\n        var theDeck = Game.player.data.卡组[this.index_deck];\n        var temp_卡牌列表 = ArrayUtils.matchAttributesD2(theDeck.卡牌列表, \"卡牌\", { id: id }, true);\n        var temp_卡堆;\n        if (temp_卡牌列表[0] == undefined) {\n            temp_卡堆 = new DataStructure_卡堆();\n            temp_卡堆.卡牌 = ObjectUtils.depthClone(card);\n            temp_卡堆.数量 = 1;\n            theDeck.卡牌列表.push(temp_卡堆);\n        }\n        else {\n            temp_卡堆 = temp_卡牌列表[0];\n            if (temp_卡堆.数量 >= temp_卡堆.卡牌.数量限制) {\n                GameCommand.startCommonCommand(1002);\n                return;\n            }\n            temp_卡堆.数量 += 1;\n        }\n        this.updateCardInDeck();\n    };\n    GUI_card.prototype.interactiveEffect = function () {\n    };\n    GUI_card.prototype.turnDownTip = function () {\n        var _this = this;\n        this.interactive_turnDownTip = Tween.to(this.图片_向下滚动提示, { alpha: 0, y: 620 }, 1000, null, Callback.New(function () {\n            setTimeout(function () {\n                _this.图片_向下滚动提示.alpha = 1;\n                _this.图片_向下滚动提示.y = 605;\n                _this.turnDownTip();\n            }, 500);\n        }, this));\n    };\n    return GUI_card;\n}(GUI_3));\n",
        "var __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar GUI_mainMenu = (function (_super) {\n    __extends(GUI_mainMenu, _super);\n    function GUI_mainMenu() {\n        _super.call(this);\n        this.tweens = new Array();\n        this.按钮_匹配.on(EventObject.MOUSE_OVER, this, this.btnMatch1_mouseOver);\n        this.按钮_匹配.on(EventObject.MOUSE_OUT, this, this.btnMatch1_mouseOut);\n        this.文本_主菜单_大厅.on(EventObject.MOUSE_OVER, this, this.btnTop_mouseOver, [this.文本_主菜单_大厅2]);\n        this.文本_主菜单_大厅.on(EventObject.MOUSE_OUT, this, this.btnTop_mouseOut, [this.文本_主菜单_大厅2]);\n        this.文本_主菜单_卡牌.on(EventObject.MOUSE_OVER, this, this.btnTop_mouseOver, [this.文本_主菜单_卡牌2]);\n        this.文本_主菜单_卡牌.on(EventObject.MOUSE_OUT, this, this.btnTop_mouseOut, [this.文本_主菜单_卡牌2]);\n        this.文本_主菜单_召唤.on(EventObject.MOUSE_OVER, this, this.btnTop_mouseOver, [this.文本_主菜单_召唤2]);\n        this.文本_主菜单_召唤.on(EventObject.MOUSE_OUT, this, this.btnTop_mouseOut, [this.文本_主菜单_召唤2]);\n        this.文本_主菜单_交易.on(EventObject.MOUSE_OVER, this, this.btnTop_mouseOver, [this.文本_主菜单_交易2]);\n        this.文本_主菜单_交易.on(EventObject.MOUSE_OUT, this, this.btnTop_mouseOut, [this.文本_主菜单_交易2]);\n        this.文本_主菜单_黑市.on(EventObject.MOUSE_OVER, this, this.btnTop_mouseOver, [this.文本_主菜单_黑市2]);\n        this.文本_主菜单_黑市.on(EventObject.MOUSE_OUT, this, this.btnTop_mouseOut, [this.文本_主菜单_黑市2]);\n        this.按钮_任务.on(EventObject.MOUSE_OVER, this, this.btnLeft_mouseOver, [this.按钮_任务]);\n        this.按钮_任务.on(EventObject.MOUSE_OUT, this, this.btnLeft_mouseOut, [this.按钮_任务]);\n        this.按钮_好友.on(EventObject.MOUSE_OVER, this, this.btnLeft_mouseOver, [this.按钮_好友]);\n        this.按钮_好友.on(EventObject.MOUSE_OUT, this, this.btnLeft_mouseOut, [this.按钮_好友]);\n        this.按钮_信箱.on(EventObject.MOUSE_OVER, this, this.btnLeft_mouseOver, [this.按钮_信箱]);\n        this.按钮_信箱.on(EventObject.MOUSE_OUT, this, this.btnLeft_mouseOut, [this.按钮_信箱]);\n        this.按钮_设置.on(EventObject.MOUSE_OVER, this, this.btnLeft_mouseOver, [this.按钮_设置]);\n        this.按钮_设置.on(EventObject.MOUSE_OUT, this, this.btnLeft_mouseOut, [this.按钮_设置]);\n        this.按钮_帮助.on(EventObject.MOUSE_OVER, this, this.btnLeft_mouseOver, [this.按钮_帮助]);\n        this.按钮_帮助.on(EventObject.MOUSE_OUT, this, this.btnLeft_mouseOut, [this.按钮_帮助]);\n        this.按钮_活动.on(EventObject.MOUSE_OVER, this, this.btnLeft_mouseOver, [this.按钮_活动]);\n        this.按钮_活动.on(EventObject.MOUSE_OUT, this, this.btnLeft_mouseOut, [this.按钮_活动]);\n    }\n    GUI_mainMenu.prototype.btnTop_mouseOver = function (theBtn) {\n        var glowFilter = new GlowFilter(\"#eeeeee\", 15, 0, 0);\n        theBtn.filters = [glowFilter];\n    };\n    GUI_mainMenu.prototype.btnTop_mouseOut = function (theBtn) {\n        theBtn.filters = [];\n    };\n    GUI_mainMenu.prototype.btnLeft_mouseOver = function (theBtn) {\n        if (this.tweens[1]) {\n            this.tweens[1].clear();\n            this.tweens[1].recover();\n        }\n        this.图片_leftBg.x = -160;\n        this.图片_leftBg.y = theBtn.y;\n        this.图片_leftBg.visible = true;\n        this.tweens[1] = Tween.to(this.图片_leftBg, { x: -39 }, 450, Ease.strongOut);\n    };\n    GUI_mainMenu.prototype.btnLeft_mouseOut = function (theBtn) {\n        if (this.tweens[1])\n            this.tweens[1].clear();\n        this.图片_leftBg.visible = false;\n        this.图片_leftBg.x = -160;\n    };\n    GUI_mainMenu.prototype.btnMatch1_mouseOver = function () {\n        if (this.tweens[0]) {\n            this.tweens[0].clear();\n            this.tweens[0].recover();\n        }\n        this.按钮_匹配_文本.alpha = 0;\n        this.按钮_匹配_文本.y = 15;\n        this.按钮_匹配_文本.fontSize = 20;\n        this.按钮_匹配_文本.x = 0;\n        this.tweens[0] = Tween.to(this.按钮_匹配_文本, { alpha: 1, x: this.按钮_匹配_文本.x + 90 }, 400, Ease.strongOut);\n        this.按钮_匹配.x -= 12;\n        this.按钮_匹配.y -= 41;\n        this.按钮_匹配.width += 21;\n        this.按钮_匹配.height += 50;\n        this.按钮_匹配_遮罩.visible = true;\n    };\n    GUI_mainMenu.prototype.btnMatch1_mouseOut = function () {\n        this.按钮_匹配_遮罩.visible = false;\n        if (this.tweens[0])\n            this.tweens[0].clear();\n        this.按钮_匹配_文本.x = 12;\n        this.按钮_匹配_文本.y = 338;\n        this.按钮_匹配_文本.fontSize = 16;\n        this.按钮_匹配_文本.alpha = 1;\n        this.按钮_匹配.x += 12;\n        this.按钮_匹配.y += 41;\n        this.按钮_匹配.width -= 21;\n        this.按钮_匹配.height -= 50;\n    };\n    return GUI_mainMenu;\n}(GUI_2));\n",
        "EventUtils.addEventListener(UIBase, UIBase.EVENT_COMPONENT_CONSTRUCTOR_INIT, Callback.New(uiComponentInit, this));\nfunction uiComponentInit(uiComp) {\n    if (uiComp.hasCommand[0]) {\n        this.mouseEnabled = true;\n        uiComp.on(EventObject.CLICK, uiComp, function () {\n            var commandInputMessage;\n            if (uiComp.commandInputMessage instanceof Callback) {\n                commandInputMessage = uiComp.commandInputMessage.run();\n            }\n            else {\n                commandInputMessage = uiComp.commandInputMessage;\n            }\n            GameCommand.startUICommand(uiComp, 0, commandInputMessage);\n        });\n    }\n}\n",
        "var __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar GameFunctionClient = (function (_super) {\n    __extends(GameFunctionClient, _super);\n    function GameFunctionClient() {\n        _super.apply(this, arguments);\n    }\n    GameFunctionClient.moveTo = function (soIndex, lines) {\n        var soc = Game.currentScene.sceneObjects[soIndex];\n        if (!soc)\n            return;\n        var lastTo = lines[lines.length - 1];\n        if (lastTo[0] == soc.x && lastTo[1] == soc.y) {\n            return;\n        }\n        lines.splice(0, 0, [soc.x, soc.y]);\n        soc.startMove(lines);\n    };\n    GameFunctionClient.jumpTo = function (soIndex, x, y) {\n        var soc = Game.currentScene.sceneObjects[soIndex];\n        if (!soc)\n            return;\n        soc.jumpTo(x, y);\n    };\n    GameFunctionClient.setTo = function (soIndex, x, y) {\n        var soc = Game.currentScene.sceneObjects[soIndex];\n        if (!soc)\n            return;\n        soc.setTo(x, y);\n    };\n    GameFunctionClient.moveStop = function (soIndex, x, y) {\n        var soc = Game.currentScene.sceneObjects[soIndex];\n        if (!soc)\n            return;\n        soc.stopMove();\n        soc.correctTo(x, y);\n    };\n    GameFunctionClient.changeAvatar = function (soIndex, avatarID, actID, frame) {\n        if (actID === void 0) { actID = -1; }\n        if (frame === void 0) { frame = -1; }\n        var soc = Game.currentScene.sceneObjects[soIndex];\n        if (!soc)\n            return;\n        soc.avatarID = avatarID;\n        if (actID != -1) {\n            soc.avatarAct = actID;\n        }\n        if (frame != -1) {\n            soc.avatarFrame = frame;\n        }\n    };\n    GameFunctionClient.setOrientation = function (soIndex, ori) {\n        var soc = Game.currentScene.sceneObjects[soIndex];\n        if (!soc)\n            return;\n        soc.avatarOri = ori;\n    };\n    GameFunctionClient.changeAvatarAttribute = function (soIndex, type, v) {\n        var soc = Game.currentScene.sceneObjects[soIndex];\n        if (!soc)\n            return;\n        switch (type) {\n            case 0:\n                soc.scale = v;\n                break;\n            case 1:\n                soc.avatarAlpha = v;\n                break;\n            case 2:\n                soc.avatarHue = v;\n                break;\n            case 3:\n                soc.avatarPlayInterval = v;\n                break;\n            case 4:\n                soc.speed = v;\n                break;\n        }\n    };\n    GameFunctionClient.changeShadow = function (soIndex, enabled, w, h, alpha) {\n        var soc = Game.currentScene.sceneObjects[soIndex];\n        if (!soc)\n            return;\n        soc.shadowEnable = enabled == 1 ? true : false;\n        soc.shadowWidth = w;\n        soc.shadowHeight = h;\n        soc.shadowAlpha = alpha;\n    };\n    GameFunctionClient.playAnimation = function (soIndex, aniID, loop, isHit) {\n        var soc = Game.currentScene.sceneObjects[soIndex];\n        if (!soc)\n            return;\n        soc.playAnimation(aniID, loop, isHit);\n    };\n    GameFunctionClient.stopAnimation = function (soIndex, aniID) {\n        var soc = Game.currentScene.sceneObjects[soIndex];\n        if (!soc)\n            return;\n        soc.stopAnimation(aniID);\n    };\n    GameFunctionClient.changeAvatarState = function (soIndex, type, v) {\n        var soc = Game.currentScene.sceneObjects[soIndex];\n        if (!soc)\n            return;\n        switch (type) {\n            case 0:\n                soc.selectEnabled = v == 1;\n                break;\n            case 1:\n                soc.fixedOrientation = v == 1;\n                break;\n            case 2:\n                soc.onTop = v;\n                break;\n            case 3:\n                soc.through = v == 1;\n                break;\n            case 4:\n                soc.autoPlayEnable = v == 1;\n                break;\n            case 5:\n                soc.bridge = v == 1;\n                break;\n        }\n    };\n    return GameFunctionClient;\n}(GameFunction));\n",
        "var MsgHandler = (function () {\n    function MsgHandler() {\n    }\n    MsgHandler.loadNewScene = function (sceneData) {\n        var lastTonal;\n        if (Game.currentScene) {\n            lastTonal = Game.currentScene.displayObject.getTonal();\n            Game.layer.sceneLayer.removeChildren();\n            Game.currentScene.dispose();\n            if (typeof Controller != \"undefined\")\n                Controller.stop();\n        }\n        ClientScene.createScene(sceneData.modelID, Callback.New(onLoadedNewScene, this), null, true);\n        function onLoadedNewScene(scene) {\n            Game.currentScene = scene;\n            ClientMsgSender.rpc(\"RequestHandler\", \"inScene\");\n        }\n    };\n    MsgHandler.inNewScene = function (sceneObjects, isExecuteSceneCommand) {\n        for (var i = 0; i < sceneObjects.length; i++) {\n            var so = sceneObjects[i];\n            if (so) {\n                var playerData = so[\"player\"];\n                delete so[\"player\"];\n                var soc = Game.currentScene.addSceneObject(so, false, true);\n                MsgHandler.addPlayer(soc, playerData);\n            }\n        }\n        Game.currentScene.startRender();\n        Game.layer.sceneLayer.addChild(Game.currentScene.displayObject);\n        if (Game.currentScene.bgm) {\n            GameAudio.playBGM(Game.currentScene.bgm, Game.currentScene.bgmVolume, 9999, true, Config.SCENE_BGM_TWEEN, Game.currentScene.bgmPitch);\n        }\n        if (Game.currentScene.bgs) {\n            GameAudio.playBGS(Game.currentScene.bgs, Game.currentScene.bgsVolume, 9999, true, Config.SCENE_BGM_TWEEN, Game.currentScene.bgsPitch);\n        }\n        Controller.clearEvent();\n        if (isExecuteSceneCommand) {\n            EventUtils.happen(Controller, Controller.EVENT_IN_SCENE_COMMAND, [true]);\n        }\n    };\n    MsgHandler.inSceneCommandExecuteOver = function () {\n        EventUtils.happen(Controller, Controller.EVENT_IN_SCENE_COMMAND, [false]);\n    };\n    MsgHandler.addSceneObject = function (so) {\n        if (!Game.currentScene)\n            return;\n        var playerData = so[\"player\"];\n        delete so[\"player\"];\n        var soc = Game.currentScene.addSceneObject(so, false, true);\n        MsgHandler.addPlayer(soc, playerData);\n        if (soc.playerUID == Game.player.uid) {\n            Game.mySceneObject = soc;\n            Game.currentScene.setCameraSceneObject(soc);\n            if (typeof Controller != \"undefined\")\n                Controller.start();\n        }\n    };\n    MsgHandler.removeSceneObject = function (so) {\n        if (!Game.currentScene)\n            return;\n        var soc = Game.currentScene.removeSceneObject(so);\n        if (soc && soc.player) {\n            Game.currentScene.removePlayer(soc.player);\n        }\n        soc.dispose();\n    };\n    MsgHandler.addPlayer = function (soc, playerData) {\n        if (playerData) {\n            if (soc.playerUID == Game.player.uid) {\n                soc.player = Game.player;\n            }\n            else {\n                soc.player = new ClientPlayer();\n            }\n            ObjectUtils.clone(playerData, soc.player);\n            soc.player.sceneObject = soc;\n            Game.currentScene.addPlayer(soc.player);\n        }\n    };\n    return MsgHandler;\n}());\n",
        "var Controller = (function () {\n    function Controller() {\n    }\n    Controller.init = function () {\n        this.onCommandStartCB = Callback.New(this.onCommandStart, this, [Controller.ENABLED_COMMAND_SCENE_OBJECT_CLICK_EXECUTE]);\n    };\n    Controller.start = function () {\n        var sceneLayer = Game.currentScene.displayObject;\n        sceneLayer.width = Game.currentScene.width;\n        sceneLayer.height = Game.currentScene.height;\n        sceneLayer.on(EventObject.MOUSE_DOWN, this, Controller.onMouseDown);\n        sceneLayer.on(EventObject.MOUSE_MOVE, this, Controller.onMouseMove);\n        stage.on(EventObject.RIGHT_CLICK, this, Controller.onMove);\n        EventUtils.addEventListener(Controller, Controller.EVENT_SCENE_OBJECT_CLICK_COMMAND, Callback.New(this.onCommandStart, this, [Controller.ENABLED_COMMAND_SCENE_OBJECT_CLICK_EXECUTE]));\n        EventUtils.addEventListener(Controller, Controller.EVENT_IN_SCENE_COMMAND, Callback.New(this.onCommandStart, this, [Controller.ENABLED_COMMAND_IN_SCENE_EXECUTE]));\n        Controller.selectEffect = new ColorFilter([\n            1, 0, 0, 0.4, 0,\n            0, 1, 0, 0.4, 0,\n            0, 0, 1, 0.4, 0,\n            0, 0, 0, 1, 0\n        ]);\n    };\n    Controller.stop = function () {\n        Controller.selectSceneObject = null;\n        var sceneLayer = Game.currentScene.displayObject;\n        sceneLayer.off(EventObject.MOUSE_DOWN, this, Controller.onMouseDown);\n        sceneLayer.off(EventObject.MOUSE_MOVE, this, Controller.onMouseMove);\n        sceneLayer.off(EventObject.RIGHT_CLICK, this, Controller.onMove);\n        EventUtils.clear(GameCommand, GameCommand.EVENT_SCENE_OBJECT_CLICK_COMMAND);\n    };\n    Object.defineProperty(Controller, \"enabled\", {\n        get: function () {\n            for (var i in Controller.enabledMapping) {\n                if (!Controller.enabledMapping[i])\n                    return false;\n            }\n            return true;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Controller.clearEvent = function () {\n        EventUtils.happen(Controller, Controller.EVENT_SCENE_OBJECT_CLICK_COMMAND, [false]);\n        EventUtils.happen(Controller, Controller.EVENT_IN_SCENE_COMMAND, [false]);\n    };\n    Controller.onCommandStart = function (enabledID, isStart) {\n        Controller.enabledMapping[enabledID] = !isStart;\n    };\n    Controller.onCommandOver = function () {\n    };\n    Controller.stopControl = function () {\n    };\n    Controller.checkTouch = function (so) {\n        if (Config.EDIT_MODE)\n            return;\n        if (!Game.currentScene || !Game.mySceneObject || Game.mySceneObject.state_isJumping || !Game.mySceneObject.inScene || !so.inScene)\n            return;\n        if (so == Game.mySceneObject) {\n            var gridSos = so.scene.gridSceneObjects[so.posGrid.x][so.posGrid.y];\n            for (var i = gridSos.length - 1; i >= 0; i--) {\n                var gridSo = gridSos[i];\n                GameCommand.startSceneObjectCommand(gridSo.index, 1);\n            }\n        }\n        else {\n            if (so.posGrid.x == Game.mySceneObject.posGrid.x && so.posGrid.y == Game.mySceneObject.posGrid.y) {\n                GameCommand.startSceneObjectCommand(so.index, 1);\n            }\n        }\n    };\n    Controller.updateSelectSceneObject = function () {\n        if (Config.EDIT_MODE)\n            return;\n        var len = Game.currentScene.sceneObjects.length;\n        var globalP = Game.currentScene.globalPos;\n        for (var i = len - 1; i >= 0; i--) {\n            var soc = Game.currentScene.sceneObjects[i];\n            if (!soc)\n                continue;\n            if (!soc.root.stage)\n                continue;\n            if (!soc.selectEnabled)\n                continue;\n            this.unselectOneSceneObject(soc);\n            if (soc.avatar.hitTestPoint(globalP.x, globalP.y)) {\n                this.selectOneSceneObject(soc);\n                return;\n            }\n        }\n    };\n    Controller.selectOneSceneObject = function (soc) {\n        if (this.selectSceneObject)\n            this.unselectOneSceneObject(this.selectSceneObject);\n        this.selectSceneObject = soc;\n        soc.avatar.appendGameFilter(Controller.selectEffect);\n    };\n    Controller.unselectOneSceneObject = function (soc) {\n        if (soc == this.selectSceneObject) {\n            this.selectSceneObject = null;\n            soc.avatar.subtractGameFilter(Controller.selectEffect);\n        }\n    };\n    Controller.onMouseDown = function (e) {\n        this.updateSelectSceneObject();\n        if (!Controller.enabled)\n            return;\n        if (this.selectSceneObject && this.selectSceneObject.inScene) {\n            if (this.selectSceneObject.hasCommand[0]) {\n                EventUtils.happen(Controller, Controller.EVENT_SCENE_OBJECT_CLICK_COMMAND, [true]);\n                GameCommand.startSceneObjectCommand(this.selectSceneObject.index, 0, null, Callback.New(function () {\n                    EventUtils.happen(Controller, Controller.EVENT_SCENE_OBJECT_CLICK_COMMAND, [false]);\n                }, this));\n            }\n        }\n        else {\n            if (Game.mySceneObject.state_isJumping)\n                return;\n            this.onMove(e);\n        }\n    };\n    Controller.onMouseMove = function (e) {\n        this.updateSelectSceneObject();\n    };\n    Controller.onMove = function (e) {\n        if (!Controller.enabled)\n            return;\n        if (Game.mySceneObject.state_isJumping)\n            return;\n        var realLineArr;\n        var toP = new Point(Game.currentScene.localX, Game.currentScene.localY);\n        Game.currentScene.limitInside(toP);\n        if (Config.MOVE_TO_GRID_CENTER) {\n            GameUtils.getGridCenter(toP, toP);\n        }\n        if (toP.x == Game.mySceneObject.x && toP.y == Game.mySceneObject.y)\n            return;\n        if (Game.mySceneObject.through && !Config.MOVE_4_ORI) {\n            realLineArr = [[toP.x, toP.y]];\n        }\n        else {\n            if (Game.currentScene.isObstacle(toP, Game.mySceneObject)) {\n                var gridP = GameUtils.getGridPostion(toP);\n                var myGridP = GameUtils.getGridPostion(new Point(Game.mySceneObject.x, Game.mySceneObject.y));\n                gridP = this.getNearThrouughGrid(gridP, myGridP);\n                if (!gridP)\n                    return;\n                gridP.x *= Config.SCENE_GRID_SIZE;\n                gridP.y *= Config.SCENE_GRID_SIZE;\n                toP = GameUtils.getGridCenter(gridP, toP);\n                if (!toP)\n                    return;\n            }\n            if (GameUtils.twoPointHasObstacle(Game.mySceneObject.x, Game.mySceneObject.y, toP.x, toP.y, Game.currentScene, Game.mySceneObject) || Config.MOVE_4_ORI) {\n                var gridW = Math.floor(Game.currentScene.width / Config.SCENE_GRID_SIZE);\n                var gridH = Math.floor(Game.currentScene.height / Config.SCENE_GRID_SIZE);\n                realLineArr = AstarUtils.moveTo(Game.mySceneObject.x, Game.mySceneObject.y, toP.x, toP.y, gridW, gridH, Game.currentScene);\n                if (!realLineArr)\n                    return;\n            }\n            else {\n                realLineArr = [[toP.x, toP.y]];\n            }\n        }\n        ClientMsgSender.rpc(\"RequestHandler\", \"requestMove\", [realLineArr]);\n    };\n    Controller.getNearThrouughGrid = function (gridP, targetP) {\n        if (targetP === void 0) { targetP = null; }\n        var nearGrid = 5;\n        var n_32_x1 = gridP.x - nearGrid;\n        var n_32_x2 = gridP.x + nearGrid;\n        var n_32_y1 = gridP.y - nearGrid;\n        var n_32_y2 = gridP.y + nearGrid;\n        n_32_x1 = n_32_x1 < 0 ? 0 : n_32_x1;\n        n_32_y1 = n_32_y1 < 0 ? 0 : n_32_y1;\n        n_32_x2 = n_32_x2 > Game.currentScene.gridWidth ? Game.currentScene.gridWidth : n_32_x2;\n        n_32_y2 = n_32_y2 > Game.currentScene.gridHeight ? Game.currentScene.gridHeight : n_32_y2;\n        var findGrid = new Point(-1, -1);\n        var helpP = new Point();\n        var dis_x = 9999;\n        var findGrids = [];\n        for (var x = n_32_x1; x < n_32_x2; x++) {\n            for (var y = n_32_y1; y < n_32_y2; y++) {\n                helpP.x = x;\n                helpP.y = y;\n                if (Game.currentScene.isOutsideByGrid(helpP)) {\n                    continue;\n                }\n                if (Game.currentScene.isObstacleGrid(helpP)) {\n                    continue;\n                }\n                var n_jin_x32 = Math.abs(x - gridP.x);\n                var n_jin_y32 = Math.abs(y - gridP.y);\n                var dis = n_jin_x32 + n_jin_y32;\n                if (targetP) {\n                    if (dis <= dis_x) {\n                        findGrid.x = x;\n                        findGrid.y = y;\n                        if (dis_x != dis)\n                            findGrids.length = 0;\n                        dis_x = dis;\n                        findGrids.push(new Point(findGrid.x, findGrid.y));\n                    }\n                }\n                else {\n                    if (dis < dis_x) {\n                        findGrid.x = x;\n                        findGrid.y = y;\n                        dis_x = dis;\n                    }\n                }\n            }\n        }\n        if (targetP) {\n            findGrid = new Point(-1, -1);\n            dis_x = 9999;\n            for (var p in findGrids) {\n                var tp = findGrids[p];\n                var n_jin_x32 = Math.abs(tp.x - targetP.x);\n                var n_jin_y32 = Math.abs(tp.y - targetP.y);\n                var dis = n_jin_x32 + n_jin_y32;\n                if (dis < dis_x) {\n                    findGrid = tp;\n                    dis_x = dis;\n                }\n            }\n        }\n        if (findGrid.x == -1)\n            return null;\n        return findGrid;\n    };\n    Controller.EVENT_SCENE_OBJECT_CLICK_COMMAND = \"GameCommand_EVENT_SCENE_OBJECT_CLICK_COMMAND\";\n    Controller.EVENT_IN_SCENE_COMMAND = \"GameCommand_EVENT_IN_SCENE_COMMAND\";\n    Controller.ENABLED_COMMAND_SCENE_OBJECT_CLICK_EXECUTE = 0;\n    Controller.ENABLED_COMMAND_IN_SCENE_EXECUTE = 1;\n    Controller.enabledMapping = {\n        0: true,\n        1: true\n    };\n    return Controller;\n}());\n",
        "var _this = this;\nos.defaultFamily = \"黑体\";\nif (ClientWorld.isGame) {\n    EventUtils.addEventListener(ClientWorld, ClientWorld.EVENT_INITED, Callback.New(function () {\n        ClientWorld.startLogin(Callback.New(function () {\n        }, _this), Callback.New(function () {\n        }, _this));\n    }, this), true);\n}\n",
        "var __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar GameClientScene = (function (_super) {\n    __extends(GameClientScene, _super);\n    function GameClientScene() {\n        _super.call(this);\n    }\n    GameClientScene.prototype.dispose = function (autoStopAudio) {\n        if (autoStopAudio === void 0) { autoStopAudio = true; }\n        _super.prototype.dispose.apply(this, arguments);\n    };\n    GameClientScene.prototype.onRender = function () {\n        _super.prototype.onRender.apply(this, arguments);\n    };\n    GameClientScene.prototype.addSceneObject = function (soData, isSoc, useModelClass) {\n        if (isSoc === void 0) { isSoc = false; }\n        if (useModelClass === void 0) { useModelClass = false; }\n        trace(\"添加场景对象\" + soData.index);\n        return _super.prototype.addSceneObject.apply(this, arguments);\n    };\n    GameClientScene.prototype.removeSceneObject = function (so) {\n        return _super.prototype.removeSceneObject.apply(this, arguments);\n    };\n    return GameClientScene;\n}(ClientScene));\n",
        "var __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar GameClientSceneObject_Core = (function (_super) {\n    __extends(GameClientSceneObject_Core, _super);\n    function GameClientSceneObject_Core(soData, scene) {\n        if (soData === void 0) { soData = null; }\n        if (scene === void 0) { scene = null; }\n        _super.call(this, soData, scene);\n    }\n    GameClientSceneObject_Core.prototype.startMove = function (arr, _costTime) {\n        if (_costTime === void 0) { _costTime = 0; }\n        var _arr = [];\n        for (var i in arr) {\n            _arr.push(new Point(arr[i][0], arr[i][1]));\n        }\n        this.roadMax = arr.length;\n        if (arr && this.roadMax > 1) {\n            this.endPoint = _arr[arr.length - 1];\n            this.myLastX32 = Math.floor(this.x / Config.SCENE_GRID_SIZE);\n            this.myLastY32 = Math.floor(this.y / Config.SCENE_GRID_SIZE);\n            this.nowRoadStartDate = (new Date()).getTime();\n            this.nowRoadStartDate -= _costTime;\n            this.roadsArr = _arr;\n            this.state_isMoving = true;\n        }\n    };\n    Object.defineProperty(GameClientSceneObject_Core.prototype, \"state_isMoving\", {\n        get: function () { return this._isMoving; },\n        set: function (_isMove) {\n            if (_isMove) {\n                this.avatarAct = 2;\n                this.nowRoad = 0;\n                this.nowRoadTime = 0;\n                var serverS = this.roadsArr[0].distance(this.roadsArr[1].x, this.roadsArr[1].y);\n                var clientS = new Point(this.x, this.y).distance(this.roadsArr[1].x, this.roadsArr[1].y);\n                this.roadsArr[0].x = this.x;\n                this.roadsArr[0].y = this.y;\n                this.realMoveSpeed = clientS * this.speed / serverS;\n                this._isMoving = _isMove;\n                this.updateCoordinate((new Date()).getTime());\n            }\n            else {\n                this._isMoving = _isMove;\n                this.avatarAct = 1;\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    GameClientSceneObject_Core.prototype.updateCoordinate = function (_nowTime) {\n        var per;\n        var isChangeDir;\n        var thisRoadP = this.roadsArr[this.nowRoad];\n        var nextRoadP = this.roadsArr[this.nowRoad + 1];\n        if (this.nowRoadTime == 0) {\n            var thisRoadS = thisRoadP.distance(nextRoadP.x, nextRoadP.y);\n            this.nowRoadTime = thisRoadS * 1000 / this.realMoveSpeed;\n            isChangeDir = true;\n        }\n        var nowRoadEndDate = this.nowRoadStartDate + this.nowRoadTime;\n        if (_nowTime > nowRoadEndDate) {\n            this.nowRoad++;\n            if (this.nowRoad < this.roadMax - 1) {\n                this.nowRoadStartDate += this.nowRoadTime;\n                this.nowRoadTime = 0;\n                this.realMoveSpeed = this.speed;\n                this.updateCoordinate(_nowTime);\n                return;\n            }\n            else {\n                per = 1;\n                this.state_isMoving = false;\n                EventUtils.happen(this, SceneObject.EVENT_MOVE_OVER);\n            }\n        }\n        else {\n            per = (_nowTime - this.nowRoadStartDate) / this.nowRoadTime;\n        }\n        if (isChangeDir) {\n            var dir = GameUtils.getOriByAngle(MathUtils.direction_360(this.x, this.y, nextRoadP.x, nextRoadP.y));\n            this.avatarOri = dir;\n        }\n        var nowP = Point.interpolate(nextRoadP, thisRoadP, per);\n        this.setTo(nowP.x, nowP.y, false);\n    };\n    GameClientSceneObject_Core.prototype.stopMove = function () {\n        this.state_isMoving = false;\n    };\n    GameClientSceneObject_Core.prototype.update = function (_nowTime) {\n        if (this.state_isMoving) {\n            this.updateCoordinate(_nowTime);\n        }\n    };\n    GameClientSceneObject_Core.prototype.jumpTo = function (x, y) {\n        var _this = this;\n        this.state_isMoving = false;\n        this.state_isJumping = true;\n        Tween.to(this, { x: x, y: y }, Config.SCENE_OBJECT_JUMP_INTERVAL, null, Callback.New(function () {\n            if (_this.isDisposed)\n                return;\n            _this.state_isJumping = false;\n            _this.refreshCoordinate();\n            EventUtils.happen(_this, ClientSceneObject.EVENT_JUMP_OVER);\n        }, this));\n        Tween.to(this, { jumpY: -Config.SCENE_OBJECT_JUMP_HEIGHT }, Math.floor(Config.SCENE_OBJECT_JUMP_INTERVAL / 2), Ease.quintOut, Callback.New(function () {\n            if (_this.isDisposed)\n                return;\n            Tween.to(_this, { jumpY: 0 }, Config.SCENE_OBJECT_JUMP_INTERVAL - Math.floor(Config.SCENE_OBJECT_JUMP_INTERVAL / 2), Ease.quintIn);\n        }, this));\n    };\n    Object.defineProperty(GameClientSceneObject_Core.prototype, \"jumpY\", {\n        get: function () {\n            return this.avatar ? this.avatar.y : 0;\n        },\n        set: function (v) {\n            this.avatar.y = v;\n            var scale = 1 - (this.avatar.y / -Config.SCENE_OBJECT_JUMP_HEIGHT) * 0.5;\n            this.refreshShadow(scale);\n        },\n        enumerable: true,\n        configurable: true\n    });\n    GameClientSceneObject_Core.prototype.setTo = function (x, y, stopMove) {\n        if (stopMove === void 0) { stopMove = true; }\n        if (stopMove)\n            this.state_isMoving = false;\n        this._x = x;\n        this._y = y;\n        this.root.pos(x, y);\n        this.refreshCoordinate();\n    };\n    GameClientSceneObject_Core.prototype.correctTo = function (x, y) {\n        if (Math.abs(x - this.x) >= Config.SCENE_GRID_SIZE || Math.abs(y - this.y) >= Config.SCENE_GRID_SIZE) {\n            this.setTo(x, y);\n        }\n    };\n    GameClientSceneObject_Core.prototype.refreshCoordinate = function (refreshCamera, refreshShadow, refreshGridPos, refreshDynamicObs, refreshMask) {\n        if (refreshCamera === void 0) { refreshCamera = true; }\n        if (refreshShadow === void 0) { refreshShadow = true; }\n        if (refreshGridPos === void 0) { refreshGridPos = true; }\n        if (refreshDynamicObs === void 0) { refreshDynamicObs = true; }\n        if (refreshMask === void 0) { refreshMask = true; }\n        if (!this.inScene)\n            return;\n        if (this.scene.cameraObject == this) {\n            this.scene.updateCamera();\n        }\n        this.updateShadow();\n        this.posHelper.x = this.x;\n        this.posHelper.y = this.y;\n        GameUtils.getGridPostion(this.posHelper, this.tempPosHelper);\n        if (this.posGrid.x != this.tempPosHelper.x || this.posGrid.y != this.tempPosHelper.y) {\n            this.posGrid.x = this.tempPosHelper.x;\n            this.posGrid.y = this.tempPosHelper.y;\n            Controller.checkTouch(this);\n            this.scene.updateDynamicObsAndBridge(this, true, this.posGrid);\n            this.root.alpha = this.scene.isMask(new Point(this.x, this.y)) ? 0.5 : 1;\n        }\n    };\n    GameClientSceneObject_Core.prototype.setPreviewSceneObjectBehaviorInit = function (defSceneObejct) {\n        ObjectUtils.clone(defSceneObejct, this);\n        this.state_ignoreCantMove = false;\n        this.stopMove();\n        this.stopAllAnimation();\n        this.refreshShadow();\n        this.scene.setCameraSceneObject(this);\n        this.root.skewX = 0;\n        this.root.skewY = 0;\n    };\n    GameClientSceneObject_Core.prototype.setPreviewSceneObjectBehaviorPlay = function (behaviorStage, index, playMode, onPlayFin) {\n        if (onPlayFin === void 0) { onPlayFin = null; }\n        var behavior = behaviorStage[index];\n        if (!behavior)\n            return;\n        var id = behavior[0];\n        if (id == 0) {\n            this.avatarID = behavior[1];\n            this.avatarAct = behavior[2];\n            this.avatarFrame = behavior[3];\n        }\n        else if (id >= 1 && id <= 8) {\n            var dArr = [[0, 1, 2], [-1, 0, 4], [0, -1, 8], [1, 0, 6], [-1, 1, 1], [1, 1, 3], [-1, -1, 7], [1, -1, 9]];\n            var dIndex = id - 1;\n            var toP = new Point(this.x + dArr[dIndex][0] * Config.SCENE_GRID_SIZE, this.y + dArr[dIndex][1] * Config.SCENE_GRID_SIZE);\n            var toP32 = GameUtils.getGridPostion(toP);\n            if (this.scene.isObstacleGrid(toP32)) {\n                if (!this.through) {\n                    if (this.state_ignoreCantMove) {\n                        onPlayFin && onPlayFin.run();\n                        return;\n                    }\n                    else {\n                        onPlayFin && onPlayFin.runWith([true]);\n                        return;\n                    }\n                }\n                else if (this.scene.isOutsideByGrid(toP32)) {\n                    onPlayFin && onPlayFin.runWith([true]);\n                    return;\n                }\n            }\n            if (playMode) {\n                this.avatarOri = dArr[dIndex][2];\n                this.startMove([[this.x, this.y], [toP.x, toP.y]]);\n                EventUtils.addEventListener(this, SceneObject.EVENT_MOVE_OVER, Callback.New(function () {\n                    onPlayFin && onPlayFin.run();\n                }, this), true);\n                return;\n            }\n            else {\n                this.x = toP.x;\n                this.y = toP.y;\n                this.avatarOri = dArr[dIndex][2];\n                this.scene.updateCamera();\n            }\n        }\n        else if (id >= 12 && id <= 14) {\n            var isGrid = behavior[1];\n            if (isGrid) {\n                toP = GameUtils.getGridCenter(new Point(behavior[2] * Config.SCENE_GRID_SIZE, behavior[3] * Config.SCENE_GRID_SIZE));\n            }\n            else {\n                toP = new Point(behavior[2], behavior[3]);\n            }\n            if (!playMode) {\n                this.x = toP.x;\n                this.y = toP.y;\n            }\n            else {\n                if (id == 12) {\n                    this.startMove([[this.x, this.y], [toP.x, toP.y]]);\n                    EventUtils.addEventListener(this, SceneObject.EVENT_MOVE_OVER, Callback.New(function () {\n                        onPlayFin && onPlayFin.run();\n                    }, this), true);\n                    return;\n                }\n                else if (id == 13) {\n                    this.jumpTo(toP.x, toP.y);\n                    EventUtils.addEventListener(this, SceneObject.EVENT_JUMP_OVER, Callback.New(function () {\n                        onPlayFin && onPlayFin.run();\n                    }, this), true);\n                    return;\n                }\n                else {\n                    this.setTo(toP.x, toP.y);\n                }\n            }\n        }\n        else if (id == 16) {\n            if (playMode) {\n                setFrameout(function () {\n                    onPlayFin && onPlayFin.run();\n                }, behavior[1]);\n                return;\n            }\n        }\n        else if (id == 17) {\n            this.state_ignoreCantMove = true;\n        }\n        else if (id == 18) {\n            this.state_ignoreCantMove = false;\n        }\n        else if (id >= 19 && id <= 26) {\n            var oriArr = [2, 4, 8, 6, 1, 3, 7, 9];\n            this.avatarOri = oriArr[id - 19];\n        }\n        else if (id == 29) {\n            this.scale = behavior[1];\n        }\n        else if (id == 30) {\n            this.speed = behavior[1];\n        }\n        else if (id == 31) {\n            this.avatarAlpha = behavior[1];\n        }\n        else if (id == 32) {\n            this.avatarHue = behavior[1];\n        }\n        else if (id == 33) {\n            this.avatarPlayInterval = behavior[1];\n        }\n        else if (id == 34) {\n            this.shadowEnable = behavior[1];\n            this.shadowWidth = behavior[2];\n            this.shadowHeight = behavior[3];\n            this.shadowAlpha = behavior[4];\n            this.refreshShadow();\n        }\n        else if (id == 35) {\n            var loop = Boolean(Number(behavior[2]));\n            var isHit = Boolean(Number(behavior[3]));\n            this.playAnimation(behavior[1], loop, isHit);\n        }\n        else if (id == 36) {\n            this.stopAnimation(behavior[1]);\n        }\n        else if (id == 37) {\n            if (playMode) {\n                GameAudio.playSE(behavior[1], behavior[2], behavior[3]);\n            }\n        }\n        else if (id == 40) {\n            this.fixedOrientation = true;\n        }\n        else if (id == 41) {\n            this.fixedOrientation = false;\n        }\n        else if (id == 42) {\n            this.onTop = 2;\n        }\n        else if (id == 43) {\n            this.onTop = 1;\n        }\n        else if (id == 44) {\n            this.through = true;\n        }\n        else if (id == 45) {\n            this.through = false;\n        }\n        else if (id == 46) {\n            this.autoPlayEnable = true;\n        }\n        else if (id == 47) {\n            this.autoPlayEnable = false;\n        }\n        else if (id == 50) {\n            Tween.to(this.root, { skewY: 200 }, 2000, null, Callback.New(function () {\n                onPlayFin && onPlayFin.run();\n            }, this));\n            return;\n        }\n        else if (id == 51) {\n            Tween.to(this.root, { scaleX: 2, scaleY: 2 }, 2000, null, Callback.New(function () {\n                onPlayFin && onPlayFin.run();\n            }, this));\n            return;\n        }\n        onPlayFin && onPlayFin.run();\n    };\n    return GameClientSceneObject_Core;\n}(ClientSceneObject));\n",
        "var __extends = (this && this.__extends) || function (d, b) {\n    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    function __() { this.constructor = d; }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n};\nvar GameClientSceneObject_1 = (function (_super) {\n    __extends(GameClientSceneObject_1, _super);\n    function GameClientSceneObject_1(soData, scene) {\n        if (scene === void 0) { scene = null; }\n        _super.call(this, soData, scene);\n    }\n    return GameClientSceneObject_1;\n}(ClientSceneObject_1));\n"
    ]
}